/*! For license information please see /assets/LICENSES.txt */
/******/
(function() { // webpackBootstrap
    /******/
    "use strict";
    /******/
    var __webpack_modules__ = ({

        /***/
        "./node_modules/core-js/es/symbol/index.js":
            /*!*************************************************!*\
              !*** ./node_modules/core-js/es/symbol/index.js ***!
              \*************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                __webpack_require__( /*! ../../modules/es.array.concat */ "./node_modules/core-js/modules/es.array.concat.js");
                __webpack_require__( /*! ../../modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");
                __webpack_require__( /*! ../../modules/es.symbol */ "./node_modules/core-js/modules/es.symbol.js");
                __webpack_require__( /*! ../../modules/es.symbol.async-iterator */ "./node_modules/core-js/modules/es.symbol.async-iterator.js");
                __webpack_require__( /*! ../../modules/es.symbol.description */ "./node_modules/core-js/modules/es.symbol.description.js");
                __webpack_require__( /*! ../../modules/es.symbol.has-instance */ "./node_modules/core-js/modules/es.symbol.has-instance.js");
                __webpack_require__( /*! ../../modules/es.symbol.is-concat-spreadable */ "./node_modules/core-js/modules/es.symbol.is-concat-spreadable.js");
                __webpack_require__( /*! ../../modules/es.symbol.iterator */ "./node_modules/core-js/modules/es.symbol.iterator.js");
                __webpack_require__( /*! ../../modules/es.symbol.match */ "./node_modules/core-js/modules/es.symbol.match.js");
                __webpack_require__( /*! ../../modules/es.symbol.match-all */ "./node_modules/core-js/modules/es.symbol.match-all.js");
                __webpack_require__( /*! ../../modules/es.symbol.replace */ "./node_modules/core-js/modules/es.symbol.replace.js");
                __webpack_require__( /*! ../../modules/es.symbol.search */ "./node_modules/core-js/modules/es.symbol.search.js");
                __webpack_require__( /*! ../../modules/es.symbol.species */ "./node_modules/core-js/modules/es.symbol.species.js");
                __webpack_require__( /*! ../../modules/es.symbol.split */ "./node_modules/core-js/modules/es.symbol.split.js");
                __webpack_require__( /*! ../../modules/es.symbol.to-primitive */ "./node_modules/core-js/modules/es.symbol.to-primitive.js");
                __webpack_require__( /*! ../../modules/es.symbol.to-string-tag */ "./node_modules/core-js/modules/es.symbol.to-string-tag.js");
                __webpack_require__( /*! ../../modules/es.symbol.unscopables */ "./node_modules/core-js/modules/es.symbol.unscopables.js");
                __webpack_require__( /*! ../../modules/es.json.to-string-tag */ "./node_modules/core-js/modules/es.json.to-string-tag.js");
                __webpack_require__( /*! ../../modules/es.math.to-string-tag */ "./node_modules/core-js/modules/es.math.to-string-tag.js");
                __webpack_require__( /*! ../../modules/es.reflect.to-string-tag */ "./node_modules/core-js/modules/es.reflect.to-string-tag.js");
                var path = __webpack_require__( /*! ../../internals/path */ "./node_modules/core-js/internals/path.js");
                module.exports = path.Symbol;


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/a-callable.js":
            /*!******************************************************!*\
              !*** ./node_modules/core-js/internals/a-callable.js ***!
              \******************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var isCallable = __webpack_require__( /*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
                var tryToString = __webpack_require__( /*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");
                var TypeError = global.TypeError;
                // `Assert: IsCallable(argument) is true`
                module.exports = function(argument) {
                    if (isCallable(argument))
                        return argument;
                    throw TypeError(tryToString(argument) + ' is not a function');
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/an-object.js":
            /*!*****************************************************!*\
              !*** ./node_modules/core-js/internals/an-object.js ***!
              \*****************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var isObject = __webpack_require__( /*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
                var String = global.String;
                var TypeError = global.TypeError;
                // `Assert: Type(argument) is Object`
                module.exports = function(argument) {
                    if (isObject(argument))
                        return argument;
                    throw TypeError(String(argument) + ' is not an object');
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/array-includes.js":
            /*!**********************************************************!*\
              !*** ./node_modules/core-js/internals/array-includes.js ***!
              \**********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var toIndexedObject = __webpack_require__( /*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
                var toAbsoluteIndex = __webpack_require__( /*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
                var lengthOfArrayLike = __webpack_require__( /*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
                // `Array.prototype.{ indexOf, includes }` methods implementation
                var createMethod = function(IS_INCLUDES) {
                    return function($this, el, fromIndex) {
                        var O = toIndexedObject($this);
                        var length = lengthOfArrayLike(O);
                        var index = toAbsoluteIndex(fromIndex, length);
                        var value;
                        // Array#includes uses SameValueZero equality algorithm
                        // eslint-disable-next-line no-self-compare -- NaN check
                        if (IS_INCLUDES && el != el)
                            while (length > index) {
                                value = O[index++];
                                // eslint-disable-next-line no-self-compare -- NaN check
                                if (value != value)
                                    return true;
                                // Array#indexOf ignores holes, Array#includes - not
                            }
                        else
                            for (; length > index; index++) {
                                if ((IS_INCLUDES || index in O) && O[index] === el)
                                    return IS_INCLUDES || index || 0;
                            }
                        return !IS_INCLUDES && -1;
                    };
                };
                module.exports = {
                    // `Array.prototype.includes` method
                    // https://tc39.es/ecma262/#sec-array.prototype.includes
                    includes: createMethod(true),
                    // `Array.prototype.indexOf` method
                    // https://tc39.es/ecma262/#sec-array.prototype.indexof
                    indexOf: createMethod(false)
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/array-iteration.js":
            /*!***********************************************************!*\
              !*** ./node_modules/core-js/internals/array-iteration.js ***!
              \***********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var bind = __webpack_require__( /*! ../internals/function-bind-context */ "./node_modules/core-js/internals/function-bind-context.js");
                var uncurryThis = __webpack_require__( /*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
                var IndexedObject = __webpack_require__( /*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
                var toObject = __webpack_require__( /*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
                var lengthOfArrayLike = __webpack_require__( /*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
                var arraySpeciesCreate = __webpack_require__( /*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");
                var push = uncurryThis([].push);
                // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
                var createMethod = function(TYPE) {
                    var IS_MAP = TYPE == 1;
                    var IS_FILTER = TYPE == 2;
                    var IS_SOME = TYPE == 3;
                    var IS_EVERY = TYPE == 4;
                    var IS_FIND_INDEX = TYPE == 6;
                    var IS_FILTER_REJECT = TYPE == 7;
                    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
                    return function($this, callbackfn, that, specificCreate) {
                        var O = toObject($this);
                        var self = IndexedObject(O);
                        var boundFunction = bind(callbackfn, that);
                        var length = lengthOfArrayLike(self);
                        var index = 0;
                        var create = specificCreate || arraySpeciesCreate;
                        var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
                        var value, result;
                        for (; length > index; index++)
                            if (NO_HOLES || index in self) {
                                value = self[index];
                                result = boundFunction(value, index, O);
                                if (TYPE) {
                                    if (IS_MAP)
                                        target[index] = result; // map
                                    else if (result)
                                        switch (TYPE) {
                                            case 3:
                                                return true; // some
                                            case 5:
                                                return value; // find
                                            case 6:
                                                return index; // findIndex
                                            case 2:
                                                push(target, value); // filter
                                        }
                                    else
                                        switch (TYPE) {
                                            case 4:
                                                return false; // every
                                            case 7:
                                                push(target, value); // filterReject
                                        }
                                }
                            }
                        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
                    };
                };
                module.exports = {
                    // `Array.prototype.forEach` method
                    // https://tc39.es/ecma262/#sec-array.prototype.foreach
                    forEach: createMethod(0),
                    // `Array.prototype.map` method
                    // https://tc39.es/ecma262/#sec-array.prototype.map
                    map: createMethod(1),
                    // `Array.prototype.filter` method
                    // https://tc39.es/ecma262/#sec-array.prototype.filter
                    filter: createMethod(2),
                    // `Array.prototype.some` method
                    // https://tc39.es/ecma262/#sec-array.prototype.some
                    some: createMethod(3),
                    // `Array.prototype.every` method
                    // https://tc39.es/ecma262/#sec-array.prototype.every
                    every: createMethod(4),
                    // `Array.prototype.find` method
                    // https://tc39.es/ecma262/#sec-array.prototype.find
                    find: createMethod(5),
                    // `Array.prototype.findIndex` method
                    // https://tc39.es/ecma262/#sec-array.prototype.findIndex
                    findIndex: createMethod(6),
                    // `Array.prototype.filterReject` method
                    // https://github.com/tc39/proposal-array-filtering
                    filterReject: createMethod(7)
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/array-method-has-species-support.js":
            /*!****************************************************************************!*\
              !*** ./node_modules/core-js/internals/array-method-has-species-support.js ***!
              \****************************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var fails = __webpack_require__( /*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
                var wellKnownSymbol = __webpack_require__( /*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
                var V8_VERSION = __webpack_require__( /*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");
                var SPECIES = wellKnownSymbol('species');
                module.exports = function(METHOD_NAME) {
                    // We can't use this feature detection in V8 since it causes
                    // deoptimization and serious performance degradation
                    // https://github.com/zloirock/core-js/issues/677
                    return V8_VERSION >= 51 || !fails(function() {
                        var array = [];
                        var constructor = array.constructor = {};
                        constructor[SPECIES] = function() {
                            return {
                                foo: 1
                            };
                        };
                        return array[METHOD_NAME](Boolean).foo !== 1;
                    });
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/array-slice-simple.js":
            /*!**************************************************************!*\
              !*** ./node_modules/core-js/internals/array-slice-simple.js ***!
              \**************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var toAbsoluteIndex = __webpack_require__( /*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
                var lengthOfArrayLike = __webpack_require__( /*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
                var createProperty = __webpack_require__( /*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
                var Array = global.Array;
                var max = Math.max;
                module.exports = function(O, start, end) {
                    var length = lengthOfArrayLike(O);
                    var k = toAbsoluteIndex(start, length);
                    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
                    var result = Array(max(fin - k, 0));
                    for (var n = 0; k < fin; k++, n++)
                        createProperty(result, n, O[k]);
                    result.length = n;
                    return result;
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/array-slice.js":
            /*!*******************************************************!*\
              !*** ./node_modules/core-js/internals/array-slice.js ***!
              \*******************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var uncurryThis = __webpack_require__( /*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
                module.exports = uncurryThis([].slice);


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/array-species-constructor.js":
            /*!*********************************************************************!*\
              !*** ./node_modules/core-js/internals/array-species-constructor.js ***!
              \*********************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var isArray = __webpack_require__( /*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
                var isConstructor = __webpack_require__( /*! ../internals/is-constructor */ "./node_modules/core-js/internals/is-constructor.js");
                var isObject = __webpack_require__( /*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
                var wellKnownSymbol = __webpack_require__( /*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
                var SPECIES = wellKnownSymbol('species');
                var Array = global.Array;
                // a part of `ArraySpeciesCreate` abstract operation
                // https://tc39.es/ecma262/#sec-arrayspeciescreate
                module.exports = function(originalArray) {
                    var C;
                    if (isArray(originalArray)) {
                        C = originalArray.constructor;
                        // cross-realm fallback
                        if (isConstructor(C) && (C === Array || isArray(C.prototype)))
                            C = undefined;
                        else if (isObject(C)) {
                            C = C[SPECIES];
                            if (C === null)
                                C = undefined;
                        }
                    }
                    return C === undefined ? Array : C;
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/array-species-create.js":
            /*!****************************************************************!*\
              !*** ./node_modules/core-js/internals/array-species-create.js ***!
              \****************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var arraySpeciesConstructor = __webpack_require__( /*! ../internals/array-species-constructor */ "./node_modules/core-js/internals/array-species-constructor.js");
                // `ArraySpeciesCreate` abstract operation
                // https://tc39.es/ecma262/#sec-arrayspeciescreate
                module.exports = function(originalArray, length) {
                    return new(arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/classof-raw.js":
            /*!*******************************************************!*\
              !*** ./node_modules/core-js/internals/classof-raw.js ***!
              \*******************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var uncurryThis = __webpack_require__( /*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
                var toString = uncurryThis({}.toString);
                var stringSlice = uncurryThis(''.slice);
                module.exports = function(it) {
                    return stringSlice(toString(it), 8, -1);
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/classof.js":
            /*!***************************************************!*\
              !*** ./node_modules/core-js/internals/classof.js ***!
              \***************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var TO_STRING_TAG_SUPPORT = __webpack_require__( /*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
                var isCallable = __webpack_require__( /*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
                var classofRaw = __webpack_require__( /*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
                var wellKnownSymbol = __webpack_require__( /*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
                var TO_STRING_TAG = wellKnownSymbol('toStringTag');
                var Object = global.Object;
                // ES3 wrong here
                var CORRECT_ARGUMENTS = classofRaw(function() {
                    return arguments;
                }()) == 'Arguments';
                // fallback for IE11 Script Access Denied error
                var tryGet = function(it, key) {
                    try {
                        return it[key];
                    } catch (error) { /* empty */ }
                };
                // getting tag from ES6+ `Object.prototype.toString`
                module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
                    var O, tag, result;
                    return it === undefined ? 'Undefined' : it === null ? 'Null'
                        // @@toStringTag case
                        :
                        typeof(tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
                        // builtinTag case
                        :
                        CORRECT_ARGUMENTS ? classofRaw(O)
                        // ES3 arguments fallback
                        :
                        (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/copy-constructor-properties.js":
            /*!***********************************************************************!*\
              !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
              \***********************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var hasOwn = __webpack_require__( /*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
                var ownKeys = __webpack_require__( /*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
                var getOwnPropertyDescriptorModule = __webpack_require__( /*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
                var definePropertyModule = __webpack_require__( /*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
                module.exports = function(target, source, exceptions) {
                    var keys = ownKeys(source);
                    var defineProperty = definePropertyModule.f;
                    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
                            defineProperty(target, key, getOwnPropertyDescriptor(source, key));
                        }
                    }
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/create-non-enumerable-property.js":
            /*!**************************************************************************!*\
              !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
              \**************************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var DESCRIPTORS = __webpack_require__( /*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
                var definePropertyModule = __webpack_require__( /*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
                var createPropertyDescriptor = __webpack_require__( /*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
                module.exports = DESCRIPTORS ? function(object, key, value) {
                    return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
                } : function(object, key, value) {
                    object[key] = value;
                    return object;
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/create-property-descriptor.js":
            /*!**********************************************************************!*\
              !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
              \**********************************************************************/
            /***/
            (function(module) {


                module.exports = function(bitmap, value) {
                    return {
                        enumerable: !(bitmap & 1),
                        configurable: !(bitmap & 2),
                        writable: !(bitmap & 4),
                        value: value
                    };
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/create-property.js":
            /*!***********************************************************!*\
              !*** ./node_modules/core-js/internals/create-property.js ***!
              \***********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var toPropertyKey = __webpack_require__( /*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
                var definePropertyModule = __webpack_require__( /*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
                var createPropertyDescriptor = __webpack_require__( /*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
                module.exports = function(object, key, value) {
                    var propertyKey = toPropertyKey(key);
                    if (propertyKey in object)
                        definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
                    else
                        object[propertyKey] = value;
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/define-built-in.js":
            /*!***********************************************************!*\
              !*** ./node_modules/core-js/internals/define-built-in.js ***!
              \***********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var isCallable = __webpack_require__( /*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
                var createNonEnumerableProperty = __webpack_require__( /*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
                var makeBuiltIn = __webpack_require__( /*! ../internals/make-built-in */ "./node_modules/core-js/internals/make-built-in.js");
                var setGlobal = __webpack_require__( /*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
                module.exports = function(O, key, value, options) {
                    var unsafe = options ? !!options.unsafe : false;
                    var simple = options ? !!options.enumerable : false;
                    var noTargetGet = options ? !!options.noTargetGet : false;
                    var name = options && options.name !== undefined ? options.name : key;
                    if (isCallable(value))
                        makeBuiltIn(value, name, options);
                    if (O === global) {
                        if (simple)
                            O[key] = value;
                        else
                            setGlobal(key, value);
                        return O;
                    } else if (!unsafe) {
                        delete O[key];
                    } else if (!noTargetGet && O[key]) {
                        simple = true;
                    }
                    if (simple)
                        O[key] = value;
                    else
                        createNonEnumerableProperty(O, key, value);
                    return O;
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/define-well-known-symbol.js":
            /*!********************************************************************!*\
              !*** ./node_modules/core-js/internals/define-well-known-symbol.js ***!
              \********************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var path = __webpack_require__( /*! ../internals/path */ "./node_modules/core-js/internals/path.js");
                var hasOwn = __webpack_require__( /*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
                var wrappedWellKnownSymbolModule = __webpack_require__( /*! ../internals/well-known-symbol-wrapped */ "./node_modules/core-js/internals/well-known-symbol-wrapped.js");
                var defineProperty = (__webpack_require__( /*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
                module.exports = function(NAME) {
                    var Symbol = path.Symbol || (path.Symbol = {});
                    if (!hasOwn(Symbol, NAME))
                        defineProperty(Symbol, NAME, {
                            value: wrappedWellKnownSymbolModule.f(NAME)
                        });
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/descriptors.js":
            /*!*******************************************************!*\
              !*** ./node_modules/core-js/internals/descriptors.js ***!
              \*******************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var fails = __webpack_require__( /*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
                // Detect IE8's incomplete defineProperty implementation
                module.exports = !fails(function() {
                    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
                    return Object.defineProperty({}, 1, {
                        get: function() {
                            return 7;
                        }
                    })[1] != 7;
                });


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/document-create-element.js":
            /*!*******************************************************************!*\
              !*** ./node_modules/core-js/internals/document-create-element.js ***!
              \*******************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var isObject = __webpack_require__( /*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
                var document = global.document;
                // typeof document.createElement is 'object' in old IE
                var EXISTS = isObject(document) && isObject(document.createElement);
                module.exports = function(it) {
                    return EXISTS ? document.createElement(it) : {};
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/engine-user-agent.js":
            /*!*************************************************************!*\
              !*** ./node_modules/core-js/internals/engine-user-agent.js ***!
              \*************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var getBuiltIn = __webpack_require__( /*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
                module.exports = getBuiltIn('navigator', 'userAgent') || '';


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/engine-v8-version.js":
            /*!*************************************************************!*\
              !*** ./node_modules/core-js/internals/engine-v8-version.js ***!
              \*************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var userAgent = __webpack_require__( /*! ../internals/engine-user-agent */ "./node_modules/core-js/internals/engine-user-agent.js");
                var process = global.process;
                var Deno = global.Deno;
                var versions = process && process.versions || Deno && Deno.version;
                var v8 = versions && versions.v8;
                var match, version;
                if (v8) {
                    match = v8.split('.');
                    // in old Chrome, versions of V8 isn't V8 = Chrome / 10
                    // but their correct versions are not interesting for us
                    version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
                }
                // BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
                // so check `userAgent` even if `.v8` exists, but 0
                if (!version && userAgent) {
                    match = userAgent.match(/Edge\/(\d+)/);
                    if (!match || match[1] >= 74) {
                        match = userAgent.match(/Chrome\/(\d+)/);
                        if (match)
                            version = +match[1];
                    }
                }
                module.exports = version;


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/enum-bug-keys.js":
            /*!*********************************************************!*\
              !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
              \*********************************************************/
            /***/
            (function(module) {


                // IE8- don't enum bug keys
                module.exports = [
                    'constructor',
                    'hasOwnProperty',
                    'isPrototypeOf',
                    'propertyIsEnumerable',
                    'toLocaleString',
                    'toString',
                    'valueOf'
                ];


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/export.js":
            /*!**************************************************!*\
              !*** ./node_modules/core-js/internals/export.js ***!
              \**************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var getOwnPropertyDescriptor = (__webpack_require__( /*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f);
                var createNonEnumerableProperty = __webpack_require__( /*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
                var defineBuiltIn = __webpack_require__( /*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
                var setGlobal = __webpack_require__( /*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
                var copyConstructorProperties = __webpack_require__( /*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
                var isForced = __webpack_require__( /*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
                /*
                  options.target      - name of the target object
                  options.global      - target is the global object
                  options.stat        - export as static methods of target
                  options.proto       - export as prototype methods of target
                  options.real        - real prototype method for the `pure` version
                  options.forced      - export even if the native feature is available
                  options.bind        - bind methods to the target, required for the `pure` version
                  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
                  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
                  options.sham        - add a flag to not completely full polyfills
                  options.enumerable  - export as enumerable property
                  options.noTargetGet - prevent calling a getter on target
                  options.name        - the .name of the function if it does not match the key
                */
                module.exports = function(options, source) {
                    var TARGET = options.target;
                    var GLOBAL = options.global;
                    var STATIC = options.stat;
                    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
                    if (GLOBAL) {
                        target = global;
                    } else if (STATIC) {
                        target = global[TARGET] || setGlobal(TARGET, {});
                    } else {
                        target = (global[TARGET] || {}).prototype;
                    }
                    if (target)
                        for (key in source) {
                            sourceProperty = source[key];
                            if (options.noTargetGet) {
                                descriptor = getOwnPropertyDescriptor(target, key);
                                targetProperty = descriptor && descriptor.value;
                            } else
                                targetProperty = target[key];
                            FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
                            // contained in target
                            if (!FORCED && targetProperty !== undefined) {
                                if (typeof sourceProperty == typeof targetProperty)
                                    continue;
                                copyConstructorProperties(sourceProperty, targetProperty);
                            }
                            // add a flag to not completely full polyfills
                            if (options.sham || (targetProperty && targetProperty.sham)) {
                                createNonEnumerableProperty(sourceProperty, 'sham', true);
                            }
                            defineBuiltIn(target, key, sourceProperty, options);
                        }
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/fails.js":
            /*!*************************************************!*\
              !*** ./node_modules/core-js/internals/fails.js ***!
              \*************************************************/
            /***/
            (function(module) {


                module.exports = function(exec) {
                    try {
                        return !!exec();
                    } catch (error) {
                        return true;
                    }
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/function-apply.js":
            /*!**********************************************************!*\
              !*** ./node_modules/core-js/internals/function-apply.js ***!
              \**********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var NATIVE_BIND = __webpack_require__( /*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");
                var FunctionPrototype = Function.prototype;
                var apply = FunctionPrototype.apply;
                var call = FunctionPrototype.call;
                // eslint-disable-next-line es-x/no-reflect -- safe
                module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
                    return call.apply(apply, arguments);
                });


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/function-bind-context.js":
            /*!*****************************************************************!*\
              !*** ./node_modules/core-js/internals/function-bind-context.js ***!
              \*****************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var uncurryThis = __webpack_require__( /*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
                var aCallable = __webpack_require__( /*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
                var NATIVE_BIND = __webpack_require__( /*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");
                var bind = uncurryThis(uncurryThis.bind);
                // optional / simple context binding
                module.exports = function(fn, that) {
                    aCallable(fn);
                    return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function( /* ...args */ ) {
                        return fn.apply(that, arguments);
                    };
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/function-bind-native.js":
            /*!****************************************************************!*\
              !*** ./node_modules/core-js/internals/function-bind-native.js ***!
              \****************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var fails = __webpack_require__( /*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
                module.exports = !fails(function() {
                    // eslint-disable-next-line es-x/no-function-prototype-bind -- safe
                    var test = (function() {}).bind();
                    // eslint-disable-next-line no-prototype-builtins -- safe
                    return typeof test != 'function' || test.hasOwnProperty('prototype');
                });


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/function-call.js":
            /*!*********************************************************!*\
              !*** ./node_modules/core-js/internals/function-call.js ***!
              \*********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var NATIVE_BIND = __webpack_require__( /*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");
                var call = Function.prototype.call;
                module.exports = NATIVE_BIND ? call.bind(call) : function() {
                    return call.apply(call, arguments);
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/function-name.js":
            /*!*********************************************************!*\
              !*** ./node_modules/core-js/internals/function-name.js ***!
              \*********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var DESCRIPTORS = __webpack_require__( /*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
                var hasOwn = __webpack_require__( /*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
                var FunctionPrototype = Function.prototype;
                // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
                var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
                var EXISTS = hasOwn(FunctionPrototype, 'name');
                // additional protection from minified / mangled / dropped function names
                var PROPER = EXISTS && (function something() {}).name === 'something';
                var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));
                module.exports = {
                    EXISTS: EXISTS,
                    PROPER: PROPER,
                    CONFIGURABLE: CONFIGURABLE
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/function-uncurry-this.js":
            /*!*****************************************************************!*\
              !*** ./node_modules/core-js/internals/function-uncurry-this.js ***!
              \*****************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var NATIVE_BIND = __webpack_require__( /*! ../internals/function-bind-native */ "./node_modules/core-js/internals/function-bind-native.js");
                var FunctionPrototype = Function.prototype;
                var bind = FunctionPrototype.bind;
                var call = FunctionPrototype.call;
                var uncurryThis = NATIVE_BIND && bind.bind(call, call);
                module.exports = NATIVE_BIND ? function(fn) {
                    return fn && uncurryThis(fn);
                } : function(fn) {
                    return fn && function() {
                        return call.apply(fn, arguments);
                    };
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/get-built-in.js":
            /*!********************************************************!*\
              !*** ./node_modules/core-js/internals/get-built-in.js ***!
              \********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var isCallable = __webpack_require__( /*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
                var aFunction = function(argument) {
                    return isCallable(argument) ? argument : undefined;
                };
                module.exports = function(namespace, method) {
                    return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/get-method.js":
            /*!******************************************************!*\
              !*** ./node_modules/core-js/internals/get-method.js ***!
              \******************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var aCallable = __webpack_require__( /*! ../internals/a-callable */ "./node_modules/core-js/internals/a-callable.js");
                // `GetMethod` abstract operation
                // https://tc39.es/ecma262/#sec-getmethod
                module.exports = function(V, P) {
                    var func = V[P];
                    return func == null ? undefined : aCallable(func);
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/global.js":
            /*!**************************************************!*\
              !*** ./node_modules/core-js/internals/global.js ***!
              \**************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var check = function(it) {
                    return it && it.Math == Math && it;
                };
                // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
                module.exports =
                    // eslint-disable-next-line es-x/no-global-this -- safe
                    check(typeof globalThis == 'object' && globalThis) ||
                    check(typeof window == 'object' && window) ||
                    // eslint-disable-next-line no-restricted-globals -- safe
                    check(typeof self == 'object' && self) ||
                    check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) ||
                    // eslint-disable-next-line no-new-func -- fallback
                    (function() {
                        return this;
                    })() || Function('return this')();


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/has-own-property.js":
            /*!************************************************************!*\
              !*** ./node_modules/core-js/internals/has-own-property.js ***!
              \************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var uncurryThis = __webpack_require__( /*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
                var toObject = __webpack_require__( /*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
                var hasOwnProperty = uncurryThis({}.hasOwnProperty);
                // `HasOwnProperty` abstract operation
                // https://tc39.es/ecma262/#sec-hasownproperty
                // eslint-disable-next-line es-x/no-object-hasown -- safe
                module.exports = Object.hasOwn || function hasOwn(it, key) {
                    return hasOwnProperty(toObject(it), key);
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/hidden-keys.js":
            /*!*******************************************************!*\
              !*** ./node_modules/core-js/internals/hidden-keys.js ***!
              \*******************************************************/
            /***/
            (function(module) {


                module.exports = {};


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/html.js":
            /*!************************************************!*\
              !*** ./node_modules/core-js/internals/html.js ***!
              \************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var getBuiltIn = __webpack_require__( /*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
                module.exports = getBuiltIn('document', 'documentElement');


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/ie8-dom-define.js":
            /*!**********************************************************!*\
              !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
              \**********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var DESCRIPTORS = __webpack_require__( /*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
                var fails = __webpack_require__( /*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
                var createElement = __webpack_require__( /*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
                // Thanks to IE8 for its funny defineProperty
                module.exports = !DESCRIPTORS && !fails(function() {
                    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
                    return Object.defineProperty(createElement('div'), 'a', {
                        get: function() {
                            return 7;
                        }
                    }).a != 7;
                });


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/indexed-object.js":
            /*!**********************************************************!*\
              !*** ./node_modules/core-js/internals/indexed-object.js ***!
              \**********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var uncurryThis = __webpack_require__( /*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
                var fails = __webpack_require__( /*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
                var classof = __webpack_require__( /*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
                var Object = global.Object;
                var split = uncurryThis(''.split);
                // fallback for non-array-like ES3 and non-enumerable old V8 strings
                module.exports = fails(function() {
                    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
                    // eslint-disable-next-line no-prototype-builtins -- safe
                    return !Object('z').propertyIsEnumerable(0);
                }) ? function(it) {
                    return classof(it) == 'String' ? split(it, '') : Object(it);
                } : Object;


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/inspect-source.js":
            /*!**********************************************************!*\
              !*** ./node_modules/core-js/internals/inspect-source.js ***!
              \**********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var uncurryThis = __webpack_require__( /*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
                var isCallable = __webpack_require__( /*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
                var store = __webpack_require__( /*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");
                var functionToString = uncurryThis(Function.toString);
                // this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
                if (!isCallable(store.inspectSource)) {
                    store.inspectSource = function(it) {
                        return functionToString(it);
                    };
                }
                module.exports = store.inspectSource;


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/internal-state.js":
            /*!**********************************************************!*\
              !*** ./node_modules/core-js/internals/internal-state.js ***!
              \**********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var NATIVE_WEAK_MAP = __webpack_require__( /*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");
                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var uncurryThis = __webpack_require__( /*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
                var isObject = __webpack_require__( /*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
                var createNonEnumerableProperty = __webpack_require__( /*! ../internals/create-non-enumerable-property */ "./node_modules/core-js/internals/create-non-enumerable-property.js");
                var hasOwn = __webpack_require__( /*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
                var shared = __webpack_require__( /*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");
                var sharedKey = __webpack_require__( /*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
                var hiddenKeys = __webpack_require__( /*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
                var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
                var TypeError = global.TypeError;
                var WeakMap = global.WeakMap;
                var set, get, has;
                var enforce = function(it) {
                    return has(it) ? get(it) : set(it, {});
                };
                var getterFor = function(TYPE) {
                    return function(it) {
                        var state;
                        if (!isObject(it) || (state = get(it)).type !== TYPE) {
                            throw TypeError('Incompatible receiver, ' + TYPE + ' required');
                        }
                        return state;
                    };
                };
                if (NATIVE_WEAK_MAP || shared.state) {
                    var store = shared.state || (shared.state = new WeakMap());
                    var wmget = uncurryThis(store.get);
                    var wmhas = uncurryThis(store.has);
                    var wmset = uncurryThis(store.set);
                    set = function(it, metadata) {
                        if (wmhas(store, it))
                            throw new TypeError(OBJECT_ALREADY_INITIALIZED);
                        metadata.facade = it;
                        wmset(store, it, metadata);
                        return metadata;
                    };
                    get = function(it) {
                        return wmget(store, it) || {};
                    };
                    has = function(it) {
                        return wmhas(store, it);
                    };
                } else {
                    var STATE = sharedKey('state');
                    hiddenKeys[STATE] = true;
                    set = function(it, metadata) {
                        if (hasOwn(it, STATE))
                            throw new TypeError(OBJECT_ALREADY_INITIALIZED);
                        metadata.facade = it;
                        createNonEnumerableProperty(it, STATE, metadata);
                        return metadata;
                    };
                    get = function(it) {
                        return hasOwn(it, STATE) ? it[STATE] : {};
                    };
                    has = function(it) {
                        return hasOwn(it, STATE);
                    };
                }
                module.exports = {
                    set: set,
                    get: get,
                    has: has,
                    enforce: enforce,
                    getterFor: getterFor
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/is-array.js":
            /*!****************************************************!*\
              !*** ./node_modules/core-js/internals/is-array.js ***!
              \****************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var classof = __webpack_require__( /*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
                // `IsArray` abstract operation
                // https://tc39.es/ecma262/#sec-isarray
                // eslint-disable-next-line es-x/no-array-isarray -- safe
                module.exports = Array.isArray || function isArray(argument) {
                    return classof(argument) == 'Array';
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/is-callable.js":
            /*!*******************************************************!*\
              !*** ./node_modules/core-js/internals/is-callable.js ***!
              \*******************************************************/
            /***/
            (function(module) {


                // `IsCallable` abstract operation
                // https://tc39.es/ecma262/#sec-iscallable
                module.exports = function(argument) {
                    return typeof argument == 'function';
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/is-constructor.js":
            /*!**********************************************************!*\
              !*** ./node_modules/core-js/internals/is-constructor.js ***!
              \**********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var uncurryThis = __webpack_require__( /*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
                var fails = __webpack_require__( /*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
                var isCallable = __webpack_require__( /*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
                var classof = __webpack_require__( /*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
                var getBuiltIn = __webpack_require__( /*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
                var inspectSource = __webpack_require__( /*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");
                var noop = function() {};
                var empty = [];
                var construct = getBuiltIn('Reflect', 'construct');
                var constructorRegExp = /^\s*(?:class|function)\b/;
                var exec = uncurryThis(constructorRegExp.exec);
                var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
                var isConstructorModern = function isConstructor(argument) {
                    if (!isCallable(argument))
                        return false;
                    try {
                        construct(noop, empty, argument);
                        return true;
                    } catch (error) {
                        return false;
                    }
                };
                var isConstructorLegacy = function isConstructor(argument) {
                    if (!isCallable(argument))
                        return false;
                    switch (classof(argument)) {
                        case 'AsyncFunction':
                        case 'GeneratorFunction':
                        case 'AsyncGeneratorFunction':
                            return false;
                    }
                    try {
                        // we can't check .prototype since constructors produced by .bind haven't it
                        // `Function#toString` throws on some built-it function in some legacy engines
                        // (for example, `DOMQuad` and similar in FF41-)
                        return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
                    } catch (error) {
                        return true;
                    }
                };
                isConstructorLegacy.sham = true;
                // `IsConstructor` abstract operation
                // https://tc39.es/ecma262/#sec-isconstructor
                module.exports = !construct || fails(function() {
                    var called;
                    return isConstructorModern(isConstructorModern.call) ||
                        !isConstructorModern(Object) ||
                        !isConstructorModern(function() {
                            called = true;
                        }) ||
                        called;
                }) ? isConstructorLegacy : isConstructorModern;


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/is-forced.js":
            /*!*****************************************************!*\
              !*** ./node_modules/core-js/internals/is-forced.js ***!
              \*****************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var fails = __webpack_require__( /*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
                var isCallable = __webpack_require__( /*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
                var replacement = /#|\.prototype\./;
                var isForced = function(feature, detection) {
                    var value = data[normalize(feature)];
                    return value == POLYFILL ? true :
                        value == NATIVE ? false :
                        isCallable(detection) ? fails(detection) :
                        !!detection;
                };
                var normalize = isForced.normalize = function(string) {
                    return String(string).replace(replacement, '.').toLowerCase();
                };
                var data = isForced.data = {};
                var NATIVE = isForced.NATIVE = 'N';
                var POLYFILL = isForced.POLYFILL = 'P';
                module.exports = isForced;


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/is-object.js":
            /*!*****************************************************!*\
              !*** ./node_modules/core-js/internals/is-object.js ***!
              \*****************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var isCallable = __webpack_require__( /*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
                module.exports = function(it) {
                    return typeof it == 'object' ? it !== null : isCallable(it);
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/is-pure.js":
            /*!***************************************************!*\
              !*** ./node_modules/core-js/internals/is-pure.js ***!
              \***************************************************/
            /***/
            (function(module) {


                module.exports = false;


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/is-symbol.js":
            /*!*****************************************************!*\
              !*** ./node_modules/core-js/internals/is-symbol.js ***!
              \*****************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var getBuiltIn = __webpack_require__( /*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
                var isCallable = __webpack_require__( /*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
                var isPrototypeOf = __webpack_require__( /*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
                var USE_SYMBOL_AS_UID = __webpack_require__( /*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");
                var Object = global.Object;
                module.exports = USE_SYMBOL_AS_UID ? function(it) {
                    return typeof it == 'symbol';
                } : function(it) {
                    var $Symbol = getBuiltIn('Symbol');
                    return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, Object(it));
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/length-of-array-like.js":
            /*!****************************************************************!*\
              !*** ./node_modules/core-js/internals/length-of-array-like.js ***!
              \****************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var toLength = __webpack_require__( /*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
                // `LengthOfArrayLike` abstract operation
                // https://tc39.es/ecma262/#sec-lengthofarraylike
                module.exports = function(obj) {
                    return toLength(obj.length);
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/make-built-in.js":
            /*!*********************************************************!*\
              !*** ./node_modules/core-js/internals/make-built-in.js ***!
              \*********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var fails = __webpack_require__( /*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
                var isCallable = __webpack_require__( /*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
                var hasOwn = __webpack_require__( /*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
                var defineProperty = (__webpack_require__( /*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
                var CONFIGURABLE_FUNCTION_NAME = (__webpack_require__( /*! ../internals/function-name */ "./node_modules/core-js/internals/function-name.js").CONFIGURABLE);
                var inspectSource = __webpack_require__( /*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");
                var InternalStateModule = __webpack_require__( /*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
                var enforceInternalState = InternalStateModule.enforce;
                var getInternalState = InternalStateModule.get;
                var CONFIGURABLE_LENGTH = !fails(function() {
                    return defineProperty(function() {}, 'length', {
                        value: 8
                    }).length !== 8;
                });
                var TEMPLATE = String(String).split('String');
                var makeBuiltIn = module.exports = function(value, name, options) {
                    if (String(name).slice(0, 7) === 'Symbol(') {
                        name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
                    }
                    if (options && options.getter)
                        name = 'get ' + name;
                    if (options && options.setter)
                        name = 'set ' + name;
                    if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
                        defineProperty(value, 'name', {
                            value: name,
                            configurable: true
                        });
                    }
                    if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {
                        defineProperty(value, 'length', {
                            value: options.arity
                        });
                    }
                    var state = enforceInternalState(value);
                    if (!hasOwn(state, 'source')) {
                        state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
                    }
                    return value;
                };
                // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
                // eslint-disable-next-line no-extend-native -- required
                Function.prototype.toString = makeBuiltIn(function toString() {
                    return isCallable(this) && getInternalState(this).source || inspectSource(this);
                }, 'toString');


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/native-symbol-registry.js":
            /*!******************************************************************!*\
              !*** ./node_modules/core-js/internals/native-symbol-registry.js ***!
              \******************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var NATIVE_SYMBOL = __webpack_require__( /*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
                /* eslint-disable es-x/no-symbol -- safe */
                module.exports = NATIVE_SYMBOL && !!Symbol['for'] && !!Symbol.keyFor;


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/native-symbol.js":
            /*!*********************************************************!*\
              !*** ./node_modules/core-js/internals/native-symbol.js ***!
              \*********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                /* eslint-disable es-x/no-symbol -- required for testing */
                var V8_VERSION = __webpack_require__( /*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");
                var fails = __webpack_require__( /*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
                // eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing
                module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
                    var symbol = Symbol();
                    // Chrome 38 Symbol has incorrect toString conversion
                    // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
                    return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
                        // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
                        !Symbol.sham && V8_VERSION && V8_VERSION < 41;
                });


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/native-weak-map.js":
            /*!***********************************************************!*\
              !*** ./node_modules/core-js/internals/native-weak-map.js ***!
              \***********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var isCallable = __webpack_require__( /*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
                var inspectSource = __webpack_require__( /*! ../internals/inspect-source */ "./node_modules/core-js/internals/inspect-source.js");
                var WeakMap = global.WeakMap;
                module.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/object-create.js":
            /*!*********************************************************!*\
              !*** ./node_modules/core-js/internals/object-create.js ***!
              \*********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                /* global ActiveXObject -- old IE, WSH */
                var anObject = __webpack_require__( /*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
                var definePropertiesModule = __webpack_require__( /*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
                var enumBugKeys = __webpack_require__( /*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");
                var hiddenKeys = __webpack_require__( /*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
                var html = __webpack_require__( /*! ../internals/html */ "./node_modules/core-js/internals/html.js");
                var documentCreateElement = __webpack_require__( /*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
                var sharedKey = __webpack_require__( /*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
                var GT = '>';
                var LT = '<';
                var PROTOTYPE = 'prototype';
                var SCRIPT = 'script';
                var IE_PROTO = sharedKey('IE_PROTO');
                var EmptyConstructor = function() {};
                var scriptTag = function(content) {
                    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
                };
                // Create object with fake `null` prototype: use ActiveX Object with cleared prototype
                var NullProtoObjectViaActiveX = function(activeXDocument) {
                    activeXDocument.write(scriptTag(''));
                    activeXDocument.close();
                    var temp = activeXDocument.parentWindow.Object;
                    activeXDocument = null; // avoid memory leak
                    return temp;
                };
                // Create object with fake `null` prototype: use iframe Object with cleared prototype
                var NullProtoObjectViaIFrame = function() {
                    // Thrash, waste and sodomy: IE GC bug
                    var iframe = documentCreateElement('iframe');
                    var JS = 'java' + SCRIPT + ':';
                    var iframeDocument;
                    iframe.style.display = 'none';
                    html.appendChild(iframe);
                    // https://github.com/zloirock/core-js/issues/475
                    iframe.src = String(JS);
                    iframeDocument = iframe.contentWindow.document;
                    iframeDocument.open();
                    iframeDocument.write(scriptTag('document.F=Object'));
                    iframeDocument.close();
                    return iframeDocument.F;
                };
                // Check for document.domain and active x support
                // No need to use active x approach when document.domain is not set
                // see https://github.com/es-shims/es5-shim/issues/150
                // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
                // avoid IE GC bug
                var activeXDocument;
                var NullProtoObject = function() {
                    try {
                        activeXDocument = new ActiveXObject('htmlfile');
                    } catch (error) { /* ignore */ }
                    NullProtoObject = typeof document != 'undefined' ?
                        document.domain && activeXDocument ?
                        NullProtoObjectViaActiveX(activeXDocument) // old IE
                        :
                        NullProtoObjectViaIFrame() :
                        NullProtoObjectViaActiveX(activeXDocument); // WSH
                    var length = enumBugKeys.length;
                    while (length--)
                        delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
                    return NullProtoObject();
                };
                hiddenKeys[IE_PROTO] = true;
                // `Object.create` method
                // https://tc39.es/ecma262/#sec-object.create
                // eslint-disable-next-line es-x/no-object-create -- safe
                module.exports = Object.create || function create(O, Properties) {
                    var result;
                    if (O !== null) {
                        EmptyConstructor[PROTOTYPE] = anObject(O);
                        result = new EmptyConstructor();
                        EmptyConstructor[PROTOTYPE] = null;
                        // add "__proto__" for Object.getPrototypeOf polyfill
                        result[IE_PROTO] = O;
                    } else
                        result = NullProtoObject();
                    return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/object-define-properties.js":
            /*!********************************************************************!*\
              !*** ./node_modules/core-js/internals/object-define-properties.js ***!
              \********************************************************************/
            /***/
            (function(__unused_webpack_module, exports, __webpack_require__) {


                var DESCRIPTORS = __webpack_require__( /*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
                var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__( /*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");
                var definePropertyModule = __webpack_require__( /*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
                var anObject = __webpack_require__( /*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
                var toIndexedObject = __webpack_require__( /*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
                var objectKeys = __webpack_require__( /*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
                // `Object.defineProperties` method
                // https://tc39.es/ecma262/#sec-object.defineproperties
                // eslint-disable-next-line es-x/no-object-defineproperties -- safe
                exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
                    anObject(O);
                    var props = toIndexedObject(Properties);
                    var keys = objectKeys(Properties);
                    var length = keys.length;
                    var index = 0;
                    var key;
                    while (length > index)
                        definePropertyModule.f(O, key = keys[index++], props[key]);
                    return O;
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/object-define-property.js":
            /*!******************************************************************!*\
              !*** ./node_modules/core-js/internals/object-define-property.js ***!
              \******************************************************************/
            /***/
            (function(__unused_webpack_module, exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var DESCRIPTORS = __webpack_require__( /*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
                var IE8_DOM_DEFINE = __webpack_require__( /*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
                var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__( /*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js/internals/v8-prototype-define-bug.js");
                var anObject = __webpack_require__( /*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
                var toPropertyKey = __webpack_require__( /*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
                var TypeError = global.TypeError;
                // eslint-disable-next-line es-x/no-object-defineproperty -- safe
                var $defineProperty = Object.defineProperty;
                // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
                var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
                var ENUMERABLE = 'enumerable';
                var CONFIGURABLE = 'configurable';
                var WRITABLE = 'writable';
                // `Object.defineProperty` method
                // https://tc39.es/ecma262/#sec-object.defineproperty
                exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
                    anObject(O);
                    P = toPropertyKey(P);
                    anObject(Attributes);
                    if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
                        var current = $getOwnPropertyDescriptor(O, P);
                        if (current && current[WRITABLE]) {
                            O[P] = Attributes.value;
                            Attributes = {
                                configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                                enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                                writable: false
                            };
                        }
                    }
                    return $defineProperty(O, P, Attributes);
                } : $defineProperty : function defineProperty(O, P, Attributes) {
                    anObject(O);
                    P = toPropertyKey(P);
                    anObject(Attributes);
                    if (IE8_DOM_DEFINE)
                        try {
                            return $defineProperty(O, P, Attributes);
                        }
                    catch (error) { /* empty */ }
                    if ('get' in Attributes || 'set' in Attributes)
                        throw TypeError('Accessors not supported');
                    if ('value' in Attributes)
                        O[P] = Attributes.value;
                    return O;
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
            /*!******************************************************************************!*\
              !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
              \******************************************************************************/
            /***/
            (function(__unused_webpack_module, exports, __webpack_require__) {


                var DESCRIPTORS = __webpack_require__( /*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
                var call = __webpack_require__( /*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
                var propertyIsEnumerableModule = __webpack_require__( /*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
                var createPropertyDescriptor = __webpack_require__( /*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
                var toIndexedObject = __webpack_require__( /*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
                var toPropertyKey = __webpack_require__( /*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
                var hasOwn = __webpack_require__( /*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
                var IE8_DOM_DEFINE = __webpack_require__( /*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
                // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
                var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
                // `Object.getOwnPropertyDescriptor` method
                // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
                exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
                    O = toIndexedObject(O);
                    P = toPropertyKey(P);
                    if (IE8_DOM_DEFINE)
                        try {
                            return $getOwnPropertyDescriptor(O, P);
                        }
                    catch (error) { /* empty */ }
                    if (hasOwn(O, P))
                        return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/object-get-own-property-names-external.js":
            /*!**********************************************************************************!*\
              !*** ./node_modules/core-js/internals/object-get-own-property-names-external.js ***!
              \**********************************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                /* eslint-disable es-x/no-object-getownpropertynames -- safe */
                var classof = __webpack_require__( /*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
                var toIndexedObject = __webpack_require__( /*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
                var $getOwnPropertyNames = (__webpack_require__( /*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f);
                var arraySlice = __webpack_require__( /*! ../internals/array-slice-simple */ "./node_modules/core-js/internals/array-slice-simple.js");
                var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ?
                    Object.getOwnPropertyNames(window) : [];
                var getWindowNames = function(it) {
                    try {
                        return $getOwnPropertyNames(it);
                    } catch (error) {
                        return arraySlice(windowNames);
                    }
                };
                // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
                module.exports.f = function getOwnPropertyNames(it) {
                    return windowNames && classof(it) == 'Window' ?
                        getWindowNames(it) :
                        $getOwnPropertyNames(toIndexedObject(it));
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/object-get-own-property-names.js":
            /*!*************************************************************************!*\
              !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
              \*************************************************************************/
            /***/
            (function(__unused_webpack_module, exports, __webpack_require__) {


                var internalObjectKeys = __webpack_require__( /*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
                var enumBugKeys = __webpack_require__( /*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");
                var hiddenKeys = enumBugKeys.concat('length', 'prototype');
                // `Object.getOwnPropertyNames` method
                // https://tc39.es/ecma262/#sec-object.getownpropertynames
                // eslint-disable-next-line es-x/no-object-getownpropertynames -- safe
                exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
                    return internalObjectKeys(O, hiddenKeys);
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/object-get-own-property-symbols.js":
            /*!***************************************************************************!*\
              !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
              \***************************************************************************/
            /***/
            (function(__unused_webpack_module, exports) {


                // eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe
                exports.f = Object.getOwnPropertySymbols;


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/object-is-prototype-of.js":
            /*!******************************************************************!*\
              !*** ./node_modules/core-js/internals/object-is-prototype-of.js ***!
              \******************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var uncurryThis = __webpack_require__( /*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
                module.exports = uncurryThis({}.isPrototypeOf);


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/object-keys-internal.js":
            /*!****************************************************************!*\
              !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
              \****************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var uncurryThis = __webpack_require__( /*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
                var hasOwn = __webpack_require__( /*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
                var toIndexedObject = __webpack_require__( /*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
                var indexOf = (__webpack_require__( /*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf);
                var hiddenKeys = __webpack_require__( /*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
                var push = uncurryThis([].push);
                module.exports = function(object, names) {
                    var O = toIndexedObject(object);
                    var i = 0;
                    var result = [];
                    var key;
                    for (key in O)
                        !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
                    // Don't enum bug & hidden keys
                    while (names.length > i)
                        if (hasOwn(O, key = names[i++])) {
                            ~indexOf(result, key) || push(result, key);
                        }
                    return result;
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/object-keys.js":
            /*!*******************************************************!*\
              !*** ./node_modules/core-js/internals/object-keys.js ***!
              \*******************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var internalObjectKeys = __webpack_require__( /*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
                var enumBugKeys = __webpack_require__( /*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");
                // `Object.keys` method
                // https://tc39.es/ecma262/#sec-object.keys
                // eslint-disable-next-line es-x/no-object-keys -- safe
                module.exports = Object.keys || function keys(O) {
                    return internalObjectKeys(O, enumBugKeys);
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/object-property-is-enumerable.js":
            /*!*************************************************************************!*\
              !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
              \*************************************************************************/
            /***/
            (function(__unused_webpack_module, exports) {


                var $propertyIsEnumerable = {}.propertyIsEnumerable;
                // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe
                var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
                // Nashorn ~ JDK8 bug
                var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({
                    1: 2
                }, 1);
                // `Object.prototype.propertyIsEnumerable` method implementation
                // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
                exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
                    var descriptor = getOwnPropertyDescriptor(this, V);
                    return !!descriptor && descriptor.enumerable;
                } : $propertyIsEnumerable;


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/object-to-string.js":
            /*!************************************************************!*\
              !*** ./node_modules/core-js/internals/object-to-string.js ***!
              \************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var TO_STRING_TAG_SUPPORT = __webpack_require__( /*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
                var classof = __webpack_require__( /*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
                // `Object.prototype.toString` method implementation
                // https://tc39.es/ecma262/#sec-object.prototype.tostring
                module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
                    return '[object ' + classof(this) + ']';
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/ordinary-to-primitive.js":
            /*!*****************************************************************!*\
              !*** ./node_modules/core-js/internals/ordinary-to-primitive.js ***!
              \*****************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var call = __webpack_require__( /*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
                var isCallable = __webpack_require__( /*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
                var isObject = __webpack_require__( /*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
                var TypeError = global.TypeError;
                // `OrdinaryToPrimitive` abstract operation
                // https://tc39.es/ecma262/#sec-ordinarytoprimitive
                module.exports = function(input, pref) {
                    var fn, val;
                    if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
                        return val;
                    if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))
                        return val;
                    if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))
                        return val;
                    throw TypeError("Can't convert object to primitive value");
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/own-keys.js":
            /*!****************************************************!*\
              !*** ./node_modules/core-js/internals/own-keys.js ***!
              \****************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var getBuiltIn = __webpack_require__( /*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
                var uncurryThis = __webpack_require__( /*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
                var getOwnPropertyNamesModule = __webpack_require__( /*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
                var getOwnPropertySymbolsModule = __webpack_require__( /*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
                var anObject = __webpack_require__( /*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
                var concat = uncurryThis([].concat);
                // all object keys, includes non-enumerable and symbols
                module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
                    var keys = getOwnPropertyNamesModule.f(anObject(it));
                    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                    return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/path.js":
            /*!************************************************!*\
              !*** ./node_modules/core-js/internals/path.js ***!
              \************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                module.exports = global;


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/require-object-coercible.js":
            /*!********************************************************************!*\
              !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
              \********************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var TypeError = global.TypeError;
                // `RequireObjectCoercible` abstract operation
                // https://tc39.es/ecma262/#sec-requireobjectcoercible
                module.exports = function(it) {
                    if (it == undefined)
                        throw TypeError("Can't call method on " + it);
                    return it;
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/set-global.js":
            /*!******************************************************!*\
              !*** ./node_modules/core-js/internals/set-global.js ***!
              \******************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                // eslint-disable-next-line es-x/no-object-defineproperty -- safe
                var defineProperty = Object.defineProperty;
                module.exports = function(key, value) {
                    try {
                        defineProperty(global, key, {
                            value: value,
                            configurable: true,
                            writable: true
                        });
                    } catch (error) {
                        global[key] = value;
                    }
                    return value;
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/set-to-string-tag.js":
            /*!*************************************************************!*\
              !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
              \*************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var defineProperty = (__webpack_require__( /*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
                var hasOwn = __webpack_require__( /*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
                var wellKnownSymbol = __webpack_require__( /*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
                var TO_STRING_TAG = wellKnownSymbol('toStringTag');
                module.exports = function(target, TAG, STATIC) {
                    if (target && !STATIC)
                        target = target.prototype;
                    if (target && !hasOwn(target, TO_STRING_TAG)) {
                        defineProperty(target, TO_STRING_TAG, {
                            configurable: true,
                            value: TAG
                        });
                    }
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/shared-key.js":
            /*!******************************************************!*\
              !*** ./node_modules/core-js/internals/shared-key.js ***!
              \******************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var shared = __webpack_require__( /*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
                var uid = __webpack_require__( /*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
                var keys = shared('keys');
                module.exports = function(key) {
                    return keys[key] || (keys[key] = uid(key));
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/shared-store.js":
            /*!********************************************************!*\
              !*** ./node_modules/core-js/internals/shared-store.js ***!
              \********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var setGlobal = __webpack_require__( /*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
                var SHARED = '__core-js_shared__';
                var store = global[SHARED] || setGlobal(SHARED, {});
                module.exports = store;


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/shared.js":
            /*!**************************************************!*\
              !*** ./node_modules/core-js/internals/shared.js ***!
              \**************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var IS_PURE = __webpack_require__( /*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
                var store = __webpack_require__( /*! ../internals/shared-store */ "./node_modules/core-js/internals/shared-store.js");
                (module.exports = function(key, value) {
                    return store[key] || (store[key] = value !== undefined ? value : {});
                })('versions', []).push({
                    version: '3.22.4',
                    mode: IS_PURE ? 'pure' : 'global',
                    copyright: ' 2014-2022 Denis Pushkarev (zloirock.ru)',
                    license: 'https://github.com/zloirock/core-js/blob/v3.22.4/LICENSE',
                    source: 'https://github.com/zloirock/core-js'
                });


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/symbol-define-to-primitive.js":
            /*!**********************************************************************!*\
              !*** ./node_modules/core-js/internals/symbol-define-to-primitive.js ***!
              \**********************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var call = __webpack_require__( /*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
                var getBuiltIn = __webpack_require__( /*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
                var wellKnownSymbol = __webpack_require__( /*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
                var defineBuiltIn = __webpack_require__( /*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
                module.exports = function() {
                    var Symbol = getBuiltIn('Symbol');
                    var SymbolPrototype = Symbol && Symbol.prototype;
                    var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
                    var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
                    if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
                        // `Symbol.prototype[@@toPrimitive]` method
                        // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
                        // eslint-disable-next-line no-unused-vars -- required for .length
                        defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function(hint) {
                            return call(valueOf, this);
                        }, {
                            arity: 1
                        });
                    }
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/to-absolute-index.js":
            /*!*************************************************************!*\
              !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
              \*************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var toIntegerOrInfinity = __webpack_require__( /*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");
                var max = Math.max;
                var min = Math.min;
                // Helper for a popular repeating case of the spec:
                // Let integer be ? ToInteger(index).
                // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
                module.exports = function(index, length) {
                    var integer = toIntegerOrInfinity(index);
                    return integer < 0 ? max(integer + length, 0) : min(integer, length);
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/to-indexed-object.js":
            /*!*************************************************************!*\
              !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
              \*************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                // toObject with fallback for non-array-like ES3 strings
                var IndexedObject = __webpack_require__( /*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
                var requireObjectCoercible = __webpack_require__( /*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
                module.exports = function(it) {
                    return IndexedObject(requireObjectCoercible(it));
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/to-integer-or-infinity.js":
            /*!******************************************************************!*\
              !*** ./node_modules/core-js/internals/to-integer-or-infinity.js ***!
              \******************************************************************/
            /***/
            (function(module) {


                var ceil = Math.ceil;
                var floor = Math.floor;
                // `ToIntegerOrInfinity` abstract operation
                // https://tc39.es/ecma262/#sec-tointegerorinfinity
                module.exports = function(argument) {
                    var number = +argument;
                    // eslint-disable-next-line no-self-compare -- safe
                    return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/to-length.js":
            /*!*****************************************************!*\
              !*** ./node_modules/core-js/internals/to-length.js ***!
              \*****************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var toIntegerOrInfinity = __webpack_require__( /*! ../internals/to-integer-or-infinity */ "./node_modules/core-js/internals/to-integer-or-infinity.js");
                var min = Math.min;
                // `ToLength` abstract operation
                // https://tc39.es/ecma262/#sec-tolength
                module.exports = function(argument) {
                    return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/to-object.js":
            /*!*****************************************************!*\
              !*** ./node_modules/core-js/internals/to-object.js ***!
              \*****************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var requireObjectCoercible = __webpack_require__( /*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
                var Object = global.Object;
                // `ToObject` abstract operation
                // https://tc39.es/ecma262/#sec-toobject
                module.exports = function(argument) {
                    return Object(requireObjectCoercible(argument));
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/to-primitive.js":
            /*!********************************************************!*\
              !*** ./node_modules/core-js/internals/to-primitive.js ***!
              \********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var call = __webpack_require__( /*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
                var isObject = __webpack_require__( /*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
                var isSymbol = __webpack_require__( /*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
                var getMethod = __webpack_require__( /*! ../internals/get-method */ "./node_modules/core-js/internals/get-method.js");
                var ordinaryToPrimitive = __webpack_require__( /*! ../internals/ordinary-to-primitive */ "./node_modules/core-js/internals/ordinary-to-primitive.js");
                var wellKnownSymbol = __webpack_require__( /*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
                var TypeError = global.TypeError;
                var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
                // `ToPrimitive` abstract operation
                // https://tc39.es/ecma262/#sec-toprimitive
                module.exports = function(input, pref) {
                    if (!isObject(input) || isSymbol(input))
                        return input;
                    var exoticToPrim = getMethod(input, TO_PRIMITIVE);
                    var result;
                    if (exoticToPrim) {
                        if (pref === undefined)
                            pref = 'default';
                        result = call(exoticToPrim, input, pref);
                        if (!isObject(result) || isSymbol(result))
                            return result;
                        throw TypeError("Can't convert object to primitive value");
                    }
                    if (pref === undefined)
                        pref = 'number';
                    return ordinaryToPrimitive(input, pref);
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/to-property-key.js":
            /*!***********************************************************!*\
              !*** ./node_modules/core-js/internals/to-property-key.js ***!
              \***********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var toPrimitive = __webpack_require__( /*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
                var isSymbol = __webpack_require__( /*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
                // `ToPropertyKey` abstract operation
                // https://tc39.es/ecma262/#sec-topropertykey
                module.exports = function(argument) {
                    var key = toPrimitive(argument, 'string');
                    return isSymbol(key) ? key : key + '';
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/to-string-tag-support.js":
            /*!*****************************************************************!*\
              !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!
              \*****************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var wellKnownSymbol = __webpack_require__( /*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
                var TO_STRING_TAG = wellKnownSymbol('toStringTag');
                var test = {};
                test[TO_STRING_TAG] = 'z';
                module.exports = String(test) === '[object z]';


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/to-string.js":
            /*!*****************************************************!*\
              !*** ./node_modules/core-js/internals/to-string.js ***!
              \*****************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var classof = __webpack_require__( /*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
                var String = global.String;
                module.exports = function(argument) {
                    if (classof(argument) === 'Symbol')
                        throw TypeError('Cannot convert a Symbol value to a string');
                    return String(argument);
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/try-to-string.js":
            /*!*********************************************************!*\
              !*** ./node_modules/core-js/internals/try-to-string.js ***!
              \*********************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var String = global.String;
                module.exports = function(argument) {
                    try {
                        return String(argument);
                    } catch (error) {
                        return 'Object';
                    }
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/uid.js":
            /*!***********************************************!*\
              !*** ./node_modules/core-js/internals/uid.js ***!
              \***********************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var uncurryThis = __webpack_require__( /*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
                var id = 0;
                var postfix = Math.random();
                var toString = uncurryThis(1.0.toString);
                module.exports = function(key) {
                    return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/use-symbol-as-uid.js":
            /*!*************************************************************!*\
              !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
              \*************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                /* eslint-disable es-x/no-symbol -- required for testing */
                var NATIVE_SYMBOL = __webpack_require__( /*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
                module.exports = NATIVE_SYMBOL &&
                    !Symbol.sham &&
                    typeof Symbol.iterator == 'symbol';


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/v8-prototype-define-bug.js":
            /*!*******************************************************************!*\
              !*** ./node_modules/core-js/internals/v8-prototype-define-bug.js ***!
              \*******************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var DESCRIPTORS = __webpack_require__( /*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
                var fails = __webpack_require__( /*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
                // V8 ~ Chrome 36-
                // https://bugs.chromium.org/p/v8/issues/detail?id=3334
                module.exports = DESCRIPTORS && fails(function() {
                    // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing
                    return Object.defineProperty(function() {}, 'prototype', {
                        value: 42,
                        writable: false
                    }).prototype != 42;
                });


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/well-known-symbol-wrapped.js":
            /*!*********************************************************************!*\
              !*** ./node_modules/core-js/internals/well-known-symbol-wrapped.js ***!
              \*********************************************************************/
            /***/
            (function(__unused_webpack_module, exports, __webpack_require__) {


                var wellKnownSymbol = __webpack_require__( /*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
                exports.f = wellKnownSymbol;


                /***/
            }),

        /***/
        "./node_modules/core-js/internals/well-known-symbol.js":
            /*!*************************************************************!*\
              !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
              \*************************************************************/
            /***/
            (function(module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var shared = __webpack_require__( /*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
                var hasOwn = __webpack_require__( /*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
                var uid = __webpack_require__( /*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
                var NATIVE_SYMBOL = __webpack_require__( /*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
                var USE_SYMBOL_AS_UID = __webpack_require__( /*! ../internals/use-symbol-as-uid */ "./node_modules/core-js/internals/use-symbol-as-uid.js");
                var WellKnownSymbolsStore = shared('wks');
                var Symbol = global.Symbol;
                var symbolFor = Symbol && Symbol['for'];
                var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;
                module.exports = function(name) {
                    if (!hasOwn(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
                        var description = 'Symbol.' + name;
                        if (NATIVE_SYMBOL && hasOwn(Symbol, name)) {
                            WellKnownSymbolsStore[name] = Symbol[name];
                        } else if (USE_SYMBOL_AS_UID && symbolFor) {
                            WellKnownSymbolsStore[name] = symbolFor(description);
                        } else {
                            WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
                        }
                    }
                    return WellKnownSymbolsStore[name];
                };


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.array.concat.js":
            /*!*********************************************************!*\
              !*** ./node_modules/core-js/modules/es.array.concat.js ***!
              \*********************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var $ = __webpack_require__( /*! ../internals/export */ "./node_modules/core-js/internals/export.js");
                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var fails = __webpack_require__( /*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
                var isArray = __webpack_require__( /*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
                var isObject = __webpack_require__( /*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
                var toObject = __webpack_require__( /*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
                var lengthOfArrayLike = __webpack_require__( /*! ../internals/length-of-array-like */ "./node_modules/core-js/internals/length-of-array-like.js");
                var createProperty = __webpack_require__( /*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
                var arraySpeciesCreate = __webpack_require__( /*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");
                var arrayMethodHasSpeciesSupport = __webpack_require__( /*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");
                var wellKnownSymbol = __webpack_require__( /*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
                var V8_VERSION = __webpack_require__( /*! ../internals/engine-v8-version */ "./node_modules/core-js/internals/engine-v8-version.js");
                var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
                var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
                var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';
                var TypeError = global.TypeError;
                // We can't use this feature detection in V8 since it causes
                // deoptimization and serious performance degradation
                // https://github.com/zloirock/core-js/issues/679
                var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
                    var array = [];
                    array[IS_CONCAT_SPREADABLE] = false;
                    return array.concat()[0] !== array;
                });
                var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');
                var isConcatSpreadable = function(O) {
                    if (!isObject(O))
                        return false;
                    var spreadable = O[IS_CONCAT_SPREADABLE];
                    return spreadable !== undefined ? !!spreadable : isArray(O);
                };
                var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
                // `Array.prototype.concat` method
                // https://tc39.es/ecma262/#sec-array.prototype.concat
                // with adding support of @@isConcatSpreadable and @@species
                $({
                    target: 'Array',
                    proto: true,
                    arity: 1,
                    forced: FORCED
                }, {
                    // eslint-disable-next-line no-unused-vars -- required for `.length`
                    concat: function concat(arg) {
                        var O = toObject(this);
                        var A = arraySpeciesCreate(O, 0);
                        var n = 0;
                        var i, k, length, len, E;
                        for (i = -1, length = arguments.length; i < length; i++) {
                            E = i === -1 ? O : arguments[i];
                            if (isConcatSpreadable(E)) {
                                len = lengthOfArrayLike(E);
                                if (n + len > MAX_SAFE_INTEGER)
                                    throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                                for (k = 0; k < len; k++, n++)
                                    if (k in E)
                                        createProperty(A, n, E[k]);
                            } else {
                                if (n >= MAX_SAFE_INTEGER)
                                    throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                                createProperty(A, n++, E);
                            }
                        }
                        A.length = n;
                        return A;
                    }
                });


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.json.stringify.js":
            /*!***********************************************************!*\
              !*** ./node_modules/core-js/modules/es.json.stringify.js ***!
              \***********************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var $ = __webpack_require__( /*! ../internals/export */ "./node_modules/core-js/internals/export.js");
                var getBuiltIn = __webpack_require__( /*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
                var apply = __webpack_require__( /*! ../internals/function-apply */ "./node_modules/core-js/internals/function-apply.js");
                var call = __webpack_require__( /*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
                var uncurryThis = __webpack_require__( /*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
                var fails = __webpack_require__( /*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
                var isArray = __webpack_require__( /*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
                var isCallable = __webpack_require__( /*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
                var isObject = __webpack_require__( /*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
                var isSymbol = __webpack_require__( /*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
                var arraySlice = __webpack_require__( /*! ../internals/array-slice */ "./node_modules/core-js/internals/array-slice.js");
                var NATIVE_SYMBOL = __webpack_require__( /*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
                var $stringify = getBuiltIn('JSON', 'stringify');
                var exec = uncurryThis(/./.exec);
                var charAt = uncurryThis(''.charAt);
                var charCodeAt = uncurryThis(''.charCodeAt);
                var replace = uncurryThis(''.replace);
                var numberToString = uncurryThis(1.0.toString);
                var tester = /[\uD800-\uDFFF]/g;
                var low = /^[\uD800-\uDBFF]$/;
                var hi = /^[\uDC00-\uDFFF]$/;
                var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function() {
                    var symbol = getBuiltIn('Symbol')();
                    // MS Edge converts symbol values to JSON as {}
                    return $stringify([symbol]) != '[null]'
                        // WebKit converts symbol values to JSON as null
                        ||
                        $stringify({
                            a: symbol
                        }) != '{}'
                        // V8 throws on boxed symbols
                        ||
                        $stringify(Object(symbol)) != '{}';
                });
                // https://github.com/tc39/proposal-well-formed-stringify
                var ILL_FORMED_UNICODE = fails(function() {
                    return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"' ||
                        $stringify('\uDEAD') !== '"\\udead"';
                });
                var stringifyWithSymbolsFix = function(it, replacer) {
                    var args = arraySlice(arguments);
                    var $replacer = replacer;
                    if (!isObject(replacer) && it === undefined || isSymbol(it))
                        return; // IE8 returns string on undefined
                    if (!isArray(replacer))
                        replacer = function(key, value) {
                            if (isCallable($replacer))
                                value = call($replacer, this, key, value);
                            if (!isSymbol(value))
                                return value;
                        };
                    args[1] = replacer;
                    return apply($stringify, null, args);
                };
                var fixIllFormed = function(match, offset, string) {
                    var prev = charAt(string, offset - 1);
                    var next = charAt(string, offset + 1);
                    if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
                        return '\\u' + numberToString(charCodeAt(match, 0), 16);
                    }
                    return match;
                };
                if ($stringify) {
                    // `JSON.stringify` method
                    // https://tc39.es/ecma262/#sec-json.stringify
                    $({
                        target: 'JSON',
                        stat: true,
                        arity: 3,
                        forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE
                    }, {
                        // eslint-disable-next-line no-unused-vars -- required for `.length`
                        stringify: function stringify(it, replacer, space) {
                            var args = arraySlice(arguments);
                            var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
                            return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
                        }
                    });
                }


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.json.to-string-tag.js":
            /*!***************************************************************!*\
              !*** ./node_modules/core-js/modules/es.json.to-string-tag.js ***!
              \***************************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var setToStringTag = __webpack_require__( /*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
                // JSON[@@toStringTag] property
                // https://tc39.es/ecma262/#sec-json-@@tostringtag
                setToStringTag(global.JSON, 'JSON', true);


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.math.to-string-tag.js":
            /*!***************************************************************!*\
              !*** ./node_modules/core-js/modules/es.math.to-string-tag.js ***!
              \***************************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var setToStringTag = __webpack_require__( /*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
                // Math[@@toStringTag] property
                // https://tc39.es/ecma262/#sec-math-@@tostringtag
                setToStringTag(Math, 'Math', true);


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.object.get-own-property-symbols.js":
            /*!****************************************************************************!*\
              !*** ./node_modules/core-js/modules/es.object.get-own-property-symbols.js ***!
              \****************************************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var $ = __webpack_require__( /*! ../internals/export */ "./node_modules/core-js/internals/export.js");
                var NATIVE_SYMBOL = __webpack_require__( /*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
                var fails = __webpack_require__( /*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
                var getOwnPropertySymbolsModule = __webpack_require__( /*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
                var toObject = __webpack_require__( /*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
                // V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
                // https://bugs.chromium.org/p/v8/issues/detail?id=3443
                var FORCED = !NATIVE_SYMBOL || fails(function() {
                    getOwnPropertySymbolsModule.f(1);
                });
                // `Object.getOwnPropertySymbols` method
                // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
                $({
                    target: 'Object',
                    stat: true,
                    forced: FORCED
                }, {
                    getOwnPropertySymbols: function getOwnPropertySymbols(it) {
                        var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                        return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
                    }
                });


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.object.to-string.js":
            /*!*************************************************************!*\
              !*** ./node_modules/core-js/modules/es.object.to-string.js ***!
              \*************************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var TO_STRING_TAG_SUPPORT = __webpack_require__( /*! ../internals/to-string-tag-support */ "./node_modules/core-js/internals/to-string-tag-support.js");
                var defineBuiltIn = __webpack_require__( /*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
                var toString = __webpack_require__( /*! ../internals/object-to-string */ "./node_modules/core-js/internals/object-to-string.js");
                // `Object.prototype.toString` method
                // https://tc39.es/ecma262/#sec-object.prototype.tostring
                if (!TO_STRING_TAG_SUPPORT) {
                    defineBuiltIn(Object.prototype, 'toString', toString, {
                        unsafe: true
                    });
                }


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.reflect.to-string-tag.js":
            /*!******************************************************************!*\
              !*** ./node_modules/core-js/modules/es.reflect.to-string-tag.js ***!
              \******************************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var $ = __webpack_require__( /*! ../internals/export */ "./node_modules/core-js/internals/export.js");
                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var setToStringTag = __webpack_require__( /*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
                $({
                    global: true
                }, {
                    Reflect: {}
                });
                // Reflect[@@toStringTag] property
                // https://tc39.es/ecma262/#sec-reflect-@@tostringtag
                setToStringTag(global.Reflect, 'Reflect', true);


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.async-iterator.js":
            /*!******************************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.async-iterator.js ***!
              \******************************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var defineWellKnownSymbol = __webpack_require__( /*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
                // `Symbol.asyncIterator` well-known symbol
                // https://tc39.es/ecma262/#sec-symbol.asynciterator
                defineWellKnownSymbol('asyncIterator');


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.constructor.js":
            /*!***************************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.constructor.js ***!
              \***************************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var $ = __webpack_require__( /*! ../internals/export */ "./node_modules/core-js/internals/export.js");
                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var call = __webpack_require__( /*! ../internals/function-call */ "./node_modules/core-js/internals/function-call.js");
                var uncurryThis = __webpack_require__( /*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
                var IS_PURE = __webpack_require__( /*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
                var DESCRIPTORS = __webpack_require__( /*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
                var NATIVE_SYMBOL = __webpack_require__( /*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
                var fails = __webpack_require__( /*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
                var hasOwn = __webpack_require__( /*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
                var isPrototypeOf = __webpack_require__( /*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
                var anObject = __webpack_require__( /*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
                var toIndexedObject = __webpack_require__( /*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
                var toPropertyKey = __webpack_require__( /*! ../internals/to-property-key */ "./node_modules/core-js/internals/to-property-key.js");
                var $toString = __webpack_require__( /*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
                var createPropertyDescriptor = __webpack_require__( /*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
                var nativeObjectCreate = __webpack_require__( /*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
                var objectKeys = __webpack_require__( /*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
                var getOwnPropertyNamesModule = __webpack_require__( /*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
                var getOwnPropertyNamesExternal = __webpack_require__( /*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js/internals/object-get-own-property-names-external.js");
                var getOwnPropertySymbolsModule = __webpack_require__( /*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
                var getOwnPropertyDescriptorModule = __webpack_require__( /*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
                var definePropertyModule = __webpack_require__( /*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
                var definePropertiesModule = __webpack_require__( /*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
                var propertyIsEnumerableModule = __webpack_require__( /*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
                var defineBuiltIn = __webpack_require__( /*! ../internals/define-built-in */ "./node_modules/core-js/internals/define-built-in.js");
                var shared = __webpack_require__( /*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
                var sharedKey = __webpack_require__( /*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
                var hiddenKeys = __webpack_require__( /*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
                var uid = __webpack_require__( /*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
                var wellKnownSymbol = __webpack_require__( /*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
                var wrappedWellKnownSymbolModule = __webpack_require__( /*! ../internals/well-known-symbol-wrapped */ "./node_modules/core-js/internals/well-known-symbol-wrapped.js");
                var defineWellKnownSymbol = __webpack_require__( /*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
                var defineSymbolToPrimitive = __webpack_require__( /*! ../internals/symbol-define-to-primitive */ "./node_modules/core-js/internals/symbol-define-to-primitive.js");
                var setToStringTag = __webpack_require__( /*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
                var InternalStateModule = __webpack_require__( /*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
                var $forEach = (__webpack_require__( /*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").forEach);
                var HIDDEN = sharedKey('hidden');
                var SYMBOL = 'Symbol';
                var PROTOTYPE = 'prototype';
                var setInternalState = InternalStateModule.set;
                var getInternalState = InternalStateModule.getterFor(SYMBOL);
                var ObjectPrototype = Object[PROTOTYPE];
                var $Symbol = global.Symbol;
                var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
                var TypeError = global.TypeError;
                var QObject = global.QObject;
                var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                var nativeDefineProperty = definePropertyModule.f;
                var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
                var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
                var push = uncurryThis([].push);
                var AllSymbols = shared('symbols');
                var ObjectPrototypeSymbols = shared('op-symbols');
                var WellKnownSymbolsStore = shared('wks');
                // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
                var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
                // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
                var setSymbolDescriptor = DESCRIPTORS && fails(function() {
                    return nativeObjectCreate(nativeDefineProperty({}, 'a', {
                        get: function() {
                            return nativeDefineProperty(this, 'a', {
                                value: 7
                            }).a;
                        }
                    })).a != 7;
                }) ? function(O, P, Attributes) {
                    var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
                    if (ObjectPrototypeDescriptor)
                        delete ObjectPrototype[P];
                    nativeDefineProperty(O, P, Attributes);
                    if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
                        nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
                    }
                } : nativeDefineProperty;
                var wrap = function(tag, description) {
                    var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
                    setInternalState(symbol, {
                        type: SYMBOL,
                        tag: tag,
                        description: description
                    });
                    if (!DESCRIPTORS)
                        symbol.description = description;
                    return symbol;
                };
                var $defineProperty = function defineProperty(O, P, Attributes) {
                    if (O === ObjectPrototype)
                        $defineProperty(ObjectPrototypeSymbols, P, Attributes);
                    anObject(O);
                    var key = toPropertyKey(P);
                    anObject(Attributes);
                    if (hasOwn(AllSymbols, key)) {
                        if (!Attributes.enumerable) {
                            if (!hasOwn(O, HIDDEN))
                                nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
                            O[HIDDEN][key] = true;
                        } else {
                            if (hasOwn(O, HIDDEN) && O[HIDDEN][key])
                                O[HIDDEN][key] = false;
                            Attributes = nativeObjectCreate(Attributes, {
                                enumerable: createPropertyDescriptor(0, false)
                            });
                        }
                        return setSymbolDescriptor(O, key, Attributes);
                    }
                    return nativeDefineProperty(O, key, Attributes);
                };
                var $defineProperties = function defineProperties(O, Properties) {
                    anObject(O);
                    var properties = toIndexedObject(Properties);
                    var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
                    $forEach(keys, function(key) {
                        if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key))
                            $defineProperty(O, key, properties[key]);
                    });
                    return O;
                };
                var $create = function create(O, Properties) {
                    return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
                };
                var $propertyIsEnumerable = function propertyIsEnumerable(V) {
                    var P = toPropertyKey(V);
                    var enumerable = call(nativePropertyIsEnumerable, this, P);
                    if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P))
                        return false;
                    return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P] ?
                        enumerable : true;
                };
                var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
                    var it = toIndexedObject(O);
                    var key = toPropertyKey(P);
                    if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key))
                        return;
                    var descriptor = nativeGetOwnPropertyDescriptor(it, key);
                    if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
                        descriptor.enumerable = true;
                    }
                    return descriptor;
                };
                var $getOwnPropertyNames = function getOwnPropertyNames(O) {
                    var names = nativeGetOwnPropertyNames(toIndexedObject(O));
                    var result = [];
                    $forEach(names, function(key) {
                        if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key))
                            push(result, key);
                    });
                    return result;
                };
                var $getOwnPropertySymbols = function(O) {
                    var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
                    var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
                    var result = [];
                    $forEach(names, function(key) {
                        if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
                            push(result, AllSymbols[key]);
                        }
                    });
                    return result;
                };
                // `Symbol` constructor
                // https://tc39.es/ecma262/#sec-symbol-constructor
                if (!NATIVE_SYMBOL) {
                    $Symbol = function Symbol() {
                        if (isPrototypeOf(SymbolPrototype, this))
                            throw TypeError('Symbol is not a constructor');
                        var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
                        var tag = uid(description);
                        var setter = function(value) {
                            if (this === ObjectPrototype)
                                call(setter, ObjectPrototypeSymbols, value);
                            if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag))
                                this[HIDDEN][tag] = false;
                            setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
                        };
                        if (DESCRIPTORS && USE_SETTER)
                            setSymbolDescriptor(ObjectPrototype, tag, {
                                configurable: true,
                                set: setter
                            });
                        return wrap(tag, description);
                    };
                    SymbolPrototype = $Symbol[PROTOTYPE];
                    defineBuiltIn(SymbolPrototype, 'toString', function toString() {
                        return getInternalState(this).tag;
                    });
                    defineBuiltIn($Symbol, 'withoutSetter', function(description) {
                        return wrap(uid(description), description);
                    });
                    propertyIsEnumerableModule.f = $propertyIsEnumerable;
                    definePropertyModule.f = $defineProperty;
                    definePropertiesModule.f = $defineProperties;
                    getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
                    getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
                    getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
                    wrappedWellKnownSymbolModule.f = function(name) {
                        return wrap(wellKnownSymbol(name), name);
                    };
                    if (DESCRIPTORS) {
                        // https://github.com/tc39/proposal-Symbol-description
                        nativeDefineProperty(SymbolPrototype, 'description', {
                            configurable: true,
                            get: function description() {
                                return getInternalState(this).description;
                            }
                        });
                        if (!IS_PURE) {
                            defineBuiltIn(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, {
                                unsafe: true
                            });
                        }
                    }
                }
                $({
                    global: true,
                    wrap: true,
                    forced: !NATIVE_SYMBOL,
                    sham: !NATIVE_SYMBOL
                }, {
                    Symbol: $Symbol
                });
                $forEach(objectKeys(WellKnownSymbolsStore), function(name) {
                    defineWellKnownSymbol(name);
                });
                $({
                    target: SYMBOL,
                    stat: true,
                    forced: !NATIVE_SYMBOL
                }, {
                    useSetter: function() {
                        USE_SETTER = true;
                    },
                    useSimple: function() {
                        USE_SETTER = false;
                    }
                });
                $({
                    target: 'Object',
                    stat: true,
                    forced: !NATIVE_SYMBOL,
                    sham: !DESCRIPTORS
                }, {
                    // `Object.create` method
                    // https://tc39.es/ecma262/#sec-object.create
                    create: $create,
                    // `Object.defineProperty` method
                    // https://tc39.es/ecma262/#sec-object.defineproperty
                    defineProperty: $defineProperty,
                    // `Object.defineProperties` method
                    // https://tc39.es/ecma262/#sec-object.defineproperties
                    defineProperties: $defineProperties,
                    // `Object.getOwnPropertyDescriptor` method
                    // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
                    getOwnPropertyDescriptor: $getOwnPropertyDescriptor
                });
                $({
                    target: 'Object',
                    stat: true,
                    forced: !NATIVE_SYMBOL
                }, {
                    // `Object.getOwnPropertyNames` method
                    // https://tc39.es/ecma262/#sec-object.getownpropertynames
                    getOwnPropertyNames: $getOwnPropertyNames
                });
                // `Symbol.prototype[@@toPrimitive]` method
                // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
                defineSymbolToPrimitive();
                // `Symbol.prototype[@@toStringTag]` property
                // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
                setToStringTag($Symbol, SYMBOL);
                hiddenKeys[HIDDEN] = true;


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.description.js":
            /*!***************************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.description.js ***!
              \***************************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

                // `Symbol.prototype.description` getter
                // https://tc39.es/ecma262/#sec-symbol.prototype.description

                var $ = __webpack_require__( /*! ../internals/export */ "./node_modules/core-js/internals/export.js");
                var DESCRIPTORS = __webpack_require__( /*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
                var global = __webpack_require__( /*! ../internals/global */ "./node_modules/core-js/internals/global.js");
                var uncurryThis = __webpack_require__( /*! ../internals/function-uncurry-this */ "./node_modules/core-js/internals/function-uncurry-this.js");
                var hasOwn = __webpack_require__( /*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
                var isCallable = __webpack_require__( /*! ../internals/is-callable */ "./node_modules/core-js/internals/is-callable.js");
                var isPrototypeOf = __webpack_require__( /*! ../internals/object-is-prototype-of */ "./node_modules/core-js/internals/object-is-prototype-of.js");
                var toString = __webpack_require__( /*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
                var defineProperty = (__webpack_require__( /*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f);
                var copyConstructorProperties = __webpack_require__( /*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
                var NativeSymbol = global.Symbol;
                var SymbolPrototype = NativeSymbol && NativeSymbol.prototype;
                if (DESCRIPTORS && isCallable(NativeSymbol) && (!('description' in SymbolPrototype) ||
                        // Safari 12 bug
                        NativeSymbol().description !== undefined)) {
                    var EmptyStringDescriptionStore = {};
                    // wrap Symbol constructor for correct work with undefined description
                    var SymbolWrapper = function Symbol() {
                        var description = arguments.length < 1 || arguments[0] === undefined ? undefined : toString(arguments[0]);
                        var result = isPrototypeOf(SymbolPrototype, this) ?
                            new NativeSymbol(description)
                            // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
                            :
                            description === undefined ? NativeSymbol() : NativeSymbol(description);
                        if (description === '')
                            EmptyStringDescriptionStore[result] = true;
                        return result;
                    };
                    copyConstructorProperties(SymbolWrapper, NativeSymbol);
                    SymbolWrapper.prototype = SymbolPrototype;
                    SymbolPrototype.constructor = SymbolWrapper;
                    var NATIVE_SYMBOL = String(NativeSymbol('test')) == 'Symbol(test)';
                    var symbolToString = uncurryThis(SymbolPrototype.toString);
                    var symbolValueOf = uncurryThis(SymbolPrototype.valueOf);
                    var regexp = /^Symbol\((.*)\)[^)]+$/;
                    var replace = uncurryThis(''.replace);
                    var stringSlice = uncurryThis(''.slice);
                    defineProperty(SymbolPrototype, 'description', {
                        configurable: true,
                        get: function description() {
                            var symbol = symbolValueOf(this);
                            var string = symbolToString(symbol);
                            if (hasOwn(EmptyStringDescriptionStore, symbol))
                                return '';
                            var desc = NATIVE_SYMBOL ? stringSlice(string, 7, -1) : replace(string, regexp, '$1');
                            return desc === '' ? undefined : desc;
                        }
                    });
                    $({
                        global: true,
                        forced: true
                    }, {
                        Symbol: SymbolWrapper
                    });
                }


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.for.js":
            /*!*******************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.for.js ***!
              \*******************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var $ = __webpack_require__( /*! ../internals/export */ "./node_modules/core-js/internals/export.js");
                var getBuiltIn = __webpack_require__( /*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
                var hasOwn = __webpack_require__( /*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
                var toString = __webpack_require__( /*! ../internals/to-string */ "./node_modules/core-js/internals/to-string.js");
                var shared = __webpack_require__( /*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
                var NATIVE_SYMBOL_REGISTRY = __webpack_require__( /*! ../internals/native-symbol-registry */ "./node_modules/core-js/internals/native-symbol-registry.js");
                var StringToSymbolRegistry = shared('string-to-symbol-registry');
                var SymbolToStringRegistry = shared('symbol-to-string-registry');
                // `Symbol.for` method
                // https://tc39.es/ecma262/#sec-symbol.for
                $({
                    target: 'Symbol',
                    stat: true,
                    forced: !NATIVE_SYMBOL_REGISTRY
                }, {
                    'for': function(key) {
                        var string = toString(key);
                        if (hasOwn(StringToSymbolRegistry, string))
                            return StringToSymbolRegistry[string];
                        var symbol = getBuiltIn('Symbol')(string);
                        StringToSymbolRegistry[string] = symbol;
                        SymbolToStringRegistry[symbol] = string;
                        return symbol;
                    }
                });


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.has-instance.js":
            /*!****************************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.has-instance.js ***!
              \****************************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var defineWellKnownSymbol = __webpack_require__( /*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
                // `Symbol.hasInstance` well-known symbol
                // https://tc39.es/ecma262/#sec-symbol.hasinstance
                defineWellKnownSymbol('hasInstance');


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.is-concat-spreadable.js":
            /*!************************************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.is-concat-spreadable.js ***!
              \************************************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var defineWellKnownSymbol = __webpack_require__( /*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
                // `Symbol.isConcatSpreadable` well-known symbol
                // https://tc39.es/ecma262/#sec-symbol.isconcatspreadable
                defineWellKnownSymbol('isConcatSpreadable');


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.iterator.js":
            /*!************************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.iterator.js ***!
              \************************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var defineWellKnownSymbol = __webpack_require__( /*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
                // `Symbol.iterator` well-known symbol
                // https://tc39.es/ecma262/#sec-symbol.iterator
                defineWellKnownSymbol('iterator');


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.js":
            /*!***************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.js ***!
              \***************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                // TODO: Remove this module from `core-js@4` since it's split to modules listed below
                __webpack_require__( /*! ../modules/es.symbol.constructor */ "./node_modules/core-js/modules/es.symbol.constructor.js");
                __webpack_require__( /*! ../modules/es.symbol.for */ "./node_modules/core-js/modules/es.symbol.for.js");
                __webpack_require__( /*! ../modules/es.symbol.key-for */ "./node_modules/core-js/modules/es.symbol.key-for.js");
                __webpack_require__( /*! ../modules/es.json.stringify */ "./node_modules/core-js/modules/es.json.stringify.js");
                __webpack_require__( /*! ../modules/es.object.get-own-property-symbols */ "./node_modules/core-js/modules/es.object.get-own-property-symbols.js");


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.key-for.js":
            /*!***********************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.key-for.js ***!
              \***********************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var $ = __webpack_require__( /*! ../internals/export */ "./node_modules/core-js/internals/export.js");
                var hasOwn = __webpack_require__( /*! ../internals/has-own-property */ "./node_modules/core-js/internals/has-own-property.js");
                var isSymbol = __webpack_require__( /*! ../internals/is-symbol */ "./node_modules/core-js/internals/is-symbol.js");
                var tryToString = __webpack_require__( /*! ../internals/try-to-string */ "./node_modules/core-js/internals/try-to-string.js");
                var shared = __webpack_require__( /*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
                var NATIVE_SYMBOL_REGISTRY = __webpack_require__( /*! ../internals/native-symbol-registry */ "./node_modules/core-js/internals/native-symbol-registry.js");
                var SymbolToStringRegistry = shared('symbol-to-string-registry');
                // `Symbol.keyFor` method
                // https://tc39.es/ecma262/#sec-symbol.keyfor
                $({
                    target: 'Symbol',
                    stat: true,
                    forced: !NATIVE_SYMBOL_REGISTRY
                }, {
                    keyFor: function keyFor(sym) {
                        if (!isSymbol(sym))
                            throw TypeError(tryToString(sym) + ' is not a symbol');
                        if (hasOwn(SymbolToStringRegistry, sym))
                            return SymbolToStringRegistry[sym];
                    }
                });


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.match-all.js":
            /*!*************************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.match-all.js ***!
              \*************************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var defineWellKnownSymbol = __webpack_require__( /*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
                // `Symbol.matchAll` well-known symbol
                // https://tc39.es/ecma262/#sec-symbol.matchall
                defineWellKnownSymbol('matchAll');


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.match.js":
            /*!*********************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.match.js ***!
              \*********************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var defineWellKnownSymbol = __webpack_require__( /*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
                // `Symbol.match` well-known symbol
                // https://tc39.es/ecma262/#sec-symbol.match
                defineWellKnownSymbol('match');


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.replace.js":
            /*!***********************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.replace.js ***!
              \***********************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var defineWellKnownSymbol = __webpack_require__( /*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
                // `Symbol.replace` well-known symbol
                // https://tc39.es/ecma262/#sec-symbol.replace
                defineWellKnownSymbol('replace');


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.search.js":
            /*!**********************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.search.js ***!
              \**********************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var defineWellKnownSymbol = __webpack_require__( /*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
                // `Symbol.search` well-known symbol
                // https://tc39.es/ecma262/#sec-symbol.search
                defineWellKnownSymbol('search');


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.species.js":
            /*!***********************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.species.js ***!
              \***********************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var defineWellKnownSymbol = __webpack_require__( /*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
                // `Symbol.species` well-known symbol
                // https://tc39.es/ecma262/#sec-symbol.species
                defineWellKnownSymbol('species');


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.split.js":
            /*!*********************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.split.js ***!
              \*********************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var defineWellKnownSymbol = __webpack_require__( /*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
                // `Symbol.split` well-known symbol
                // https://tc39.es/ecma262/#sec-symbol.split
                defineWellKnownSymbol('split');


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.to-primitive.js":
            /*!****************************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.to-primitive.js ***!
              \****************************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var defineWellKnownSymbol = __webpack_require__( /*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
                var defineSymbolToPrimitive = __webpack_require__( /*! ../internals/symbol-define-to-primitive */ "./node_modules/core-js/internals/symbol-define-to-primitive.js");
                // `Symbol.toPrimitive` well-known symbol
                // https://tc39.es/ecma262/#sec-symbol.toprimitive
                defineWellKnownSymbol('toPrimitive');
                // `Symbol.prototype[@@toPrimitive]` method
                // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
                defineSymbolToPrimitive();


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.to-string-tag.js":
            /*!*****************************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.to-string-tag.js ***!
              \*****************************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var getBuiltIn = __webpack_require__( /*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
                var defineWellKnownSymbol = __webpack_require__( /*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
                var setToStringTag = __webpack_require__( /*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
                // `Symbol.toStringTag` well-known symbol
                // https://tc39.es/ecma262/#sec-symbol.tostringtag
                defineWellKnownSymbol('toStringTag');
                // `Symbol.prototype[@@toStringTag]` property
                // https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
                setToStringTag(getBuiltIn('Symbol'), 'Symbol');


                /***/
            }),

        /***/
        "./node_modules/core-js/modules/es.symbol.unscopables.js":
            /*!***************************************************************!*\
              !*** ./node_modules/core-js/modules/es.symbol.unscopables.js ***!
              \***************************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {


                var defineWellKnownSymbol = __webpack_require__( /*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
                // `Symbol.unscopables` well-known symbol
                // https://tc39.es/ecma262/#sec-symbol.unscopables
                defineWellKnownSymbol('unscopables');


                /***/
            }),

        /***/
        "./node_modules/furnace/dist/index.js":
            /*!********************************************!*\
              !*** ./node_modules/furnace/dist/index.js ***!
              \********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "childHandle": function() {
                        return /* binding */ W;
                    },
                    /* harmony export */
                    "createContext": function() {
                        return /* binding */ ut;
                    },
                    /* harmony export */
                    "default": function() {
                        return /* binding */ st;
                    },
                    /* harmony export */
                    "dict": function() {
                        return /* binding */ H;
                    },
                    /* harmony export */
                    "domRefs": function() {
                        return /* binding */ K;
                    },
                    /* harmony export */
                    "effect": function() {
                        return /* binding */ j;
                    },
                    /* harmony export */
                    "isDict": function() {
                        return /* binding */ V;
                    },
                    /* harmony export */
                    "isVal": function() {
                        return /* binding */ k;
                    },
                    /* harmony export */
                    "onConnected": function() {
                        return /* binding */ Q;
                    },
                    /* harmony export */
                    "onDestroyed": function() {
                        return /* binding */ $;
                    },
                    /* harmony export */
                    "onDisconnected": function() {
                        return /* binding */ R;
                    },
                    /* harmony export */
                    "rootRef": function() {
                        return /* binding */ X;
                    },
                    /* harmony export */
                    "useComputed": function() {
                        return /* binding */ Y;
                    },
                    /* harmony export */
                    "useDomRef": function() {
                        return /* binding */ Z;
                    },
                    /* harmony export */
                    "useEvent": function() {
                        return /* binding */ et;
                    },
                    /* harmony export */
                    "useIntersectionWatch": function() {
                        return /* binding */ rt;
                    },
                    /* harmony export */
                    "useTick": function() {
                        return /* binding */ ot;
                    },
                    /* harmony export */
                    "useWatch": function() {
                        return /* binding */ it;
                    },
                    /* harmony export */
                    "val": function() {
                        return /* binding */ F;
                    },
                    /* harmony export */
                    "withContext": function() {
                        return /* binding */ ct;
                    }
                    /* harmony export */
                });
                var t = function(n, e) {
                    return t = Object.setPrototypeOf || {
                        __proto__: []
                    }
                    instanceof Array && function(t, n) {
                        t.__proto__ = n;
                    } || function(t, n) {
                        for (var e in n)
                            Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e]);
                    }, t(n, e);
                };

                function n(n, e) {
                    if ("function" != typeof e && null !== e)
                        throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");

                    function r() {
                        this.constructor = n;
                    }
                    t(n, e), n.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r);
                }
                var e = function() {
                    return e = Object.assign || function(t) {
                        for (var n, e = 1, r = arguments.length; e < r; e++)
                            for (var o in n = arguments[e])
                                Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);
                        return t;
                    }, e.apply(this, arguments);
                };
                var r = function() {
                        function t(t) {
                            this.$dispatcher = t;
                        }
                        return t.prototype.scheduleDispatch = function() {
                            throw new Error("scheduleDispatch method must be implemented");
                        }, t.prototype.assign = function(t) {
                            this.$dispatcher.assign(t), t.scheduler = this, this.scheduleDispatch();
                        }, t;
                    }(),
                    o = function(t) {
                        function e(n) {
                            return t.call(this, n) || this;
                        }
                        return n(e, t), e.prototype.scheduleDispatch = function() {
                            this.$dispatcher.dispatch();
                        }, e;
                    }(r),
                    i = function(t) {
                        function e(n) {
                            var e = t.call(this, n) || this;
                            return e._raf = null, e;
                        }
                        return n(e, t), e.prototype.scheduleDispatch = function() {
                            var t = this;
                            this._raf || (this._raf = requestAnimationFrame((function() {
                                t.$dispatcher.dispatch(), t._raf = null, t.$dispatcher.remains && t.scheduleDispatch();
                            })));
                        }, e;
                    }(r),
                    u = function() {
                        function t() {
                            this._effectQueue = [];
                        }
                        return Object.defineProperty(t.prototype, "remains", {
                            get: function() {
                                return !!this._effectQueue.length;
                            },
                            enumerable: !1,
                            configurable: !0
                        }), t.prototype.assign = function(t) {
                            t.willDispatch(), this._effectQueue.push(t);
                        }, t.prototype.dispatch = function() {
                            this._effectQueue.slice().forEach((function(t) {
                                t.shouldDispatch && (t.cleanUp(), _(t), t.dispatch(), _(null));
                            })), this._effectQueue = this._effectQueue.filter((function(t) {
                                return t.shouldDispatch;
                            }));
                        }, t;
                    }();
                var c = function(t) {
                    function e(n) {
                        return t.call(this, n) || this;
                    }
                    return n(e, t), e;
                }(Error);

                function a(t) {
                    var n = w.currentHandled;
                    return n || function(t) {
                        throw new c("".concat(t, " hook must be called in top-level of Functional Component"));
                    }(t), n;
                }

                function s() {
                    return w.currentHandled;
                }

                function f(t) {
                    w.currentHandled = t;
                }
                var l = 0,
                    p = 1,
                    h = 2,
                    d = 3,
                    v = 4,
                    y = 5,
                    w = function() {
                        function t() {
                            this.element = null, this.tag = null, this.onConnected = [], this.onDisconnected = [], this.onDestroyed = [], this.parent = null, this.children = [], this.contextState = l, this.contextIds = [], this.effectUnsubscriptionHandlers = [];
                        }
                        return t.prototype.addChild = function(t) {
                            this.children.push(t), t.parent = this;
                        }, t.prototype.removeChild = function(t) {
                            var n = this.children.indexOf(t); - 1 !== n && (this.children.splice(n, 1), t.parent = null);
                        }, t.currentHandled = null, t;
                    }();

                function _(t) {
                    O.currentHandled = t;
                }
                var g = new WeakMap;

                function m() {}
                var b, D = (b = new u, new o(b)),
                    S = function() {
                        var t = new u;
                        return new i(t);
                    }();
                var O = function() {
                        function t(t) {
                            this._shouldDispatch = !1, this.handler = t, this.cleanUp = m, this.callerDeps = new Set, this.scheduler = null;
                        }
                        return Object.defineProperty(t.prototype, "shouldDispatch", {
                            get: function() {
                                return this._shouldDispatch;
                            },
                            enumerable: !1,
                            configurable: !0
                        }), t.prototype.willDispatch = function() {
                            this._shouldDispatch = !0;
                        }, t.prototype.dispatch = function() {
                            var t;
                            this.shouldDispatch && (this.cleanUp = this.handler((t = this, function(n) {
                                _(null);
                                var e = n();
                                return _(t), e;
                            })) || m, this._shouldDispatch = !1);
                        }, t.prototype.delete = function() {
                            var t = this;
                            this.callerDeps.forEach((function(n) {
                                n.delete(t);
                            })), this.callerDeps.clear(), this.cleanUp(), this.cleanUp = m, this._shouldDispatch = !1;
                        }, t.currentHandled = null, t;
                    }(),
                    E = 1,
                    x = 2;

                function j(t, n) {
                    void 0 === n && (n = {
                        priority: x
                    });
                    var e = a("effect");
                    if (!e)
                        throw new Error("effect must be called in top level of Function Component");
                    var r = new O(t);
                    switch (n.priority || (n.priority = x), n.priority) {
                        case E:
                            D.assign(r);
                            break;
                        case x:
                            S.assign(r);
                            break;
                        default:
                            throw new Error("Unknown priority");
                    }
                    e.effectUnsubscriptionHandlers.push((function() {
                        r.delete();
                    }));
                }

                function C(t, n) {
                    var e = O.currentHandled;
                    if (e) {
                        var r = function(t, n, e) {
                            var r = g.get(n);
                            r || (r = new Map, g.set(n, r));
                            var o = r.get(e);
                            o || (o = new Set, r.set(e, o));
                            return o.add(t), o;
                        }(e, t, n);
                        ! function(t, n) {
                            t.callerDeps.add(n);
                        }(e, r);
                    }
                }

                function A(t, n) {
                    var e, r = g.get(t);
                    r && (null === (e = r.get(n)) || void 0 === e || e.forEach((function(t) {
                        t.scheduler && t.scheduler.assign(t);
                    })));
                }

                function V(t) {
                    return !!(null == t ? void 0 : t.__isDict);
                }
                var P = function() {
                    function t(t) {
                        var n, r;
                        this._rawValue = e({}, t), this._proxiedValue = (n = this._rawValue, r = e({}, n), new Proxy(r, {
                            get: function(t, n, e) {
                                var r = Reflect.get(t, n, e);
                                return C(t, n), r;
                            },
                            set: function(t, e, r, o) {
                                var i = t[e],
                                    u = Reflect.set(t, e, r, o);
                                return u && i !== r && (n[e] = r, A(t, e)), u;
                            }
                        }));
                    }
                    return Object.defineProperty(t.prototype, "__isDict", {
                        get: function() {
                            return !0;
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.prototype.wrap = function(t) {
                        t instanceof Function ? this.wrap(t(this._rawValue)) : (Object.assign(this._rawValue, t), Object.assign(this._proxiedValue, this._rawValue));
                    }, t.prototype.unwrap = function() {
                        return this._proxiedValue;
                    }, t;
                }();

                function H(t) {
                    return new P(t);
                }
                var U = function() {
                    function t(t) {
                        this._rawValue = {
                            value: t
                        };
                    }
                    return Object.defineProperty(t.prototype, "__isValue", {
                        get: function() {
                            return !0;
                        },
                        enumerable: !1,
                        configurable: !0
                    }), t.prototype.wrap = function(t) {
                        t instanceof Function && (t = t(this._rawValue.value)), this._rawValue.value !== t && (this._rawValue.value = t, A(this._rawValue, "value"));
                    }, t.prototype.unwrap = function() {
                        return C(this._rawValue, "value"), this._rawValue.value;
                    }, t;
                }();

                function F(t) {
                    return new U(t);
                }

                function k(t) {
                    return !!(null == t ? void 0 : t.__isValue);
                }

                function Q(t) {
                    a("onConnected").onConnected.push(t);
                }

                function R(t) {
                    a("onDisconnected").onDisconnected.push(t);
                }

                function $(t) {
                    a("onDestroyed").onDestroyed.push(t);
                }

                function q(t, n) {
                    return function(t, n) {
                        var e = s(),
                            r = new w;
                        return r.contextState = p, f(r), null == e || e.addChild(r), t(n), f(e), r;
                    }(t, n);
                }

                function I(t, n) {
                    t.contextState = h, t.onConnected.forEach((function(t) {
                        return t(n);
                    }));
                }

                function M(t) {
                    t.contextState = d;
                }

                function N(t) {
                    t.contextState = v, t.onDisconnected.forEach((function(t) {
                        return t();
                    }));
                }

                function z(t) {
                    var n;
                    null === (n = t.parent) || void 0 === n || n.removeChild(t), t.effectUnsubscriptionHandlers.forEach((function(t) {
                        return t();
                    })), t.contextState = y;
                }

                function L(t, n, e, r) {
                    void 0 === r && (r = document);
                    var o = Array.from(r.querySelectorAll('[data-component="'.concat(t, '"]'))).filter((function(t) {
                        for (var n = t.parentNode; n && n !== document && !n.matches("[data-component]");)
                            n = n.parentNode;
                        return n === document || n === r;
                    }));
                    o.length && o.forEach((function(r) {
                        var o = JSON.parse(r.dataset.componentProps || "{}"),
                            i = Object.assign({}, n.defaultProps, e || {}, o),
                            u = q(n, i);
                        u.element = r, u.tag = t, I(u, {
                            el: r
                        }), M(u);
                    }));
                }
                var T = {};

                function J(t, n) {
                    n.children.filter((function(n) {
                        return n.tag === t;
                    })).forEach((function(t) {
                        return function(t) {
                            N(t), z(t);
                        }(t);
                    }));
                }

                function W() {
                    var t = a("childHandle");
                    return {
                        addChild: function(n, e, r) {
                            ! function(t, n, e, r) {
                                var o, i = null !== (o = Object.assign({}, T, r || {}).tag) && void 0 !== o ? o : n.tag || n.name;
                                if (t.contextState < d)
                                    t.onConnected.push((function(r) {
                                        var o = r.el,
                                            u = s();
                                        f(t), L(i, n, e, o), f(u);
                                    }));
                                else {
                                    if (!(t.contextState < v))
                                        throw new Error("Component is disconnecting or already disconnected");
                                    var u = s();
                                    f(t), L(i, n, e, t.element), f(u);
                                }
                                t.onDisconnected.push((function() {
                                    J(i, t);
                                }));
                            }(t, n, e, r);
                        },
                        removeChild: function(n) {
                            J(n, t);
                        }
                    };
                }
                var B = new Map,
                    G = function() {
                        function t(t) {
                            this._refs = t, this._currentScope = null;
                        }
                        return Object.defineProperty(t.prototype, "refs", {
                            get: function() {
                                return this._refs;
                            },
                            enumerable: !1,
                            configurable: !0
                        }), Object.defineProperty(t.prototype, "currentScope", {
                            get: function() {
                                return this._currentScope;
                            },
                            enumerable: !1,
                            configurable: !0
                        }), t.prototype._resolveRef = function(t) {
                            var n = this;
                            if (this._currentScope) {
                                var e = function(t, n, e) {
                                        if (e || 2 === arguments.length)
                                            for (var r, o = 0, i = n.length; o < i; o++)
                                                !r && o in n || (r || (r = Array.prototype.slice.call(n, 0, o)), r[o] = n[o]);
                                        return t.concat(r || Array.prototype.slice.call(n));
                                    }([], function(t, n) {
                                        var e = "function" == typeof Symbol && t[Symbol.iterator];
                                        if (!e)
                                            return t;
                                        var r, o, i = e.call(t),
                                            u = [];
                                        try {
                                            for (;
                                                (void 0 === n || n-- > 0) && !(r = i.next()).done;)
                                                u.push(r.value);
                                        } catch (t) {
                                            o = {
                                                error: t
                                            };
                                        } finally {
                                            try {
                                                r && !r.done && (e = i.return) && e.call(i);
                                            } finally {
                                                if (o)
                                                    throw o.error;
                                            }
                                        }
                                        return u;
                                    }(this._currentScope.querySelectorAll('[data-ref="'.concat(t, '"]'))), !1),
                                    r = e.filter((function(t) {
                                        var e = t.closest("[data-component]");
                                        return null == e || e === n._currentScope;
                                    }));
                                Array.isArray(this._refs[t]) ? this._refs[t] = r : this._refs[t] = r[0];
                            }
                        }, t.prototype.validate = function(t) {
                            var n = this;
                            this._currentScope = t, Object.keys(this._refs).forEach((function(t) {
                                n._resolveRef(t);
                            }));
                        }, t;
                    }();

                function K(t) {
                    var n = a("domRef"),
                        e = function(t) {
                            return new G(t);
                        }(t);
                    return function(t, n) {
                        B.has(t) || B.set(t, n);
                    }(n, e), n.onConnected.push((function(t) {
                        var n = t.el;
                        e.validate(n);
                    })), n.onDisconnected.push((function() {
                        ! function(t) {
                            B.delete(t);
                        }(n);
                    })), {
                        get: function() {
                            return e.refs;
                        },
                        validate: function(t) {
                            var n = e.currentScope;
                            if (!n)
                                throw new Error("no scope found");
                            e.validate(n), t(e.refs);
                        }
                    };
                }

                function X() {
                    var t = a("useEl"),
                        n = F(null);
                    return t.onConnected.push((function(t) {
                        n.wrap(t.el);
                    })), n;
                }

                function Y(t) {
                    var n = F(t());
                    return j((function() {
                        n.wrap(t());
                    })), n;
                }

                function Z(t) {
                    var n = K(t),
                        e = H(n.get()),
                        r = function() {
                            n.validate((function(t) {
                                e.wrap(t);
                            }));
                        };
                    return j((function() {
                        r();
                    })), {
                        refs: e,
                        validate: r
                    };
                }

                function tt(t, n, e, r) {
                    Array.isArray(t) ? t.forEach((function(t) {
                        tt(t, n, e, r);
                    })) : t.addEventListener(n, e, r);
                }

                function nt(t, n, e, r) {
                    Array.isArray(t) ? t.forEach((function(t) {
                        nt(t, n, e, r);
                    })) : t.removeEventListener(n, e, r);
                }

                function et(t, n, e, r) {
                    var o = F(!0);
                    return j((function() {
                        var i = t(),
                            u = o.unwrap();
                        if (i && u) {
                            var c = function(t) {
                                e(t, t.currentTarget);
                            };
                            return tt(i, n, c, r),
                                function() {
                                    nt(i, n, c, r);
                                };
                        }
                    })), {
                        suspend: function() {
                            o.wrap(!1);
                        },
                        resume: function() {
                            o.wrap(!0);
                        }
                    };
                }

                function rt(t, n, e) {
                    var r = (null == e ? void 0 : e.observer) || function(t, n) {
                            return new IntersectionObserver((function(n, e) {
                                n.forEach((function(n) {
                                    t(n, e);
                                }));
                            }), n);
                        }(n, e),
                        o = function(t) {
                            Array.isArray(t) ? t.forEach((function(t) {
                                o(t);
                            })) : r.observe(t);
                        };
                    j((function() {
                        var n = t();
                        return n && o(n),
                            function() {
                                r.disconnect();
                            };
                    }));
                }

                function ot(t, n) {
                    void 0 === n && (n = {
                        autoStart: !1
                    });
                    var e = 0,
                        r = F(n.autoStart),
                        o = function() {
                            e = requestAnimationFrame(o), t();
                        };
                    return j((function(t) {
                        if (r.unwrap())
                            return o(),
                                function() {
                                    return cancelAnimationFrame(e);
                                };
                    })), {
                        start: function() {
                            r.wrap(!0);
                        },
                        stop: function() {
                            r.wrap(!1);
                        }
                    };
                }

                function it(t, n) {
                    var e;
                    j((function(r) {
                        var o = t();
                        if (e !== o)
                            return r((function() {
                                var t = n(o, e);
                                return e = o, t;
                            }));
                    }));
                }

                function ut(t) {
                    var n, e = Symbol();
                    return Object.freeze({
                        provide: function() {
                            var r = a("createContext.provide");
                            n = t(), r.contextIds.push(e);
                        },
                        use: function() {
                            for (var t = a("createContext.use"); t;) {
                                if (t.contextIds.includes(e))
                                    return n;
                                t = t.parent;
                            }
                            throw new Error("context not found");
                        }
                    });
                }

                function ct(t, n) {
                    return function(t, n) {
                        var e = function(e) {
                            n.provide(), t(e);
                        };
                        return e.tag = t.tag, e.defaultProps = t.defaultProps, e;
                    }(t, n);
                }
                var at = [];
                var st = Object.freeze({
                    __proto__: null,
                    create: function(t, n, e) {
                        var r = q(n, Object.assign({}, n.defaultProps, e || {}));
                        return r.element = t, r.tag = "root", I(r, {
                            el: t
                        }), M(r), at.push(r), {
                            destroy: function() {
                                var t = at.indexOf(r);
                                N(r), z(r), -1 !== t && at.splice(t, 1);
                            }
                        };
                    }
                });



                /***/
            }),

        /***/
        "./node_modules/gsap/CSSPlugin.js":
            /*!****************************************!*\
              !*** ./node_modules/gsap/CSSPlugin.js ***!
              \****************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "CSSPlugin": function() {
                        return /* binding */ CSSPlugin;
                    },
                    /* harmony export */
                    "_createElement": function() {
                        return /* binding */ _createElement;
                    },
                    /* harmony export */
                    "_getBBox": function() {
                        return /* binding */ _getBBox;
                    },
                    /* harmony export */
                    "checkPrefix": function() {
                        return /* binding */ _checkPropPrefix;
                    },
                    /* harmony export */
                    "default": function() {
                        return /* binding */ CSSPlugin;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
                /*!
                 * CSSPlugin 3.10.2
                 * https://greensock.com
                 *
                 * Copyright 2008-2022, GreenSock. All rights reserved.
                 * Subject to the terms at https://greensock.com/standard-license or for
                 * Club GreenSock members, the agreement issued with that membership.
                 * @author: Jack Doyle, jack@greensock.com
                 */
                /* eslint-disable */

                var _win, _doc, _docElement, _pluginInitted, _tempDiv, _tempDivStyler, _recentSetterPlugin, _windowExists = function _windowExists() {
                        return typeof window !== "undefined";
                    },
                    _transformProps = {},
                    _RAD2DEG = 180 / Math.PI,
                    _DEG2RAD = Math.PI / 180,
                    _atan2 = Math.atan2,
                    _bigNum = 1e8,
                    _capsExp = /([A-Z])/g,
                    _horizontalExp = /(left|right|width|margin|padding|x)/i,
                    _complexExp = /[\s,\(]\S/,
                    _propertyAliases = {
                        autoAlpha: "opacity,visibility",
                        scale: "scaleX,scaleY",
                        alpha: "opacity"
                    },
                    _renderCSSProp = function _renderCSSProp(ratio, data) {
                        return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
                    },
                    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
                        return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
                    },
                    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
                        return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
                    },
                    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
                    _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
                        var value = data.s + data.c * ratio;
                        data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
                    },
                    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
                        return data.set(data.t, data.p, ratio ? data.e : data.b, data);
                    },
                    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
                        return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
                    },
                    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
                        return target.style[property] = value;
                    },
                    _setterCSSProp = function _setterCSSProp(target, property, value) {
                        return target.style.setProperty(property, value);
                    },
                    _setterTransform = function _setterTransform(target, property, value) {
                        return target._gsap[property] = value;
                    },
                    _setterScale = function _setterScale(target, property, value) {
                        return target._gsap.scaleX = target._gsap.scaleY = value;
                    },
                    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
                        var cache = target._gsap;
                        cache.scaleX = cache.scaleY = value;
                        cache.renderTransform(ratio, cache);
                    },
                    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
                        var cache = target._gsap;
                        cache[property] = value;
                        cache.renderTransform(ratio, cache);
                    },
                    _transformProp = "transform",
                    _transformOriginProp = _transformProp + "Origin",
                    _supports3D, _createElement = function _createElement(type, ns) {
                        var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.
                        return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
                    },
                    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
                        var cs = getComputedStyle(target);
                        return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
                    },
                    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
                    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
                        var e = element || _tempDiv,
                            s = e.style,
                            i = 5;
                        if (property in s && !preferPrefix) {
                            return property;
                        }
                        property = property.charAt(0).toUpperCase() + property.substr(1);
                        while (i-- && !(_prefixes[i] + property in s)) {}
                        return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
                    },
                    _initCore = function _initCore() {
                        if (_windowExists() && window.document) {
                            _win = window;
                            _doc = _win.document;
                            _docElement = _doc.documentElement;
                            _tempDiv = _createElement("div") || {
                                style: {}
                            };
                            _tempDivStyler = _createElement("div");
                            _transformProp = _checkPropPrefix(_transformProp);
                            _transformOriginProp = _transformProp + "Origin";
                            _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.
                            _supports3D = !!_checkPropPrefix("perspective");
                            _pluginInitted = 1;
                        }
                    },
                    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
                        //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
                        var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                            oldParent = this.parentNode,
                            oldSibling = this.nextSibling,
                            oldCSS = this.style.cssText,
                            bbox;
                        _docElement.appendChild(svg);
                        svg.appendChild(this);
                        this.style.display = "block";
                        if (swapIfPossible) {
                            try {
                                bbox = this.getBBox();
                                this._gsapBBox = this.getBBox; //store the original
                                this.getBBox = _getBBoxHack;
                            } catch (e) {}
                        } else if (this._gsapBBox) {
                            bbox = this._gsapBBox();
                        }
                        if (oldParent) {
                            if (oldSibling) {
                                oldParent.insertBefore(this, oldSibling);
                            } else {
                                oldParent.appendChild(this);
                            }
                        }
                        _docElement.removeChild(svg);
                        this.style.cssText = oldCSS;
                        return bbox;
                    },
                    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
                        var i = attributesArray.length;
                        while (i--) {
                            if (target.hasAttribute(attributesArray[i])) {
                                return target.getAttribute(attributesArray[i]);
                            }
                        }
                    },
                    _getBBox = function _getBBox(target) {
                        var bounds;
                        try {
                            bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
                        } catch (error) {
                            bounds = _getBBoxHack.call(target, true);
                        }
                        bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.
                        return bounds && !bounds.width && !bounds.x && !bounds.y ? {
                            x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
                            y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
                            width: 0,
                            height: 0
                        } : bounds;
                    },
                    _isSVG = function _isSVG(e) {
                        return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
                    },
                    //reports if the element is an SVG on which getBBox() actually works
                    _removeProperty = function _removeProperty(target, property) {
                        if (property) {
                            var style = target.style;
                            if (property in _transformProps && property !== _transformOriginProp) {
                                property = _transformProp;
                            }
                            if (style.removeProperty) {
                                if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
                                    //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
                                    property = "-" + property;
                                }
                                style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
                            } else {
                                //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
                                style.removeAttribute(property);
                            }
                        }
                    },
                    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
                        var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
                        plugin._pt = pt;
                        pt.b = beginning;
                        pt.e = end;
                        plugin._props.push(property);
                        return pt;
                    },
                    _nonConvertibleUnits = {
                        deg: 1,
                        rad: 1,
                        turn: 1
                    },
                    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
                    _convertToUnit = function _convertToUnit(target, property, value, unit) {
                        var curValue = parseFloat(value) || 0,
                            curUnit = (value + "").trim().substr((curValue + "").length) || "px",
                            // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
                            style = _tempDiv.style,
                            horizontal = _horizontalExp.test(property),
                            isRootSVG = target.tagName.toLowerCase() === "svg",
                            measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
                            amount = 100,
                            toPixels = unit === "px",
                            toPercent = unit === "%",
                            px, parent, cache, isSVG;
                        if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
                            return curValue;
                        }
                        curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
                        isSVG = target.getCTM && _isSVG(target);
                        if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
                            px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
                            return (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPercent ? curValue / px * amount : curValue / 100 * px);
                        }
                        style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
                        parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
                        if (isSVG) {
                            parent = (target.ownerSVGElement || {}).parentNode;
                        }
                        if (!parent || parent === _doc || !parent.appendChild) {
                            parent = _doc.body;
                        }
                        cache = parent._gsap;
                        if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time) {
                            return (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(curValue / cache.width * amount);
                        } else {
                            (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
                            parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.
                            parent.appendChild(_tempDiv);
                            px = _tempDiv[measureProperty];
                            parent.removeChild(_tempDiv);
                            style.position = "absolute";
                            if (horizontal && toPercent) {
                                cache = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(parent);
                                cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time;
                                cache.width = parent[measureProperty];
                            }
                        }
                        return (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
                    },
                    _get = function _get(target, property, unit, uncache) {
                        var value;
                        _pluginInitted || _initCore();
                        if (property in _propertyAliases && property !== "transform") {
                            property = _propertyAliases[property];
                            if (~property.indexOf(",")) {
                                property = property.split(",")[0];
                            }
                        }
                        if (_transformProps[property] && property !== "transform") {
                            value = _parseTransform(target, uncache);
                            value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
                        } else {
                            value = target.style[property];
                            if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
                                value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getProperty)(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
                            }
                        }
                        return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
                    },
                    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
                        // note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
                        if (!start || start === "none") {
                            // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
                            var p = _checkPropPrefix(prop, target, 1),
                                s = p && _getComputedProperty(target, p, 1);
                            if (s && s !== start) {
                                prop = p;
                                start = s;
                            } else if (prop === "borderColor") {
                                start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
                            }
                        }
                        var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._renderComplexString),
                            index = 0,
                            matchIndex = 0,
                            a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
                        pt.b = start;
                        pt.e = end;
                        start += ""; // ensure values are strings
                        end += "";
                        if (end === "auto") {
                            target.style[prop] = end;
                            end = _getComputedProperty(target, prop) || end;
                            target.style[prop] = start;
                        }
                        a = [start, end];
                        (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorStringFilter)(a); // pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().
                        start = a[0];
                        end = a[1];
                        startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];
                        endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];
                        if (endValues.length) {
                            while (result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.exec(end)) {
                                endValue = result[0];
                                chunk = end.substring(index, result.index);
                                if (color) {
                                    color = (color + 1) % 5;
                                } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
                                    color = 1;
                                }
                                if (endValue !== (startValue = startValues[matchIndex++] || "")) {
                                    startNum = parseFloat(startValue) || 0;
                                    startUnit = startValue.substr((startNum + "").length);
                                    endValue.charAt(1) === "=" && (endValue = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, endValue) + startUnit);
                                    endNum = parseFloat(endValue);
                                    endUnit = endValue.substr((endNum + "").length);
                                    index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.lastIndex - endUnit.length;
                                    if (!endUnit) {
                                        //if something like "perspective:300" is passed in and we must add a unit to the end
                                        endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[prop] || startUnit;
                                        if (index === end.length) {
                                            end += endUnit;
                                            pt.e += endUnit;
                                        }
                                    }
                                    if (startUnit !== endUnit) {
                                        startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
                                    } // these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.
                                    pt._pt = {
                                        _next: pt._pt,
                                        p: chunk || matchIndex === 1 ? chunk : ",",
                                        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
                                        s: startNum,
                                        c: endNum - startNum,
                                        m: color && color < 4 || prop === "zIndex" ? Math.round : 0
                                    };
                                }
                            }
                            pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
                        } else {
                            pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
                        }
                        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
                        this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.
                        return pt;
                    },
                    _keywordToPercent = {
                        top: "0%",
                        bottom: "100%",
                        left: "0%",
                        right: "100%",
                        center: "50%"
                    },
                    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
                        var split = value.split(" "),
                            x = split[0],
                            y = split[1] || "50%";
                        if (x === "top" || x === "bottom" || y === "left" || y === "right") {
                            //the user provided them in the wrong order, so flip them
                            value = x;
                            x = y;
                            y = value;
                        }
                        split[0] = _keywordToPercent[x] || x;
                        split[1] = _keywordToPercent[y] || y;
                        return split.join(" ");
                    },
                    _renderClearProps = function _renderClearProps(ratio, data) {
                        if (data.tween && data.tween._time === data.tween._dur) {
                            var target = data.t,
                                style = target.style,
                                props = data.u,
                                cache = target._gsap,
                                prop, clearTransforms, i;
                            if (props === "all" || props === true) {
                                style.cssText = "";
                                clearTransforms = 1;
                            } else {
                                props = props.split(",");
                                i = props.length;
                                while (--i > -1) {
                                    prop = props[i];
                                    if (_transformProps[prop]) {
                                        clearTransforms = 1;
                                        prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
                                    }
                                    _removeProperty(target, prop);
                                }
                            }
                            if (clearTransforms) {
                                _removeProperty(target, _transformProp);
                                if (cache) {
                                    cache.svg && target.removeAttribute("transform");
                                    _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.
                                    cache.uncache = 1;
                                }
                            }
                        }
                    },
                    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
                    _specialProps = {
                        clearProps: function clearProps(plugin, target, property, endValue, tween) {
                            if (tween.data !== "isFromStart") {
                                var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
                                pt.u = endValue;
                                pt.pr = -10;
                                pt.tween = tween;
                                plugin._props.push(property);
                                return 1;
                            }
                        }
                        /* className feature (about 0.4kb gzipped).
                        , className(plugin, target, property, endValue, tween) {
                          let _renderClassName = (ratio, data) => {
                                  data.css.render(ratio, data.css);
                                  if (!ratio || ratio === 1) {
                                      let inline = data.rmv,
                                          target = data.t,
                                          p;
                                      target.setAttribute("class", ratio ? data.e : data.b);
                                      for (p in inline) {
                                          _removeProperty(target, p);
                                      }
                                  }
                              },
                              _getAllStyles = (target) => {
                                  let styles = {},
                                      computed = getComputedStyle(target),
                                      p;
                                  for (p in computed) {
                                      if (isNaN(p) && p !== "cssText" && p !== "length") {
                                          styles[p] = computed[p];
                                      }
                                  }
                                  _setDefaults(styles, _parseTransform(target, 1));
                                  return styles;
                              },
                              startClassList = target.getAttribute("class"),
                              style = target.style,
                              cssText = style.cssText,
                              cache = target._gsap,
                              classPT = cache.classPT,
                              inlineToRemoveAtEnd = {},
                              data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
                              changingVars = {},
                              startVars = _getAllStyles(target),
                              transformRelated = /(transform|perspective)/i,
                              endVars, p;
                          if (classPT) {
                              classPT.r(1, classPT.d);
                              _removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
                          }
                          target.setAttribute("class", data.e);
                          endVars = _getAllStyles(target, true);
                          target.setAttribute("class", startClassList);
                          for (p in endVars) {
                              if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
                                  changingVars[p] = endVars[p];
                                  if (!style[p] && style[p] !== "0") {
                                      inlineToRemoveAtEnd[p] = 1;
                                  }
                              }
                          }
                          cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
                          if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
                              style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
                          }
                          _parseTransform(target, true); //to clear the caching of transforms
                          data.css = new gsap.plugins.css();
                          data.css.init(target, changingVars, tween);
                          plugin._props.push(...data.css._props);
                          return 1;
                        }
                        */
                    },
                    /*
                     * --------------------------------------------------------------------------------------
                     * TRANSFORMS
                     * --------------------------------------------------------------------------------------
                     */
                    _identity2DMatrix = [1, 0, 0, 1, 0, 0],
                    _rotationalProperties = {},
                    _isNullTransform = function _isNullTransform(value) {
                        return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
                    },
                    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
                        var matrixString = _getComputedProperty(target, _transformProp);
                        return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round);
                    },
                    _getMatrix = function _getMatrix(target, force2D) {
                        var cache = target._gsap || (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(target),
                            style = target.style,
                            matrix = _getComputedTransformMatrixAsArray(target),
                            parent, nextSibling, temp, addedToDOM;
                        if (cache.svg && target.getAttribute("transform")) {
                            temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.
                            matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
                            return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
                        } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
                            //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
                            //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
                            temp = style.display;
                            style.display = "block";
                            parent = target.parentNode;
                            if (!parent || !target.offsetParent) {
                                // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
                                addedToDOM = 1; //flag
                                nextSibling = target.nextSibling;
                                _docElement.appendChild(target); //we must add it to the DOM in order to get values properly
                            }
                            matrix = _getComputedTransformMatrixAsArray(target);
                            temp ? style.display = temp : _removeProperty(target, "display");
                            if (addedToDOM) {
                                nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
                            }
                        }
                        return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
                    },
                    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
                        var cache = target._gsap,
                            matrix = matrixArray || _getMatrix(target, true),
                            xOriginOld = cache.xOrigin || 0,
                            yOriginOld = cache.yOrigin || 0,
                            xOffsetOld = cache.xOffset || 0,
                            yOffsetOld = cache.yOffset || 0,
                            a = matrix[0],
                            b = matrix[1],
                            c = matrix[2],
                            d = matrix[3],
                            tx = matrix[4],
                            ty = matrix[5],
                            originSplit = origin.split(" "),
                            xOrigin = parseFloat(originSplit[0]) || 0,
                            yOrigin = parseFloat(originSplit[1]) || 0,
                            bounds, determinant, x, y;
                        if (!originIsAbsolute) {
                            bounds = _getBBox(target);
                            xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
                            yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
                        } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
                            //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
                            x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
                            y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
                            xOrigin = x;
                            yOrigin = y;
                        }
                        if (smooth || smooth !== false && cache.smooth) {
                            tx = xOrigin - xOriginOld;
                            ty = yOrigin - yOriginOld;
                            cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
                            cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
                        } else {
                            cache.xOffset = cache.yOffset = 0;
                        }
                        cache.xOrigin = xOrigin;
                        cache.yOrigin = yOrigin;
                        cache.smooth = !!smooth;
                        cache.origin = origin;
                        cache.originIsAbsolute = !!originIsAbsolute;
                        target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).
                        if (pluginToAddPropTweensTo) {
                            _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
                            _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
                            _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
                            _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
                        }
                        target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
                    },
                    _parseTransform = function _parseTransform(target, uncache) {
                        var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.GSCache(target);
                        if ("x" in cache && !uncache && !cache.uncache) {
                            return cache;
                        }
                        var style = target.style,
                            invertedScaleX = cache.scaleX < 0,
                            px = "px",
                            deg = "deg",
                            origin = _getComputedProperty(target, _transformOriginProp) || "0",
                            x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
                        x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
                        scaleX = scaleY = 1;
                        cache.svg = !!(target.getCTM && _isSVG(target));
                        matrix = _getMatrix(target, cache.svg);
                        if (cache.svg) {
                            t1 = (!cache.uncache || origin === "0px 0px") && !uncache && target.getAttribute("data-svg-origin"); // if origin is 0,0 and cache.uncache is true, let the recorded data-svg-origin stay. Otherwise, whenever we set cache.uncache to true, we'd need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.
                            _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
                        }
                        xOrigin = cache.xOrigin || 0;
                        yOrigin = cache.yOrigin || 0;
                        if (matrix !== _identity2DMatrix) {
                            a = matrix[0]; //a11
                            b = matrix[1]; //a21
                            c = matrix[2]; //a31
                            d = matrix[3]; //a41
                            x = a12 = matrix[4];
                            y = a22 = matrix[5]; //2D matrix
                            if (matrix.length === 6) {
                                scaleX = Math.sqrt(a * a + b * b);
                                scaleY = Math.sqrt(d * d + c * c);
                                rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
                                skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
                                skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
                                if (cache.svg) {
                                    x -= xOrigin - (xOrigin * a + yOrigin * c);
                                    y -= yOrigin - (xOrigin * b + yOrigin * d);
                                } //3D matrix
                            } else {
                                a32 = matrix[6];
                                a42 = matrix[7];
                                a13 = matrix[8];
                                a23 = matrix[9];
                                a33 = matrix[10];
                                a43 = matrix[11];
                                x = matrix[12];
                                y = matrix[13];
                                z = matrix[14];
                                angle = _atan2(a32, a33);
                                rotationX = angle * _RAD2DEG; //rotationX
                                if (angle) {
                                    cos = Math.cos(-angle);
                                    sin = Math.sin(-angle);
                                    t1 = a12 * cos + a13 * sin;
                                    t2 = a22 * cos + a23 * sin;
                                    t3 = a32 * cos + a33 * sin;
                                    a13 = a12 * -sin + a13 * cos;
                                    a23 = a22 * -sin + a23 * cos;
                                    a33 = a32 * -sin + a33 * cos;
                                    a43 = a42 * -sin + a43 * cos;
                                    a12 = t1;
                                    a22 = t2;
                                    a32 = t3;
                                } //rotationY
                                angle = _atan2(-c, a33);
                                rotationY = angle * _RAD2DEG;
                                if (angle) {
                                    cos = Math.cos(-angle);
                                    sin = Math.sin(-angle);
                                    t1 = a * cos - a13 * sin;
                                    t2 = b * cos - a23 * sin;
                                    t3 = c * cos - a33 * sin;
                                    a43 = d * sin + a43 * cos;
                                    a = t1;
                                    b = t2;
                                    c = t3;
                                } //rotationZ
                                angle = _atan2(b, a);
                                rotation = angle * _RAD2DEG;
                                if (angle) {
                                    cos = Math.cos(angle);
                                    sin = Math.sin(angle);
                                    t1 = a * cos + b * sin;
                                    t2 = a12 * cos + a22 * sin;
                                    b = b * cos - a * sin;
                                    a22 = a22 * cos - a12 * sin;
                                    a = t1;
                                    a12 = t2;
                                }
                                if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
                                    //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
                                    rotationX = rotation = 0;
                                    rotationY = 180 - rotationY;
                                }
                                scaleX = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a * a + b * b + c * c));
                                scaleY = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a22 * a22 + a32 * a32));
                                angle = _atan2(a12, a22);
                                skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
                                perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
                            }
                            if (cache.svg) {
                                //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
                                t1 = target.getAttribute("transform");
                                cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
                                t1 && target.setAttribute("transform", t1);
                            }
                        }
                        if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
                            if (invertedScaleX) {
                                scaleX *= -1;
                                skewX += rotation <= 0 ? 180 : -180;
                                rotation += rotation <= 0 ? 180 : -180;
                            } else {
                                scaleY *= -1;
                                skewX += skewX <= 0 ? 180 : -180;
                            }
                        }
                        uncache = uncache || cache.uncache;
                        cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
                        cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
                        cache.z = z + px;
                        cache.scaleX = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleX);
                        cache.scaleY = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleY);
                        cache.rotation = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotation) + deg;
                        cache.rotationX = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationX) + deg;
                        cache.rotationY = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationY) + deg;
                        cache.skewX = skewX + deg;
                        cache.skewY = skewY + deg;
                        cache.transformPerspective = perspective + px;
                        if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
                            style[_transformOriginProp] = _firstTwoOnly(origin);
                        }
                        cache.xOffset = cache.yOffset = 0;
                        cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.force3D;
                        cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
                        cache.uncache = 0;
                        return cache;
                    },
                    _firstTwoOnly = function _firstTwoOnly(value) {
                        return (value = value.split(" "))[0] + " " + value[1];
                    },
                    //for handling transformOrigin values, stripping out the 3rd dimension
                    _addPxTranslate = function _addPxTranslate(target, start, value) {
                        var unit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(start);
                        return (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
                    },
                    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
                        cache.z = "0px";
                        cache.rotationY = cache.rotationX = "0deg";
                        cache.force3D = 0;
                        _renderCSSTransforms(ratio, cache);
                    },
                    _zeroDeg = "0deg",
                    _zeroPx = "0px",
                    _endParenthesis = ") ",
                    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
                        var _ref = cache || this,
                            xPercent = _ref.xPercent,
                            yPercent = _ref.yPercent,
                            x = _ref.x,
                            y = _ref.y,
                            z = _ref.z,
                            rotation = _ref.rotation,
                            rotationY = _ref.rotationY,
                            rotationX = _ref.rotationX,
                            skewX = _ref.skewX,
                            skewY = _ref.skewY,
                            scaleX = _ref.scaleX,
                            scaleY = _ref.scaleY,
                            transformPerspective = _ref.transformPerspective,
                            force3D = _ref.force3D,
                            target = _ref.target,
                            zOrigin = _ref.zOrigin,
                            transforms = "",
                            use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)
                        if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
                            var angle = parseFloat(rotationY) * _DEG2RAD,
                                a13 = Math.sin(angle),
                                a33 = Math.cos(angle),
                                cos;
                            angle = parseFloat(rotationX) * _DEG2RAD;
                            cos = Math.cos(angle);
                            x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
                            y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
                            z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
                        }
                        if (transformPerspective !== _zeroPx) {
                            transforms += "perspective(" + transformPerspective + _endParenthesis;
                        }
                        if (xPercent || yPercent) {
                            transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
                        }
                        if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
                            transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
                        }
                        if (rotation !== _zeroDeg) {
                            transforms += "rotate(" + rotation + _endParenthesis;
                        }
                        if (rotationY !== _zeroDeg) {
                            transforms += "rotateY(" + rotationY + _endParenthesis;
                        }
                        if (rotationX !== _zeroDeg) {
                            transforms += "rotateX(" + rotationX + _endParenthesis;
                        }
                        if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
                            transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
                        }
                        if (scaleX !== 1 || scaleY !== 1) {
                            transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
                        }
                        target.style[_transformProp] = transforms || "translate(0, 0)";
                    },
                    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
                        var _ref2 = cache || this,
                            xPercent = _ref2.xPercent,
                            yPercent = _ref2.yPercent,
                            x = _ref2.x,
                            y = _ref2.y,
                            rotation = _ref2.rotation,
                            skewX = _ref2.skewX,
                            skewY = _ref2.skewY,
                            scaleX = _ref2.scaleX,
                            scaleY = _ref2.scaleY,
                            target = _ref2.target,
                            xOrigin = _ref2.xOrigin,
                            yOrigin = _ref2.yOrigin,
                            xOffset = _ref2.xOffset,
                            yOffset = _ref2.yOffset,
                            forceCSS = _ref2.forceCSS,
                            tx = parseFloat(x),
                            ty = parseFloat(y),
                            a11, a21, a12, a22, temp;
                        rotation = parseFloat(rotation);
                        skewX = parseFloat(skewX);
                        skewY = parseFloat(skewY);
                        if (skewY) {
                            //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
                            skewY = parseFloat(skewY);
                            skewX += skewY;
                            rotation += skewY;
                        }
                        if (rotation || skewX) {
                            rotation *= _DEG2RAD;
                            skewX *= _DEG2RAD;
                            a11 = Math.cos(rotation) * scaleX;
                            a21 = Math.sin(rotation) * scaleX;
                            a12 = Math.sin(rotation - skewX) * -scaleY;
                            a22 = Math.cos(rotation - skewX) * scaleY;
                            if (skewX) {
                                skewY *= _DEG2RAD;
                                temp = Math.tan(skewX - skewY);
                                temp = Math.sqrt(1 + temp * temp);
                                a12 *= temp;
                                a22 *= temp;
                                if (skewY) {
                                    temp = Math.tan(skewY);
                                    temp = Math.sqrt(1 + temp * temp);
                                    a11 *= temp;
                                    a21 *= temp;
                                }
                            }
                            a11 = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a11);
                            a21 = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a21);
                            a12 = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a12);
                            a22 = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a22);
                        } else {
                            a11 = scaleX;
                            a22 = scaleY;
                            a21 = a12 = 0;
                        }
                        if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
                            tx = _convertToUnit(target, "x", x, "px");
                            ty = _convertToUnit(target, "y", y, "px");
                        }
                        if (xOrigin || yOrigin || xOffset || yOffset) {
                            tx = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
                            ty = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
                        }
                        if (xPercent || yPercent) {
                            //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
                            temp = target.getBBox();
                            tx = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xPercent / 100 * temp.width);
                            ty = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yPercent / 100 * temp.height);
                        }
                        temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
                        target.setAttribute("transform", temp);
                        forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the  transform attribute changes!)
                    },
                    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
                        var cap = 360,
                            isString = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(endValue),
                            endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
                            change = endNum - startNum,
                            finalValue = startNum + change + "deg",
                            direction, pt;
                        if (isString) {
                            direction = endValue.split("_")[1];
                            if (direction === "short") {
                                change %= cap;
                                if (change !== change % (cap / 2)) {
                                    change += change < 0 ? cap : -cap;
                                }
                            }
                            if (direction === "cw" && change < 0) {
                                change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
                            } else if (direction === "ccw" && change > 0) {
                                change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
                            }
                        }
                        plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
                        pt.e = finalValue;
                        pt.u = "deg";
                        plugin._props.push(property);
                        return pt;
                    },
                    _assign = function _assign(target, source) {
                        // Internet Explorer doesn't have Object.assign(), so we recreate it here.
                        for (var p in source) {
                            target[p] = source[p];
                        }
                        return target;
                    },
                    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
                        //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
                        var startCache = _assign({}, target._gsap),
                            exclude = "perspective,force3D,transformOrigin,svgOrigin",
                            style = target.style,
                            endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;
                        if (startCache.svg) {
                            startValue = target.getAttribute("transform");
                            target.setAttribute("transform", "");
                            style[_transformProp] = transforms;
                            endCache = _parseTransform(target, 1);
                            _removeProperty(target, _transformProp);
                            target.setAttribute("transform", startValue);
                        } else {
                            startValue = getComputedStyle(target)[_transformProp];
                            style[_transformProp] = transforms;
                            endCache = _parseTransform(target, 1);
                            style[_transformProp] = startValue;
                        }
                        for (p in _transformProps) {
                            startValue = startCache[p];
                            endValue = endCache[p];
                            if (startValue !== endValue && exclude.indexOf(p) < 0) {
                                //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
                                startUnit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
                                endUnit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
                                startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
                                endNum = parseFloat(endValue);
                                plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
                                plugin._pt.u = endUnit || 0;
                                plugin._props.push(p);
                            }
                        }
                        _assign(endCache, startCache);
                    }; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.
                (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("padding,margin,Width,Radius", function(name, index) {
                    var t = "Top",
                        r = "Right",
                        b = "Bottom",
                        l = "Left",
                        props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function(side) {
                            return index < 2 ? name + side : "border" + side + name;
                        });
                    _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
                        var a, vars;
                        if (arguments.length < 4) {
                            // getter, passed target, property, and unit (from _get())
                            a = props.map(function(prop) {
                                return _get(plugin, prop, property);
                            });
                            vars = a.join(" ");
                            return vars.split(a[0]).length === 5 ? a[0] : vars;
                        }
                        a = (endValue + "").split(" ");
                        vars = {};
                        props.forEach(function(prop, i) {
                            return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
                        });
                        plugin.init(target, vars, tween);
                    };
                });
                var CSSPlugin = {
                    name: "css",
                    register: _initCore,
                    targetTest: function targetTest(target) {
                        return target.style && target.nodeType;
                    },
                    init: function init(target, vars, tween, index, targets) {
                        var props = this._props,
                            style = target.style,
                            startAt = tween.vars.startAt,
                            startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority;
                        _pluginInitted || _initCore();
                        for (p in vars) {
                            if (p === "autoRound") {
                                continue;
                            }
                            endValue = vars[p];
                            if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._plugins[p] && (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._checkPlugin)(p, vars, tween, index, target, targets)) {
                                // plugins
                                continue;
                            }
                            type = typeof endValue;
                            specialProp = _specialProps[p];
                            if (type === "function") {
                                endValue = endValue.call(tween, index, target, targets);
                                type = typeof endValue;
                            }
                            if (type === "string" && ~endValue.indexOf("random(")) {
                                endValue = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(endValue);
                            }
                            if (specialProp) {
                                specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
                            } else if (p.substr(0, 2) === "--") {
                                //CSS variable
                                startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
                                endValue += "";
                                _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.lastIndex = 0;
                                if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.test(startValue)) {
                                    // colors don't have units
                                    startUnit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
                                    endUnit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
                                }
                                endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
                                this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
                                props.push(p);
                            } else if (type !== "undefined") {
                                if (startAt && p in startAt) {
                                    // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
                                    startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
                                    (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(startValue) && ~startValue.indexOf("random(") && (startValue = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(startValue));
                                    (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue + "") || (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] || (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(_get(target, p)) || ""); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.
                                    (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
                                } else {
                                    startValue = _get(target, p);
                                }
                                startNum = parseFloat(startValue);
                                relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
                                relative && (endValue = endValue.substr(2));
                                endNum = parseFloat(endValue);
                                if (p in _propertyAliases) {
                                    if (p === "autoAlpha") {
                                        //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
                                        if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                                            //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
                                            startNum = 0;
                                        }
                                        _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
                                    }
                                    if (p !== "scale" && p !== "transform") {
                                        p = _propertyAliases[p];
                                        ~p.indexOf(",") && (p = p.split(",")[0]);
                                    }
                                }
                                isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---
                                if (isTransformRelated) {
                                    if (!transformPropTween) {
                                        cache = target._gsap;
                                        cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.
                                        smooth = vars.smoothOrigin !== false && cache.smooth;
                                        transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)
                                        transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
                                    }
                                    if (p === "scale") {
                                        this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0);
                                        props.push("scaleY", p);
                                        p += "X";
                                    } else if (p === "transformOrigin") {
                                        endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.
                                        if (cache.svg) {
                                            _applySVGOrigin(target, endValue, 0, smooth, 0, this);
                                        } else {
                                            endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!
                                            endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                                            _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
                                        }
                                        continue;
                                    } else if (p === "svgOrigin") {
                                        _applySVGOrigin(target, endValue, 1, smooth, 0, this);
                                        continue;
                                    } else if (p in _rotationalProperties) {
                                        _addRotationalPropTween(this, cache, p, startNum, relative ? (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endValue) : endValue);
                                        continue;
                                    } else if (p === "smoothOrigin") {
                                        _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
                                        continue;
                                    } else if (p === "force3D") {
                                        cache[p] = endValue;
                                        continue;
                                    } else if (p === "transform") {
                                        _addRawTransformPTs(this, endValue, target);
                                        continue;
                                    }
                                } else if (!(p in style)) {
                                    p = _checkPropPrefix(p) || p;
                                }
                                if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
                                    startUnit = (startValue + "").substr((startNum + "").length);
                                    endNum || (endNum = 0); // protect against NaN
                                    endUnit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] : startUnit);
                                    startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
                                    this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
                                    this._pt.u = endUnit || 0;
                                    if (startUnit !== endUnit && endUnit !== "%") {
                                        //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
                                        this._pt.b = startValue;
                                        this._pt.r = _renderCSSPropWithBeginning;
                                    }
                                } else if (!(p in style)) {
                                    if (p in target) {
                                        //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
                                        this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
                                    } else {
                                        (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._missingPlugin)(p, endValue);
                                        continue;
                                    }
                                } else {
                                    _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
                                }
                                props.push(p);
                            }
                        }
                        hasPriority && (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._sortPropTweensByPriority)(this);
                    },
                    get: _get,
                    aliases: _propertyAliases,
                    getSetter: function getSetter(target, property, plugin) {
                        //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
                        var p = _propertyAliases[property];
                        p && p.indexOf(",") < 0 && (property = p);
                        return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getSetter)(target, property);
                    },
                    core: {
                        _removeProperty: _removeProperty,
                        _getMatrix: _getMatrix
                    }
                };
                _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.utils.checkPrefix = _checkPropPrefix;
                (function(positionAndScale, rotation, others, aliases) {
                    var all = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(positionAndScale + "," + rotation + "," + others, function(name) {
                        _transformProps[name] = 1;
                    });
                    (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(rotation, function(name) {
                        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "deg";
                        _rotationalProperties[name] = 1;
                    });
                    _propertyAliases[all[13]] = positionAndScale + "," + rotation;
                    (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(aliases, function(name) {
                        var split = name.split(":");
                        _propertyAliases[split[1]] = all[split[0]];
                    });
                })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
                (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
                    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "px";
                });
                _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(CSSPlugin);



                /***/
            }),

        /***/
        "./node_modules/gsap/ScrollToPlugin.js":
            /*!*********************************************!*\
              !*** ./node_modules/gsap/ScrollToPlugin.js ***!
              \*********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "ScrollToPlugin": function() {
                        return /* binding */ ScrollToPlugin;
                    },
                    /* harmony export */
                    "default": function() {
                        return /* binding */ ScrollToPlugin;
                    }
                    /* harmony export */
                });
                /*!
                 * ScrollToPlugin 3.10.2
                 * https://greensock.com
                 *
                 * @license Copyright 2008-2022, GreenSock. All rights reserved.
                 * Subject to the terms at https://greensock.com/standard-license or for
                 * Club GreenSock members, the agreement issued with that membership.
                 * @author: Jack Doyle, jack@greensock.com
                 */
                /* eslint-disable */
                var gsap, _coreInitted, _window, _docEl, _body, _toArray, _config, _windowExists = function _windowExists() {
                        return typeof window !== "undefined";
                    },
                    _getGSAP = function _getGSAP() {
                        return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
                    },
                    _isString = function _isString(value) {
                        return typeof value === "string";
                    },
                    _isFunction = function _isFunction(value) {
                        return typeof value === "function";
                    },
                    _max = function _max(element, axis) {
                        var dim = axis === "x" ? "Width" : "Height",
                            scroll = "scroll" + dim,
                            client = "client" + dim;
                        return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window["inner" + dim] || _docEl[client] || _body[client]) : element[scroll] - element["offset" + dim];
                    },
                    _buildGetter = function _buildGetter(e, axis) {
                        //pass in an element and an axis ("x" or "y") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.
                        var p = "scroll" + (axis === "x" ? "Left" : "Top");
                        if (e === _window) {
                            if (e.pageXOffset != null) {
                                p = "page" + axis.toUpperCase() + "Offset";
                            } else {
                                e = _docEl[p] != null ? _docEl : _body;
                            }
                        }
                        return function() {
                            return e[p];
                        };
                    },
                    _clean = function _clean(value, index, target, targets) {
                        _isFunction(value) && (value = value(index, target, targets));
                        if (typeof value !== "object") {
                            return _isString(value) && value !== "max" && value.charAt(1) !== "=" ? {
                                x: value,
                                y: value
                            } : {
                                y: value
                            }; //if we don't receive an object as the parameter, assume the user intends "y".
                        } else if (value.nodeType) {
                            return {
                                y: value,
                                x: value
                            };
                        } else {
                            var result = {},
                                p;
                            for (p in value) {
                                result[p] = p !== "onAutoKill" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];
                            }
                            return result;
                        }
                    },
                    _getOffset = function _getOffset(element, container) {
                        element = _toArray(element)[0];
                        if (!element || !element.getBoundingClientRect) {
                            return console.warn("scrollTo target doesn't exist. Using 0") || {
                                x: 0,
                                y: 0
                            };
                        }
                        var rect = element.getBoundingClientRect(),
                            isRoot = !container || container === _window || container === _body,
                            cRect = isRoot ? {
                                top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),
                                left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)
                            } : container.getBoundingClientRect(),
                            offsets = {
                                x: rect.left - cRect.left,
                                y: rect.top - cRect.top
                            };
                        if (!isRoot && container) {
                            //only add the current scroll position if it's not the window/body.
                            offsets.x += _buildGetter(container, "x")();
                            offsets.y += _buildGetter(container, "y")();
                        }
                        return offsets;
                    },
                    _parseVal = function _parseVal(value, target, axis, currentVal, offset) {
                        return !isNaN(value) && typeof value !== "object" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === "=" ? parseFloat(value.substr(2)) * (value.charAt(0) === "-" ? -1 : 1) + currentVal - offset : value === "max" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);
                    },
                    _initCore = function _initCore() {
                        gsap = _getGSAP();
                        if (_windowExists() && gsap && document.body) {
                            _window = window;
                            _body = document.body;
                            _docEl = document.documentElement;
                            _toArray = gsap.utils.toArray;
                            gsap.config({
                                autoKillThreshold: 7
                            });
                            _config = gsap.config();
                            _coreInitted = 1;
                        }
                    };
                var ScrollToPlugin = {
                    version: "3.10.2",
                    name: "scrollTo",
                    rawVars: 1,
                    register: function register(core) {
                        gsap = core;
                        _initCore();
                    },
                    init: function init(target, value, tween, index, targets) {
                        _coreInitted || _initCore();
                        var data = this,
                            snapType = gsap.getProperty(target, "scrollSnapType");
                        data.isWin = target === _window;
                        data.target = target;
                        data.tween = tween;
                        value = _clean(value, index, target, targets);
                        data.vars = value;
                        data.autoKill = !!value.autoKill;
                        data.getX = _buildGetter(target, "x");
                        data.getY = _buildGetter(target, "y");
                        data.x = data.xPrev = data.getX();
                        data.y = data.yPrev = data.getY();
                        if (snapType && snapType !== "none") {
                            // disable scroll snapping to avoid strange behavior
                            data.snap = 1;
                            data.snapInline = target.style.scrollSnapType;
                            target.style.scrollSnapType = "none";
                        }
                        if (value.x != null) {
                            data.add(data, "x", data.x, _parseVal(value.x, target, "x", data.x, value.offsetX || 0), index, targets);
                            data._props.push("scrollTo_x");
                        } else {
                            data.skipX = 1;
                        }
                        if (value.y != null) {
                            data.add(data, "y", data.y, _parseVal(value.y, target, "y", data.y, value.offsetY || 0), index, targets);
                            data._props.push("scrollTo_y");
                        } else {
                            data.skipY = 1;
                        }
                    },
                    render: function render(ratio, data) {
                        var pt = data._pt,
                            target = data.target,
                            tween = data.tween,
                            autoKill = data.autoKill,
                            xPrev = data.xPrev,
                            yPrev = data.yPrev,
                            isWin = data.isWin,
                            snap = data.snap,
                            snapInline = data.snapInline,
                            x, y, yDif, xDif, threshold;
                        while (pt) {
                            pt.r(ratio, pt.d);
                            pt = pt._next;
                        }
                        x = isWin || !data.skipX ? data.getX() : xPrev;
                        y = isWin || !data.skipY ? data.getY() : yPrev;
                        yDif = y - yPrev;
                        xDif = x - xPrev;
                        threshold = _config.autoKillThreshold;
                        if (data.x < 0) {
                            //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)
                            data.x = 0;
                        }
                        if (data.y < 0) {
                            data.y = 0;
                        }
                        if (autoKill) {
                            //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.
                            if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, "x")) {
                                data.skipX = 1; //if the user scrolls separately, we should stop tweening!
                            }
                            if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, "y")) {
                                data.skipY = 1; //if the user scrolls separately, we should stop tweening!
                            }
                            if (data.skipX && data.skipY) {
                                tween.kill();
                                data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);
                            }
                        }
                        if (isWin) {
                            _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);
                        } else {
                            data.skipY || (target.scrollTop = data.y);
                            data.skipX || (target.scrollLeft = data.x);
                        }
                        if (snap && (ratio === 1 || ratio === 0)) {
                            y = target.scrollTop;
                            x = target.scrollLeft;
                            snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty("scroll-snap-type");
                            target.scrollTop = y + 1; // bug in Safari causes the element to totally reset its scroll position when scroll-snap-type changes, so we need to set it to a slightly different value and then back again to work around this bug.
                            target.scrollLeft = x + 1;
                            target.scrollTop = y;
                            target.scrollLeft = x;
                        }
                        data.xPrev = data.x;
                        data.yPrev = data.y;
                    },
                    kill: function kill(property) {
                        var both = property === "scrollTo";
                        if (both || property === "scrollTo_x") {
                            this.skipX = 1;
                        }
                        if (both || property === "scrollTo_y") {
                            this.skipY = 1;
                        }
                    }
                };
                ScrollToPlugin.max = _max;
                ScrollToPlugin.getOffset = _getOffset;
                ScrollToPlugin.buildGetter = _buildGetter;
                _getGSAP() && gsap.registerPlugin(ScrollToPlugin);



                /***/
            }),

        /***/
        "./node_modules/gsap/gsap-core.js":
            /*!****************************************!*\
              !*** ./node_modules/gsap/gsap-core.js ***!
              \****************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "Animation": function() {
                        return /* binding */ Animation;
                    },
                    /* harmony export */
                    "Back": function() {
                        return /* binding */ Back;
                    },
                    /* harmony export */
                    "Bounce": function() {
                        return /* binding */ Bounce;
                    },
                    /* harmony export */
                    "Circ": function() {
                        return /* binding */ Circ;
                    },
                    /* harmony export */
                    "Cubic": function() {
                        return /* binding */ Cubic;
                    },
                    /* harmony export */
                    "Elastic": function() {
                        return /* binding */ Elastic;
                    },
                    /* harmony export */
                    "Expo": function() {
                        return /* binding */ Expo;
                    },
                    /* harmony export */
                    "GSCache": function() {
                        return /* binding */ GSCache;
                    },
                    /* harmony export */
                    "Linear": function() {
                        return /* binding */ Linear;
                    },
                    /* harmony export */
                    "Power0": function() {
                        return /* binding */ Power0;
                    },
                    /* harmony export */
                    "Power1": function() {
                        return /* binding */ Power1;
                    },
                    /* harmony export */
                    "Power2": function() {
                        return /* binding */ Power2;
                    },
                    /* harmony export */
                    "Power3": function() {
                        return /* binding */ Power3;
                    },
                    /* harmony export */
                    "Power4": function() {
                        return /* binding */ Power4;
                    },
                    /* harmony export */
                    "PropTween": function() {
                        return /* binding */ PropTween;
                    },
                    /* harmony export */
                    "Quad": function() {
                        return /* binding */ Quad;
                    },
                    /* harmony export */
                    "Quart": function() {
                        return /* binding */ Quart;
                    },
                    /* harmony export */
                    "Quint": function() {
                        return /* binding */ Quint;
                    },
                    /* harmony export */
                    "Sine": function() {
                        return /* binding */ Sine;
                    },
                    /* harmony export */
                    "SteppedEase": function() {
                        return /* binding */ SteppedEase;
                    },
                    /* harmony export */
                    "Strong": function() {
                        return /* binding */ Strong;
                    },
                    /* harmony export */
                    "Timeline": function() {
                        return /* binding */ Timeline;
                    },
                    /* harmony export */
                    "TimelineLite": function() {
                        return /* binding */ Timeline;
                    },
                    /* harmony export */
                    "TimelineMax": function() {
                        return /* binding */ Timeline;
                    },
                    /* harmony export */
                    "Tween": function() {
                        return /* binding */ Tween;
                    },
                    /* harmony export */
                    "TweenLite": function() {
                        return /* binding */ Tween;
                    },
                    /* harmony export */
                    "TweenMax": function() {
                        return /* binding */ Tween;
                    },
                    /* harmony export */
                    "_checkPlugin": function() {
                        return /* binding */ _checkPlugin;
                    },
                    /* harmony export */
                    "_colorExp": function() {
                        return /* binding */ _colorExp;
                    },
                    /* harmony export */
                    "_colorStringFilter": function() {
                        return /* binding */ _colorStringFilter;
                    },
                    /* harmony export */
                    "_config": function() {
                        return /* binding */ _config;
                    },
                    /* harmony export */
                    "_forEachName": function() {
                        return /* binding */ _forEachName;
                    },
                    /* harmony export */
                    "_getCache": function() {
                        return /* binding */ _getCache;
                    },
                    /* harmony export */
                    "_getProperty": function() {
                        return /* binding */ _getProperty;
                    },
                    /* harmony export */
                    "_getSetter": function() {
                        return /* binding */ _getSetter;
                    },
                    /* harmony export */
                    "_isString": function() {
                        return /* binding */ _isString;
                    },
                    /* harmony export */
                    "_isUndefined": function() {
                        return /* binding */ _isUndefined;
                    },
                    /* harmony export */
                    "_missingPlugin": function() {
                        return /* binding */ _missingPlugin;
                    },
                    /* harmony export */
                    "_numExp": function() {
                        return /* binding */ _numExp;
                    },
                    /* harmony export */
                    "_numWithUnitExp": function() {
                        return /* binding */ _numWithUnitExp;
                    },
                    /* harmony export */
                    "_parseRelative": function() {
                        return /* binding */ _parseRelative;
                    },
                    /* harmony export */
                    "_plugins": function() {
                        return /* binding */ _plugins;
                    },
                    /* harmony export */
                    "_relExp": function() {
                        return /* binding */ _relExp;
                    },
                    /* harmony export */
                    "_removeLinkedListItem": function() {
                        return /* binding */ _removeLinkedListItem;
                    },
                    /* harmony export */
                    "_renderComplexString": function() {
                        return /* binding */ _renderComplexString;
                    },
                    /* harmony export */
                    "_replaceRandom": function() {
                        return /* binding */ _replaceRandom;
                    },
                    /* harmony export */
                    "_round": function() {
                        return /* binding */ _round;
                    },
                    /* harmony export */
                    "_roundModifier": function() {
                        return /* binding */ _roundModifier;
                    },
                    /* harmony export */
                    "_setDefaults": function() {
                        return /* binding */ _setDefaults;
                    },
                    /* harmony export */
                    "_sortPropTweensByPriority": function() {
                        return /* binding */ _sortPropTweensByPriority;
                    },
                    /* harmony export */
                    "_ticker": function() {
                        return /* binding */ _ticker;
                    },
                    /* harmony export */
                    "clamp": function() {
                        return /* binding */ clamp;
                    },
                    /* harmony export */
                    "default": function() {
                        return /* binding */ gsap;
                    },
                    /* harmony export */
                    "distribute": function() {
                        return /* binding */ distribute;
                    },
                    /* harmony export */
                    "getUnit": function() {
                        return /* binding */ getUnit;
                    },
                    /* harmony export */
                    "gsap": function() {
                        return /* binding */ gsap;
                    },
                    /* harmony export */
                    "interpolate": function() {
                        return /* binding */ interpolate;
                    },
                    /* harmony export */
                    "mapRange": function() {
                        return /* binding */ mapRange;
                    },
                    /* harmony export */
                    "normalize": function() {
                        return /* binding */ normalize;
                    },
                    /* harmony export */
                    "pipe": function() {
                        return /* binding */ pipe;
                    },
                    /* harmony export */
                    "random": function() {
                        return /* binding */ random;
                    },
                    /* harmony export */
                    "selector": function() {
                        return /* binding */ selector;
                    },
                    /* harmony export */
                    "shuffle": function() {
                        return /* binding */ shuffle;
                    },
                    /* harmony export */
                    "snap": function() {
                        return /* binding */ snap;
                    },
                    /* harmony export */
                    "splitColor": function() {
                        return /* binding */ splitColor;
                    },
                    /* harmony export */
                    "toArray": function() {
                        return /* binding */ toArray;
                    },
                    /* harmony export */
                    "unitize": function() {
                        return /* binding */ unitize;
                    },
                    /* harmony export */
                    "wrap": function() {
                        return /* binding */ wrap;
                    },
                    /* harmony export */
                    "wrapYoyo": function() {
                        return /* binding */ wrapYoyo;
                    }
                    /* harmony export */
                });

                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return self;
                }

                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype);
                    subClass.prototype.constructor = subClass;
                    subClass.__proto__ = superClass;
                }
                /*!
                 * GSAP 3.10.2
                 * https://greensock.com
                 *
                 * @license Copyright 2008-2022, GreenSock. All rights reserved.
                 * Subject to the terms at https://greensock.com/standard-license or for
                 * Club GreenSock members, the agreement issued with that membership.
                 * @author: Jack Doyle, jack@greensock.com
                 */
                /* eslint-disable */
                var _config = {
                        autoSleep: 120,
                        force3D: "auto",
                        nullTargetWarn: 1,
                        units: {
                            lineHeight: ""
                        }
                    },
                    _defaults = {
                        duration: .5,
                        overwrite: false,
                        delay: 0
                    },
                    _suppressOverwrites, _bigNum = 1e8,
                    _tinyNum = 1 / _bigNum,
                    _2PI = Math.PI * 2,
                    _HALF_PI = _2PI / 4,
                    _gsID = 0,
                    _sqrt = Math.sqrt,
                    _cos = Math.cos,
                    _sin = Math.sin,
                    _isString = function _isString(value) {
                        return typeof value === "string";
                    },
                    _isFunction = function _isFunction(value) {
                        return typeof value === "function";
                    },
                    _isNumber = function _isNumber(value) {
                        return typeof value === "number";
                    },
                    _isUndefined = function _isUndefined(value) {
                        return typeof value === "undefined";
                    },
                    _isObject = function _isObject(value) {
                        return typeof value === "object";
                    },
                    _isNotFalse = function _isNotFalse(value) {
                        return value !== false;
                    },
                    _windowExists = function _windowExists() {
                        return typeof window !== "undefined";
                    },
                    _isFuncOrString = function _isFuncOrString(value) {
                        return _isFunction(value) || _isString(value);
                    },
                    _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {},
                    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
                    _isArray = Array.isArray,
                    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
                    //only numbers (including negatives and decimals) but NOT relative values.
                    _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
                    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
                    _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
                    _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
                    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
                    _relExp = /[+-]=-?[.\d]+/,
                    _delimitedValueExp = /[^,'"\[\]\s]+/gi,
                    // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
                    _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
                    _globalTimeline, _win, _coreInitted, _doc, _globals = {},
                    _installScope = {},
                    _coreReady, _install = function _install(scope) {
                        return (_installScope = _merge(scope, _globals)) && gsap;
                    },
                    _missingPlugin = function _missingPlugin(property, value) {
                        return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
                    },
                    _warn = function _warn(message, suppress) {
                        return !suppress && console.warn(message);
                    },
                    _addGlobal = function _addGlobal(name, obj) {
                        return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
                    },
                    _emptyFunc = function _emptyFunc() {
                        return 0;
                    },
                    _reservedProps = {},
                    _lazyTweens = [],
                    _lazyLookup = {},
                    _lastRenderedFrame, _plugins = {},
                    _effects = {},
                    _nextGCFrame = 30,
                    _harnessPlugins = [],
                    _callbackNames = "",
                    _harness = function _harness(targets) {
                        var target = targets[0],
                            harnessPlugin, i;
                        _isObject(target) || _isFunction(target) || (targets = [targets]);
                        if (!(harnessPlugin = (target._gsap || {}).harness)) {
                            // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
                            i = _harnessPlugins.length;
                            while (i-- && !_harnessPlugins[i].targetTest(target)) {}
                            harnessPlugin = _harnessPlugins[i];
                        }
                        i = targets.length;
                        while (i--) {
                            targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
                        }
                        return targets;
                    },
                    _getCache = function _getCache(target) {
                        return target._gsap || _harness(toArray(target))[0]._gsap;
                    },
                    _getProperty = function _getProperty(target, property, v) {
                        return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
                    },
                    _forEachName = function _forEachName(names, func) {
                        return (names = names.split(",")).forEach(func) || names;
                    },
                    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
                    _round = function _round(value) {
                        return Math.round(value * 100000) / 100000 || 0;
                    },
                    _roundPrecise = function _roundPrecise(value) {
                        return Math.round(value * 10000000) / 10000000 || 0;
                    },
                    // increased precision mostly for timing values.
                    _parseRelative = function _parseRelative(start, value) {
                        var operator = value.charAt(0),
                            end = parseFloat(value.substr(2));
                        start = parseFloat(start);
                        return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
                    },
                    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
                        //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
                        var l = toFind.length,
                            i = 0;
                        for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}
                        return i < l;
                    },
                    _lazyRender = function _lazyRender() {
                        var l = _lazyTweens.length,
                            a = _lazyTweens.slice(0),
                            i, tween;
                        _lazyLookup = {};
                        _lazyTweens.length = 0;
                        for (i = 0; i < l; i++) {
                            tween = a[i];
                            tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
                        }
                    },
                    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
                        _lazyTweens.length && _lazyRender();
                        animation.render(time, suppressEvents, force);
                        _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
                    },
                    _numericIfPossible = function _numericIfPossible(value) {
                        var n = parseFloat(value);
                        return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
                    },
                    _passThrough = function _passThrough(p) {
                        return p;
                    },
                    _setDefaults = function _setDefaults(obj, defaults) {
                        for (var p in defaults) {
                            p in obj || (obj[p] = defaults[p]);
                        }
                        return obj;
                    },
                    _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
                        return function(obj, defaults) {
                            for (var p in defaults) {
                                p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
                            }
                        };
                    },
                    _merge = function _merge(base, toMerge) {
                        for (var p in toMerge) {
                            base[p] = toMerge[p];
                        }
                        return base;
                    },
                    _mergeDeep = function _mergeDeep(base, toMerge) {
                        for (var p in toMerge) {
                            p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
                        }
                        return base;
                    },
                    _copyExcluding = function _copyExcluding(obj, excluding) {
                        var copy = {},
                            p;
                        for (p in obj) {
                            p in excluding || (copy[p] = obj[p]);
                        }
                        return copy;
                    },
                    _inheritDefaults = function _inheritDefaults(vars) {
                        var parent = vars.parent || _globalTimeline,
                            func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
                        if (_isNotFalse(vars.inherit)) {
                            while (parent) {
                                func(vars, parent.vars.defaults);
                                parent = parent.parent || parent._dp;
                            }
                        }
                        return vars;
                    },
                    _arraysMatch = function _arraysMatch(a1, a2) {
                        var i = a1.length,
                            match = i === a2.length;
                        while (match && i-- && a1[i] === a2[i]) {}
                        return i < 0;
                    },
                    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
                        if (firstProp === void 0) {
                            firstProp = "_first";
                        }
                        if (lastProp === void 0) {
                            lastProp = "_last";
                        }
                        var prev = parent[lastProp],
                            t;
                        if (sortBy) {
                            t = child[sortBy];
                            while (prev && prev[sortBy] > t) {
                                prev = prev._prev;
                            }
                        }
                        if (prev) {
                            child._next = prev._next;
                            prev._next = child;
                        } else {
                            child._next = parent[firstProp];
                            parent[firstProp] = child;
                        }
                        if (child._next) {
                            child._next._prev = child;
                        } else {
                            parent[lastProp] = child;
                        }
                        child._prev = prev;
                        child.parent = child._dp = parent;
                        return child;
                    },
                    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
                        if (firstProp === void 0) {
                            firstProp = "_first";
                        }
                        if (lastProp === void 0) {
                            lastProp = "_last";
                        }
                        var prev = child._prev,
                            next = child._next;
                        if (prev) {
                            prev._next = next;
                        } else if (parent[firstProp] === child) {
                            parent[firstProp] = next;
                        }
                        if (next) {
                            next._prev = prev;
                        } else if (parent[lastProp] === child) {
                            parent[lastProp] = prev;
                        }
                        child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
                    },
                    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
                        child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
                        child._act = 0;
                    },
                    _uncache = function _uncache(animation, child) {
                        if (animation && (!child || child._end > animation._dur || child._start < 0)) {
                            // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
                            var a = animation;
                            while (a) {
                                a._dirty = 1;
                                a = a.parent;
                            }
                        }
                        return animation;
                    },
                    _recacheAncestors = function _recacheAncestors(animation) {
                        var parent = animation.parent;
                        while (parent && parent.parent) {
                            //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
                            parent._dirty = 1;
                            parent.totalDuration();
                            parent = parent.parent;
                        }
                        return animation;
                    },
                    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
                        return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
                    },
                    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
                        return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
                    },
                    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
                    _animationCycle = function _animationCycle(tTime, cycleDuration) {
                        var whole = Math.floor(tTime /= cycleDuration);
                        return tTime && whole === tTime ? whole - 1 : whole;
                    },
                    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
                        return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
                    },
                    _setEnd = function _setEnd(animation) {
                        return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
                    },
                    _alignPlayhead = function _alignPlayhead(animation, totalTime) {
                        // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
                        var parent = animation._dp;
                        if (parent && parent.smoothChildTiming && animation._ts) {
                            animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
                            _setEnd(animation);
                            parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
                        }
                        return animation;
                    },
                    /*
                    _totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
                        let cycleDuration = duration + repeatDelay,
                            time = _round(clampedTotalTime % cycleDuration);
                        if (time > duration) {
                            time = duration;
                        }
                        return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
                    },
                    */
                    _postAddChecks = function _postAddChecks(timeline, child) {
                        var t;
                        if (child._time || child._initted && !child._dur) {
                            //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
                            t = _parentToChildTotalTime(timeline.rawTime(), child);
                            if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
                                child.render(t, true);
                            }
                        } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.
                        if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
                            //in case any of the ancestors had completed but should now be enabled...
                            if (timeline._dur < timeline.duration()) {
                                t = timeline;
                                while (t._dp) {
                                    t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.
                                    t = t._dp;
                                }
                            }
                            timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
                        }
                    },
                    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
                        child.parent && _removeFromParent(child);
                        child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
                        child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
                        _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);
                        _isFromOrFromStart(child) || (timeline._recent = child);
                        skipChecks || _postAddChecks(timeline, child);
                        return timeline;
                    },
                    _scrollTrigger = function _scrollTrigger(animation, trigger) {
                        return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
                    },
                    _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
                        _initTween(tween, totalTime);
                        if (!tween._initted) {
                            return 1;
                        }
                        if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
                            _lazyTweens.push(tween);
                            tween._lazy = [totalTime, suppressEvents];
                            return 1;
                        }
                    },
                    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
                        var parent = _ref.parent;
                        return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
                    },
                    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
                    _isFromOrFromStart = function _isFromOrFromStart(_ref2) {
                        var data = _ref2.data;
                        return data === "isFromStart" || data === "isStart";
                    },
                    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
                        var prevRatio = tween.ratio,
                            ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
                            // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
                            repeatDelay = tween._rDelay,
                            tTime = 0,
                            pt, iteration, prevIteration;
                        if (repeatDelay && tween._repeat) {
                            // in case there's a zero-duration tween that has a repeat with a repeatDelay
                            tTime = _clamp(0, tween._tDur, totalTime);
                            iteration = _animationCycle(tTime, repeatDelay);
                            tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
                            if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
                                // if iteration changed
                                prevRatio = 1 - ratio;
                                tween.vars.repeatRefresh && tween._initted && tween.invalidate();
                            }
                        }
                        if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
                            if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
                                // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
                                return;
                            }
                            prevIteration = tween._zTime;
                            tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.
                            suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.
                            tween.ratio = ratio;
                            tween._from && (ratio = 1 - ratio);
                            tween._time = 0;
                            tween._tTime = tTime;
                            pt = tween._pt;
                            while (pt) {
                                pt.r(ratio, pt.d);
                                pt = pt._next;
                            }
                            tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
                            tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
                            tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
                            if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
                                ratio && _removeFromParent(tween, 1);
                                if (!suppressEvents) {
                                    _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
                                    tween._prom && tween._prom();
                                }
                            }
                        } else if (!tween._zTime) {
                            tween._zTime = totalTime;
                        }
                    },
                    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
                        var child;
                        if (time > prevTime) {
                            child = animation._first;
                            while (child && child._start <= time) {
                                if (child.data === "isPause" && child._start > prevTime) {
                                    return child;
                                }
                                child = child._next;
                            }
                        } else {
                            child = animation._last;
                            while (child && child._start >= time) {
                                if (child.data === "isPause" && child._start < prevTime) {
                                    return child;
                                }
                                child = child._prev;
                            }
                        }
                    },
                    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
                        var repeat = animation._repeat,
                            dur = _roundPrecise(duration) || 0,
                            totalProgress = animation._tTime / animation._tDur;
                        totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
                        animation._dur = dur;
                        animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
                        totalProgress > 0 && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);
                        skipUncache || _uncache(animation.parent, animation);
                        return animation;
                    },
                    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
                        return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
                    },
                    _zeroPosition = {
                        _start: 0,
                        endTime: _emptyFunc,
                        totalDuration: _emptyFunc
                    },
                    _parsePosition = function _parsePosition(animation, position, percentAnimation) {
                        var labels = animation.labels,
                            recent = animation._recent || _zeroPosition,
                            clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
                            //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
                            i, offset, isPercent;
                        if (_isString(position) && (isNaN(position) || position in labels)) {
                            //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
                            offset = position.charAt(0);
                            isPercent = position.substr(-1) === "%";
                            i = position.indexOf("=");
                            if (offset === "<" || offset === ">") {
                                i >= 0 && (position = position.replace(/=/, ""));
                                return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
                            }
                            if (i < 0) {
                                position in labels || (labels[position] = clippedDuration);
                                return labels[position];
                            }
                            offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
                            if (isPercent && percentAnimation) {
                                offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
                            }
                            return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
                        }
                        return position == null ? clippedDuration : +position;
                    },
                    _createTweenType = function _createTweenType(type, params, timeline) {
                        var isLegacy = _isNumber(params[1]),
                            varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
                            vars = params[varsIndex],
                            irVars, parent;
                        isLegacy && (vars.duration = params[1]);
                        vars.parent = timeline;
                        if (type) {
                            irVars = vars;
                            parent = timeline;
                            while (parent && !("immediateRender" in irVars)) {
                                // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
                                irVars = parent.vars.defaults || {};
                                parent = _isNotFalse(parent.vars.inherit) && parent.parent;
                            }
                            vars.immediateRender = _isNotFalse(irVars.immediateRender);
                            type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
                        }
                        return new Tween(params[0], vars, params[varsIndex + 1]);
                    },
                    _conditionalReturn = function _conditionalReturn(value, func) {
                        return value || value === 0 ? func(value) : func;
                    },
                    _clamp = function _clamp(min, max, value) {
                        return value < min ? min : value > max ? max : value;
                    },
                    getUnit = function getUnit(value, v) {
                        return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1];
                    },
                    // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
                    clamp = function clamp(min, max, value) {
                        return _conditionalReturn(value, function(v) {
                            return _clamp(min, max, v);
                        });
                    },
                    _slice = [].slice,
                    _isArrayLike = function _isArrayLike(value, nonEmpty) {
                        return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
                    },
                    _flatten = function _flatten(ar, leaveStrings, accumulator) {
                        if (accumulator === void 0) {
                            accumulator = [];
                        }
                        return ar.forEach(function(value) {
                            var _accumulator;
                            return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
                        }) || accumulator;
                    },
                    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
                    toArray = function toArray(value, scope, leaveStrings) {
                        return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
                    },
                    selector = function selector(value) {
                        value = toArray(value)[0] || _warn("Invalid scope") || {};
                        return function(v) {
                            var el = value.current || value.nativeElement || value;
                            return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
                        };
                    },
                    shuffle = function shuffle(a) {
                        return a.sort(function() {
                            return .5 - Math.random();
                        });
                    },
                    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
                    //for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
                    distribute = function distribute(v) {
                        if (_isFunction(v)) {
                            return v;
                        }
                        var vars = _isObject(v) ? v : {
                                each: v
                            },
                            //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
                            ease = _parseEase(vars.ease),
                            from = vars.from || 0,
                            base = parseFloat(vars.base) || 0,
                            cache = {},
                            isDecimal = from > 0 && from < 1,
                            ratios = isNaN(from) || isDecimal,
                            axis = vars.axis,
                            ratioX = from,
                            ratioY = from;
                        if (_isString(from)) {
                            ratioX = ratioY = {
                                center: .5,
                                edges: .5,
                                end: 1
                            }[from] || 0;
                        } else if (!isDecimal && ratios) {
                            ratioX = from[0];
                            ratioY = from[1];
                        }
                        return function(i, target, a) {
                            var l = (a || vars).length,
                                distances = cache[l],
                                originX, originY, x, y, d, j, max, min, wrapAt;
                            if (!distances) {
                                wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
                                if (!wrapAt) {
                                    max = -_bigNum;
                                    while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}
                                    wrapAt--;
                                }
                                distances = cache[l] = [];
                                originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
                                originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
                                max = 0;
                                min = _bigNum;
                                for (j = 0; j < l; j++) {
                                    x = j % wrapAt - originX;
                                    y = originY - (j / wrapAt | 0);
                                    distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
                                    d > max && (max = d);
                                    d < min && (min = d);
                                }
                                from === "random" && shuffle(distances);
                                distances.max = max - min;
                                distances.min = min;
                                distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
                                distances.b = l < 0 ? base - l : base;
                                distances.u = getUnit(vars.amount || vars.each) || 0; //unit
                                ease = ease && l < 0 ? _invertEase(ease) : ease;
                            }
                            l = (distances[i] - distances.min) / distances.max || 0;
                            return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
                        };
                    },
                    _roundModifier = function _roundModifier(v) {
                        //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
                        var p = Math.pow(10, ((v + "").split(".")[1] || "").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())
                        return function(raw) {
                            var n = Math.round(parseFloat(raw) / v) * v * p;
                            return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
                        };
                    },
                    snap = function snap(snapTo, value) {
                        var isArray = _isArray(snapTo),
                            radius, is2D;
                        if (!isArray && _isObject(snapTo)) {
                            radius = isArray = snapTo.radius || _bigNum;
                            if (snapTo.values) {
                                snapTo = toArray(snapTo.values);
                                if (is2D = !_isNumber(snapTo[0])) {
                                    radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
                                }
                            } else {
                                snapTo = _roundModifier(snapTo.increment);
                            }
                        }
                        return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
                            is2D = snapTo(raw);
                            return Math.abs(is2D - raw) <= radius ? is2D : raw;
                        } : function(raw) {
                            var x = parseFloat(is2D ? raw.x : raw),
                                y = parseFloat(is2D ? raw.y : 0),
                                min = _bigNum,
                                closest = 0,
                                i = snapTo.length,
                                dx, dy;
                            while (i--) {
                                if (is2D) {
                                    dx = snapTo[i].x - x;
                                    dy = snapTo[i].y - y;
                                    dx = dx * dx + dy * dy;
                                } else {
                                    dx = Math.abs(snapTo[i] - x);
                                }
                                if (dx < min) {
                                    min = dx;
                                    closest = i;
                                }
                            }
                            closest = !radius || min <= radius ? snapTo[closest] : raw;
                            return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
                        });
                    },
                    random = function random(min, max, roundingIncrement, returnFunction) {
                        return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
                            return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
                        });
                    },
                    pipe = function pipe() {
                        for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
                            functions[_key] = arguments[_key];
                        }
                        return function(value) {
                            return functions.reduce(function(v, f) {
                                return f(v);
                            }, value);
                        };
                    },
                    unitize = function unitize(func, unit) {
                        return function(value) {
                            return func(parseFloat(value)) + (unit || getUnit(value));
                        };
                    },
                    normalize = function normalize(min, max, value) {
                        return mapRange(min, max, 0, 1, value);
                    },
                    _wrapArray = function _wrapArray(a, wrapper, value) {
                        return _conditionalReturn(value, function(index) {
                            return a[~~wrapper(index)];
                        });
                    },
                    wrap = function wrap(min, max, value) {
                        // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
                        var range = max - min;
                        return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function(value) {
                            return (range + (value - min) % range) % range + min;
                        });
                    },
                    wrapYoyo = function wrapYoyo(min, max, value) {
                        var range = max - min,
                            total = range * 2;
                        return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function(value) {
                            value = (total + (value - min) % total) % total || 0;
                            return min + (value > range ? total - value : value);
                        });
                    },
                    _replaceRandom = function _replaceRandom(value) {
                        //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
                        var prev = 0,
                            s = "",
                            i, nums, end, isArray;
                        while (~(i = value.indexOf("random(", prev))) {
                            end = value.indexOf(")", i);
                            isArray = value.charAt(i + 7) === "[";
                            nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
                            s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
                            prev = end + 1;
                        }
                        return s + value.substr(prev, value.length - prev);
                    },
                    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
                        var inRange = inMax - inMin,
                            outRange = outMax - outMin;
                        return _conditionalReturn(value, function(value) {
                            return outMin + ((value - inMin) / inRange * outRange || 0);
                        });
                    },
                    interpolate = function interpolate(start, end, progress, mutate) {
                        var func = isNaN(start + end) ? 0 : function(p) {
                            return (1 - p) * start + p * end;
                        };
                        if (!func) {
                            var isString = _isString(start),
                                master = {},
                                p, i, interpolators, l, il;
                            progress === true && (mutate = 1) && (progress = null);
                            if (isString) {
                                start = {
                                    p: start
                                };
                                end = {
                                    p: end
                                };
                            } else if (_isArray(start) && !_isArray(end)) {
                                interpolators = [];
                                l = start.length;
                                il = l - 2;
                                for (i = 1; i < l; i++) {
                                    interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
                                }
                                l--;
                                func = function func(p) {
                                    p *= l;
                                    var i = Math.min(il, ~~p);
                                    return interpolators[i](p - i);
                                };
                                progress = end;
                            } else if (!mutate) {
                                start = _merge(_isArray(start) ? [] : {}, start);
                            }
                            if (!interpolators) {
                                for (p in end) {
                                    _addPropTween.call(master, start, p, "get", end[p]);
                                }
                                func = function func(p) {
                                    return _renderPropTweens(p, master) || (isString ? start.p : start);
                                };
                            }
                        }
                        return _conditionalReturn(progress, func);
                    },
                    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
                        //used for nextLabel() and previousLabel()
                        var labels = timeline.labels,
                            min = _bigNum,
                            p, distance, label;
                        for (p in labels) {
                            distance = labels[p] - fromTime;
                            if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
                                label = p;
                                min = distance;
                            }
                        }
                        return label;
                    },
                    _callback = function _callback(animation, type, executeLazyFirst) {
                        var v = animation.vars,
                            callback = v[type],
                            params, scope;
                        if (!callback) {
                            return;
                        }
                        params = v[type + "Params"];
                        scope = v.callbackScope || animation;
                        executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
                        return params ? callback.apply(scope, params) : callback.call(scope);
                    },
                    _interrupt = function _interrupt(animation) {
                        _removeFromParent(animation);
                        animation.scrollTrigger && animation.scrollTrigger.kill(false);
                        animation.progress() < 1 && _callback(animation, "onInterrupt");
                        return animation;
                    },
                    _quickTween, _createPlugin = function _createPlugin(config) {
                        config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.
                        var name = config.name,
                            isFunc = _isFunction(config),
                            Plugin = name && !isFunc && config.init ? function() {
                                this._props = [];
                            } : config,
                            //in case someone passes in an object that's not a plugin, like CustomEase
                            instanceDefaults = {
                                init: _emptyFunc,
                                render: _renderPropTweens,
                                add: _addPropTween,
                                kill: _killPropTweensOf,
                                modifier: _addPluginModifier,
                                rawVars: 0
                            },
                            statics = {
                                targetTest: 0,
                                get: 0,
                                getSetter: _getSetter,
                                aliases: {},
                                register: 0
                            };
                        _wake();
                        if (config !== Plugin) {
                            if (_plugins[name]) {
                                return;
                            }
                            _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods
                            _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods
                            _plugins[Plugin.prop = name] = Plugin;
                            if (config.targetTest) {
                                _harnessPlugins.push(Plugin);
                                _reservedProps[name] = 1;
                            }
                            name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
                        }
                        _addGlobal(name, Plugin);
                        config.register && config.register(gsap, Plugin, PropTween);
                    },
                    /*
                     * --------------------------------------------------------------------------------------
                     * COLORS
                     * --------------------------------------------------------------------------------------
                     */
                    _255 = 255,
                    _colorLookup = {
                        aqua: [0, _255, _255],
                        lime: [0, _255, 0],
                        silver: [192, 192, 192],
                        black: [0, 0, 0],
                        maroon: [128, 0, 0],
                        teal: [0, 128, 128],
                        blue: [0, 0, _255],
                        navy: [0, 0, 128],
                        white: [_255, _255, _255],
                        olive: [128, 128, 0],
                        yellow: [_255, _255, 0],
                        orange: [_255, 165, 0],
                        gray: [128, 128, 128],
                        purple: [128, 0, 128],
                        green: [0, 128, 0],
                        red: [_255, 0, 0],
                        pink: [_255, 192, 203],
                        cyan: [0, _255, _255],
                        transparent: [_255, _255, _255, 0]
                    },
                    // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:
                    // let ctx = _doc.createElement("canvas").getContext("2d");
                    // _forEachName("aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});
                    _hue = function _hue(h, m1, m2) {
                        h += h < 0 ? 1 : h > 1 ? -1 : 0;
                        return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
                    },
                    splitColor = function splitColor(v, toHSL, forceAlpha) {
                        var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
                            r, g, b, h, s, l, max, min, d, wasHSL;
                        if (!a) {
                            if (v.substr(-1) === ",") {
                                //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
                                v = v.substr(0, v.length - 1);
                            }
                            if (_colorLookup[v]) {
                                a = _colorLookup[v];
                            } else if (v.charAt(0) === "#") {
                                if (v.length < 6) {
                                    //for shorthand like #9F0 or #9F0F (could have alpha)
                                    r = v.charAt(1);
                                    g = v.charAt(2);
                                    b = v.charAt(3);
                                    v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
                                }
                                if (v.length === 9) {
                                    // hex with alpha, like #fd5e53ff
                                    a = parseInt(v.substr(1, 6), 16);
                                    return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
                                }
                                v = parseInt(v.substr(1), 16);
                                a = [v >> 16, v >> 8 & _255, v & _255];
                            } else if (v.substr(0, 3) === "hsl") {
                                a = wasHSL = v.match(_strictNumExp);
                                if (!toHSL) {
                                    h = +a[0] % 360 / 360;
                                    s = +a[1] / 100;
                                    l = +a[2] / 100;
                                    g = l <= .5 ? l * (s + 1) : l + s - l * s;
                                    r = l * 2 - g;
                                    a.length > 3 && (a[3] *= 1); //cast as number
                                    a[0] = _hue(h + 1 / 3, r, g);
                                    a[1] = _hue(h, r, g);
                                    a[2] = _hue(h - 1 / 3, r, g);
                                } else if (~v.indexOf("=")) {
                                    //if relative values are found, just return the raw strings with the relative prefixes in place.
                                    a = v.match(_numExp);
                                    forceAlpha && a.length < 4 && (a[3] = 1);
                                    return a;
                                }
                            } else {
                                a = v.match(_strictNumExp) || _colorLookup.transparent;
                            }
                            a = a.map(Number);
                        }
                        if (toHSL && !wasHSL) {
                            r = a[0] / _255;
                            g = a[1] / _255;
                            b = a[2] / _255;
                            max = Math.max(r, g, b);
                            min = Math.min(r, g, b);
                            l = (max + min) / 2;
                            if (max === min) {
                                h = s = 0;
                            } else {
                                d = max - min;
                                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                                h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
                                h *= 60;
                            }
                            a[0] = ~~(h + .5);
                            a[1] = ~~(s * 100 + .5);
                            a[2] = ~~(l * 100 + .5);
                        }
                        forceAlpha && a.length < 4 && (a[3] = 1);
                        return a;
                    },
                    _colorOrderData = function _colorOrderData(v) {
                        // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
                        var values = [],
                            c = [],
                            i = -1;
                        v.split(_colorExp).forEach(function(v) {
                            var a = v.match(_numWithUnitExp) || [];
                            values.push.apply(values, a);
                            c.push(i += a.length + 1);
                        });
                        values.c = c;
                        return values;
                    },
                    _formatColors = function _formatColors(s, toHSL, orderMatchData) {
                        var result = "",
                            colors = (s + result).match(_colorExp),
                            type = toHSL ? "hsla(" : "rgba(",
                            i = 0,
                            c, shell, d, l;
                        if (!colors) {
                            return s;
                        }
                        colors = colors.map(function(color) {
                            return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
                        });
                        if (orderMatchData) {
                            d = _colorOrderData(s);
                            c = orderMatchData.c;
                            if (c.join(result) !== d.c.join(result)) {
                                shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
                                l = shell.length - 1;
                                for (; i < l; i++) {
                                    result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
                                }
                            }
                        }
                        if (!shell) {
                            shell = s.split(_colorExp);
                            l = shell.length - 1;
                            for (; i < l; i++) {
                                result += shell[i] + colors[i];
                            }
                        }
                        return result + shell[l];
                    },
                    _colorExp = function() {
                        var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
                            //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
                            p;
                        for (p in _colorLookup) {
                            s += "|" + p + "\\b";
                        }
                        return new RegExp(s + ")", "gi");
                    }(),
                    _hslExp = /hsl[a]?\(/,
                    _colorStringFilter = function _colorStringFilter(a) {
                        var combined = a.join(" "),
                            toHSL;
                        _colorExp.lastIndex = 0;
                        if (_colorExp.test(combined)) {
                            toHSL = _hslExp.test(combined);
                            a[1] = _formatColors(a[1], toHSL);
                            a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.
                            return true;
                        }
                    },
                    /*
                     * --------------------------------------------------------------------------------------
                     * TICKER
                     * --------------------------------------------------------------------------------------
                     */
                    _tickerActive, _ticker = function() {
                        var _getTime = Date.now,
                            _lagThreshold = 500,
                            _adjustedLag = 33,
                            _startTime = _getTime(),
                            _lastUpdate = _startTime,
                            _gap = 1000 / 240,
                            _nextTime = _gap,
                            _listeners = [],
                            _id, _req, _raf, _self, _delta, _i, _tick = function _tick(v) {
                                var elapsed = _getTime() - _lastUpdate,
                                    manual = v === true,
                                    overlap, dispatch, time, frame;
                                elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
                                _lastUpdate += elapsed;
                                time = _lastUpdate - _startTime;
                                overlap = time - _nextTime;
                                if (overlap > 0 || manual) {
                                    frame = ++_self.frame;
                                    _delta = time - _self.time * 1000;
                                    _self.time = time = time / 1000;
                                    _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
                                    dispatch = 1;
                                }
                                manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
                                if (dispatch) {
                                    for (_i = 0; _i < _listeners.length; _i++) {
                                        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
                                        _listeners[_i](time, _delta, frame, v);
                                    }
                                }
                            };
                        _self = {
                            time: 0,
                            frame: 0,
                            tick: function tick() {
                                _tick(true);
                            },
                            deltaRatio: function deltaRatio(fps) {
                                return _delta / (1000 / (fps || 60));
                            },
                            wake: function wake() {
                                if (_coreReady) {
                                    if (!_coreInitted && _windowExists()) {
                                        _win = _coreInitted = window;
                                        _doc = _win.document || {};
                                        _globals.gsap = gsap;
                                        (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
                                        _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
                                        _raf = _win.requestAnimationFrame;
                                    }
                                    _id && _self.sleep();
                                    _req = _raf || function(f) {
                                        return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
                                    };
                                    _tickerActive = 1;
                                    _tick(2);
                                }
                            },
                            sleep: function sleep() {
                                (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
                                _tickerActive = 0;
                                _req = _emptyFunc;
                            },
                            lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
                                _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited
                                _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
                            },
                            fps: function fps(_fps) {
                                _gap = 1000 / (_fps || 240);
                                _nextTime = _self.time * 1000 + _gap;
                            },
                            add: function add(callback, once, prioritize) {
                                var func = once ? function(t, d, f, v) {
                                    callback(t, d, f, v);
                                    _self.remove(func);
                                } : callback;
                                _self.remove(callback);
                                _listeners[prioritize ? "unshift" : "push"](func);
                                _wake();
                                return func;
                            },
                            remove: function remove(callback, i) {
                                ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
                            },
                            _listeners: _listeners
                        };
                        return _self;
                    }(),
                    _wake = function _wake() {
                        return !_tickerActive && _ticker.wake();
                    },
                    //also ensures the core classes are initialized.
                    /*
                     * -------------------------------------------------
                     * EASING
                     * -------------------------------------------------
                     */
                    _easeMap = {},
                    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
                    _quotesExp = /["']/g,
                    _parseObjectInString = function _parseObjectInString(value) {
                        //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
                        var obj = {},
                            split = value.substr(1, value.length - 3).split(":"),
                            key = split[0],
                            i = 1,
                            l = split.length,
                            index, val, parsedVal;
                        for (; i < l; i++) {
                            val = split[i];
                            index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
                            parsedVal = val.substr(0, index);
                            obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
                            key = val.substr(index + 1).trim();
                        }
                        return obj;
                    },
                    _valueInParentheses = function _valueInParentheses(value) {
                        var open = value.indexOf("(") + 1,
                            close = value.indexOf(")"),
                            nested = value.indexOf("(", open);
                        return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
                    },
                    _configEaseFromString = function _configEaseFromString(name) {
                        //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
                        var split = (name + "").split("("),
                            ease = _easeMap[split[0]];
                        return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
                    },
                    _invertEase = function _invertEase(ease) {
                        return function(p) {
                            return 1 - ease(1 - p);
                        };
                    },
                    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
                    _propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
                        var child = timeline._first,
                            ease;
                        while (child) {
                            if (child instanceof Timeline) {
                                _propagateYoyoEase(child, isYoyo);
                            } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
                                if (child.timeline) {
                                    _propagateYoyoEase(child.timeline, isYoyo);
                                } else {
                                    ease = child._ease;
                                    child._ease = child._yEase;
                                    child._yEase = ease;
                                    child._yoyo = isYoyo;
                                }
                            }
                            child = child._next;
                        }
                    },
                    _parseEase = function _parseEase(ease, defaultEase) {
                        return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
                    },
                    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
                        if (easeOut === void 0) {
                            easeOut = function easeOut(p) {
                                return 1 - easeIn(1 - p);
                            };
                        }
                        if (easeInOut === void 0) {
                            easeInOut = function easeInOut(p) {
                                return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
                            };
                        }
                        var ease = {
                                easeIn: easeIn,
                                easeOut: easeOut,
                                easeInOut: easeInOut
                            },
                            lowercaseName;
                        _forEachName(names, function(name) {
                            _easeMap[name] = _globals[name] = ease;
                            _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
                            for (var p in ease) {
                                _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
                            }
                        });
                        return ease;
                    },
                    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
                        return function(p) {
                            return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
                        };
                    },
                    _configElastic = function _configElastic(type, amplitude, period) {
                        var p1 = amplitude >= 1 ? amplitude : 1,
                            //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
                            p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
                            p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
                            easeOut = function easeOut(p) {
                                return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
                            },
                            ease = type === "out" ? easeOut : type === "in" ? function(p) {
                                return 1 - easeOut(1 - p);
                            } : _easeInOutFromOut(easeOut);
                        p2 = _2PI / p2; //precalculate to optimize
                        ease.config = function(amplitude, period) {
                            return _configElastic(type, amplitude, period);
                        };
                        return ease;
                    },
                    _configBack = function _configBack(type, overshoot) {
                        if (overshoot === void 0) {
                            overshoot = 1.70158;
                        }
                        var easeOut = function easeOut(p) {
                                return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
                            },
                            ease = type === "out" ? easeOut : type === "in" ? function(p) {
                                return 1 - easeOut(1 - p);
                            } : _easeInOutFromOut(easeOut);
                        ease.config = function(overshoot) {
                            return _configBack(type, overshoot);
                        };
                        return ease;
                    }; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
                // _weightedEase = ratio => {
                // 	let y = 0.5 + ratio / 2;
                // 	return p => (2 * (1 - p) * p * y + p * p);
                // },
                // a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
                // _weightedEaseStrong = ratio => {
                // 	ratio = .5 + ratio / 2;
                // 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
                // 		b = ratio - o,
                // 		c = ratio + o;
                // 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
                // };
                _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i) {
                    var power = i < 5 ? i + 1 : i;
                    _insertEase(name + ",Power" + (power - 1), i ? function(p) {
                        return Math.pow(p, power);
                    } : function(p) {
                        return p;
                    }, function(p) {
                        return 1 - Math.pow(1 - p, power);
                    }, function(p) {
                        return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
                    });
                });
                _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
                _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
                (function(n, c) {
                    var n1 = 1 / c,
                        n2 = 2 * n1,
                        n3 = 2.5 * n1,
                        easeOut = function easeOut(p) {
                            return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
                        };
                    _insertEase("Bounce", function(p) {
                        return 1 - easeOut(1 - p);
                    }, easeOut);
                })(7.5625, 2.75);
                _insertEase("Expo", function(p) {
                    return p ? Math.pow(2, 10 * (p - 1)) : 0;
                });
                _insertEase("Circ", function(p) {
                    return -(_sqrt(1 - p * p) - 1);
                });
                _insertEase("Sine", function(p) {
                    return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
                });
                _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
                _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
                    config: function config(steps, immediateStart) {
                        if (steps === void 0) {
                            steps = 1;
                        }
                        var p1 = 1 / steps,
                            p2 = steps + (immediateStart ? 0 : 1),
                            p3 = immediateStart ? 1 : 0,
                            max = 1 - _tinyNum;
                        return function(p) {
                            return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
                        };
                    }
                };
                _defaults.ease = _easeMap["quad.out"];
                _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
                    return _callbackNames += name + "," + name + "Params,";
                });
                /*
                 * --------------------------------------------------------------------------------------
                 * CACHE
                 * --------------------------------------------------------------------------------------
                 */
                var GSCache = function GSCache(target, harness) {
                    this.id = _gsID++;
                    target._gsap = this;
                    this.target = target;
                    this.harness = harness;
                    this.get = harness ? harness.get : _getProperty;
                    this.set = harness ? harness.getSetter : _getSetter;
                };
                /*
                 * --------------------------------------------------------------------------------------
                 * ANIMATION
                 * --------------------------------------------------------------------------------------
                 */
                var Animation = /*#__PURE__*/ function() {
                    function Animation(vars) {
                        this.vars = vars;
                        this._delay = +vars.delay || 0;
                        if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
                            // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
                            this._rDelay = vars.repeatDelay || 0;
                            this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
                        }
                        this._ts = 1;
                        _setDuration(this, +vars.duration, 1, 1);
                        this.data = vars.data;
                        _tickerActive || _ticker.wake();
                    }
                    var _proto = Animation.prototype;
                    _proto.delay = function delay(value) {
                        if (value || value === 0) {
                            this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
                            this._delay = value;
                            return this;
                        }
                        return this._delay;
                    };
                    _proto.duration = function duration(value) {
                        return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
                    };
                    _proto.totalDuration = function totalDuration(value) {
                        if (!arguments.length) {
                            return this._tDur;
                        }
                        this._dirty = 0;
                        return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
                    };
                    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
                        _wake();
                        if (!arguments.length) {
                            return this._tTime;
                        }
                        var parent = this._dp;
                        if (parent && parent.smoothChildTiming && this._ts) {
                            _alignPlayhead(this, _totalTime);
                            !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
                            //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.
                            while (parent && parent.parent) {
                                if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
                                    parent.totalTime(parent._tTime, true);
                                }
                                parent = parent.parent;
                            }
                            if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
                                //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
                                _addToTimeline(this._dp, this, this._start - this._delay);
                            }
                        }
                        if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
                            // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
                            this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
                            //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
                            //   this._lock = 1;
                            _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
                            //}
                        }
                        return this;
                    };
                    _proto.time = function time(value, suppressEvents) {
                        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
                    };
                    _proto.totalProgress = function totalProgress(value, suppressEvents) {
                        return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
                    };
                    _proto.progress = function progress(value, suppressEvents) {
                        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
                    };
                    _proto.iteration = function iteration(value, suppressEvents) {
                        var cycleDuration = this.duration() + this._rDelay;
                        return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
                    } // potential future addition:
                    ;
                    _proto.timeScale = function timeScale(value) {
                        if (!arguments.length) {
                            return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
                        }
                        if (this._rts === value) {
                            return this;
                        }
                        var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
                        // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
                        //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);
                        // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.
                        this._rts = +value || 0;
                        this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.
                        this.totalTime(_clamp(-this._delay, this._tDur, tTime), true);
                        _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.
                        return _recacheAncestors(this);
                    };
                    _proto.paused = function paused(value) {
                        if (!arguments.length) {
                            return this._ps;
                        }
                        if (this._ps !== value) {
                            this._ps = value;
                            if (value) {
                                this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.
                                this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
                            } else {
                                _wake();
                                this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.
                                this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
                            }
                        }
                        return this;
                    };
                    _proto.startTime = function startTime(value) {
                        if (arguments.length) {
                            this._start = value;
                            var parent = this.parent || this._dp;
                            parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
                            return this;
                        }
                        return this._start;
                    };
                    _proto.endTime = function endTime(includeRepeats) {
                        return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
                    };
                    _proto.rawTime = function rawTime(wrapRepeats) {
                        var parent = this.parent || this._dp; // _dp = detached parent
                        return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
                    };
                    _proto.globalTime = function globalTime(rawTime) {
                        var animation = this,
                            time = arguments.length ? rawTime : animation.rawTime();
                        while (animation) {
                            time = animation._start + time / (animation._ts || 1);
                            animation = animation._dp;
                        }
                        return time;
                    };
                    _proto.repeat = function repeat(value) {
                        if (arguments.length) {
                            this._repeat = value === Infinity ? -2 : value;
                            return _onUpdateTotalDuration(this);
                        }
                        return this._repeat === -2 ? Infinity : this._repeat;
                    };
                    _proto.repeatDelay = function repeatDelay(value) {
                        if (arguments.length) {
                            var time = this._time;
                            this._rDelay = value;
                            _onUpdateTotalDuration(this);
                            return time ? this.time(time) : this;
                        }
                        return this._rDelay;
                    };
                    _proto.yoyo = function yoyo(value) {
                        if (arguments.length) {
                            this._yoyo = value;
                            return this;
                        }
                        return this._yoyo;
                    };
                    _proto.seek = function seek(position, suppressEvents) {
                        return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
                    };
                    _proto.restart = function restart(includeDelay, suppressEvents) {
                        return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
                    };
                    _proto.play = function play(from, suppressEvents) {
                        from != null && this.seek(from, suppressEvents);
                        return this.reversed(false).paused(false);
                    };
                    _proto.reverse = function reverse(from, suppressEvents) {
                        from != null && this.seek(from || this.totalDuration(), suppressEvents);
                        return this.reversed(true).paused(false);
                    };
                    _proto.pause = function pause(atTime, suppressEvents) {
                        atTime != null && this.seek(atTime, suppressEvents);
                        return this.paused(true);
                    };
                    _proto.resume = function resume() {
                        return this.paused(false);
                    };
                    _proto.reversed = function reversed(value) {
                        if (arguments.length) {
                            !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.
                            return this;
                        }
                        return this._rts < 0;
                    };
                    _proto.invalidate = function invalidate() {
                        this._initted = this._act = 0;
                        this._zTime = -_tinyNum;
                        return this;
                    };
                    _proto.isActive = function isActive() {
                        var parent = this.parent || this._dp,
                            start = this._start,
                            rawTime;
                        return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
                    };
                    _proto.eventCallback = function eventCallback(type, callback, params) {
                        var vars = this.vars;
                        if (arguments.length > 1) {
                            if (!callback) {
                                delete vars[type];
                            } else {
                                vars[type] = callback;
                                params && (vars[type + "Params"] = params);
                                type === "onUpdate" && (this._onUpdate = callback);
                            }
                            return this;
                        }
                        return vars[type];
                    };
                    _proto.then = function then(onFulfilled) {
                        var self = this;
                        return new Promise(function(resolve) {
                            var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
                                _resolve = function _resolve() {
                                    var _then = self.then;
                                    self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)
                                    _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
                                    resolve(f);
                                    self.then = _then;
                                };
                            if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
                                _resolve();
                            } else {
                                self._prom = _resolve;
                            }
                        });
                    };
                    _proto.kill = function kill() {
                        _interrupt(this);
                    };
                    return Animation;
                }();
                _setDefaults(Animation.prototype, {
                    _time: 0,
                    _start: 0,
                    _end: 0,
                    _tTime: 0,
                    _tDur: 0,
                    _dirty: 0,
                    _repeat: 0,
                    _yoyo: false,
                    parent: null,
                    _initted: false,
                    _rDelay: 0,
                    _ts: 1,
                    _dp: 0,
                    ratio: 0,
                    _zTime: -_tinyNum,
                    _prom: 0,
                    _ps: false,
                    _rts: 1
                });
                /*
                 * -------------------------------------------------
                 * TIMELINE
                 * -------------------------------------------------
                 */
                var Timeline = /*#__PURE__*/ function(_Animation) {
                    _inheritsLoose(Timeline, _Animation);

                    function Timeline(vars, position) {
                        var _this;
                        if (vars === void 0) {
                            vars = {};
                        }
                        _this = _Animation.call(this, vars) || this;
                        _this.labels = {};
                        _this.smoothChildTiming = !!vars.smoothChildTiming;
                        _this.autoRemoveChildren = !!vars.autoRemoveChildren;
                        _this._sort = _isNotFalse(vars.sortChildren);
                        _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
                        vars.reversed && _this.reverse();
                        vars.paused && _this.paused(true);
                        vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
                        return _this;
                    }
                    var _proto2 = Timeline.prototype;
                    _proto2.to = function to(targets, vars, position) {
                        _createTweenType(0, arguments, this);
                        return this;
                    };
                    _proto2.from = function from(targets, vars, position) {
                        _createTweenType(1, arguments, this);
                        return this;
                    };
                    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
                        _createTweenType(2, arguments, this);
                        return this;
                    };
                    _proto2.set = function set(targets, vars, position) {
                        vars.duration = 0;
                        vars.parent = this;
                        _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
                        vars.immediateRender = !!vars.immediateRender;
                        new Tween(targets, vars, _parsePosition(this, position), 1);
                        return this;
                    };
                    _proto2.call = function call(callback, params, position) {
                        return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
                    } //ONLY for backward compatibility! Maybe delete?
                    ;
                    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
                        vars.duration = duration;
                        vars.stagger = vars.stagger || stagger;
                        vars.onComplete = onCompleteAll;
                        vars.onCompleteParams = onCompleteAllParams;
                        vars.parent = this;
                        new Tween(targets, vars, _parsePosition(this, position));
                        return this;
                    };
                    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
                        vars.runBackwards = 1;
                        _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
                        return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
                    };
                    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
                        toVars.startAt = fromVars;
                        _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
                        return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
                    };
                    _proto2.render = function render(totalTime, suppressEvents, force) {
                        var prevTime = this._time,
                            tDur = this._dirty ? this.totalDuration() : this._tDur,
                            dur = this._dur,
                            tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
                            // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.
                            crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
                            time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
                        this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
                        if (tTime !== this._tTime || force || crossingStart) {
                            if (prevTime !== this._time && dur) {
                                //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
                                tTime += this._time - prevTime;
                                totalTime += this._time - prevTime;
                            }
                            time = tTime;
                            prevStart = this._start;
                            timeScale = this._ts;
                            prevPaused = !timeScale;
                            if (crossingStart) {
                                dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.
                                (totalTime || !suppressEvents) && (this._zTime = totalTime);
                            }
                            if (this._repeat) {
                                //adjust the time for repeats and yoyos
                                yoyo = this._yoyo;
                                cycleDuration = dur + this._rDelay;
                                if (this._repeat < -1 && totalTime < 0) {
                                    return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
                                }
                                time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)
                                if (tTime === tDur) {
                                    // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
                                    iteration = this._repeat;
                                    time = dur;
                                } else {
                                    iteration = ~~(tTime / cycleDuration);
                                    if (iteration && iteration === tTime / cycleDuration) {
                                        time = dur;
                                        iteration--;
                                    }
                                    time > dur && (time = dur);
                                }
                                prevIteration = _animationCycle(this._tTime, cycleDuration);
                                !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005
                                if (yoyo && iteration & 1) {
                                    time = dur - time;
                                    isYoyo = 1;
                                }
                                /*
                                make sure children at the end/beginning of the timeline are rendered properly. If, for example,
                                a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
                                would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
                                could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
                                we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
                                ensure that zero-duration tweens at the very beginning or end of the Timeline work.
                                */
                                if (iteration !== prevIteration && !this._lock) {
                                    var rewinding = yoyo && prevIteration & 1,
                                        doesWrap = rewinding === (yoyo && iteration & 1);
                                    iteration < prevIteration && (rewinding = !rewinding);
                                    prevTime = rewinding ? 0 : dur;
                                    this._lock = 1;
                                    this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
                                    this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.
                                    !suppressEvents && this.parent && _callback(this, "onRepeat");
                                    this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
                                    if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
                                        // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
                                        return this;
                                    }
                                    dur = this._dur; // in case the duration changed in the onRepeat
                                    tDur = this._tDur;
                                    if (doesWrap) {
                                        this._lock = 2;
                                        prevTime = rewinding ? dur : -0.0001;
                                        this.render(prevTime, true);
                                        this.vars.repeatRefresh && !isYoyo && this.invalidate();
                                    }
                                    this._lock = 0;
                                    if (!this._ts && !prevPaused) {
                                        return this;
                                    } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.
                                    _propagateYoyoEase(this, isYoyo);
                                }
                            }
                            if (this._hasPause && !this._forcing && this._lock < 2) {
                                pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
                                if (pauseTween) {
                                    tTime -= time - (time = pauseTween._start);
                                }
                            }
                            this._tTime = tTime;
                            this._time = time;
                            this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.
                            if (!this._initted) {
                                this._onUpdate = this.vars.onUpdate;
                                this._initted = 1;
                                this._zTime = totalTime;
                                prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
                            }
                            if (!prevTime && time && !suppressEvents) {
                                _callback(this, "onStart");
                                if (this._tTime !== tTime) {
                                    // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
                                    return this;
                                }
                            }
                            if (time >= prevTime && totalTime >= 0) {
                                child = this._first;
                                while (child) {
                                    next = child._next;
                                    if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
                                        if (child.parent !== this) {
                                            // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
                                            return this.render(totalTime, suppressEvents, force);
                                        }
                                        child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
                                        if (time !== this._time || !this._ts && !prevPaused) {
                                            //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
                                            pauseTween = 0;
                                            next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)
                                            break;
                                        }
                                    }
                                    child = next;
                                }
                            } else {
                                child = this._last;
                                var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.
                                while (child) {
                                    next = child._prev;
                                    if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
                                        if (child.parent !== this) {
                                            // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
                                            return this.render(totalTime, suppressEvents, force);
                                        }
                                        child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);
                                        if (time !== this._time || !this._ts && !prevPaused) {
                                            //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
                                            pauseTween = 0;
                                            next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)
                                            break;
                                        }
                                    }
                                    child = next;
                                }
                            }
                            if (pauseTween && !suppressEvents) {
                                this.pause();
                                pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
                                if (this._ts) {
                                    //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
                                    this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.
                                    _setEnd(this);
                                    return this.render(totalTime, suppressEvents, force);
                                }
                            }
                            this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
                            if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime)
                                if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts))
                                    if (!this._lock) {
                                        // remember, a child's callback may alter this timeline's playhead or timeScale which is why we need to add some of these checks.
                                        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.
                                        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                                            _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                                            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
                                        }
                                    }
                        }
                        return this;
                    };
                    _proto2.add = function add(child, position) {
                        var _this2 = this;
                        _isNumber(position) || (position = _parsePosition(this, position, child));
                        if (!(child instanceof Animation)) {
                            if (_isArray(child)) {
                                child.forEach(function(obj) {
                                    return _this2.add(obj, position);
                                });
                                return this;
                            }
                            if (_isString(child)) {
                                return this.addLabel(child, position);
                            }
                            if (_isFunction(child)) {
                                child = Tween.delayedCall(0, child);
                            } else {
                                return this;
                            }
                        }
                        return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
                    };
                    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
                        if (nested === void 0) {
                            nested = true;
                        }
                        if (tweens === void 0) {
                            tweens = true;
                        }
                        if (timelines === void 0) {
                            timelines = true;
                        }
                        if (ignoreBeforeTime === void 0) {
                            ignoreBeforeTime = -_bigNum;
                        }
                        var a = [],
                            child = this._first;
                        while (child) {
                            if (child._start >= ignoreBeforeTime) {
                                if (child instanceof Tween) {
                                    tweens && a.push(child);
                                } else {
                                    timelines && a.push(child);
                                    nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
                                }
                            }
                            child = child._next;
                        }
                        return a;
                    };
                    _proto2.getById = function getById(id) {
                        var animations = this.getChildren(1, 1, 1),
                            i = animations.length;
                        while (i--) {
                            if (animations[i].vars.id === id) {
                                return animations[i];
                            }
                        }
                    };
                    _proto2.remove = function remove(child) {
                        if (_isString(child)) {
                            return this.removeLabel(child);
                        }
                        if (_isFunction(child)) {
                            return this.killTweensOf(child);
                        }
                        _removeLinkedListItem(this, child);
                        if (child === this._recent) {
                            this._recent = this._last;
                        }
                        return _uncache(this);
                    };
                    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
                        if (!arguments.length) {
                            return this._tTime;
                        }
                        this._forcing = 1;
                        if (!this._dp && this._ts) {
                            //special case for the global timeline (or any other that has no parent or detached parent).
                            this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
                        }
                        _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
                        this._forcing = 0;
                        return this;
                    };
                    _proto2.addLabel = function addLabel(label, position) {
                        this.labels[label] = _parsePosition(this, position);
                        return this;
                    };
                    _proto2.removeLabel = function removeLabel(label) {
                        delete this.labels[label];
                        return this;
                    };
                    _proto2.addPause = function addPause(position, callback, params) {
                        var t = Tween.delayedCall(0, callback || _emptyFunc, params);
                        t.data = "isPause";
                        this._hasPause = 1;
                        return _addToTimeline(this, t, _parsePosition(this, position));
                    };
                    _proto2.removePause = function removePause(position) {
                        var child = this._first;
                        position = _parsePosition(this, position);
                        while (child) {
                            if (child._start === position && child.data === "isPause") {
                                _removeFromParent(child);
                            }
                            child = child._next;
                        }
                    };
                    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
                        var tweens = this.getTweensOf(targets, onlyActive),
                            i = tweens.length;
                        while (i--) {
                            _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
                        }
                        return this;
                    };
                    _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
                        var a = [],
                            parsedTargets = toArray(targets),
                            child = this._first,
                            isGlobalTime = _isNumber(onlyActive),
                            // a number is interpreted as a global time. If the animation spans
                            children;
                        while (child) {
                            if (child instanceof Tween) {
                                if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
                                    // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
                                    a.push(child);
                                }
                            } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
                                a.push.apply(a, children);
                            }
                            child = child._next;
                        }
                        return a;
                    } // potential future feature - targets() on timelines
                    ;
                    _proto2.tweenTo = function tweenTo(position, vars) {
                        vars = vars || {};
                        var tl = this,
                            endTime = _parsePosition(tl, position),
                            _vars = vars,
                            startAt = _vars.startAt,
                            _onStart = _vars.onStart,
                            onStartParams = _vars.onStartParams,
                            immediateRender = _vars.immediateRender,
                            initted, tween = Tween.to(tl, _setDefaults({
                                ease: vars.ease || "none",
                                lazy: false,
                                immediateRender: false,
                                time: endTime,
                                overwrite: "auto",
                                duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
                                onStart: function onStart() {
                                    tl.pause();
                                    if (!initted) {
                                        var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
                                        tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
                                        initted = 1;
                                    }
                                    _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
                                }
                            }, vars));
                        return immediateRender ? tween.render(0) : tween;
                    };
                    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
                        return this.tweenTo(toPosition, _setDefaults({
                            startAt: {
                                time: _parsePosition(this, fromPosition)
                            }
                        }, vars));
                    };
                    _proto2.recent = function recent() {
                        return this._recent;
                    };
                    _proto2.nextLabel = function nextLabel(afterTime) {
                        if (afterTime === void 0) {
                            afterTime = this._time;
                        }
                        return _getLabelInDirection(this, _parsePosition(this, afterTime));
                    };
                    _proto2.previousLabel = function previousLabel(beforeTime) {
                        if (beforeTime === void 0) {
                            beforeTime = this._time;
                        }
                        return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
                    };
                    _proto2.currentLabel = function currentLabel(value) {
                        return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
                    };
                    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
                        if (ignoreBeforeTime === void 0) {
                            ignoreBeforeTime = 0;
                        }
                        var child = this._first,
                            labels = this.labels,
                            p;
                        while (child) {
                            if (child._start >= ignoreBeforeTime) {
                                child._start += amount;
                                child._end += amount;
                            }
                            child = child._next;
                        }
                        if (adjustLabels) {
                            for (p in labels) {
                                if (labels[p] >= ignoreBeforeTime) {
                                    labels[p] += amount;
                                }
                            }
                        }
                        return _uncache(this);
                    };
                    _proto2.invalidate = function invalidate() {
                        var child = this._first;
                        this._lock = 0;
                        while (child) {
                            child.invalidate();
                            child = child._next;
                        }
                        return _Animation.prototype.invalidate.call(this);
                    };
                    _proto2.clear = function clear(includeLabels) {
                        if (includeLabels === void 0) {
                            includeLabels = true;
                        }
                        var child = this._first,
                            next;
                        while (child) {
                            next = child._next;
                            this.remove(child);
                            child = next;
                        }
                        this._dp && (this._time = this._tTime = this._pTime = 0);
                        includeLabels && (this.labels = {});
                        return _uncache(this);
                    };
                    _proto2.totalDuration = function totalDuration(value) {
                        var max = 0,
                            self = this,
                            child = self._last,
                            prevStart = _bigNum,
                            prev, start, parent;
                        if (arguments.length) {
                            return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
                        }
                        if (self._dirty) {
                            parent = self.parent;
                            while (child) {
                                prev = child._prev; //record it here in case the tween changes position in the sequence...
                                child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.
                                start = child._start;
                                if (start > prevStart && self._sort && child._ts && !self._lock) {
                                    //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
                                    self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().
                                    _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
                                } else {
                                    prevStart = start;
                                }
                                if (start < 0 && child._ts) {
                                    //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
                                    max -= start;
                                    if (!parent && !self._dp || parent && parent.smoothChildTiming) {
                                        self._start += start / self._ts;
                                        self._time -= start;
                                        self._tTime -= start;
                                    }
                                    self.shiftChildren(-start, false, -1e999);
                                    prevStart = 0;
                                }
                                child._end > max && child._ts && (max = child._end);
                                child = prev;
                            }
                            _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);
                            self._dirty = 0;
                        }
                        return self._tDur;
                    };
                    Timeline.updateRoot = function updateRoot(time) {
                        if (_globalTimeline._ts) {
                            _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
                            _lastRenderedFrame = _ticker.frame;
                        }
                        if (_ticker.frame >= _nextGCFrame) {
                            _nextGCFrame += _config.autoSleep || 120;
                            var child = _globalTimeline._first;
                            if (!child || !child._ts)
                                if (_config.autoSleep && _ticker._listeners.length < 2) {
                                    while (child && !child._ts) {
                                        child = child._next;
                                    }
                                    child || _ticker.sleep();
                                }
                        }
                    };
                    return Timeline;
                }(Animation);
                _setDefaults(Timeline.prototype, {
                    _lock: 0,
                    _hasPause: 0,
                    _forcing: 0
                });
                var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
                        //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
                        var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
                            index = 0,
                            matchIndex = 0,
                            result, startNums, color, endNum, chunk, startNum, hasRandom, a;
                        pt.b = start;
                        pt.e = end;
                        start += ""; //ensure values are strings
                        end += "";
                        if (hasRandom = ~end.indexOf("random(")) {
                            end = _replaceRandom(end);
                        }
                        if (stringFilter) {
                            a = [start, end];
                            stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.
                            start = a[0];
                            end = a[1];
                        }
                        startNums = start.match(_complexStringNumExp) || [];
                        while (result = _complexStringNumExp.exec(end)) {
                            endNum = result[0];
                            chunk = end.substring(index, result.index);
                            if (color) {
                                color = (color + 1) % 5;
                            } else if (chunk.substr(-5) === "rgba(") {
                                color = 1;
                            }
                            if (endNum !== startNums[matchIndex++]) {
                                startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.
                                pt._pt = {
                                    _next: pt._pt,
                                    p: chunk || matchIndex === 1 ? chunk : ",",
                                    //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
                                    s: startNum,
                                    c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
                                    m: color && color < 4 ? Math.round : 0
                                };
                                index = _complexStringNumExp.lastIndex;
                            }
                        }
                        pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
                        pt.fp = funcParam;
                        if (_relExp.test(end) || hasRandom) {
                            pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
                        }
                        this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
                        return pt;
                    },
                    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
                        _isFunction(end) && (end = end(index || 0, target, targets));
                        var currentValue = target[prop],
                            parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
                            setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
                            pt;
                        if (_isString(end)) {
                            if (~end.indexOf("random(")) {
                                end = _replaceRandom(end);
                            }
                            if (end.charAt(1) === "=") {
                                pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
                                if (pt || pt === 0) {
                                    // to avoid isNaN, like if someone passes in a value like "!= whatever"
                                    end = pt;
                                }
                            }
                        }
                        if (parsedStart !== end || _forceAllPropTweens) {
                            if (!isNaN(parsedStart * end) && end !== "") {
                                // fun fact: any number multiplied by "" is evaluated as the number 0!
                                pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
                                funcParam && (pt.fp = funcParam);
                                modifier && pt.modifier(modifier, this, target);
                                return this._pt = pt;
                            }!currentValue && !(prop in target) && _missingPlugin(prop, end);
                            return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
                        }
                    },
                    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
                    _processVars = function _processVars(vars, index, target, targets, tween) {
                        _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
                        if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
                            return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
                        }
                        var copy = {},
                            p;
                        for (p in vars) {
                            copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
                        }
                        return copy;
                    },
                    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
                        var plugin, pt, ptLookup, i;
                        if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
                            tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
                            if (tween !== _quickTween) {
                                ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.
                                i = plugin._props.length;
                                while (i--) {
                                    ptLookup[plugin._props[i]] = pt;
                                }
                            }
                        }
                        return plugin;
                    },
                    _overwritingTween,
                    //store a reference temporarily so we can avoid overwriting itself.
                    _forceAllPropTweens, _initTween = function _initTween(tween, time) {
                        var vars = tween.vars,
                            ease = vars.ease,
                            startAt = vars.startAt,
                            immediateRender = vars.immediateRender,
                            lazy = vars.lazy,
                            onUpdate = vars.onUpdate,
                            onUpdateParams = vars.onUpdateParams,
                            callbackScope = vars.callbackScope,
                            runBackwards = vars.runBackwards,
                            yoyoEase = vars.yoyoEase,
                            keyframes = vars.keyframes,
                            autoRevert = vars.autoRevert,
                            dur = tween._dur,
                            prevStartAt = tween._startAt,
                            targets = tween._targets,
                            parent = tween.parent,
                            fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,
                            autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
                            tl = tween.timeline,
                            cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;
                        tl && (!keyframes || !ease) && (ease = "none");
                        tween._ease = _parseEase(ease, _defaults.ease);
                        tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
                        if (yoyoEase && tween._yoyo && !tween._repeat) {
                            //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
                            yoyoEase = tween._yEase;
                            tween._yEase = tween._ease;
                            tween._ease = yoyoEase;
                        }
                        tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.
                        if (!tl || keyframes && !vars.stagger) {
                            //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
                            harness = targets[0] ? _getCache(targets[0]).harness : 0;
                            harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.
                            cleanVars = _copyExcluding(vars, _reservedProps);
                            if (prevStartAt) {
                                _removeFromParent(prevStartAt.render(-1, true));
                                prevStartAt._lazy = 0;
                            }
                            if (startAt) {
                                _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
                                    data: "isStart",
                                    overwrite: false,
                                    parent: parent,
                                    immediateRender: true,
                                    lazy: _isNotFalse(lazy),
                                    startAt: null,
                                    delay: 0,
                                    onUpdate: onUpdate,
                                    onUpdateParams: onUpdateParams,
                                    callbackScope: callbackScope,
                                    stagger: 0
                                }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);
                                time < 0 && !immediateRender && !autoRevert && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.
                                if (immediateRender) {
                                    time > 0 && !autoRevert && (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
                                    if (dur && time <= 0) {
                                        time && (tween._zTime = time);
                                        return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
                                    } // if (time > 0) {
                                    // 	autoRevert || (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
                                    // } else if (dur && !(time < 0 && prevStartAt)) {
                                    // 	time && (tween._zTime = time);
                                    // 	return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
                                    // }
                                } else if (autoRevert === false) {
                                    tween._startAt = 0;
                                }
                            } else if (runBackwards && dur) {
                                //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
                                if (prevStartAt) {
                                    !autoRevert && (tween._startAt = 0);
                                } else {
                                    time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
                                    p = _setDefaults({
                                        overwrite: false,
                                        data: "isFromStart",
                                        //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
                                        lazy: immediateRender && _isNotFalse(lazy),
                                        immediateRender: immediateRender,
                                        //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
                                        stagger: 0,
                                        parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})
                                    }, cleanVars);
                                    harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})
                                    _removeFromParent(tween._startAt = Tween.set(targets, p));
                                    time < 0 && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted from() tween.
                                    tween._zTime = time;
                                    if (!immediateRender) {
                                        _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded
                                    } else if (!time) {
                                        return;
                                    }
                                }
                            }
                            tween._pt = tween._ptCache = 0;
                            lazy = dur && _isNotFalse(lazy) || lazy && !dur;
                            for (i = 0; i < targets.length; i++) {
                                target = targets[i];
                                gsData = target._gsap || _harness(targets)[i]._gsap;
                                tween._ptLookup[i] = ptLookup = {};
                                _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
                                index = fullTargets === targets ? i : fullTargets.indexOf(target);
                                if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
                                    tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
                                    plugin._props.forEach(function(name) {
                                        ptLookup[name] = pt;
                                    });
                                    plugin.priority && (hasPriority = 1);
                                }
                                if (!harness || harnessVars) {
                                    for (p in cleanVars) {
                                        if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
                                            plugin.priority && (hasPriority = 1);
                                        } else {
                                            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
                                        }
                                    }
                                }
                                tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
                                if (autoOverwrite && tween._pt) {
                                    _overwritingTween = tween;
                                    _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!
                                    overwritten = !tween.parent;
                                    _overwritingTween = 0;
                                }
                                tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
                            }
                            hasPriority && _sortPropTweensByPriority(tween);
                            tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
                        }
                        tween._onUpdate = onUpdate;
                        tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.
                        keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the "before" state for any staggered/delayed animations thus when the following tween initializes, it'll use the "before" state instead of the "after" state as the initial values.
                    },
                    _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time) {
                        var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],
                            pt, lookup, i;
                        if (!ptCache) {
                            ptCache = tween._ptCache[property] = [];
                            lookup = tween._ptLookup;
                            i = tween._targets.length;
                            while (i--) {
                                pt = lookup[i][property];
                                if (pt && pt.d && pt.d._pt) {
                                    // it's a plugin, so find the nested PropTween
                                    pt = pt.d._pt;
                                    while (pt && pt.p !== property) {
                                        pt = pt._next;
                                    }
                                }
                                if (!pt) {
                                    // there is no PropTween associated with that property, so we must FORCE one to be created and ditch out of this
                                    // if the tween has other properties that already rendered at new positions, we'd normally have to rewind to put them back like tween.render(0, true) before forcing an _initTween(), but that can create another edge case like tweening a timeline's progress would trigger onUpdates to fire which could move other things around. It's better to just inform users that .resetTo() should ONLY be used for tweens that already have that property. For example, you can't gsap.to(...{ y: 0 }) and then tween.restTo("x", 200) for example.
                                    _forceAllPropTweens = 1; // otherwise, when we _addPropTween() and it finds no change between the start and end values, it skips creating a PropTween (for efficiency...why tween when there's no difference?) but in this case we NEED that PropTween created so we can edit it.
                                    tween.vars[property] = "+=0";
                                    _initTween(tween, time);
                                    _forceAllPropTweens = 0;
                                    return 1;
                                }
                                ptCache.push(pt);
                            }
                        }
                        i = ptCache.length;
                        while (i--) {
                            pt = ptCache[i];
                            pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
                            pt.c = value - pt.s;
                            pt.e && (pt.e = _round(value) + getUnit(pt.e)); // mainly for CSSPlugin (end value)
                            pt.b && (pt.b = pt.s + getUnit(pt.b)); // (beginning value)
                        }
                    },
                    _addAliasesToVars = function _addAliasesToVars(targets, vars) {
                        var harness = targets[0] ? _getCache(targets[0]).harness : 0,
                            propertyAliases = harness && harness.aliases,
                            copy, p, i, aliases;
                        if (!propertyAliases) {
                            return vars;
                        }
                        copy = _merge({}, vars);
                        for (p in propertyAliases) {
                            if (p in copy) {
                                aliases = propertyAliases[p].split(",");
                                i = aliases.length;
                                while (i--) {
                                    copy[aliases[i]] = copy[p];
                                }
                            }
                        }
                        return copy;
                    },
                    // parses multiple formats, like {"0%": {x: 100}, {"50%": {x: -20}} and { x: {"0%": 100, "50%": -20} }, and an "ease" can be set on any object. We populate an "allProps" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a "t" (time), "v", (value), and "e" (ease) property. This allows us to piece together a timeline later.
                    _parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
                        var ease = obj.ease || easeEach || "power1.inOut",
                            p, a;
                        if (_isArray(obj)) {
                            a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease
                            obj.forEach(function(value, i) {
                                return a.push({
                                    t: i / (obj.length - 1) * 100,
                                    v: value,
                                    e: ease
                                });
                            });
                        } else {
                            for (p in obj) {
                                a = allProps[p] || (allProps[p] = []);
                                p === "ease" || a.push({
                                    t: parseFloat(prop),
                                    v: obj[p],
                                    e: ease
                                });
                            }
                        }
                    },
                    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
                        return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
                    },
                    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
                    _staggerPropsToSkip = {};
                _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
                    return _staggerPropsToSkip[name] = 1;
                });
                /*
                 * --------------------------------------------------------------------------------------
                 * TWEEN
                 * --------------------------------------------------------------------------------------
                 */
                var Tween = /*#__PURE__*/ function(_Animation2) {
                    _inheritsLoose(Tween, _Animation2);

                    function Tween(targets, vars, position, skipInherit) {
                        var _this3;
                        if (typeof vars === "number") {
                            position.duration = vars;
                            vars = position;
                            position = null;
                        }
                        _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
                        var _this3$vars = _this3.vars,
                            duration = _this3$vars.duration,
                            delay = _this3$vars.delay,
                            immediateRender = _this3$vars.immediateRender,
                            stagger = _this3$vars.stagger,
                            overwrite = _this3$vars.overwrite,
                            keyframes = _this3$vars.keyframes,
                            defaults = _this3$vars.defaults,
                            scrollTrigger = _this3$vars.scrollTrigger,
                            yoyoEase = _this3$vars.yoyoEase,
                            parent = vars.parent || _globalTimeline,
                            parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
                            tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge;
                        _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
                        _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property
                        _this3._overwrite = overwrite;
                        if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
                            vars = _this3.vars;
                            tl = _this3.timeline = new Timeline({
                                data: "nested",
                                defaults: defaults || {}
                            });
                            tl.kill();
                            tl.parent = tl._dp = _assertThisInitialized(_this3);
                            tl._start = 0;
                            if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
                                l = parsedTargets.length;
                                staggerFunc = stagger && distribute(stagger);
                                if (_isObject(stagger)) {
                                    //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
                                    for (p in stagger) {
                                        if (~_staggerTweenProps.indexOf(p)) {
                                            staggerVarsToMerge || (staggerVarsToMerge = {});
                                            staggerVarsToMerge[p] = stagger[p];
                                        }
                                    }
                                }
                                for (i = 0; i < l; i++) {
                                    copy = _copyExcluding(vars, _staggerPropsToSkip);
                                    copy.stagger = 0;
                                    yoyoEase && (copy.yoyoEase = yoyoEase);
                                    staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
                                    curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.
                                    copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
                                    copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;
                                    if (!stagger && l === 1 && copy.delay) {
                                        // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
                                        _this3._delay = delay = copy.delay;
                                        _this3._start += delay;
                                        copy.delay = 0;
                                    }
                                    tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
                                    tl._ease = _easeMap.none;
                                }
                                tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
                            } else if (keyframes) {
                                _inheritDefaults(_setDefaults(tl.vars.defaults, {
                                    ease: "none"
                                }));
                                tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
                                var time = 0,
                                    a, kf, v;
                                if (_isArray(keyframes)) {
                                    keyframes.forEach(function(frame) {
                                        return tl.to(parsedTargets, frame, ">");
                                    });
                                } else {
                                    copy = {};
                                    for (p in keyframes) {
                                        p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
                                    }
                                    for (p in copy) {
                                        a = copy[p].sort(function(a, b) {
                                            return a.t - b.t;
                                        });
                                        time = 0;
                                        for (i = 0; i < a.length; i++) {
                                            kf = a[i];
                                            v = {
                                                ease: kf.e,
                                                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
                                            };
                                            v[p] = kf.v;
                                            tl.to(parsedTargets, v, time);
                                            time += v.duration;
                                        }
                                    }
                                    tl.duration() < duration && tl.to({}, {
                                        duration: duration - tl.duration()
                                    }); // in case keyframes didn't go to 100%
                                }
                            }
                            duration || _this3.duration(duration = tl.duration());
                        } else {
                            _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
                        }
                        if (overwrite === true && !_suppressOverwrites) {
                            _overwritingTween = _assertThisInitialized(_this3);
                            _globalTimeline.killTweensOf(parsedTargets);
                            _overwritingTween = 0;
                        }
                        _addToTimeline(parent, _assertThisInitialized(_this3), position);
                        vars.reversed && _this3.reverse();
                        vars.paused && _this3.paused(true);
                        if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
                            _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
                            _this3.render(Math.max(0, -delay)); //in case delay is negative
                        }
                        scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
                        return _this3;
                    }
                    var _proto3 = Tween.prototype;
                    _proto3.render = function render(totalTime, suppressEvents, force) {
                        var prevTime = this._time,
                            tDur = this._tDur,
                            dur = this._dur,
                            tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
                            time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline, yoyoEase;
                        if (!dur) {
                            _renderZeroDurationTween(this, totalTime, suppressEvents, force);
                        } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {
                            //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
                            time = tTime;
                            timeline = this.timeline;
                            if (this._repeat) {
                                //adjust the time for repeats and yoyos
                                cycleDuration = dur + this._rDelay;
                                if (this._repeat < -1 && totalTime < 0) {
                                    return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
                                }
                                time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)
                                if (tTime === tDur) {
                                    // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
                                    iteration = this._repeat;
                                    time = dur;
                                } else {
                                    iteration = ~~(tTime / cycleDuration);
                                    if (iteration && iteration === tTime / cycleDuration) {
                                        time = dur;
                                        iteration--;
                                    }
                                    time > dur && (time = dur);
                                }
                                isYoyo = this._yoyo && iteration & 1;
                                if (isYoyo) {
                                    yoyoEase = this._yEase;
                                    time = dur - time;
                                }
                                prevIteration = _animationCycle(this._tTime, cycleDuration);
                                if (time === prevTime && !force && this._initted) {
                                    //could be during the repeatDelay part. No need to render and fire callbacks.
                                    this._tTime = tTime;
                                    return this;
                                }
                                if (iteration !== prevIteration) {
                                    timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality
                                    if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
                                        this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.
                                        this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
                                    }
                                }
                            }
                            if (!this._initted) {
                                if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
                                    this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.
                                    return this;
                                }
                                if (prevTime !== this._time) {
                                    // rare edge case - during initialization, an onUpdate in the _startAt (.fromTo()) might force this tween to render at a different spot in which case we should ditch this render() call so that it doesn't revert the values.
                                    return this;
                                }
                                if (dur !== this._dur) {
                                    // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
                                    return this.render(totalTime, suppressEvents, force);
                                }
                            }
                            this._tTime = tTime;
                            this._time = time;
                            if (!this._act && this._ts) {
                                this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.
                                this._lazy = 0;
                            }
                            this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
                            if (this._from) {
                                this.ratio = ratio = 1 - ratio;
                            }
                            if (time && !prevTime && !suppressEvents) {
                                _callback(this, "onStart");
                                if (this._tTime !== tTime) {
                                    // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
                                    return this;
                                }
                            }
                            pt = this._pt;
                            while (pt) {
                                pt.r(ratio, pt.d);
                                pt = pt._next;
                            }
                            timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
                            if (this._onUpdate && !suppressEvents) {
                                totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
                                _callback(this, "onUpdate");
                            }
                            this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
                            if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
                                totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
                                (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.
                                if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
                                    // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
                                    _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
                                    this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
                                }
                            }
                        }
                        return this;
                    };
                    _proto3.targets = function targets() {
                        return this._targets;
                    };
                    _proto3.invalidate = function invalidate() {
                        this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
                        this._ptLookup = [];
                        this.timeline && this.timeline.invalidate();
                        return _Animation2.prototype.invalidate.call(this);
                    };
                    _proto3.resetTo = function resetTo(property, value, start, startIsRelative) {
                        _tickerActive || _ticker.wake();
                        this._ts || this.play();
                        var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
                            ratio, p;
                        this._initted || _initTween(this, time);
                        ratio = this._ease(time / this._dur); // don't just get tween.ratio because it may not have rendered yet.
                        // possible future addition to allow an object with multiple values to update, like tween.resetTo({x: 100, y: 200}); At this point, it doesn't seem worth the added kb given the fact that most users will likely opt for the convenient gsap.quickTo() way of interacting with this method.
                        // if (_isObject(property)) { // performance optimization
                        // 	for (p in property) {
                        // 		if (_updatePropTweens(this, p, property[p], value ? value[p] : null, start, ratio, time)) {
                        // 			return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
                        // 		}
                        // 	}
                        // } else {
                        if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time)) {
                            return this.resetTo(property, value, start, startIsRelative); // if a PropTween wasn't found for the property, it'll get forced with a re-initialization so we need to jump out and start over again.
                        } //}
                        _alignPlayhead(this, 0);
                        this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
                        return this.render(0);
                    };
                    _proto3.kill = function kill(targets, vars) {
                        if (vars === void 0) {
                            vars = "all";
                        }
                        if (!targets && (!vars || vars === "all")) {
                            this._lazy = this._pt = 0;
                            return this.parent ? _interrupt(this) : this;
                        }
                        if (this.timeline) {
                            var tDur = this.timeline.totalDuration();
                            this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.
                            this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.
                            return this;
                        }
                        var parsedTargets = this._targets,
                            killingTargets = targets ? toArray(targets) : parsedTargets,
                            propTweenLookup = this._ptLookup,
                            firstPT = this._pt,
                            overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i;
                        if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
                            vars === "all" && (this._pt = 0);
                            return _interrupt(this);
                        }
                        overwrittenProps = this._op = this._op || [];
                        if (vars !== "all") {
                            //so people can pass in a comma-delimited list of property names
                            if (_isString(vars)) {
                                p = {};
                                _forEachName(vars, function(name) {
                                    return p[name] = 1;
                                });
                                vars = p;
                            }
                            vars = _addAliasesToVars(parsedTargets, vars);
                        }
                        i = parsedTargets.length;
                        while (i--) {
                            if (~killingTargets.indexOf(parsedTargets[i])) {
                                curLookup = propTweenLookup[i];
                                if (vars === "all") {
                                    overwrittenProps[i] = vars;
                                    props = curLookup;
                                    curOverwriteProps = {};
                                } else {
                                    curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
                                    props = vars;
                                }
                                for (p in props) {
                                    pt = curLookup && curLookup[p];
                                    if (pt) {
                                        if (!("kill" in pt.d) || pt.d.kill(p) === true) {
                                            _removeLinkedListItem(this, pt, "_pt");
                                        }
                                        delete curLookup[p];
                                    }
                                    if (curOverwriteProps !== "all") {
                                        curOverwriteProps[p] = 1;
                                    }
                                }
                            }
                        }
                        this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
                        return this;
                    };
                    Tween.to = function to(targets, vars) {
                        return new Tween(targets, vars, arguments[2]);
                    };
                    Tween.from = function from(targets, vars) {
                        return _createTweenType(1, arguments);
                    };
                    Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
                        return new Tween(callback, 0, {
                            immediateRender: false,
                            lazy: false,
                            overwrite: false,
                            delay: delay,
                            onComplete: callback,
                            onReverseComplete: callback,
                            onCompleteParams: params,
                            onReverseCompleteParams: params,
                            callbackScope: scope
                        });
                    };
                    Tween.fromTo = function fromTo(targets, fromVars, toVars) {
                        return _createTweenType(2, arguments);
                    };
                    Tween.set = function set(targets, vars) {
                        vars.duration = 0;
                        vars.repeatDelay || (vars.repeat = 0);
                        return new Tween(targets, vars);
                    };
                    Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
                        return _globalTimeline.killTweensOf(targets, props, onlyActive);
                    };
                    return Tween;
                }(Animation);
                _setDefaults(Tween.prototype, {
                    _targets: [],
                    _lazy: 0,
                    _startAt: 0,
                    _op: 0,
                    _onInit: 0
                }); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
                // _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
                // 	Tween.prototype[name] = function() {
                // 		let tl = new Timeline();
                // 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
                // 	}
                // });
                //for backward compatibility. Leverage the timeline calls.
                _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
                    Tween[name] = function() {
                        var tl = new Timeline(),
                            params = _slice.call(arguments, 0);
                        params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
                        return tl[name].apply(tl, params);
                    };
                });
                /*
                 * --------------------------------------------------------------------------------------
                 * PROPTWEEN
                 * --------------------------------------------------------------------------------------
                 */
                var _setterPlain = function _setterPlain(target, property, value) {
                        return target[property] = value;
                    },
                    _setterFunc = function _setterFunc(target, property, value) {
                        return target[property](value);
                    },
                    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
                        return target[property](data.fp, value);
                    },
                    _setterAttribute = function _setterAttribute(target, property, value) {
                        return target.setAttribute(property, value);
                    },
                    _getSetter = function _getSetter(target, property) {
                        return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
                    },
                    _renderPlain = function _renderPlain(ratio, data) {
                        return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
                    },
                    _renderBoolean = function _renderBoolean(ratio, data) {
                        return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
                    },
                    _renderComplexString = function _renderComplexString(ratio, data) {
                        var pt = data._pt,
                            s = "";
                        if (!ratio && data.b) {
                            //b = beginning string
                            s = data.b;
                        } else if (ratio === 1 && data.e) {
                            //e = ending string
                            s = data.e;
                        } else {
                            while (pt) {
                                s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.
                                pt = pt._next;
                            }
                            s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
                        }
                        data.set(data.t, data.p, s, data);
                    },
                    _renderPropTweens = function _renderPropTweens(ratio, data) {
                        var pt = data._pt;
                        while (pt) {
                            pt.r(ratio, pt.d);
                            pt = pt._next;
                        }
                    },
                    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
                        var pt = this._pt,
                            next;
                        while (pt) {
                            next = pt._next;
                            pt.p === property && pt.modifier(modifier, tween, target);
                            pt = next;
                        }
                    },
                    _killPropTweensOf = function _killPropTweensOf(property) {
                        var pt = this._pt,
                            hasNonDependentRemaining, next;
                        while (pt) {
                            next = pt._next;
                            if (pt.p === property && !pt.op || pt.op === property) {
                                _removeLinkedListItem(this, pt, "_pt");
                            } else if (!pt.dep) {
                                hasNonDependentRemaining = 1;
                            }
                            pt = next;
                        }
                        return !hasNonDependentRemaining;
                    },
                    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
                        data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
                    },
                    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
                        var pt = parent._pt,
                            next, pt2, first, last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)
                        while (pt) {
                            next = pt._next;
                            pt2 = first;
                            while (pt2 && pt2.pr > pt.pr) {
                                pt2 = pt2._next;
                            }
                            if (pt._prev = pt2 ? pt2._prev : last) {
                                pt._prev._next = pt;
                            } else {
                                first = pt;
                            }
                            if (pt._next = pt2) {
                                pt2._prev = pt;
                            } else {
                                last = pt;
                            }
                            pt = next;
                        }
                        parent._pt = first;
                    }; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)
                var PropTween = /*#__PURE__*/ function() {
                    function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
                        this.t = target;
                        this.s = start;
                        this.c = change;
                        this.p = prop;
                        this.r = renderer || _renderPlain;
                        this.d = data || this;
                        this.set = setter || _setterPlain;
                        this.pr = priority || 0;
                        this._next = next;
                        if (next) {
                            next._prev = this;
                        }
                    }
                    var _proto4 = PropTween.prototype;
                    _proto4.modifier = function modifier(func, tween, target) {
                        this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)
                        this.set = _setterWithModifier;
                        this.m = func;
                        this.mt = target; //modifier target
                        this.tween = tween;
                    };
                    return PropTween;
                }(); //Initialization tasks
                _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
                    return _reservedProps[name] = 1;
                });
                _globals.TweenMax = _globals.TweenLite = Tween;
                _globals.TimelineLite = _globals.TimelineMax = Timeline;
                _globalTimeline = new Timeline({
                    sortChildren: false,
                    defaults: _defaults,
                    autoRemoveChildren: true,
                    id: "root",
                    smoothChildTiming: true
                });
                _config.stringFilter = _colorStringFilter;
                /*
                 * --------------------------------------------------------------------------------------
                 * GSAP
                 * --------------------------------------------------------------------------------------
                 */
                var _gsap = {
                    registerPlugin: function registerPlugin() {
                        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                            args[_key2] = arguments[_key2];
                        }
                        args.forEach(function(config) {
                            return _createPlugin(config);
                        });
                    },
                    timeline: function timeline(vars) {
                        return new Timeline(vars);
                    },
                    getTweensOf: function getTweensOf(targets, onlyActive) {
                        return _globalTimeline.getTweensOf(targets, onlyActive);
                    },
                    getProperty: function getProperty(target, property, unit, uncache) {
                        _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in
                        var getter = _getCache(target || {}).get,
                            format = unit ? _passThrough : _numericIfPossible;
                        unit === "native" && (unit = "");
                        return !target ? target : !property ? function(property, unit, uncache) {
                            return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
                        } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
                    },
                    quickSetter: function quickSetter(target, property, unit) {
                        target = toArray(target);
                        if (target.length > 1) {
                            var setters = target.map(function(t) {
                                    return gsap.quickSetter(t, property, unit);
                                }),
                                l = setters.length;
                            return function(value) {
                                var i = l;
                                while (i--) {
                                    setters[i](value);
                                }
                            };
                        }
                        target = target[0] || {};
                        var Plugin = _plugins[property],
                            cache = _getCache(target),
                            p = cache.harness && (cache.harness.aliases || {})[property] || property,
                            // in case it's an alias, like "rotate" for "rotation".
                            setter = Plugin ? function(value) {
                                var p = new Plugin();
                                _quickTween._pt = 0;
                                p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
                                p.render(1, p);
                                _quickTween._pt && _renderPropTweens(1, _quickTween);
                            } : cache.set(target, p);
                        return Plugin ? setter : function(value) {
                            return setter(target, p, unit ? value + unit : value, cache, 1);
                        };
                    },
                    quickTo: function quickTo(target, property, vars) {
                        var _merge2;
                        var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = "+=0.1", _merge2.paused = true, _merge2), vars || {})),
                            func = function func(value, start, startIsRelative) {
                                return tween.resetTo(property, value, start, startIsRelative);
                            };
                        func.tween = tween;
                        return func;
                    },
                    isTweening: function isTweening(targets) {
                        return _globalTimeline.getTweensOf(targets, true).length > 0;
                    },
                    defaults: function defaults(value) {
                        value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
                        return _mergeDeep(_defaults, value || {});
                    },
                    config: function config(value) {
                        return _mergeDeep(_config, value || {});
                    },
                    registerEffect: function registerEffect(_ref3) {
                        var name = _ref3.name,
                            effect = _ref3.effect,
                            plugins = _ref3.plugins,
                            defaults = _ref3.defaults,
                            extendTimeline = _ref3.extendTimeline;
                        (plugins || "").split(",").forEach(function(pluginName) {
                            return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
                        });
                        _effects[name] = function(targets, vars, tl) {
                            return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
                        };
                        if (extendTimeline) {
                            Timeline.prototype[name] = function(targets, vars, position) {
                                return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
                            };
                        }
                    },
                    registerEase: function registerEase(name, ease) {
                        _easeMap[name] = _parseEase(ease);
                    },
                    parseEase: function parseEase(ease, defaultEase) {
                        return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
                    },
                    getById: function getById(id) {
                        return _globalTimeline.getById(id);
                    },
                    exportRoot: function exportRoot(vars, includeDelayedCalls) {
                        if (vars === void 0) {
                            vars = {};
                        }
                        var tl = new Timeline(vars),
                            child, next;
                        tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
                        _globalTimeline.remove(tl);
                        tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).
                        tl._time = tl._tTime = _globalTimeline._time;
                        child = _globalTimeline._first;
                        while (child) {
                            next = child._next;
                            if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
                                _addToTimeline(tl, child, child._start - child._delay);
                            }
                            child = next;
                        }
                        _addToTimeline(_globalTimeline, tl, 0);
                        return tl;
                    },
                    utils: {
                        wrap: wrap,
                        wrapYoyo: wrapYoyo,
                        distribute: distribute,
                        random: random,
                        snap: snap,
                        normalize: normalize,
                        getUnit: getUnit,
                        clamp: clamp,
                        splitColor: splitColor,
                        toArray: toArray,
                        selector: selector,
                        mapRange: mapRange,
                        pipe: pipe,
                        unitize: unitize,
                        interpolate: interpolate,
                        shuffle: shuffle
                    },
                    install: _install,
                    effects: _effects,
                    ticker: _ticker,
                    updateRoot: Timeline.updateRoot,
                    plugins: _plugins,
                    globalTimeline: _globalTimeline,
                    core: {
                        PropTween: PropTween,
                        globals: _addGlobal,
                        Tween: Tween,
                        Timeline: Timeline,
                        Animation: Animation,
                        getCache: _getCache,
                        _removeLinkedListItem: _removeLinkedListItem,
                        suppressOverwrites: function suppressOverwrites(value) {
                            return _suppressOverwrites = value;
                        }
                    }
                };
                _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
                    return _gsap[name] = Tween[name];
                });
                _ticker.add(Timeline.updateRoot);
                _quickTween = _gsap.to({}, {
                    duration: 0
                }); // ---- EXTRA PLUGINS --------------------------------------------------------
                var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
                        var pt = plugin._pt;
                        while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
                            pt = pt._next;
                        }
                        return pt;
                    },
                    _addModifiers = function _addModifiers(tween, modifiers) {
                        var targets = tween._targets,
                            p, i, pt;
                        for (p in modifiers) {
                            i = targets.length;
                            while (i--) {
                                pt = tween._ptLookup[i][p];
                                if (pt && (pt = pt.d)) {
                                    if (pt._pt) {
                                        // is a plugin
                                        pt = _getPluginPropTween(pt, p);
                                    }
                                    pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
                                }
                            }
                        }
                    },
                    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
                        return {
                            name: name,
                            rawVars: 1,
                            //don't pre-process function-based values or "random()" strings.
                            init: function init(target, vars, tween) {
                                tween._onInit = function(tween) {
                                    var temp, p;
                                    if (_isString(vars)) {
                                        temp = {};
                                        _forEachName(vars, function(name) {
                                            return temp[name] = 1;
                                        }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.
                                        vars = temp;
                                    }
                                    if (modifier) {
                                        temp = {};
                                        for (p in vars) {
                                            temp[p] = modifier(vars[p]);
                                        }
                                        vars = temp;
                                    }
                                    _addModifiers(tween, vars);
                                };
                            }
                        };
                    }; //register core plugins
                var gsap = _gsap.registerPlugin({
                    name: "attr",
                    init: function init(target, vars, tween, index, targets) {
                        var p, pt;
                        for (p in vars) {
                            pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);
                            pt && (pt.op = p);
                            this._props.push(p);
                        }
                    }
                }, {
                    name: "endArray",
                    init: function init(target, value) {
                        var i = value.length;
                        while (i--) {
                            this.add(target, i, target[i] || 0, value[i]);
                        }
                    }
                }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.
                Tween.version = Timeline.version = gsap.version = "3.10.2";
                _coreReady = 1;
                _windowExists() && _wake();
                var Power0 = _easeMap.Power0,
                    Power1 = _easeMap.Power1,
                    Power2 = _easeMap.Power2,
                    Power3 = _easeMap.Power3,
                    Power4 = _easeMap.Power4,
                    Linear = _easeMap.Linear,
                    Quad = _easeMap.Quad,
                    Cubic = _easeMap.Cubic,
                    Quart = _easeMap.Quart,
                    Quint = _easeMap.Quint,
                    Strong = _easeMap.Strong,
                    Elastic = _easeMap.Elastic,
                    Back = _easeMap.Back,
                    SteppedEase = _easeMap.SteppedEase,
                    Bounce = _easeMap.Bounce,
                    Sine = _easeMap.Sine,
                    Expo = _easeMap.Expo,
                    Circ = _easeMap.Circ;

                //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.



                /***/
            }),

        /***/
        "./node_modules/gsap/index.js":
            /*!************************************!*\
              !*** ./node_modules/gsap/index.js ***!
              \************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "Back": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back;
                    },
                    /* harmony export */
                    "Bounce": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce;
                    },
                    /* harmony export */
                    "CSSPlugin": function() {
                        return /* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin;
                    },
                    /* harmony export */
                    "Circ": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ;
                    },
                    /* harmony export */
                    "Cubic": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic;
                    },
                    /* harmony export */
                    "Elastic": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic;
                    },
                    /* harmony export */
                    "Expo": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo;
                    },
                    /* harmony export */
                    "Linear": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear;
                    },
                    /* harmony export */
                    "Power0": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0;
                    },
                    /* harmony export */
                    "Power1": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1;
                    },
                    /* harmony export */
                    "Power2": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2;
                    },
                    /* harmony export */
                    "Power3": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3;
                    },
                    /* harmony export */
                    "Power4": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4;
                    },
                    /* harmony export */
                    "Quad": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad;
                    },
                    /* harmony export */
                    "Quart": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart;
                    },
                    /* harmony export */
                    "Quint": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint;
                    },
                    /* harmony export */
                    "Sine": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine;
                    },
                    /* harmony export */
                    "SteppedEase": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase;
                    },
                    /* harmony export */
                    "Strong": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong;
                    },
                    /* harmony export */
                    "TimelineLite": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite;
                    },
                    /* harmony export */
                    "TimelineMax": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax;
                    },
                    /* harmony export */
                    "TweenLite": function() {
                        return /* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite;
                    },
                    /* harmony export */
                    "TweenMax": function() {
                        return /* binding */ TweenMaxWithCSS;
                    },
                    /* harmony export */
                    "default": function() {
                        return /* binding */ gsapWithCSS;
                    },
                    /* harmony export */
                    "gsap": function() {
                        return /* binding */ gsapWithCSS;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
                /* harmony import */
                var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./CSSPlugin.js */ "./node_modules/gsap/CSSPlugin.js");


                var gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap,
                    // to protect from tree shaking
                    TweenMaxWithCSS = gsapWithCSS.core.Tween;



                /***/
            }),

        /***/
        "./node_modules/proxy-polyfill/src/index.js":
            /*!**************************************************!*\
              !*** ./node_modules/proxy-polyfill/src/index.js ***!
              \**************************************************/
            /***/
            (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

                /*
                 * Copyright 2018 Google Inc. All rights reserved.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
                 * use this file except in compliance with the License. You may obtain a copy of
                 * the License at
                 *
                 *     http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
                 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
                 * License for the specific language governing permissions and limitations under
                 * the License.
                 */

                (function(scope) {
                    if (scope['Proxy']) {
                        return;
                    }
                    scope.Proxy = __webpack_require__( /*! ./proxy.js */ "./node_modules/proxy-polyfill/src/proxy.js")();
                    scope.Proxy['revocable'] = scope.Proxy.revocable;
                })(('undefined' !== typeof process &&
                        '[object process]' === {}.toString.call(process)) ||
                    ('undefined' !== typeof navigator && navigator.product === 'ReactNative') ?
                    __webpack_require__.g :
                    self);


                /***/
            }),

        /***/
        "./node_modules/proxy-polyfill/src/proxy.js":
            /*!**************************************************!*\
              !*** ./node_modules/proxy-polyfill/src/proxy.js ***!
              \**************************************************/
            /***/
            (function(module) {


                /*
                 * Copyright 2016 Google Inc. All rights reserved.
                 *
                 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
                 * use this file except in compliance with the License. You may obtain a copy of
                 * the License at
                 *
                 *     http://www.apache.org/licenses/LICENSE-2.0
                 *
                 * Unless required by applicable law or agreed to in writing, software
                 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
                 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
                 * License for the specific language governing permissions and limitations under
                 * the License.
                 */
                module.exports = function proxyPolyfill() {
                    var lastRevokeFn = null;
                    var ProxyPolyfill;
                    /**
                     * @param {*} o
                     * @return {boolean} whether this is probably a (non-null) Object
                     */
                    function isObject(o) {
                        return o ? (typeof o === 'object' || typeof o === 'function') : false;
                    }

                    function validateProto(proto) {
                        if (proto !== null && !isObject(proto)) {
                            throw new TypeError('Object prototype may only be an Object or null: ' + proto);
                        }
                    }
                    var $Object = Object;
                    // Closure assumes that `{__proto__: null} instanceof Object` is always true, hence why we check against a different name.
                    var canCreateNullProtoObjects = Boolean($Object.create) || !({
                            __proto__: null
                        }
                        instanceof $Object);
                    var objectCreate = $Object.create ||
                        (canCreateNullProtoObjects ?
                            function create(proto) {
                                validateProto(proto);
                                return {
                                    __proto__: proto
                                };
                            } :
                            function create(proto) {
                                validateProto(proto);
                                if (proto === null) {
                                    throw new SyntaxError('Native Object.create is required to create objects with null prototype');
                                }
                                // nb. cast to convince Closure compiler that this is a constructor
                                var T = /** @type {!Function} */ (function T() {});
                                T.prototype = proto;
                                return new T();
                            });
                    var noop = function() {
                        return null;
                    };
                    var getProto = $Object.getPrototypeOf ||
                        ([].__proto__ === Array.prototype ?
                            function getPrototypeOf(O) {
                                // If O.[[Prototype]] === null, then the __proto__ accessor won't exist,
                                // as it's inherited from `Object.prototype`
                                var proto = O.__proto__;
                                return isObject(proto) ? proto : null;
                            } :
                            noop);
                    /**
                     * @constructor
                     * @param {!Object} target
                     * @param {{apply, construct, get, set}} handler
                     */
                    ProxyPolyfill = function(target, handler) {
                        var newTarget = this && this instanceof ProxyPolyfill ? this.constructor : undefined;
                        if (newTarget === undefined) {
                            throw new TypeError("Constructor Proxy requires 'new'");
                        }
                        if (!isObject(target) || !isObject(handler)) {
                            throw new TypeError('Cannot create proxy with a non-object as target or handler');
                        }
                        // Construct revoke function, and set lastRevokeFn so that Proxy.revocable can steal it.
                        // The caller might get the wrong revoke function if a user replaces or wraps scope.Proxy
                        // to call itself, but that seems unlikely especially when using the polyfill.
                        var throwRevoked = function() {};
                        lastRevokeFn = function() {
                            /** @suppress {checkTypes} */
                            target = null; // clear ref
                            throwRevoked = function(trap) {
                                throw new TypeError("Cannot perform '".concat(trap, "' on a proxy that has been revoked"));
                            };
                        };
                        setTimeout(function() {
                            lastRevokeFn = null;
                        }, 0);
                        // Fail on unsupported traps: Chrome doesn't do this, but ensure that users of the polyfill
                        // are a bit more careful. Copy the internal parts of handler to prevent user changes.
                        var unsafeHandler = handler;
                        handler = {
                            'get': null,
                            'set': null,
                            'apply': null,
                            'construct': null
                        };
                        for (var k in unsafeHandler) {
                            if (!(k in handler)) {
                                throw new TypeError("Proxy polyfill does not support trap '".concat(k, "'"));
                            }
                            handler[k] = unsafeHandler[k];
                        }
                        if (typeof unsafeHandler === 'function') {
                            // Allow handler to be a function (which has an 'apply' method). This matches what is
                            // probably a bug in native versions. It treats the apply call as a trap to be configured.
                            handler.apply = unsafeHandler.apply.bind(unsafeHandler);
                        }
                        // Define proxy as an object that extends target.[[Prototype]],
                        // or a Function (if either it's callable, or apply is set).
                        var proto = getProto(target); // can return null in old browsers
                        var proxy;
                        var isMethod = false;
                        var isArray = false;
                        if (typeof target === 'function') {
                            proxy = function ProxyPolyfill() {
                                var usingNew = (this && this.constructor === proxy);
                                var args = Array.prototype.slice.call(arguments);
                                throwRevoked(usingNew ? 'construct' : 'apply');
                                // TODO(samthor): Closure compiler doesn't know about 'construct', attempts to rename it.
                                if (usingNew && handler['construct']) {
                                    return handler['construct'].call(this, target, args);
                                } else if (!usingNew && handler.apply) {
                                    return handler['apply'](target, this, args);
                                }
                                // since the target was a function, fallback to calling it directly.
                                if (usingNew) {
                                    // inspired by answers to https://stackoverflow.com/q/1606797
                                    args.unshift(target); // pass class as first arg to constructor, although irrelevant
                                    // nb. cast to convince Closure compiler that this is a constructor
                                    var f = /** @type {!Function} */ (target.bind.apply(target, args));
                                    return new f();
                                }
                                return target.apply(this, args);
                            };
                            isMethod = true;
                        } else if (target instanceof Array) {
                            proxy = [];
                            isArray = true;
                        } else {
                            proxy = (canCreateNullProtoObjects || proto !== null) ? objectCreate(proto) : {};
                        }
                        // Create default getters/setters. Create different code paths as handler.get/handler.set can't
                        // change after creation.
                        var getter = handler.get ? function(prop) {
                            throwRevoked('get');
                            return handler.get(this, prop, proxy);
                        } : function(prop) {
                            throwRevoked('get');
                            return this[prop];
                        };
                        var setter = handler.set ? function(prop, value) {
                            throwRevoked('set');
                            var status = handler.set(this, prop, value, proxy);
                            // TODO(samthor): If the calling code is in strict mode, throw TypeError.
                            // if (!status) {
                            // It's (sometimes) possible to work this out, if this code isn't strict- try to load the
                            // callee, and if it's available, that code is non-strict. However, this isn't exhaustive.
                            // }
                        } : function(prop, value) {
                            throwRevoked('set');
                            this[prop] = value;
                        };
                        // Clone direct properties (i.e., not part of a prototype).
                        var propertyNames = $Object.getOwnPropertyNames(target);
                        var propertyMap = {};
                        propertyNames.forEach(function(prop) {
                            if ((isMethod || isArray) && prop in proxy) {
                                return; // ignore properties already here, e.g. 'bind', 'prototype' etc
                            }
                            var real = $Object.getOwnPropertyDescriptor(target, prop);
                            var desc = {
                                enumerable: Boolean(real.enumerable),
                                get: getter.bind(target, prop),
                                set: setter.bind(target, prop),
                            };
                            $Object.defineProperty(proxy, prop, desc);
                            propertyMap[prop] = true;
                        });
                        // Set the prototype, or clone all prototype methods (always required if a getter is provided).
                        // TODO(samthor): We don't allow prototype methods to be set. It's (even more) awkward.
                        // An alternative here would be to _just_ clone methods to keep behavior consistent.
                        var prototypeOk = true;
                        if (isMethod || isArray) {
                            // Arrays and methods are special: above, we instantiate boring versions of these then swap
                            // our their prototype later. So we only need to use setPrototypeOf in these cases. Some old
                            // engines support `Object.getPrototypeOf` but not `Object.setPrototypeOf`.
                            var setProto = $Object.setPrototypeOf ||
                                ([].__proto__ === Array.prototype ?
                                    function setPrototypeOf(O, proto) {
                                        validateProto(proto);
                                        O.__proto__ = proto;
                                        return O;
                                    } :
                                    noop);
                            if (!(proto && setProto(proxy, proto))) {
                                prototypeOk = false;
                            }
                        }
                        if (handler.get || !prototypeOk) {
                            for (var k in target) {
                                if (propertyMap[k]) {
                                    continue;
                                }
                                $Object.defineProperty(proxy, k, {
                                    get: getter.bind(target, k)
                                });
                            }
                        }
                        // The Proxy polyfill cannot handle adding new properties. Seal the target and proxy.
                        $Object.seal(target);
                        $Object.seal(proxy);
                        return proxy; // nb. if isMethod is true, proxy != this
                    };
                    ProxyPolyfill.revocable = function(target, handler) {
                        var p = new ProxyPolyfill(target, handler);
                        return {
                            'proxy': p,
                            'revoke': lastRevokeFn
                        };
                    };
                    return ProxyPolyfill;
                };


                /***/
            }),

        /***/
        "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js":
            /*!*************************************************************************!*\
              !*** ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
              \*************************************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /**
                 * A collection of shims that provide minimal functionality of the ES6 collections.
                 *
                 * These implementations are not meant to be used outside of the ResizeObserver
                 * modules as they cover only a limited range of use cases.
                 */
                /* eslint-disable require-jsdoc, valid-jsdoc */
                var MapShim = (function() {
                    if (typeof Map !== 'undefined') {
                        return Map;
                    }
                    /**
                     * Returns index in provided array that matches the specified key.
                     *
                     * @param {Array<Array>} arr
                     * @param {*} key
                     * @returns {number}
                     */
                    function getIndex(arr, key) {
                        var result = -1;
                        arr.some(function(entry, index) {
                            if (entry[0] === key) {
                                result = index;
                                return true;
                            }
                            return false;
                        });
                        return result;
                    }
                    return /** @class */ (function() {
                        function class_1() {
                            this.__entries__ = [];
                        }
                        Object.defineProperty(class_1.prototype, "size", {
                            /**
                             * @returns {boolean}
                             */
                            get: function() {
                                return this.__entries__.length;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        /**
                         * @param {*} key
                         * @returns {*}
                         */
                        class_1.prototype.get = function(key) {
                            var index = getIndex(this.__entries__, key);
                            var entry = this.__entries__[index];
                            return entry && entry[1];
                        };
                        /**
                         * @param {*} key
                         * @param {*} value
                         * @returns {void}
                         */
                        class_1.prototype.set = function(key, value) {
                            var index = getIndex(this.__entries__, key);
                            if (~index) {
                                this.__entries__[index][1] = value;
                            } else {
                                this.__entries__.push([key, value]);
                            }
                        };
                        /**
                         * @param {*} key
                         * @returns {void}
                         */
                        class_1.prototype.delete = function(key) {
                            var entries = this.__entries__;
                            var index = getIndex(entries, key);
                            if (~index) {
                                entries.splice(index, 1);
                            }
                        };
                        /**
                         * @param {*} key
                         * @returns {void}
                         */
                        class_1.prototype.has = function(key) {
                            return !!~getIndex(this.__entries__, key);
                        };
                        /**
                         * @returns {void}
                         */
                        class_1.prototype.clear = function() {
                            this.__entries__.splice(0);
                        };
                        /**
                         * @param {Function} callback
                         * @param {*} [ctx=null]
                         * @returns {void}
                         */
                        class_1.prototype.forEach = function(callback, ctx) {
                            if (ctx === void 0) {
                                ctx = null;
                            }
                            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                                var entry = _a[_i];
                                callback.call(ctx, entry[1], entry[0]);
                            }
                        };
                        return class_1;
                    }());
                })();
                /**
                 * Detects whether window and document objects are available in current environment.
                 */
                var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;
                // Returns global object of a current environment.
                var global$1 = (function() {
                    if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.Math === Math) {
                        return __webpack_require__.g;
                    }
                    if (typeof self !== 'undefined' && self.Math === Math) {
                        return self;
                    }
                    if (typeof window !== 'undefined' && window.Math === Math) {
                        return window;
                    }
                    // eslint-disable-next-line no-new-func
                    return Function('return this')();
                })();
                /**
                 * A shim for the requestAnimationFrame which falls back to the setTimeout if
                 * first one is not supported.
                 *
                 * @returns {number} Requests' identifier.
                 */
                var requestAnimationFrame$1 = (function() {
                    if (typeof requestAnimationFrame === 'function') {
                        // It's required to use a bounded function because IE sometimes throws
                        // an "Invalid calling object" error if rAF is invoked without the global
                        // object on the left hand side.
                        return requestAnimationFrame.bind(global$1);
                    }
                    return function(callback) {
                        return setTimeout(function() {
                            return callback(Date.now());
                        }, 1000 / 60);
                    };
                })();
                // Defines minimum timeout before adding a trailing call.
                var trailingTimeout = 2;
                /**
                 * Creates a wrapper function which ensures that provided callback will be
                 * invoked only once during the specified delay period.
                 *
                 * @param {Function} callback - Function to be invoked after the delay period.
                 * @param {number} delay - Delay after which to invoke callback.
                 * @returns {Function}
                 */
                function throttle(callback, delay) {
                    var leadingCall = false,
                        trailingCall = false,
                        lastCallTime = 0;
                    /**
                     * Invokes the original callback function and schedules new invocation if
                     * the "proxy" was called during current request.
                     *
                     * @returns {void}
                     */
                    function resolvePending() {
                        if (leadingCall) {
                            leadingCall = false;
                            callback();
                        }
                        if (trailingCall) {
                            proxy();
                        }
                    }
                    /**
                     * Callback invoked after the specified delay. It will further postpone
                     * invocation of the original function delegating it to the
                     * requestAnimationFrame.
                     *
                     * @returns {void}
                     */
                    function timeoutCallback() {
                        requestAnimationFrame$1(resolvePending);
                    }
                    /**
                     * Schedules invocation of the original function.
                     *
                     * @returns {void}
                     */
                    function proxy() {
                        var timeStamp = Date.now();
                        if (leadingCall) {
                            // Reject immediately following calls.
                            if (timeStamp - lastCallTime < trailingTimeout) {
                                return;
                            }
                            // Schedule new call to be in invoked when the pending one is resolved.
                            // This is important for "transitions" which never actually start
                            // immediately so there is a chance that we might miss one if change
                            // happens amids the pending invocation.
                            trailingCall = true;
                        } else {
                            leadingCall = true;
                            trailingCall = false;
                            setTimeout(timeoutCallback, delay);
                        }
                        lastCallTime = timeStamp;
                    }
                    return proxy;
                }
                // Minimum delay before invoking the update of observers.
                var REFRESH_DELAY = 20;
                // A list of substrings of CSS properties used to find transition events that
                // might affect dimensions of observed elements.
                var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
                // Check if MutationObserver is available.
                var mutationObserverSupported = typeof MutationObserver !== 'undefined';
                /**
                 * Singleton controller class which handles updates of ResizeObserver instances.
                 */
                var ResizeObserverController = /** @class */ (function() {
                    /**
                     * Creates a new instance of ResizeObserverController.
                     *
                     * @private
                     */
                    function ResizeObserverController() {
                        /**
                         * Indicates whether DOM listeners have been added.
                         *
                         * @private {boolean}
                         */
                        this.connected_ = false;
                        /**
                         * Tells that controller has subscribed for Mutation Events.
                         *
                         * @private {boolean}
                         */
                        this.mutationEventsAdded_ = false;
                        /**
                         * Keeps reference to the instance of MutationObserver.
                         *
                         * @private {MutationObserver}
                         */
                        this.mutationsObserver_ = null;
                        /**
                         * A list of connected observers.
                         *
                         * @private {Array<ResizeObserverSPI>}
                         */
                        this.observers_ = [];
                        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
                        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
                    }
                    /**
                     * Adds observer to observers list.
                     *
                     * @param {ResizeObserverSPI} observer - Observer to be added.
                     * @returns {void}
                     */
                    ResizeObserverController.prototype.addObserver = function(observer) {
                        if (!~this.observers_.indexOf(observer)) {
                            this.observers_.push(observer);
                        }
                        // Add listeners if they haven't been added yet.
                        if (!this.connected_) {
                            this.connect_();
                        }
                    };
                    /**
                     * Removes observer from observers list.
                     *
                     * @param {ResizeObserverSPI} observer - Observer to be removed.
                     * @returns {void}
                     */
                    ResizeObserverController.prototype.removeObserver = function(observer) {
                        var observers = this.observers_;
                        var index = observers.indexOf(observer);
                        // Remove observer if it's present in registry.
                        if (~index) {
                            observers.splice(index, 1);
                        }
                        // Remove listeners if controller has no connected observers.
                        if (!observers.length && this.connected_) {
                            this.disconnect_();
                        }
                    };
                    /**
                     * Invokes the update of observers. It will continue running updates insofar
                     * it detects changes.
                     *
                     * @returns {void}
                     */
                    ResizeObserverController.prototype.refresh = function() {
                        var changesDetected = this.updateObservers_();
                        // Continue running updates if changes have been detected as there might
                        // be future ones caused by CSS transitions.
                        if (changesDetected) {
                            this.refresh();
                        }
                    };
                    /**
                     * Updates every observer from observers list and notifies them of queued
                     * entries.
                     *
                     * @private
                     * @returns {boolean} Returns "true" if any observer has detected changes in
                     *      dimensions of it's elements.
                     */
                    ResizeObserverController.prototype.updateObservers_ = function() {
                        // Collect observers that have active observations.
                        var activeObservers = this.observers_.filter(function(observer) {
                            return observer.gatherActive(), observer.hasActive();
                        });
                        // Deliver notifications in a separate cycle in order to avoid any
                        // collisions between observers, e.g. when multiple instances of
                        // ResizeObserver are tracking the same element and the callback of one
                        // of them changes content dimensions of the observed target. Sometimes
                        // this may result in notifications being blocked for the rest of observers.
                        activeObservers.forEach(function(observer) {
                            return observer.broadcastActive();
                        });
                        return activeObservers.length > 0;
                    };
                    /**
                     * Initializes DOM listeners.
                     *
                     * @private
                     * @returns {void}
                     */
                    ResizeObserverController.prototype.connect_ = function() {
                        // Do nothing if running in a non-browser environment or if listeners
                        // have been already added.
                        if (!isBrowser || this.connected_) {
                            return;
                        }
                        // Subscription to the "Transitionend" event is used as a workaround for
                        // delayed transitions. This way it's possible to capture at least the
                        // final state of an element.
                        document.addEventListener('transitionend', this.onTransitionEnd_);
                        window.addEventListener('resize', this.refresh);
                        if (mutationObserverSupported) {
                            this.mutationsObserver_ = new MutationObserver(this.refresh);
                            this.mutationsObserver_.observe(document, {
                                attributes: true,
                                childList: true,
                                characterData: true,
                                subtree: true
                            });
                        } else {
                            document.addEventListener('DOMSubtreeModified', this.refresh);
                            this.mutationEventsAdded_ = true;
                        }
                        this.connected_ = true;
                    };
                    /**
                     * Removes DOM listeners.
                     *
                     * @private
                     * @returns {void}
                     */
                    ResizeObserverController.prototype.disconnect_ = function() {
                        // Do nothing if running in a non-browser environment or if listeners
                        // have been already removed.
                        if (!isBrowser || !this.connected_) {
                            return;
                        }
                        document.removeEventListener('transitionend', this.onTransitionEnd_);
                        window.removeEventListener('resize', this.refresh);
                        if (this.mutationsObserver_) {
                            this.mutationsObserver_.disconnect();
                        }
                        if (this.mutationEventsAdded_) {
                            document.removeEventListener('DOMSubtreeModified', this.refresh);
                        }
                        this.mutationsObserver_ = null;
                        this.mutationEventsAdded_ = false;
                        this.connected_ = false;
                    };
                    /**
                     * "Transitionend" event handler.
                     *
                     * @private
                     * @param {TransitionEvent} event
                     * @returns {void}
                     */
                    ResizeObserverController.prototype.onTransitionEnd_ = function(_a) {
                        var _b = _a.propertyName,
                            propertyName = _b === void 0 ? '' : _b;
                        // Detect whether transition may affect dimensions of an element.
                        var isReflowProperty = transitionKeys.some(function(key) {
                            return !!~propertyName.indexOf(key);
                        });
                        if (isReflowProperty) {
                            this.refresh();
                        }
                    };
                    /**
                     * Returns instance of the ResizeObserverController.
                     *
                     * @returns {ResizeObserverController}
                     */
                    ResizeObserverController.getInstance = function() {
                        if (!this.instance_) {
                            this.instance_ = new ResizeObserverController();
                        }
                        return this.instance_;
                    };
                    /**
                     * Holds reference to the controller's instance.
                     *
                     * @private {ResizeObserverController}
                     */
                    ResizeObserverController.instance_ = null;
                    return ResizeObserverController;
                }());
                /**
                 * Defines non-writable/enumerable properties of the provided target object.
                 *
                 * @param {Object} target - Object for which to define properties.
                 * @param {Object} props - Properties to be defined.
                 * @returns {Object} Target object.
                 */
                var defineConfigurable = (function(target, props) {
                    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
                        var key = _a[_i];
                        Object.defineProperty(target, key, {
                            value: props[key],
                            enumerable: false,
                            writable: false,
                            configurable: true
                        });
                    }
                    return target;
                });
                /**
                 * Returns the global object associated with provided element.
                 *
                 * @param {Object} target
                 * @returns {Object}
                 */
                var getWindowOf = (function(target) {
                    // Assume that the element is an instance of Node, which means that it
                    // has the "ownerDocument" property from which we can retrieve a
                    // corresponding global object.
                    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
                    // Return the local global object if it's not possible extract one from
                    // provided element.
                    return ownerGlobal || global$1;
                });
                // Placeholder of an empty content rectangle.
                var emptyRect = createRectInit(0, 0, 0, 0);
                /**
                 * Converts provided string to a number.
                 *
                 * @param {number|string} value
                 * @returns {number}
                 */
                function toFloat(value) {
                    return parseFloat(value) || 0;
                }
                /**
                 * Extracts borders size from provided styles.
                 *
                 * @param {CSSStyleDeclaration} styles
                 * @param {...string} positions - Borders positions (top, right, ...)
                 * @returns {number}
                 */
                function getBordersSize(styles) {
                    var positions = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        positions[_i - 1] = arguments[_i];
                    }
                    return positions.reduce(function(size, position) {
                        var value = styles['border-' + position + '-width'];
                        return size + toFloat(value);
                    }, 0);
                }
                /**
                 * Extracts paddings sizes from provided styles.
                 *
                 * @param {CSSStyleDeclaration} styles
                 * @returns {Object} Paddings box.
                 */
                function getPaddings(styles) {
                    var positions = ['top', 'right', 'bottom', 'left'];
                    var paddings = {};
                    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
                        var position = positions_1[_i];
                        var value = styles['padding-' + position];
                        paddings[position] = toFloat(value);
                    }
                    return paddings;
                }
                /**
                 * Calculates content rectangle of provided SVG element.
                 *
                 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
                 *      to be calculated.
                 * @returns {DOMRectInit}
                 */
                function getSVGContentRect(target) {
                    var bbox = target.getBBox();
                    return createRectInit(0, 0, bbox.width, bbox.height);
                }
                /**
                 * Calculates content rectangle of provided HTMLElement.
                 *
                 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
                 * @returns {DOMRectInit}
                 */
                function getHTMLElementContentRect(target) {
                    // Client width & height properties can't be
                    // used exclusively as they provide rounded values.
                    var clientWidth = target.clientWidth,
                        clientHeight = target.clientHeight;
                    // By this condition we can catch all non-replaced inline, hidden and
                    // detached elements. Though elements with width & height properties less
                    // than 0.5 will be discarded as well.
                    //
                    // Without it we would need to implement separate methods for each of
                    // those cases and it's not possible to perform a precise and performance
                    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
                    // gives wrong results for elements with width & height less than 0.5.
                    if (!clientWidth && !clientHeight) {
                        return emptyRect;
                    }
                    var styles = getWindowOf(target).getComputedStyle(target);
                    var paddings = getPaddings(styles);
                    var horizPad = paddings.left + paddings.right;
                    var vertPad = paddings.top + paddings.bottom;
                    // Computed styles of width & height are being used because they are the
                    // only dimensions available to JS that contain non-rounded values. It could
                    // be possible to utilize the getBoundingClientRect if only it's data wasn't
                    // affected by CSS transformations let alone paddings, borders and scroll bars.
                    var width = toFloat(styles.width),
                        height = toFloat(styles.height);
                    // Width & height include paddings and borders when the 'border-box' box
                    // model is applied (except for IE).
                    if (styles.boxSizing === 'border-box') {
                        // Following conditions are required to handle Internet Explorer which
                        // doesn't include paddings and borders to computed CSS dimensions.
                        //
                        // We can say that if CSS dimensions + paddings are equal to the "client"
                        // properties then it's either IE, and thus we don't need to subtract
                        // anything, or an element merely doesn't have paddings/borders styles.
                        if (Math.round(width + horizPad) !== clientWidth) {
                            width -= getBordersSize(styles, 'left', 'right') + horizPad;
                        }
                        if (Math.round(height + vertPad) !== clientHeight) {
                            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
                        }
                    }
                    // Following steps can't be applied to the document's root element as its
                    // client[Width/Height] properties represent viewport area of the window.
                    // Besides, it's as well not necessary as the <html> itself neither has
                    // rendered scroll bars nor it can be clipped.
                    if (!isDocumentElement(target)) {
                        // In some browsers (only in Firefox, actually) CSS width & height
                        // include scroll bars size which can be removed at this step as scroll
                        // bars are the only difference between rounded dimensions + paddings
                        // and "client" properties, though that is not always true in Chrome.
                        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
                        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
                        // Chrome has a rather weird rounding of "client" properties.
                        // E.g. for an element with content width of 314.2px it sometimes gives
                        // the client width of 315px and for the width of 314.7px it may give
                        // 314px. And it doesn't happen all the time. So just ignore this delta
                        // as a non-relevant.
                        if (Math.abs(vertScrollbar) !== 1) {
                            width -= vertScrollbar;
                        }
                        if (Math.abs(horizScrollbar) !== 1) {
                            height -= horizScrollbar;
                        }
                    }
                    return createRectInit(paddings.left, paddings.top, width, height);
                }
                /**
                 * Checks whether provided element is an instance of the SVGGraphicsElement.
                 *
                 * @param {Element} target - Element to be checked.
                 * @returns {boolean}
                 */
                var isSVGGraphicsElement = (function() {
                    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
                    // interface.
                    if (typeof SVGGraphicsElement !== 'undefined') {
                        return function(target) {
                            return target instanceof getWindowOf(target).SVGGraphicsElement;
                        };
                    }
                    // If it's so, then check that element is at least an instance of the
                    // SVGElement and that it has the "getBBox" method.
                    // eslint-disable-next-line no-extra-parens
                    return function(target) {
                        return (target instanceof getWindowOf(target).SVGElement &&
                            typeof target.getBBox === 'function');
                    };
                })();
                /**
                 * Checks whether provided element is a document element (<html>).
                 *
                 * @param {Element} target - Element to be checked.
                 * @returns {boolean}
                 */
                function isDocumentElement(target) {
                    return target === getWindowOf(target).document.documentElement;
                }
                /**
                 * Calculates an appropriate content rectangle for provided html or svg element.
                 *
                 * @param {Element} target - Element content rectangle of which needs to be calculated.
                 * @returns {DOMRectInit}
                 */
                function getContentRect(target) {
                    if (!isBrowser) {
                        return emptyRect;
                    }
                    if (isSVGGraphicsElement(target)) {
                        return getSVGContentRect(target);
                    }
                    return getHTMLElementContentRect(target);
                }
                /**
                 * Creates rectangle with an interface of the DOMRectReadOnly.
                 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
                 *
                 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
                 * @returns {DOMRectReadOnly}
                 */
                function createReadOnlyRect(_a) {
                    var x = _a.x,
                        y = _a.y,
                        width = _a.width,
                        height = _a.height;
                    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
                    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
                    var rect = Object.create(Constr.prototype);
                    // Rectangle's properties are not writable and non-enumerable.
                    defineConfigurable(rect, {
                        x: x,
                        y: y,
                        width: width,
                        height: height,
                        top: y,
                        right: x + width,
                        bottom: height + y,
                        left: x
                    });
                    return rect;
                }
                /**
                 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
                 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
                 *
                 * @param {number} x - X coordinate.
                 * @param {number} y - Y coordinate.
                 * @param {number} width - Rectangle's width.
                 * @param {number} height - Rectangle's height.
                 * @returns {DOMRectInit}
                 */
                function createRectInit(x, y, width, height) {
                    return {
                        x: x,
                        y: y,
                        width: width,
                        height: height
                    };
                }
                /**
                 * Class that is responsible for computations of the content rectangle of
                 * provided DOM element and for keeping track of it's changes.
                 */
                var ResizeObservation = /** @class */ (function() {
                    /**
                     * Creates an instance of ResizeObservation.
                     *
                     * @param {Element} target - Element to be observed.
                     */
                    function ResizeObservation(target) {
                        /**
                         * Broadcasted width of content rectangle.
                         *
                         * @type {number}
                         */
                        this.broadcastWidth = 0;
                        /**
                         * Broadcasted height of content rectangle.
                         *
                         * @type {number}
                         */
                        this.broadcastHeight = 0;
                        /**
                         * Reference to the last observed content rectangle.
                         *
                         * @private {DOMRectInit}
                         */
                        this.contentRect_ = createRectInit(0, 0, 0, 0);
                        this.target = target;
                    }
                    /**
                     * Updates content rectangle and tells whether it's width or height properties
                     * have changed since the last broadcast.
                     *
                     * @returns {boolean}
                     */
                    ResizeObservation.prototype.isActive = function() {
                        var rect = getContentRect(this.target);
                        this.contentRect_ = rect;
                        return (rect.width !== this.broadcastWidth ||
                            rect.height !== this.broadcastHeight);
                    };
                    /**
                     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
                     * from the corresponding properties of the last observed content rectangle.
                     *
                     * @returns {DOMRectInit} Last observed content rectangle.
                     */
                    ResizeObservation.prototype.broadcastRect = function() {
                        var rect = this.contentRect_;
                        this.broadcastWidth = rect.width;
                        this.broadcastHeight = rect.height;
                        return rect;
                    };
                    return ResizeObservation;
                }());
                var ResizeObserverEntry = /** @class */ (function() {
                    /**
                     * Creates an instance of ResizeObserverEntry.
                     *
                     * @param {Element} target - Element that is being observed.
                     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
                     */
                    function ResizeObserverEntry(target, rectInit) {
                        var contentRect = createReadOnlyRect(rectInit);
                        // According to the specification following properties are not writable
                        // and are also not enumerable in the native implementation.
                        //
                        // Property accessors are not being used as they'd require to define a
                        // private WeakMap storage which may cause memory leaks in browsers that
                        // don't support this type of collections.
                        defineConfigurable(this, {
                            target: target,
                            contentRect: contentRect
                        });
                    }
                    return ResizeObserverEntry;
                }());
                var ResizeObserverSPI = /** @class */ (function() {
                    /**
                     * Creates a new instance of ResizeObserver.
                     *
                     * @param {ResizeObserverCallback} callback - Callback function that is invoked
                     *      when one of the observed elements changes it's content dimensions.
                     * @param {ResizeObserverController} controller - Controller instance which
                     *      is responsible for the updates of observer.
                     * @param {ResizeObserver} callbackCtx - Reference to the public
                     *      ResizeObserver instance which will be passed to callback function.
                     */
                    function ResizeObserverSPI(callback, controller, callbackCtx) {
                        /**
                         * Collection of resize observations that have detected changes in dimensions
                         * of elements.
                         *
                         * @private {Array<ResizeObservation>}
                         */
                        this.activeObservations_ = [];
                        /**
                         * Registry of the ResizeObservation instances.
                         *
                         * @private {Map<Element, ResizeObservation>}
                         */
                        this.observations_ = new MapShim();
                        if (typeof callback !== 'function') {
                            throw new TypeError('The callback provided as parameter 1 is not a function.');
                        }
                        this.callback_ = callback;
                        this.controller_ = controller;
                        this.callbackCtx_ = callbackCtx;
                    }
                    /**
                     * Starts observing provided element.
                     *
                     * @param {Element} target - Element to be observed.
                     * @returns {void}
                     */
                    ResizeObserverSPI.prototype.observe = function(target) {
                        if (!arguments.length) {
                            throw new TypeError('1 argument required, but only 0 present.');
                        }
                        // Do nothing if current environment doesn't have the Element interface.
                        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                            return;
                        }
                        if (!(target instanceof getWindowOf(target).Element)) {
                            throw new TypeError('parameter 1 is not of type "Element".');
                        }
                        var observations = this.observations_;
                        // Do nothing if element is already being observed.
                        if (observations.has(target)) {
                            return;
                        }
                        observations.set(target, new ResizeObservation(target));
                        this.controller_.addObserver(this);
                        // Force the update of observations.
                        this.controller_.refresh();
                    };
                    /**
                     * Stops observing provided element.
                     *
                     * @param {Element} target - Element to stop observing.
                     * @returns {void}
                     */
                    ResizeObserverSPI.prototype.unobserve = function(target) {
                        if (!arguments.length) {
                            throw new TypeError('1 argument required, but only 0 present.');
                        }
                        // Do nothing if current environment doesn't have the Element interface.
                        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                            return;
                        }
                        if (!(target instanceof getWindowOf(target).Element)) {
                            throw new TypeError('parameter 1 is not of type "Element".');
                        }
                        var observations = this.observations_;
                        // Do nothing if element is not being observed.
                        if (!observations.has(target)) {
                            return;
                        }
                        observations.delete(target);
                        if (!observations.size) {
                            this.controller_.removeObserver(this);
                        }
                    };
                    /**
                     * Stops observing all elements.
                     *
                     * @returns {void}
                     */
                    ResizeObserverSPI.prototype.disconnect = function() {
                        this.clearActive();
                        this.observations_.clear();
                        this.controller_.removeObserver(this);
                    };
                    /**
                     * Collects observation instances the associated element of which has changed
                     * it's content rectangle.
                     *
                     * @returns {void}
                     */
                    ResizeObserverSPI.prototype.gatherActive = function() {
                        var _this = this;
                        this.clearActive();
                        this.observations_.forEach(function(observation) {
                            if (observation.isActive()) {
                                _this.activeObservations_.push(observation);
                            }
                        });
                    };
                    /**
                     * Invokes initial callback function with a list of ResizeObserverEntry
                     * instances collected from active resize observations.
                     *
                     * @returns {void}
                     */
                    ResizeObserverSPI.prototype.broadcastActive = function() {
                        // Do nothing if observer doesn't have active observations.
                        if (!this.hasActive()) {
                            return;
                        }
                        var ctx = this.callbackCtx_;
                        // Create ResizeObserverEntry instance for every active observation.
                        var entries = this.activeObservations_.map(function(observation) {
                            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
                        });
                        this.callback_.call(ctx, entries, ctx);
                        this.clearActive();
                    };
                    /**
                     * Clears the collection of active observations.
                     *
                     * @returns {void}
                     */
                    ResizeObserverSPI.prototype.clearActive = function() {
                        this.activeObservations_.splice(0);
                    };
                    /**
                     * Tells whether observer has active observations.
                     *
                     * @returns {boolean}
                     */
                    ResizeObserverSPI.prototype.hasActive = function() {
                        return this.activeObservations_.length > 0;
                    };
                    return ResizeObserverSPI;
                }());
                // Registry of internal observers. If WeakMap is not available use current shim
                // for the Map collection as it has all required methods and because WeakMap
                // can't be fully polyfilled anyway.
                var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
                /**
                 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
                 * exposing only those methods and properties that are defined in the spec.
                 */
                var ResizeObserver = /** @class */ (function() {
                    /**
                     * Creates a new instance of ResizeObserver.
                     *
                     * @param {ResizeObserverCallback} callback - Callback that is invoked when
                     *      dimensions of the observed elements change.
                     */
                    function ResizeObserver(callback) {
                        if (!(this instanceof ResizeObserver)) {
                            throw new TypeError('Cannot call a class as a function.');
                        }
                        if (!arguments.length) {
                            throw new TypeError('1 argument required, but only 0 present.');
                        }
                        var controller = ResizeObserverController.getInstance();
                        var observer = new ResizeObserverSPI(callback, controller, this);
                        observers.set(this, observer);
                    }
                    return ResizeObserver;
                }());
                // Expose public methods of ResizeObserver.
                [
                    'observe',
                    'unobserve',
                    'disconnect'
                ].forEach(function(method) {
                    ResizeObserver.prototype[method] = function() {
                        var _a;
                        return (_a = observers.get(this))[method].apply(_a, arguments);
                    };
                });
                var index = (function() {
                    // Export existing implementation if available.
                    if (typeof global$1.ResizeObserver !== 'undefined') {
                        return global$1.ResizeObserver;
                    }
                    return ResizeObserver;
                })();
                /* harmony default export */
                __webpack_exports__["default"] = (index);


                /***/
            }),

        /***/
        "./node_modules/scroll-lock/dist/scroll-lock.js":
            /*!******************************************************!*\
              !*** ./node_modules/scroll-lock/dist/scroll-lock.js ***!
              \******************************************************/
            /***/
            (function(module) {


                (function webpackUniversalModuleDefinition(root, factory) {
                    if (true)
                        module.exports = factory();
                    else {}
                })(this, function() {
                    return /******/ (function(modules) {
                        /******/ // The module cache
                        /******/
                        var installedModules = {};
                        /******/
                        /******/ // The require function
                        /******/
                        function __nested_webpack_require_618__(moduleId) {
                            /******/
                            /******/ // Check if module is in cache
                            /******/
                            if (installedModules[moduleId]) {
                                /******/
                                return installedModules[moduleId].exports;
                                /******/
                            }
                            /******/ // Create a new module (and put it into the cache)
                            /******/
                            var module = installedModules[moduleId] = {
                                /******/
                                i: moduleId,
                                /******/
                                l: false,
                                /******/
                                exports: {}
                                /******/
                            };
                            /******/
                            /******/ // Execute the module function
                            /******/
                            modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_618__);
                            /******/
                            /******/ // Flag the module as loaded
                            /******/
                            module.l = true;
                            /******/
                            /******/ // Return the exports of the module
                            /******/
                            return module.exports;
                            /******/
                        }
                        /******/
                        /******/
                        /******/ // expose the modules object (__webpack_modules__)
                        /******/
                        __nested_webpack_require_618__.m = modules;
                        /******/
                        /******/ // expose the module cache
                        /******/
                        __nested_webpack_require_618__.c = installedModules;
                        /******/
                        /******/ // define getter function for harmony exports
                        /******/
                        __nested_webpack_require_618__.d = function(exports, name, getter) {
                            /******/
                            if (!__nested_webpack_require_618__.o(exports, name)) {
                                /******/
                                Object.defineProperty(exports, name, {
                                    enumerable: true,
                                    get: getter
                                });
                                /******/
                            }
                            /******/
                        };
                        /******/
                        /******/ // define __esModule on exports
                        /******/
                        __nested_webpack_require_618__.r = function(exports) {
                            /******/
                            if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                                /******/
                                Object.defineProperty(exports, Symbol.toStringTag, {
                                    value: 'Module'
                                });
                                /******/
                            }
                            /******/
                            Object.defineProperty(exports, '__esModule', {
                                value: true
                            });
                            /******/
                        };
                        /******/
                        /******/ // create a fake namespace object
                        /******/ // mode & 1: value is a module id, require it
                        /******/ // mode & 2: merge all properties of value into the ns
                        /******/ // mode & 4: return value when already ns object
                        /******/ // mode & 8|1: behave like require
                        /******/
                        __nested_webpack_require_618__.t = function(value, mode) {
                            /******/
                            if (mode & 1)
                                value = __nested_webpack_require_618__(value);
                            /******/
                            if (mode & 8)
                                return value;
                            /******/
                            if ((mode & 4) && typeof value === 'object' && value && value.__esModule)
                                return value;
                            /******/
                            var ns = Object.create(null);
                            /******/
                            __nested_webpack_require_618__.r(ns);
                            /******/
                            Object.defineProperty(ns, 'default', {
                                enumerable: true,
                                value: value
                            });
                            /******/
                            if (mode & 2 && typeof value != 'string')
                                for (var key in value)
                                    __nested_webpack_require_618__.d(ns, key, function(key) {
                                        return value[key];
                                    }.bind(null, key));
                            /******/
                            return ns;
                            /******/
                        };
                        /******/
                        /******/ // getDefaultExport function for compatibility with non-harmony modules
                        /******/
                        __nested_webpack_require_618__.n = function(module) {
                            /******/
                            var getter = module && module.__esModule ?
                                /******/
                                function getDefault() {
                                    return module['default'];
                                } :
                                /******/
                                function getModuleExports() {
                                    return module;
                                };
                            /******/
                            __nested_webpack_require_618__.d(getter, 'a', getter);
                            /******/
                            return getter;
                            /******/
                        };
                        /******/
                        /******/ // Object.prototype.hasOwnProperty.call
                        /******/
                        __nested_webpack_require_618__.o = function(object, property) {
                            return Object.prototype.hasOwnProperty.call(object, property);
                        };
                        /******/
                        /******/ // __webpack_public_path__
                        /******/
                        __nested_webpack_require_618__.p = "";
                        /******/
                        /******/
                        /******/ // Load entry module and return exports
                        /******/
                        return __nested_webpack_require_618__(__nested_webpack_require_618__.s = 0);
                        /******/
                    })([
                        /* 0 */
                        /***/
                        (function(module, __webpack_exports__, __nested_webpack_require_4940__) {
                            "use strict";
                            __nested_webpack_require_4940__.r(__webpack_exports__);
                            // CONCATENATED MODULE: ./src/tools.js
                            var argumentAsArray = function argumentAsArray(argument) {
                                return Array.isArray(argument) ? argument : [argument];
                            };
                            var isElement = function isElement(target) {
                                return target instanceof Node;
                            };
                            var isElementList = function isElementList(nodeList) {
                                return nodeList instanceof NodeList;
                            };
                            var eachNode = function eachNode(nodeList, callback) {
                                if (nodeList && callback) {
                                    nodeList = isElementList(nodeList) ? nodeList : [nodeList];
                                    for (var i = 0; i < nodeList.length; i++) {
                                        if (callback(nodeList[i], i, nodeList.length) === true) {
                                            break;
                                        }
                                    }
                                }
                            };
                            var throwError = function throwError(message) {
                                return console.error("[scroll-lock] ".concat(message));
                            };
                            var arrayAsSelector = function arrayAsSelector(array) {
                                if (Array.isArray(array)) {
                                    var selector = array.join(', ');
                                    return selector;
                                }
                            };
                            var nodeListAsArray = function nodeListAsArray(nodeList) {
                                var nodes = [];
                                eachNode(nodeList, function(node) {
                                    return nodes.push(node);
                                });
                                return nodes;
                            };
                            var findParentBySelector = function findParentBySelector($el, selector) {
                                var self = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
                                var $root = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : document;
                                if (self && nodeListAsArray($root.querySelectorAll(selector)).indexOf($el) !== -1) {
                                    return $el;
                                }
                                while (($el = $el.parentElement) && nodeListAsArray($root.querySelectorAll(selector)).indexOf($el) === -1) {;
                                }
                                return $el;
                            };
                            var elementHasSelector = function elementHasSelector($el, selector) {
                                var $root = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;
                                var has = nodeListAsArray($root.querySelectorAll(selector)).indexOf($el) !== -1;
                                return has;
                            };
                            var elementHasOverflowHidden = function elementHasOverflowHidden($el) {
                                if ($el) {
                                    var computedStyle = getComputedStyle($el);
                                    var overflowIsHidden = computedStyle.overflow === 'hidden';
                                    return overflowIsHidden;
                                }
                            };
                            var elementScrollTopOnStart = function elementScrollTopOnStart($el) {
                                if ($el) {
                                    if (elementHasOverflowHidden($el)) {
                                        return true;
                                    }
                                    var scrollTop = $el.scrollTop;
                                    return scrollTop <= 0;
                                }
                            };
                            var elementScrollTopOnEnd = function elementScrollTopOnEnd($el) {
                                if ($el) {
                                    if (elementHasOverflowHidden($el)) {
                                        return true;
                                    }
                                    var scrollTop = $el.scrollTop;
                                    var scrollHeight = $el.scrollHeight;
                                    var scrollTopWithHeight = scrollTop + $el.offsetHeight;
                                    return scrollTopWithHeight >= scrollHeight;
                                }
                            };
                            var elementScrollLeftOnStart = function elementScrollLeftOnStart($el) {
                                if ($el) {
                                    if (elementHasOverflowHidden($el)) {
                                        return true;
                                    }
                                    var scrollLeft = $el.scrollLeft;
                                    return scrollLeft <= 0;
                                }
                            };
                            var elementScrollLeftOnEnd = function elementScrollLeftOnEnd($el) {
                                if ($el) {
                                    if (elementHasOverflowHidden($el)) {
                                        return true;
                                    }
                                    var scrollLeft = $el.scrollLeft;
                                    var scrollWidth = $el.scrollWidth;
                                    var scrollLeftWithWidth = scrollLeft + $el.offsetWidth;
                                    return scrollLeftWithWidth >= scrollWidth;
                                }
                            };
                            var elementIsScrollableField = function elementIsScrollableField($el) {
                                var selector = 'textarea, [contenteditable="true"]';
                                return elementHasSelector($el, selector);
                            };
                            var elementIsInputRange = function elementIsInputRange($el) {
                                var selector = 'input[type="range"]';
                                return elementHasSelector($el, selector);
                            };
                            // CONCATENATED MODULE: ./src/scroll-lock.js
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "disablePageScroll", function() {
                                return disablePageScroll;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "enablePageScroll", function() {
                                return enablePageScroll;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "getScrollState", function() {
                                return getScrollState;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "clearQueueScrollLocks", function() {
                                return clearQueueScrollLocks;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "getTargetScrollBarWidth", function() {
                                return scroll_lock_getTargetScrollBarWidth;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "getCurrentTargetScrollBarWidth", function() {
                                return scroll_lock_getCurrentTargetScrollBarWidth;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "getPageScrollBarWidth", function() {
                                return getPageScrollBarWidth;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "getCurrentPageScrollBarWidth", function() {
                                return getCurrentPageScrollBarWidth;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "addScrollableTarget", function() {
                                return scroll_lock_addScrollableTarget;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "removeScrollableTarget", function() {
                                return scroll_lock_removeScrollableTarget;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "addScrollableSelector", function() {
                                return scroll_lock_addScrollableSelector;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "removeScrollableSelector", function() {
                                return scroll_lock_removeScrollableSelector;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "addLockableTarget", function() {
                                return scroll_lock_addLockableTarget;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "addLockableSelector", function() {
                                return scroll_lock_addLockableSelector;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "setFillGapMethod", function() {
                                return scroll_lock_setFillGapMethod;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "addFillGapTarget", function() {
                                return scroll_lock_addFillGapTarget;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "removeFillGapTarget", function() {
                                return scroll_lock_removeFillGapTarget;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "addFillGapSelector", function() {
                                return scroll_lock_addFillGapSelector;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "removeFillGapSelector", function() {
                                return scroll_lock_removeFillGapSelector;
                            });
                            /* harmony export (binding) */
                            __nested_webpack_require_4940__.d(__webpack_exports__, "refillGaps", function() {
                                return refillGaps;
                            });

                            function _objectSpread(target) {
                                for (var i = 1; i < arguments.length; i++) {
                                    var source = arguments[i] != null ? arguments[i] : {};
                                    var ownKeys = Object.keys(source);
                                    if (typeof Object.getOwnPropertySymbols === 'function') {
                                        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                                            return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                                        }));
                                    }
                                    ownKeys.forEach(function(key) {
                                        _defineProperty(target, key, source[key]);
                                    });
                                }
                                return target;
                            }

                            function _defineProperty(obj, key, value) {
                                if (key in obj) {
                                    Object.defineProperty(obj, key, {
                                        value: value,
                                        enumerable: true,
                                        configurable: true,
                                        writable: true
                                    });
                                } else {
                                    obj[key] = value;
                                }
                                return obj;
                            }
                            var FILL_GAP_AVAILABLE_METHODS = ['padding', 'margin', 'width', 'max-width', 'none'];
                            var TOUCH_DIRECTION_DETECT_OFFSET = 3;
                            var state = {
                                scroll: true,
                                queue: 0,
                                scrollableSelectors: ['[data-scroll-lock-scrollable]'],
                                lockableSelectors: ['body', '[data-scroll-lock-lockable]'],
                                fillGapSelectors: ['body', '[data-scroll-lock-fill-gap]', '[data-scroll-lock-lockable]'],
                                fillGapMethod: FILL_GAP_AVAILABLE_METHODS[0],
                                //
                                startTouchY: 0,
                                startTouchX: 0
                            };
                            var disablePageScroll = function disablePageScroll(target) {
                                if (state.queue <= 0) {
                                    state.scroll = false;
                                    scroll_lock_hideLockableOverflow();
                                    fillGaps();
                                }
                                scroll_lock_addScrollableTarget(target);
                                state.queue++;
                            };
                            var enablePageScroll = function enablePageScroll(target) {
                                state.queue > 0 && state.queue--;
                                if (state.queue <= 0) {
                                    state.scroll = true;
                                    scroll_lock_showLockableOverflow();
                                    unfillGaps();
                                }
                                scroll_lock_removeScrollableTarget(target);
                            };
                            var getScrollState = function getScrollState() {
                                return state.scroll;
                            };
                            var clearQueueScrollLocks = function clearQueueScrollLocks() {
                                state.queue = 0;
                            };
                            var scroll_lock_getTargetScrollBarWidth = function getTargetScrollBarWidth($target) {
                                var onlyExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                                if (isElement($target)) {
                                    var currentOverflowYProperty = $target.style.overflowY;
                                    if (onlyExists) {
                                        if (!getScrollState()) {
                                            $target.style.overflowY = $target.getAttribute('data-scroll-lock-saved-overflow-y-property');
                                        }
                                    } else {
                                        $target.style.overflowY = 'scroll';
                                    }
                                    var width = scroll_lock_getCurrentTargetScrollBarWidth($target);
                                    $target.style.overflowY = currentOverflowYProperty;
                                    return width;
                                } else {
                                    return 0;
                                }
                            };
                            var scroll_lock_getCurrentTargetScrollBarWidth = function getCurrentTargetScrollBarWidth($target) {
                                if (isElement($target)) {
                                    if ($target === document.body) {
                                        var documentWidth = document.documentElement.clientWidth;
                                        var windowWidth = window.innerWidth;
                                        var currentWidth = windowWidth - documentWidth;
                                        return currentWidth;
                                    } else {
                                        var borderLeftWidthCurrentProperty = $target.style.borderLeftWidth;
                                        var borderRightWidthCurrentProperty = $target.style.borderRightWidth;
                                        $target.style.borderLeftWidth = '0px';
                                        $target.style.borderRightWidth = '0px';
                                        var _currentWidth = $target.offsetWidth - $target.clientWidth;
                                        $target.style.borderLeftWidth = borderLeftWidthCurrentProperty;
                                        $target.style.borderRightWidth = borderRightWidthCurrentProperty;
                                        return _currentWidth;
                                    }
                                } else {
                                    return 0;
                                }
                            };
                            var getPageScrollBarWidth = function getPageScrollBarWidth() {
                                var onlyExists = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                                return scroll_lock_getTargetScrollBarWidth(document.body, onlyExists);
                            };
                            var getCurrentPageScrollBarWidth = function getCurrentPageScrollBarWidth() {
                                return scroll_lock_getCurrentTargetScrollBarWidth(document.body);
                            };
                            var scroll_lock_addScrollableTarget = function addScrollableTarget(target) {
                                if (target) {
                                    var targets = argumentAsArray(target);
                                    targets.map(function($targets) {
                                        eachNode($targets, function($target) {
                                            if (isElement($target)) {
                                                $target.setAttribute('data-scroll-lock-scrollable', '');
                                            } else {
                                                throwError("\"".concat($target, "\" is not a Element."));
                                            }
                                        });
                                    });
                                }
                            };
                            var scroll_lock_removeScrollableTarget = function removeScrollableTarget(target) {
                                if (target) {
                                    var targets = argumentAsArray(target);
                                    targets.map(function($targets) {
                                        eachNode($targets, function($target) {
                                            if (isElement($target)) {
                                                $target.removeAttribute('data-scroll-lock-scrollable');
                                            } else {
                                                throwError("\"".concat($target, "\" is not a Element."));
                                            }
                                        });
                                    });
                                }
                            };
                            var scroll_lock_addScrollableSelector = function addScrollableSelector(selector) {
                                if (selector) {
                                    var selectors = argumentAsArray(selector);
                                    selectors.map(function(selector) {
                                        state.scrollableSelectors.push(selector);
                                    });
                                }
                            };
                            var scroll_lock_removeScrollableSelector = function removeScrollableSelector(selector) {
                                if (selector) {
                                    var selectors = argumentAsArray(selector);
                                    selectors.map(function(selector) {
                                        state.scrollableSelectors = state.scrollableSelectors.filter(function(sSelector) {
                                            return sSelector !== selector;
                                        });
                                    });
                                }
                            };
                            var scroll_lock_addLockableTarget = function addLockableTarget(target) {
                                if (target) {
                                    var targets = argumentAsArray(target);
                                    targets.map(function($targets) {
                                        eachNode($targets, function($target) {
                                            if (isElement($target)) {
                                                $target.setAttribute('data-scroll-lock-lockable', '');
                                            } else {
                                                throwError("\"".concat($target, "\" is not a Element."));
                                            }
                                        });
                                    });
                                    if (!getScrollState()) {
                                        scroll_lock_hideLockableOverflow();
                                    }
                                }
                            };
                            var scroll_lock_addLockableSelector = function addLockableSelector(selector) {
                                if (selector) {
                                    var selectors = argumentAsArray(selector);
                                    selectors.map(function(selector) {
                                        state.lockableSelectors.push(selector);
                                    });
                                    if (!getScrollState()) {
                                        scroll_lock_hideLockableOverflow();
                                    }
                                    scroll_lock_addFillGapSelector(selector);
                                }
                            };
                            var scroll_lock_setFillGapMethod = function setFillGapMethod(method) {
                                if (method) {
                                    if (FILL_GAP_AVAILABLE_METHODS.indexOf(method) !== -1) {
                                        state.fillGapMethod = method;
                                        refillGaps();
                                    } else {
                                        var methods = FILL_GAP_AVAILABLE_METHODS.join(', ');
                                        throwError("\"".concat(method, "\" method is not available!\nAvailable fill gap methods: ").concat(methods, "."));
                                    }
                                }
                            };
                            var scroll_lock_addFillGapTarget = function addFillGapTarget(target) {
                                if (target) {
                                    var targets = argumentAsArray(target);
                                    targets.map(function($targets) {
                                        eachNode($targets, function($target) {
                                            if (isElement($target)) {
                                                $target.setAttribute('data-scroll-lock-fill-gap', '');
                                                if (!state.scroll) {
                                                    scroll_lock_fillGapTarget($target);
                                                }
                                            } else {
                                                throwError("\"".concat($target, "\" is not a Element."));
                                            }
                                        });
                                    });
                                }
                            };
                            var scroll_lock_removeFillGapTarget = function removeFillGapTarget(target) {
                                if (target) {
                                    var targets = argumentAsArray(target);
                                    targets.map(function($targets) {
                                        eachNode($targets, function($target) {
                                            if (isElement($target)) {
                                                $target.removeAttribute('data-scroll-lock-fill-gap');
                                                if (!state.scroll) {
                                                    scroll_lock_unfillGapTarget($target);
                                                }
                                            } else {
                                                throwError("\"".concat($target, "\" is not a Element."));
                                            }
                                        });
                                    });
                                }
                            };
                            var scroll_lock_addFillGapSelector = function addFillGapSelector(selector) {
                                if (selector) {
                                    var selectors = argumentAsArray(selector);
                                    selectors.map(function(selector) {
                                        if (state.fillGapSelectors.indexOf(selector) === -1) {
                                            state.fillGapSelectors.push(selector);
                                            if (!state.scroll) {
                                                scroll_lock_fillGapSelector(selector);
                                            }
                                        }
                                    });
                                }
                            };
                            var scroll_lock_removeFillGapSelector = function removeFillGapSelector(selector) {
                                if (selector) {
                                    var selectors = argumentAsArray(selector);
                                    selectors.map(function(selector) {
                                        state.fillGapSelectors = state.fillGapSelectors.filter(function(fSelector) {
                                            return fSelector !== selector;
                                        });
                                        if (!state.scroll) {
                                            scroll_lock_unfillGapSelector(selector);
                                        }
                                    });
                                }
                            };
                            var refillGaps = function refillGaps() {
                                if (!state.scroll) {
                                    fillGaps();
                                }
                            };
                            var scroll_lock_hideLockableOverflow = function hideLockableOverflow() {
                                var selector = arrayAsSelector(state.lockableSelectors);
                                scroll_lock_hideLockableOverflowSelector(selector);
                            };
                            var scroll_lock_showLockableOverflow = function showLockableOverflow() {
                                var selector = arrayAsSelector(state.lockableSelectors);
                                scroll_lock_showLockableOverflowSelector(selector);
                            };
                            var scroll_lock_hideLockableOverflowSelector = function hideLockableOverflowSelector(selector) {
                                var $targets = document.querySelectorAll(selector);
                                eachNode($targets, function($target) {
                                    scroll_lock_hideLockableOverflowTarget($target);
                                });
                            };
                            var scroll_lock_showLockableOverflowSelector = function showLockableOverflowSelector(selector) {
                                var $targets = document.querySelectorAll(selector);
                                eachNode($targets, function($target) {
                                    scroll_lock_showLockableOverflowTarget($target);
                                });
                            };
                            var scroll_lock_hideLockableOverflowTarget = function hideLockableOverflowTarget($target) {
                                if (isElement($target) && $target.getAttribute('data-scroll-lock-locked') !== 'true') {
                                    var computedStyle = window.getComputedStyle($target);
                                    $target.setAttribute('data-scroll-lock-saved-overflow-y-property', computedStyle.overflowY);
                                    $target.setAttribute('data-scroll-lock-saved-inline-overflow-property', $target.style.overflow);
                                    $target.setAttribute('data-scroll-lock-saved-inline-overflow-y-property', $target.style.overflowY);
                                    $target.style.overflow = 'hidden';
                                    $target.setAttribute('data-scroll-lock-locked', 'true');
                                }
                            };
                            var scroll_lock_showLockableOverflowTarget = function showLockableOverflowTarget($target) {
                                if (isElement($target) && $target.getAttribute('data-scroll-lock-locked') === 'true') {
                                    $target.style.overflow = $target.getAttribute('data-scroll-lock-saved-inline-overflow-property');
                                    $target.style.overflowY = $target.getAttribute('data-scroll-lock-saved-inline-overflow-y-property');
                                    $target.removeAttribute('data-scroll-lock-saved-overflow-property');
                                    $target.removeAttribute('data-scroll-lock-saved-inline-overflow-property');
                                    $target.removeAttribute('data-scroll-lock-saved-inline-overflow-y-property');
                                    $target.removeAttribute('data-scroll-lock-locked');
                                }
                            };
                            var fillGaps = function fillGaps() {
                                state.fillGapSelectors.map(function(selector) {
                                    scroll_lock_fillGapSelector(selector);
                                });
                            };
                            var unfillGaps = function unfillGaps() {
                                state.fillGapSelectors.map(function(selector) {
                                    scroll_lock_unfillGapSelector(selector);
                                });
                            };
                            var scroll_lock_fillGapSelector = function fillGapSelector(selector) {
                                var $targets = document.querySelectorAll(selector);
                                var isLockable = state.lockableSelectors.indexOf(selector) !== -1;
                                eachNode($targets, function($target) {
                                    scroll_lock_fillGapTarget($target, isLockable);
                                });
                            };
                            var scroll_lock_fillGapTarget = function fillGapTarget($target) {
                                var isLockable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                                if (isElement($target)) {
                                    var scrollBarWidth;
                                    if ($target.getAttribute('data-scroll-lock-lockable') === '' || isLockable) {
                                        scrollBarWidth = scroll_lock_getTargetScrollBarWidth($target, true);
                                    } else {
                                        var $lockableParent = findParentBySelector($target, arrayAsSelector(state.lockableSelectors));
                                        scrollBarWidth = scroll_lock_getTargetScrollBarWidth($lockableParent, true);
                                    }
                                    if ($target.getAttribute('data-scroll-lock-filled-gap') === 'true') {
                                        scroll_lock_unfillGapTarget($target);
                                    }
                                    var computedStyle = window.getComputedStyle($target);
                                    $target.setAttribute('data-scroll-lock-filled-gap', 'true');
                                    $target.setAttribute('data-scroll-lock-current-fill-gap-method', state.fillGapMethod);
                                    if (state.fillGapMethod === 'margin') {
                                        var currentMargin = parseFloat(computedStyle.marginRight);
                                        $target.style.marginRight = "".concat(currentMargin + scrollBarWidth, "px");
                                    } else if (state.fillGapMethod === 'width') {
                                        $target.style.width = "calc(100% - ".concat(scrollBarWidth, "px)");
                                    } else if (state.fillGapMethod === 'max-width') {
                                        $target.style.maxWidth = "calc(100% - ".concat(scrollBarWidth, "px)");
                                    } else if (state.fillGapMethod === 'padding') {
                                        var currentPadding = parseFloat(computedStyle.paddingRight);
                                        $target.style.paddingRight = "".concat(currentPadding + scrollBarWidth, "px");
                                    }
                                }
                            };
                            var scroll_lock_unfillGapSelector = function unfillGapSelector(selector) {
                                var $targets = document.querySelectorAll(selector);
                                eachNode($targets, function($target) {
                                    scroll_lock_unfillGapTarget($target);
                                });
                            };
                            var scroll_lock_unfillGapTarget = function unfillGapTarget($target) {
                                if (isElement($target)) {
                                    if ($target.getAttribute('data-scroll-lock-filled-gap') === 'true') {
                                        var currentFillGapMethod = $target.getAttribute('data-scroll-lock-current-fill-gap-method');
                                        $target.removeAttribute('data-scroll-lock-filled-gap');
                                        $target.removeAttribute('data-scroll-lock-current-fill-gap-method');
                                        if (currentFillGapMethod === 'margin') {
                                            $target.style.marginRight = "";
                                        } else if (currentFillGapMethod === 'width') {
                                            $target.style.width = "";
                                        } else if (currentFillGapMethod === 'max-width') {
                                            $target.style.maxWidth = "";
                                        } else if (currentFillGapMethod === 'padding') {
                                            $target.style.paddingRight = "";
                                        }
                                    }
                                }
                            };
                            var onResize = function onResize(e) {
                                refillGaps();
                            };
                            var onTouchStart = function onTouchStart(e) {
                                if (!state.scroll) {
                                    state.startTouchY = e.touches[0].clientY;
                                    state.startTouchX = e.touches[0].clientX;
                                }
                            };
                            var scroll_lock_onTouchMove = function onTouchMove(e) {
                                if (!state.scroll) {
                                    var startTouchY = state.startTouchY,
                                        startTouchX = state.startTouchX;
                                    var currentClientY = e.touches[0].clientY;
                                    var currentClientX = e.touches[0].clientX;
                                    if (e.touches.length < 2) {
                                        var selector = arrayAsSelector(state.scrollableSelectors);
                                        var direction = {
                                            up: startTouchY < currentClientY,
                                            down: startTouchY > currentClientY,
                                            left: startTouchX < currentClientX,
                                            right: startTouchX > currentClientX
                                        };
                                        var directionWithOffset = {
                                            up: startTouchY + TOUCH_DIRECTION_DETECT_OFFSET < currentClientY,
                                            down: startTouchY - TOUCH_DIRECTION_DETECT_OFFSET > currentClientY,
                                            left: startTouchX + TOUCH_DIRECTION_DETECT_OFFSET < currentClientX,
                                            right: startTouchX - TOUCH_DIRECTION_DETECT_OFFSET > currentClientX
                                        };
                                        var handle = function handle($el) {
                                            var skip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                                            if ($el) {
                                                var parentScrollableEl = findParentBySelector($el, selector, false);
                                                if (elementIsInputRange($el)) {
                                                    return false;
                                                }
                                                if (skip || elementIsScrollableField($el) && findParentBySelector($el, selector) || elementHasSelector($el, selector)) {
                                                    var prevent = false;
                                                    if (elementScrollLeftOnStart($el) && elementScrollLeftOnEnd($el)) {
                                                        if (direction.up && elementScrollTopOnStart($el) || direction.down && elementScrollTopOnEnd($el)) {
                                                            prevent = true;
                                                        }
                                                    } else if (elementScrollTopOnStart($el) && elementScrollTopOnEnd($el)) {
                                                        if (direction.left && elementScrollLeftOnStart($el) || direction.right && elementScrollLeftOnEnd($el)) {
                                                            prevent = true;
                                                        }
                                                    } else if (directionWithOffset.up && elementScrollTopOnStart($el) || directionWithOffset.down && elementScrollTopOnEnd($el) || directionWithOffset.left && elementScrollLeftOnStart($el) || directionWithOffset.right && elementScrollLeftOnEnd($el)) {
                                                        prevent = true;
                                                    }
                                                    if (prevent) {
                                                        if (parentScrollableEl) {
                                                            handle(parentScrollableEl, true);
                                                        } else {
                                                            if (e.cancelable) {
                                                                e.preventDefault();
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    handle(parentScrollableEl);
                                                }
                                            } else {
                                                if (e.cancelable) {
                                                    e.preventDefault();
                                                }
                                            }
                                        };
                                        handle(e.target);
                                    }
                                }
                            };
                            var onTouchEnd = function onTouchEnd(e) {
                                if (!state.scroll) {
                                    state.startTouchY = 0;
                                    state.startTouchX = 0;
                                }
                            };
                            if (typeof window !== 'undefined') {
                                window.addEventListener('resize', onResize);
                            }
                            if (typeof document !== 'undefined') {
                                document.addEventListener('touchstart', onTouchStart);
                                document.addEventListener('touchmove', scroll_lock_onTouchMove, {
                                    passive: false
                                });
                                document.addEventListener('touchend', onTouchEnd);
                            }
                            var deprecatedMethods = {
                                hide: function hide(target) {
                                    throwError('"hide" is deprecated! Use "disablePageScroll" instead. \n https://github.com/FL3NKEY/scroll-lock#disablepagescrollscrollabletarget');
                                    disablePageScroll(target);
                                },
                                show: function show(target) {
                                    throwError('"show" is deprecated! Use "enablePageScroll" instead. \n https://github.com/FL3NKEY/scroll-lock#enablepagescrollscrollabletarget');
                                    enablePageScroll(target);
                                },
                                toggle: function toggle(target) {
                                    throwError('"toggle" is deprecated! Do not use it.');
                                    if (getScrollState()) {
                                        disablePageScroll();
                                    } else {
                                        enablePageScroll(target);
                                    }
                                },
                                getState: function getState() {
                                    throwError('"getState" is deprecated! Use "getScrollState" instead. \n https://github.com/FL3NKEY/scroll-lock#getscrollstate');
                                    return getScrollState();
                                },
                                getWidth: function getWidth() {
                                    throwError('"getWidth" is deprecated! Use "getPageScrollBarWidth" instead. \n https://github.com/FL3NKEY/scroll-lock#getpagescrollbarwidth');
                                    return getPageScrollBarWidth();
                                },
                                getCurrentWidth: function getCurrentWidth() {
                                    throwError('"getCurrentWidth" is deprecated! Use "getCurrentPageScrollBarWidth" instead. \n https://github.com/FL3NKEY/scroll-lock#getcurrentpagescrollbarwidth');
                                    return getCurrentPageScrollBarWidth();
                                },
                                setScrollableTargets: function setScrollableTargets(target) {
                                    throwError('"setScrollableTargets" is deprecated! Use "addScrollableTarget" instead. \n https://github.com/FL3NKEY/scroll-lock#addscrollabletargetscrollabletarget');
                                    scroll_lock_addScrollableTarget(target);
                                },
                                setFillGapSelectors: function setFillGapSelectors(selector) {
                                    throwError('"setFillGapSelectors" is deprecated! Use "addFillGapSelector" instead. \n https://github.com/FL3NKEY/scroll-lock#addfillgapselectorfillgapselector');
                                    scroll_lock_addFillGapSelector(selector);
                                },
                                setFillGapTargets: function setFillGapTargets(target) {
                                    throwError('"setFillGapTargets" is deprecated! Use "addFillGapTarget" instead. \n https://github.com/FL3NKEY/scroll-lock#addfillgaptargetfillgaptarget');
                                    scroll_lock_addFillGapTarget(target);
                                },
                                clearQueue: function clearQueue() {
                                    throwError('"clearQueue" is deprecated! Use "clearQueueScrollLocks" instead. \n https://github.com/FL3NKEY/scroll-lock#clearqueuescrolllocks');
                                    clearQueueScrollLocks();
                                }
                            };
                            var scrollLock = _objectSpread({
                                disablePageScroll: disablePageScroll,
                                enablePageScroll: enablePageScroll,
                                getScrollState: getScrollState,
                                clearQueueScrollLocks: clearQueueScrollLocks,
                                getTargetScrollBarWidth: scroll_lock_getTargetScrollBarWidth,
                                getCurrentTargetScrollBarWidth: scroll_lock_getCurrentTargetScrollBarWidth,
                                getPageScrollBarWidth: getPageScrollBarWidth,
                                getCurrentPageScrollBarWidth: getCurrentPageScrollBarWidth,
                                addScrollableSelector: scroll_lock_addScrollableSelector,
                                removeScrollableSelector: scroll_lock_removeScrollableSelector,
                                addScrollableTarget: scroll_lock_addScrollableTarget,
                                removeScrollableTarget: scroll_lock_removeScrollableTarget,
                                addLockableSelector: scroll_lock_addLockableSelector,
                                addLockableTarget: scroll_lock_addLockableTarget,
                                addFillGapSelector: scroll_lock_addFillGapSelector,
                                removeFillGapSelector: scroll_lock_removeFillGapSelector,
                                addFillGapTarget: scroll_lock_addFillGapTarget,
                                removeFillGapTarget: scroll_lock_removeFillGapTarget,
                                setFillGapMethod: scroll_lock_setFillGapMethod,
                                refillGaps: refillGaps,
                                _state: state
                            }, deprecatedMethods);
                            /* harmony default export */
                            var scroll_lock = __webpack_exports__["default"] = (scrollLock);
                            /***/
                        })
                        /******/
                    ])["default"];
                });


                /***/
            }),

        /***/
        "./node_modules/ua-parser-js/src/ua-parser.js":
            /*!****************************************************!*\
              !*** ./node_modules/ua-parser-js/src/ua-parser.js ***!
              \****************************************************/
            /***/
            (function(module, exports, __webpack_require__) {

                var __WEBPACK_AMD_DEFINE_RESULT__;
                /////////////////////////////////////////////////////////////////////////////////
                /* UAParser.js v1.0.2
                   Copyright  2012-2021 Faisal Salman <f@faisalman.com>
                   MIT License */
                /*
Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.
Supports browser & node.js environment.
Demo   : https://faisalman.github.io/ua-parser-js
Source : https://github.com/faisalman/ua-parser-js */
                /////////////////////////////////////////////////////////////////////////////////
                (function(window, undefined) {
                    'use strict';
                    //////////////
                    // Constants
                    /////////////
                    var LIBVERSION = '1.0.2',
                        EMPTY = '',
                        UNKNOWN = '?',
                        FUNC_TYPE = 'function',
                        UNDEF_TYPE = 'undefined',
                        OBJ_TYPE = 'object',
                        STR_TYPE = 'string',
                        MAJOR = 'major',
                        MODEL = 'model',
                        NAME = 'name',
                        TYPE = 'type',
                        VENDOR = 'vendor',
                        VERSION = 'version',
                        ARCHITECTURE = 'architecture',
                        CONSOLE = 'console',
                        MOBILE = 'mobile',
                        TABLET = 'tablet',
                        SMARTTV = 'smarttv',
                        WEARABLE = 'wearable',
                        EMBEDDED = 'embedded',
                        UA_MAX_LENGTH = 255;
                    var AMAZON = 'Amazon',
                        APPLE = 'Apple',
                        ASUS = 'ASUS',
                        BLACKBERRY = 'BlackBerry',
                        BROWSER = 'Browser',
                        CHROME = 'Chrome',
                        EDGE = 'Edge',
                        FIREFOX = 'Firefox',
                        GOOGLE = 'Google',
                        HUAWEI = 'Huawei',
                        LG = 'LG',
                        MICROSOFT = 'Microsoft',
                        MOTOROLA = 'Motorola',
                        OPERA = 'Opera',
                        SAMSUNG = 'Samsung',
                        SONY = 'Sony',
                        XIAOMI = 'Xiaomi',
                        ZEBRA = 'Zebra',
                        FACEBOOK = 'Facebook';
                    ///////////
                    // Helper
                    //////////
                    var extend = function(regexes, extensions) {
                            var mergedRegexes = {};
                            for (var i in regexes) {
                                if (extensions[i] && extensions[i].length % 2 === 0) {
                                    mergedRegexes[i] = extensions[i].concat(regexes[i]);
                                } else {
                                    mergedRegexes[i] = regexes[i];
                                }
                            }
                            return mergedRegexes;
                        },
                        enumerize = function(arr) {
                            var enums = {};
                            for (var i = 0; i < arr.length; i++) {
                                enums[arr[i].toUpperCase()] = arr[i];
                            }
                            return enums;
                        },
                        has = function(str1, str2) {
                            return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
                        },
                        lowerize = function(str) {
                            return str.toLowerCase();
                        },
                        majorize = function(version) {
                            return typeof(version) === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split('.')[0] : undefined;
                        },
                        trim = function(str, len) {
                            if (typeof(str) === STR_TYPE) {
                                str = str.replace(/^\s\s*/, EMPTY).replace(/\s\s*$/, EMPTY);
                                return typeof(len) === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
                            }
                        };
                    ///////////////
                    // Map helper
                    //////////////
                    var rgxMapper = function(ua, arrays) {
                            var i = 0,
                                j, k, p, q, matches, match;
                            // loop through all regexes maps
                            while (i < arrays.length && !matches) {
                                var regex = arrays[i], // even sequence (0,2,4,..)
                                    props = arrays[i + 1]; // odd sequence (1,3,5,..)
                                j = k = 0;
                                // try matching uastring with regexes
                                while (j < regex.length && !matches) {
                                    matches = regex[j++].exec(ua);
                                    if (!!matches) {
                                        for (p = 0; p < props.length; p++) {
                                            match = matches[++k];
                                            q = props[p];
                                            // check if given property is actually array
                                            if (typeof q === OBJ_TYPE && q.length > 0) {
                                                if (q.length === 2) {
                                                    if (typeof q[1] == FUNC_TYPE) {
                                                        // assign modified match
                                                        this[q[0]] = q[1].call(this, match);
                                                    } else {
                                                        // assign given value, ignore regex match
                                                        this[q[0]] = q[1];
                                                    }
                                                } else if (q.length === 3) {
                                                    // check whether function or regex
                                                    if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                                        // call function (usually string mapper)
                                                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined;
                                                    } else {
                                                        // sanitize match using given regex
                                                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined;
                                                    }
                                                } else if (q.length === 4) {
                                                    this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined;
                                                }
                                            } else {
                                                this[q] = match ? match : undefined;
                                            }
                                        }
                                    }
                                }
                                i += 2;
                            }
                        },
                        strMapper = function(str, map) {
                            for (var i in map) {
                                // check if current value is array
                                if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                                    for (var j = 0; j < map[i].length; j++) {
                                        if (has(map[i][j], str)) {
                                            return (i === UNKNOWN) ? undefined : i;
                                        }
                                    }
                                } else if (has(map[i], str)) {
                                    return (i === UNKNOWN) ? undefined : i;
                                }
                            }
                            return str;
                        };
                    ///////////////
                    // String map
                    //////////////
                    // Safari < 3.0
                    var oldSafariMap = {
                            '1.0': '/8',
                            '1.2': '/1',
                            '1.3': '/3',
                            '2.0': '/412',
                            '2.0.2': '/416',
                            '2.0.3': '/417',
                            '2.0.4': '/419',
                            '?': '/'
                        },
                        windowsVersionMap = {
                            'ME': '4.90',
                            'NT 3.11': 'NT3.51',
                            'NT 4.0': 'NT4.0',
                            '2000': 'NT 5.0',
                            'XP': ['NT 5.1', 'NT 5.2'],
                            'Vista': 'NT 6.0',
                            '7': 'NT 6.1',
                            '8': 'NT 6.2',
                            '8.1': 'NT 6.3',
                            '10': ['NT 6.4', 'NT 10.0'],
                            'RT': 'ARM'
                        };
                    //////////////
                    // Regex map
                    /////////////
                    var regexes = {
                        browser: [
                            [
                                /\b(?:crmo|crios)\/([\w\.]+)/i // Chrome for Android/iOS
                            ],
                            [VERSION, [NAME, 'Chrome']],
                            [
                                /edg(?:e|ios|a)?\/([\w\.]+)/i // Microsoft Edge
                            ],
                            [VERSION, [NAME, 'Edge']],
                            [
                                // Presto based
                                /(opera mini)\/([-\w\.]+)/i,
                                /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
                                /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i // Opera
                            ],
                            [NAME, VERSION],
                            [
                                /opios[\/ ]+([\w\.]+)/i // Opera mini on iphone >= 8.0
                            ],
                            [VERSION, [NAME, OPERA + ' Mini']],
                            [
                                /\bopr\/([\w\.]+)/i // Opera Webkit
                            ],
                            [VERSION, [NAME, OPERA]],
                            [
                                // Mixed
                                /(kindle)\/([\w\.]+)/i,
                                /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
                                // Trident based
                                /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,
                                /(ba?idubrowser)[\/ ]?([\w\.]+)/i,
                                /(?:ms|\()(ie) ([\w\.]+)/i,
                                // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
                                /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq)\/([-\w\.]+)/i,
                                // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
                                /(weibo)__([\d\.]+)/i // Weibo
                            ],
                            [NAME, VERSION],
                            [
                                /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i // UCBrowser
                            ],
                            [VERSION, [NAME, 'UC' + BROWSER]],
                            [
                                /\bqbcore\/([\w\.]+)/i // WeChat Desktop for Windows Built-in Browser
                            ],
                            [VERSION, [NAME, 'WeChat(Win) Desktop']],
                            [
                                /micromessenger\/([\w\.]+)/i // WeChat
                            ],
                            [VERSION, [NAME, 'WeChat']],
                            [
                                /konqueror\/([\w\.]+)/i // Konqueror
                            ],
                            [VERSION, [NAME, 'Konqueror']],
                            [
                                /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i // IE11
                            ],
                            [VERSION, [NAME, 'IE']],
                            [
                                /yabrowser\/([\w\.]+)/i // Yandex
                            ],
                            [VERSION, [NAME, 'Yandex']],
                            [
                                /(avast|avg)\/([\w\.]+)/i // Avast/AVG Secure Browser
                            ],
                            [
                                [NAME, /(.+)/, '$1 Secure ' + BROWSER], VERSION
                            ],
                            [
                                /\bfocus\/([\w\.]+)/i // Firefox Focus
                            ],
                            [VERSION, [NAME, FIREFOX + ' Focus']],
                            [
                                /\bopt\/([\w\.]+)/i // Opera Touch
                            ],
                            [VERSION, [NAME, OPERA + ' Touch']],
                            [
                                /coc_coc\w+\/([\w\.]+)/i // Coc Coc Browser
                            ],
                            [VERSION, [NAME, 'Coc Coc']],
                            [
                                /dolfin\/([\w\.]+)/i // Dolphin
                            ],
                            [VERSION, [NAME, 'Dolphin']],
                            [
                                /coast\/([\w\.]+)/i // Opera Coast
                            ],
                            [VERSION, [NAME, OPERA + ' Coast']],
                            [
                                /miuibrowser\/([\w\.]+)/i // MIUI Browser
                            ],
                            [VERSION, [NAME, 'MIUI ' + BROWSER]],
                            [
                                /fxios\/([-\w\.]+)/i // Firefox for iOS
                            ],
                            [VERSION, [NAME, FIREFOX]],
                            [
                                /\bqihu|(qi?ho?o?|360)browser/i // 360
                            ],
                            [
                                [NAME, '360 ' + BROWSER]
                            ],
                            [
                                /(oculus|samsung|sailfish)browser\/([\w\.]+)/i
                            ],
                            [
                                [NAME, /(.+)/, '$1 ' + BROWSER], VERSION
                            ],
                            [
                                /(comodo_dragon)\/([\w\.]+)/i // Comodo Dragon
                            ],
                            [
                                [NAME, /_/g, ' '], VERSION
                            ],
                            [
                                /(electron)\/([\w\.]+) safari/i,
                                /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
                                /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i // QQBrowser/Baidu App/2345 Browser
                            ],
                            [NAME, VERSION],
                            [
                                /(metasr)[\/ ]?([\w\.]+)/i,
                                /(lbbrowser)/i // LieBao Browser
                            ],
                            [NAME],
                            [
                                // WebView
                                /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i // Facebook App for iOS & Android
                            ],
                            [
                                [NAME, FACEBOOK], VERSION
                            ],
                            [
                                /safari (line)\/([\w\.]+)/i,
                                /\b(line)\/([\w\.]+)\/iab/i,
                                /(chromium|instagram)[\/ ]([-\w\.]+)/i // Chromium/Instagram
                            ],
                            [NAME, VERSION],
                            [
                                /\bgsa\/([\w\.]+) .*safari\//i // Google Search Appliance on iOS
                            ],
                            [VERSION, [NAME, 'GSA']],
                            [
                                /headlesschrome(?:\/([\w\.]+)| )/i // Chrome Headless
                            ],
                            [VERSION, [NAME, CHROME + ' Headless']],
                            [
                                / wv\).+(chrome)\/([\w\.]+)/i // Chrome WebView
                            ],
                            [
                                [NAME, CHROME + ' WebView'], VERSION
                            ],
                            [
                                /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i // Android Browser
                            ],
                            [VERSION, [NAME, 'Android ' + BROWSER]],
                            [
                                /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i // Chrome/OmniWeb/Arora/Tizen/Nokia
                            ],
                            [NAME, VERSION],
                            [
                                /version\/([\w\.]+) .*mobile\/\w+ (safari)/i // Mobile Safari
                            ],
                            [VERSION, [NAME, 'Mobile Safari']],
                            [
                                /version\/([\w\.]+) .*(mobile ?safari|safari)/i // Safari & Safari Mobile
                            ],
                            [VERSION, NAME],
                            [
                                /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i // Safari < 3.0
                            ],
                            [NAME, [VERSION, strMapper, oldSafariMap]],
                            [
                                /(webkit|khtml)\/([\w\.]+)/i
                            ],
                            [NAME, VERSION],
                            [
                                // Gecko based
                                /(navigator|netscape\d?)\/([-\w\.]+)/i // Netscape
                            ],
                            [
                                [NAME, 'Netscape'], VERSION
                            ],
                            [
                                /mobile vr; rv:([\w\.]+)\).+firefox/i // Firefox Reality
                            ],
                            [VERSION, [NAME, FIREFOX + ' Reality']],
                            [
                                /ekiohf.+(flow)\/([\w\.]+)/i,
                                /(swiftfox)/i,
                                /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
                                // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
                                /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                                // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
                                /(firefox)\/([\w\.]+)/i,
                                /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
                                // Other
                                /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                                // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
                                /(links) \(([\w\.]+)/i // Links
                            ],
                            [NAME, VERSION]
                        ],
                        cpu: [
                            [
                                /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i // AMD64 (x64)
                            ],
                            [
                                [ARCHITECTURE, 'amd64']
                            ],
                            [
                                /(ia32(?=;))/i // IA32 (quicktime)
                            ],
                            [
                                [ARCHITECTURE, lowerize]
                            ],
                            [
                                /((?:i[346]|x)86)[;\)]/i // IA32 (x86)
                            ],
                            [
                                [ARCHITECTURE, 'ia32']
                            ],
                            [
                                /\b(aarch64|arm(v?8e?l?|_?64))\b/i // ARM64
                            ],
                            [
                                [ARCHITECTURE, 'arm64']
                            ],
                            [
                                /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i // ARMHF
                            ],
                            [
                                [ARCHITECTURE, 'armhf']
                            ],
                            [
                                // PocketPC mistakenly identified as PowerPC
                                /windows (ce|mobile); ppc;/i
                            ],
                            [
                                [ARCHITECTURE, 'arm']
                            ],
                            [
                                /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i // PowerPC
                            ],
                            [
                                [ARCHITECTURE, /ower/, EMPTY, lowerize]
                            ],
                            [
                                /(sun4\w)[;\)]/i // SPARC
                            ],
                            [
                                [ARCHITECTURE, 'sparc']
                            ],
                            [
                                /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
                                // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
                            ],
                            [
                                [ARCHITECTURE, lowerize]
                            ]
                        ],
                        device: [
                            [
                                //////////////////////////
                                // MOBILES & TABLETS
                                // Ordered by popularity
                                /////////////////////////
                                // Samsung
                                /\b(sch-i[89]0\d|shw-m380s|sm-[pt]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
                            ],
                            [MODEL, [VENDOR, SAMSUNG],
                                [TYPE, TABLET]
                            ],
                            [
                                /\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i,
                                /samsung[- ]([-\w]+)/i,
                                /sec-(sgh\w+)/i
                            ],
                            [MODEL, [VENDOR, SAMSUNG],
                                [TYPE, MOBILE]
                            ],
                            [
                                // Apple
                                /\((ip(?:hone|od)[\w ]*);/i // iPod/iPhone
                            ],
                            [MODEL, [VENDOR, APPLE],
                                [TYPE, MOBILE]
                            ],
                            [
                                /\((ipad);[-\w\),; ]+apple/i,
                                /applecoremedia\/[\w\.]+ \((ipad)/i,
                                /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
                            ],
                            [MODEL, [VENDOR, APPLE],
                                [TYPE, TABLET]
                            ],
                            [
                                // Huawei
                                /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
                            ],
                            [MODEL, [VENDOR, HUAWEI],
                                [TYPE, TABLET]
                            ],
                            [
                                /(?:huawei|honor)([-\w ]+)[;\)]/i,
                                /\b(nexus 6p|\w{2,4}-[atu]?[ln][01259x][012359][an]?)\b(?!.+d\/s)/i
                            ],
                            [MODEL, [VENDOR, HUAWEI],
                                [TYPE, MOBILE]
                            ],
                            [
                                // Xiaomi
                                /\b(poco[\w ]+)(?: bui|\))/i,
                                /\b; (\w+) build\/hm\1/i,
                                /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
                                /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
                                /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i // Xiaomi Mi
                            ],
                            [
                                [MODEL, /_/g, ' '],
                                [VENDOR, XIAOMI],
                                [TYPE, MOBILE]
                            ],
                            [
                                /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i // Mi Pad tablets
                            ],
                            [
                                [MODEL, /_/g, ' '],
                                [VENDOR, XIAOMI],
                                [TYPE, TABLET]
                            ],
                            [
                                // OPPO
                                /; (\w+) bui.+ oppo/i,
                                /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
                            ],
                            [MODEL, [VENDOR, 'OPPO'],
                                [TYPE, MOBILE]
                            ],
                            [
                                // Vivo
                                /vivo (\w+)(?: bui|\))/i,
                                /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
                            ],
                            [MODEL, [VENDOR, 'Vivo'],
                                [TYPE, MOBILE]
                            ],
                            [
                                // Realme
                                /\b(rmx[12]\d{3})(?: bui|;|\))/i
                            ],
                            [MODEL, [VENDOR, 'Realme'],
                                [TYPE, MOBILE]
                            ],
                            [
                                // Motorola
                                /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
                                /\bmot(?:orola)?[- ](\w*)/i,
                                /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
                            ],
                            [MODEL, [VENDOR, MOTOROLA],
                                [TYPE, MOBILE]
                            ],
                            [
                                /\b(mz60\d|xoom[2 ]{0,2}) build\//i
                            ],
                            [MODEL, [VENDOR, MOTOROLA],
                                [TYPE, TABLET]
                            ],
                            [
                                // LG
                                /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
                            ],
                            [MODEL, [VENDOR, LG],
                                [TYPE, TABLET]
                            ],
                            [
                                /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
                                /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
                                /\blg-?([\d\w]+) bui/i
                            ],
                            [MODEL, [VENDOR, LG],
                                [TYPE, MOBILE]
                            ],
                            [
                                // Lenovo
                                /(ideatab[-\w ]+)/i,
                                /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
                            ],
                            [MODEL, [VENDOR, 'Lenovo'],
                                [TYPE, TABLET]
                            ],
                            [
                                // Nokia
                                /(?:maemo|nokia).*(n900|lumia \d+)/i,
                                /nokia[-_ ]?([-\w\.]*)/i
                            ],
                            [
                                [MODEL, /_/g, ' '],
                                [VENDOR, 'Nokia'],
                                [TYPE, MOBILE]
                            ],
                            [
                                // Google
                                /(pixel c)\b/i // Google Pixel C
                            ],
                            [MODEL, [VENDOR, GOOGLE],
                                [TYPE, TABLET]
                            ],
                            [
                                /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i // Google Pixel
                            ],
                            [MODEL, [VENDOR, GOOGLE],
                                [TYPE, MOBILE]
                            ],
                            [
                                // Sony
                                /droid.+ ([c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
                            ],
                            [MODEL, [VENDOR, SONY],
                                [TYPE, MOBILE]
                            ],
                            [
                                /sony tablet [ps]/i,
                                /\b(?:sony)?sgp\w+(?: bui|\))/i
                            ],
                            [
                                [MODEL, 'Xperia Tablet'],
                                [VENDOR, SONY],
                                [TYPE, TABLET]
                            ],
                            [
                                // OnePlus
                                / (kb2005|in20[12]5|be20[12][59])\b/i,
                                /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
                            ],
                            [MODEL, [VENDOR, 'OnePlus'],
                                [TYPE, MOBILE]
                            ],
                            [
                                // Amazon
                                /(alexa)webm/i,
                                /(kf[a-z]{2}wi)( bui|\))/i,
                                /(kf[a-z]+)( bui|\)).+silk\//i // Kindle Fire HD
                            ],
                            [MODEL, [VENDOR, AMAZON],
                                [TYPE, TABLET]
                            ],
                            [
                                /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i // Fire Phone
                            ],
                            [
                                [MODEL, /(.+)/g, 'Fire Phone $1'],
                                [VENDOR, AMAZON],
                                [TYPE, MOBILE]
                            ],
                            [
                                // BlackBerry
                                /(playbook);[-\w\),; ]+(rim)/i // BlackBerry PlayBook
                            ],
                            [MODEL, VENDOR, [TYPE, TABLET]],
                            [
                                /\b((?:bb[a-f]|st[hv])100-\d)/i,
                                /\(bb10; (\w+)/i // BlackBerry 10
                            ],
                            [MODEL, [VENDOR, BLACKBERRY],
                                [TYPE, MOBILE]
                            ],
                            [
                                // Asus
                                /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
                            ],
                            [MODEL, [VENDOR, ASUS],
                                [TYPE, TABLET]
                            ],
                            [
                                / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
                            ],
                            [MODEL, [VENDOR, ASUS],
                                [TYPE, MOBILE]
                            ],
                            [
                                // HTC
                                /(nexus 9)/i // HTC Nexus 9
                            ],
                            [MODEL, [VENDOR, 'HTC'],
                                [TYPE, TABLET]
                            ],
                            [
                                /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
                                // ZTE
                                /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
                                /(alcatel|geeksphone|nexian|panasonic|sony)[-_ ]?([-\w]*)/i // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
                            ],
                            [VENDOR, [MODEL, /_/g, ' '],
                                [TYPE, MOBILE]
                            ],
                            [
                                // Acer
                                /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
                            ],
                            [MODEL, [VENDOR, 'Acer'],
                                [TYPE, TABLET]
                            ],
                            [
                                // Meizu
                                /droid.+; (m[1-5] note) bui/i,
                                /\bmz-([-\w]{2,})/i
                            ],
                            [MODEL, [VENDOR, 'Meizu'],
                                [TYPE, MOBILE]
                            ],
                            [
                                // Sharp
                                /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
                            ],
                            [MODEL, [VENDOR, 'Sharp'],
                                [TYPE, MOBILE]
                            ],
                            [
                                // MIXED
                                /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
                                // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
                                /(hp) ([\w ]+\w)/i,
                                /(asus)-?(\w+)/i,
                                /(microsoft); (lumia[\w ]+)/i,
                                /(lenovo)[-_ ]?([-\w]+)/i,
                                /(jolla)/i,
                                /(oppo) ?([\w ]+) bui/i // OPPO
                            ],
                            [VENDOR, MODEL, [TYPE, MOBILE]],
                            [
                                /(archos) (gamepad2?)/i,
                                /(hp).+(touchpad(?!.+tablet)|tablet)/i,
                                /(kindle)\/([\w\.]+)/i,
                                /(nook)[\w ]+build\/(\w+)/i,
                                /(dell) (strea[kpr\d ]*[\dko])/i,
                                /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
                                /(trinity)[- ]*(t\d{3}) bui/i,
                                /(gigaset)[- ]+(q\w{1,9}) bui/i,
                                /(vodafone) ([\w ]+)(?:\)| bui)/i // Vodafone
                            ],
                            [VENDOR, MODEL, [TYPE, TABLET]],
                            [
                                /(surface duo)/i // Surface Duo
                            ],
                            [MODEL, [VENDOR, MICROSOFT],
                                [TYPE, TABLET]
                            ],
                            [
                                /droid [\d\.]+; (fp\du?)(?: b|\))/i // Fairphone
                            ],
                            [MODEL, [VENDOR, 'Fairphone'],
                                [TYPE, MOBILE]
                            ],
                            [
                                /(u304aa)/i // AT&T
                            ],
                            [MODEL, [VENDOR, 'AT&T'],
                                [TYPE, MOBILE]
                            ],
                            [
                                /\bsie-(\w*)/i // Siemens
                            ],
                            [MODEL, [VENDOR, 'Siemens'],
                                [TYPE, MOBILE]
                            ],
                            [
                                /\b(rct\w+) b/i // RCA Tablets
                            ],
                            [MODEL, [VENDOR, 'RCA'],
                                [TYPE, TABLET]
                            ],
                            [
                                /\b(venue[\d ]{2,7}) b/i // Dell Venue Tablets
                            ],
                            [MODEL, [VENDOR, 'Dell'],
                                [TYPE, TABLET]
                            ],
                            [
                                /\b(q(?:mv|ta)\w+) b/i // Verizon Tablet
                            ],
                            [MODEL, [VENDOR, 'Verizon'],
                                [TYPE, TABLET]
                            ],
                            [
                                /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i // Barnes & Noble Tablet
                            ],
                            [MODEL, [VENDOR, 'Barnes & Noble'],
                                [TYPE, TABLET]
                            ],
                            [
                                /\b(tm\d{3}\w+) b/i
                            ],
                            [MODEL, [VENDOR, 'NuVision'],
                                [TYPE, TABLET]
                            ],
                            [
                                /\b(k88) b/i // ZTE K Series Tablet
                            ],
                            [MODEL, [VENDOR, 'ZTE'],
                                [TYPE, TABLET]
                            ],
                            [
                                /\b(nx\d{3}j) b/i // ZTE Nubia
                            ],
                            [MODEL, [VENDOR, 'ZTE'],
                                [TYPE, MOBILE]
                            ],
                            [
                                /\b(gen\d{3}) b.+49h/i // Swiss GEN Mobile
                            ],
                            [MODEL, [VENDOR, 'Swiss'],
                                [TYPE, MOBILE]
                            ],
                            [
                                /\b(zur\d{3}) b/i // Swiss ZUR Tablet
                            ],
                            [MODEL, [VENDOR, 'Swiss'],
                                [TYPE, TABLET]
                            ],
                            [
                                /\b((zeki)?tb.*\b) b/i // Zeki Tablets
                            ],
                            [MODEL, [VENDOR, 'Zeki'],
                                [TYPE, TABLET]
                            ],
                            [
                                /\b([yr]\d{2}) b/i,
                                /\b(dragon[- ]+touch |dt)(\w{5}) b/i // Dragon Touch Tablet
                            ],
                            [
                                [VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]
                            ],
                            [
                                /\b(ns-?\w{0,9}) b/i // Insignia Tablets
                            ],
                            [MODEL, [VENDOR, 'Insignia'],
                                [TYPE, TABLET]
                            ],
                            [
                                /\b((nxa|next)-?\w{0,9}) b/i // NextBook Tablets
                            ],
                            [MODEL, [VENDOR, 'NextBook'],
                                [TYPE, TABLET]
                            ],
                            [
                                /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i // Voice Xtreme Phones
                            ],
                            [
                                [VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]
                            ],
                            [
                                /\b(lvtel\-)?(v1[12]) b/i // LvTel Phones
                            ],
                            [
                                [VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]
                            ],
                            [
                                /\b(ph-1) /i // Essential PH-1
                            ],
                            [MODEL, [VENDOR, 'Essential'],
                                [TYPE, MOBILE]
                            ],
                            [
                                /\b(v(100md|700na|7011|917g).*\b) b/i // Envizen Tablets
                            ],
                            [MODEL, [VENDOR, 'Envizen'],
                                [TYPE, TABLET]
                            ],
                            [
                                /\b(trio[-\w\. ]+) b/i // MachSpeed Tablets
                            ],
                            [MODEL, [VENDOR, 'MachSpeed'],
                                [TYPE, TABLET]
                            ],
                            [
                                /\btu_(1491) b/i // Rotor Tablets
                            ],
                            [MODEL, [VENDOR, 'Rotor'],
                                [TYPE, TABLET]
                            ],
                            [
                                /(shield[\w ]+) b/i // Nvidia Shield Tablets
                            ],
                            [MODEL, [VENDOR, 'Nvidia'],
                                [TYPE, TABLET]
                            ],
                            [
                                /(sprint) (\w+)/i // Sprint Phones
                            ],
                            [VENDOR, MODEL, [TYPE, MOBILE]],
                            [
                                /(kin\.[onetw]{3})/i // Microsoft Kin
                            ],
                            [
                                [MODEL, /\./g, ' '],
                                [VENDOR, MICROSOFT],
                                [TYPE, MOBILE]
                            ],
                            [
                                /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i // Zebra
                            ],
                            [MODEL, [VENDOR, ZEBRA],
                                [TYPE, TABLET]
                            ],
                            [
                                /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
                            ],
                            [MODEL, [VENDOR, ZEBRA],
                                [TYPE, MOBILE]
                            ],
                            [
                                ///////////////////
                                // CONSOLES
                                ///////////////////
                                /(ouya)/i,
                                /(nintendo) ([wids3utch]+)/i // Nintendo
                            ],
                            [VENDOR, MODEL, [TYPE, CONSOLE]],
                            [
                                /droid.+; (shield) bui/i // Nvidia
                            ],
                            [MODEL, [VENDOR, 'Nvidia'],
                                [TYPE, CONSOLE]
                            ],
                            [
                                /(playstation [345portablevi]+)/i // Playstation
                            ],
                            [MODEL, [VENDOR, SONY],
                                [TYPE, CONSOLE]
                            ],
                            [
                                /\b(xbox(?: one)?(?!; xbox))[\); ]/i // Microsoft Xbox
                            ],
                            [MODEL, [VENDOR, MICROSOFT],
                                [TYPE, CONSOLE]
                            ],
                            [
                                ///////////////////
                                // SMARTTVS
                                ///////////////////
                                /smart-tv.+(samsung)/i // Samsung
                            ],
                            [VENDOR, [TYPE, SMARTTV]],
                            [
                                /hbbtv.+maple;(\d+)/i
                            ],
                            [
                                [MODEL, /^/, 'SmartTV'],
                                [VENDOR, SAMSUNG],
                                [TYPE, SMARTTV]
                            ],
                            [
                                /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i // LG SmartTV
                            ],
                            [
                                [VENDOR, LG],
                                [TYPE, SMARTTV]
                            ],
                            [
                                /(apple) ?tv/i // Apple TV
                            ],
                            [VENDOR, [MODEL, APPLE + ' TV'],
                                [TYPE, SMARTTV]
                            ],
                            [
                                /crkey/i // Google Chromecast
                            ],
                            [
                                [MODEL, CHROME + 'cast'],
                                [VENDOR, GOOGLE],
                                [TYPE, SMARTTV]
                            ],
                            [
                                /droid.+aft(\w)( bui|\))/i // Fire TV
                            ],
                            [MODEL, [VENDOR, AMAZON],
                                [TYPE, SMARTTV]
                            ],
                            [
                                /\(dtv[\);].+(aquos)/i // Sharp
                            ],
                            [MODEL, [VENDOR, 'Sharp'],
                                [TYPE, SMARTTV]
                            ],
                            [
                                /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
                                /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i // HbbTV devices
                            ],
                            [
                                [VENDOR, trim],
                                [MODEL, trim],
                                [TYPE, SMARTTV]
                            ],
                            [
                                /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i // SmartTV from Unidentified Vendors
                            ],
                            [
                                [TYPE, SMARTTV]
                            ],
                            [
                                ///////////////////
                                // WEARABLES
                                ///////////////////
                                /((pebble))app/i // Pebble
                            ],
                            [VENDOR, MODEL, [TYPE, WEARABLE]],
                            [
                                /droid.+; (glass) \d/i // Google Glass
                            ],
                            [MODEL, [VENDOR, GOOGLE],
                                [TYPE, WEARABLE]
                            ],
                            [
                                /droid.+; (wt63?0{2,3})\)/i
                            ],
                            [MODEL, [VENDOR, ZEBRA],
                                [TYPE, WEARABLE]
                            ],
                            [
                                /(quest( 2)?)/i // Oculus Quest
                            ],
                            [MODEL, [VENDOR, FACEBOOK],
                                [TYPE, WEARABLE]
                            ],
                            [
                                ///////////////////
                                // EMBEDDED
                                ///////////////////
                                /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i // Tesla
                            ],
                            [VENDOR, [TYPE, EMBEDDED]],
                            [
                                ////////////////////
                                // MIXED (GENERIC)
                                ///////////////////
                                /droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i // Android Phones from Unidentified Vendors
                            ],
                            [MODEL, [TYPE, MOBILE]],
                            [
                                /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i // Android Tablets from Unidentified Vendors
                            ],
                            [MODEL, [TYPE, TABLET]],
                            [
                                /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i // Unidentifiable Tablet
                            ],
                            [
                                [TYPE, TABLET]
                            ],
                            [
                                /(phone|mobile(?:[;\/]| safari)|pda(?=.+windows ce))/i // Unidentifiable Mobile
                            ],
                            [
                                [TYPE, MOBILE]
                            ],
                            [
                                /(android[-\w\. ]{0,9});.+buil/i // Generic Android Device
                            ],
                            [MODEL, [VENDOR, 'Generic']]
                        ],
                        engine: [
                            [
                                /windows.+ edge\/([\w\.]+)/i // EdgeHTML
                            ],
                            [VERSION, [NAME, EDGE + 'HTML']],
                            [
                                /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i // Blink
                            ],
                            [VERSION, [NAME, 'Blink']],
                            [
                                /(presto)\/([\w\.]+)/i,
                                /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
                                /ekioh(flow)\/([\w\.]+)/i,
                                /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
                                /(icab)[\/ ]([23]\.[\d\.]+)/i // iCab
                            ],
                            [NAME, VERSION],
                            [
                                /rv\:([\w\.]{1,9})\b.+(gecko)/i // Gecko
                            ],
                            [VERSION, NAME]
                        ],
                        os: [
                            [
                                // Windows
                                /microsoft (windows) (vista|xp)/i // Windows (iTunes)
                            ],
                            [NAME, VERSION],
                            [
                                /(windows) nt 6\.2; (arm)/i,
                                /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,
                                /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i
                            ],
                            [NAME, [VERSION, strMapper, windowsVersionMap]],
                            [
                                /(win(?=3|9|n)|win 9x )([nt\d\.]+)/i
                            ],
                            [
                                [NAME, 'Windows'],
                                [VERSION, strMapper, windowsVersionMap]
                            ],
                            [
                                // iOS/macOS
                                /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
                                /cfnetwork\/.+darwin/i
                            ],
                            [
                                [VERSION, /_/g, '.'],
                                [NAME, 'iOS']
                            ],
                            [
                                /(mac os x) ?([\w\. ]*)/i,
                                /(macintosh|mac_powerpc\b)(?!.+haiku)/i // Mac OS
                            ],
                            [
                                [NAME, 'Mac OS'],
                                [VERSION, /_/g, '.']
                            ],
                            [
                                // Mobile OSes
                                /droid ([\w\.]+)\b.+(android[- ]x86)/i // Android-x86
                            ],
                            [VERSION, NAME],
                            [
                                /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
                                /(blackberry)\w*\/([\w\.]*)/i,
                                /(tizen|kaios)[\/ ]([\w\.]+)/i,
                                /\((series40);/i // Series 40
                            ],
                            [NAME, VERSION],
                            [
                                /\(bb(10);/i // BlackBerry 10
                            ],
                            [VERSION, [NAME, BLACKBERRY]],
                            [
                                /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i // Symbian
                            ],
                            [VERSION, [NAME, 'Symbian']],
                            [
                                /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i // Firefox OS
                            ],
                            [VERSION, [NAME, FIREFOX + ' OS']],
                            [
                                /web0s;.+rt(tv)/i,
                                /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i // WebOS
                            ],
                            [VERSION, [NAME, 'webOS']],
                            [
                                // Google Chromecast
                                /crkey\/([\d\.]+)/i // Google Chromecast
                            ],
                            [VERSION, [NAME, CHROME + 'cast']],
                            [
                                /(cros) [\w]+ ([\w\.]+\w)/i // Chromium OS
                            ],
                            [
                                [NAME, 'Chromium OS'], VERSION
                            ],
                            [
                                // Console
                                /(nintendo|playstation) ([wids345portablevuch]+)/i,
                                /(xbox); +xbox ([^\);]+)/i,
                                // Other
                                /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
                                /(mint)[\/\(\) ]?(\w*)/i,
                                /(mageia|vectorlinux)[; ]/i,
                                /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                                // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
                                /(hurd|linux) ?([\w\.]*)/i,
                                /(gnu) ?([\w\.]*)/i,
                                /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
                                /(haiku) (\w+)/i // Haiku
                            ],
                            [NAME, VERSION],
                            [
                                /(sunos) ?([\w\.\d]*)/i // Solaris
                            ],
                            [
                                [NAME, 'Solaris'], VERSION
                            ],
                            [
                                /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
                                /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
                                /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i,
                                /(unix) ?([\w\.]*)/i // UNIX
                            ],
                            [NAME, VERSION]
                        ]
                    };
                    /////////////////
                    // Constructor
                    ////////////////
                    var UAParser = function(ua, extensions) {
                        if (typeof ua === OBJ_TYPE) {
                            extensions = ua;
                            ua = undefined;
                        }
                        if (!(this instanceof UAParser)) {
                            return new UAParser(ua, extensions).getResult();
                        }
                        var _ua = ua || ((typeof window !== UNDEF_TYPE && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);
                        var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
                        this.getBrowser = function() {
                            var _browser = {};
                            _browser[NAME] = undefined;
                            _browser[VERSION] = undefined;
                            rgxMapper.call(_browser, _ua, _rgxmap.browser);
                            _browser.major = majorize(_browser.version);
                            return _browser;
                        };
                        this.getCPU = function() {
                            var _cpu = {};
                            _cpu[ARCHITECTURE] = undefined;
                            rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
                            return _cpu;
                        };
                        this.getDevice = function() {
                            var _device = {};
                            _device[VENDOR] = undefined;
                            _device[MODEL] = undefined;
                            _device[TYPE] = undefined;
                            rgxMapper.call(_device, _ua, _rgxmap.device);
                            return _device;
                        };
                        this.getEngine = function() {
                            var _engine = {};
                            _engine[NAME] = undefined;
                            _engine[VERSION] = undefined;
                            rgxMapper.call(_engine, _ua, _rgxmap.engine);
                            return _engine;
                        };
                        this.getOS = function() {
                            var _os = {};
                            _os[NAME] = undefined;
                            _os[VERSION] = undefined;
                            rgxMapper.call(_os, _ua, _rgxmap.os);
                            return _os;
                        };
                        this.getResult = function() {
                            return {
                                ua: this.getUA(),
                                browser: this.getBrowser(),
                                engine: this.getEngine(),
                                os: this.getOS(),
                                device: this.getDevice(),
                                cpu: this.getCPU()
                            };
                        };
                        this.getUA = function() {
                            return _ua;
                        };
                        this.setUA = function(ua) {
                            _ua = (typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH) ? trim(ua, UA_MAX_LENGTH) : ua;
                            return this;
                        };
                        this.setUA(_ua);
                        return this;
                    };
                    UAParser.VERSION = LIBVERSION;
                    UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]);
                    UAParser.CPU = enumerize([ARCHITECTURE]);
                    UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
                    UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);
                    ///////////
                    // Export
                    //////////
                    // check js environment
                    if (typeof(exports) !== UNDEF_TYPE) {
                        // nodejs env
                        if ("object" !== UNDEF_TYPE && module.exports) {
                            exports = module.exports = UAParser;
                        }
                        exports.UAParser = UAParser;
                    } else {
                        // requirejs env (optional)
                        if ("function" === FUNC_TYPE && __webpack_require__.amdO) {
                            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                                    return UAParser;
                                }).call(exports, __webpack_require__, exports, module),
                                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                        } else if (typeof window !== UNDEF_TYPE) {
                            // browser env
                            window.UAParser = UAParser;
                        }
                    }
                    // jQuery/Zepto specific (optional)
                    // Note:
                    //   In AMD env the global scope should be kept clean, but jQuery is an exception.
                    //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
                    //   and we should catch that.
                    var $ = typeof window !== UNDEF_TYPE && (window.jQuery || window.Zepto);
                    if ($ && !$.ua) {
                        var parser = new UAParser();
                        $.ua = parser.getResult();
                        $.ua.get = function() {
                            return parser.getUA();
                        };
                        $.ua.set = function(ua) {
                            parser.setUA(ua);
                            var result = parser.getResult();
                            for (var prop in result) {
                                $.ua[prop] = result[prop];
                            }
                        };
                    }
                })(typeof window === 'object' ? window : this);


                /***/
            }),

        /***/
        "./node_modules/what-input/dist/what-input.js":
            /*!****************************************************!*\
              !*** ./node_modules/what-input/dist/what-input.js ***!
              \****************************************************/
            /***/
            (function(module) {


                /**
                 * what-input - A global utility for tracking the current input method (mouse, keyboard or touch).
                 * @version v5.2.10
                 * @link https://github.com/ten1seven/what-input
                 * @license MIT
                 */
                (function webpackUniversalModuleDefinition(root, factory) {
                    if (true)
                        module.exports = factory();
                    else {}
                })(this, function() {
                    return /******/ (function(modules) {
                        /******/ // The module cache
                        /******/
                        var installedModules = {};
                        /******/ // The require function
                        /******/
                        function __nested_webpack_require_804__(moduleId) {
                            /******/ // Check if module is in cache
                            /******/
                            if (installedModules[moduleId])
                                /******/
                                return installedModules[moduleId].exports;
                            /******/ // Create a new module (and put it into the cache)
                            /******/
                            var module = installedModules[moduleId] = {
                                /******/
                                exports: {},
                                /******/
                                id: moduleId,
                                /******/
                                loaded: false
                                /******/
                            };
                            /******/ // Execute the module function
                            /******/
                            modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_804__);
                            /******/ // Flag the module as loaded
                            /******/
                            module.loaded = true;
                            /******/ // Return the exports of the module
                            /******/
                            return module.exports;
                            /******/
                        }
                        /******/ // expose the modules object (__webpack_modules__)
                        /******/
                        __nested_webpack_require_804__.m = modules;
                        /******/ // expose the module cache
                        /******/
                        __nested_webpack_require_804__.c = installedModules;
                        /******/ // __webpack_public_path__
                        /******/
                        __nested_webpack_require_804__.p = "";
                        /******/ // Load entry module and return exports
                        /******/
                        return __nested_webpack_require_804__(0);
                        /******/
                    })([
                        /* 0 */
                        /***/
                        (function(module, exports) {
                            'use strict';
                            module.exports = function() {
                                /*
                                 * bail out if there is no document or window
                                 * (i.e. in a node/non-DOM environment)
                                 *
                                 * Return a stubbed API instead
                                 */
                                if (typeof document === 'undefined' || typeof window === 'undefined') {
                                    return {
                                        // always return "initial" because no interaction will ever be detected
                                        ask: function ask() {
                                            return 'initial';
                                        },
                                        // always return null
                                        element: function element() {
                                            return null;
                                        },
                                        // no-op
                                        ignoreKeys: function ignoreKeys() {},
                                        // no-op
                                        specificKeys: function specificKeys() {},
                                        // no-op
                                        registerOnChange: function registerOnChange() {},
                                        // no-op
                                        unRegisterOnChange: function unRegisterOnChange() {}
                                    };
                                }
                                /*
                                 * variables
                                 */
                                // cache document.documentElement
                                var docElem = document.documentElement;
                                // currently focused dom element
                                var currentElement = null;
                                // last used input type
                                var currentInput = 'initial';
                                // last used input intent
                                var currentIntent = currentInput;
                                // UNIX timestamp of current event
                                var currentTimestamp = Date.now();
                                // check for a `data-whatpersist` attribute on either the `html` or `body` elements, defaults to `true`
                                var shouldPersist = 'false';
                                // form input types
                                var formInputs = ['button', 'input', 'select', 'textarea'];
                                // empty array for holding callback functions
                                var functionList = [];
                                // list of modifier keys commonly used with the mouse and
                                // can be safely ignored to prevent false keyboard detection
                                var ignoreMap = [16,
                                    17,
                                    18,
                                    91,
                                    93 // Windows menu / right Apple cmd
                                ];
                                var specificMap = [];
                                // mapping of events to input types
                                var inputMap = {
                                    keydown: 'keyboard',
                                    keyup: 'keyboard',
                                    mousedown: 'mouse',
                                    mousemove: 'mouse',
                                    MSPointerDown: 'pointer',
                                    MSPointerMove: 'pointer',
                                    pointerdown: 'pointer',
                                    pointermove: 'pointer',
                                    touchstart: 'touch',
                                    touchend: 'touch'
                                    // boolean: true if the page is being scrolled
                                };
                                var isScrolling = false;
                                // store current mouse position
                                var mousePos = {
                                    x: null,
                                    y: null
                                    // map of IE 10 pointer events
                                };
                                var pointerMap = {
                                    2: 'touch',
                                    3: 'touch',
                                    4: 'mouse'
                                    // check support for passive event listeners
                                };
                                var supportsPassive = false;
                                try {
                                    var opts = Object.defineProperty({}, 'passive', {
                                        get: function get() {
                                            supportsPassive = true;
                                        }
                                    });
                                    window.addEventListener('test', null, opts);
                                } catch (e) {}
                                // fail silently
                                /*
                                 * set up
                                 */
                                var setUp = function setUp() {
                                    // add correct mouse wheel event mapping to `inputMap`
                                    inputMap[detectWheel()] = 'mouse';
                                    addListeners();
                                };
                                /*
                                 * events
                                 */
                                var addListeners = function addListeners() {
                                    // `pointermove`, `MSPointerMove`, `mousemove` and mouse wheel event binding
                                    // can only demonstrate potential, but not actual, interaction
                                    // and are treated separately
                                    var options = supportsPassive ? {
                                        passive: true
                                    } : false;
                                    document.addEventListener('DOMContentLoaded', setPersist);
                                    // pointer events (mouse, pen, touch)
                                    if (window.PointerEvent) {
                                        window.addEventListener('pointerdown', setInput);
                                        window.addEventListener('pointermove', setIntent);
                                    } else if (window.MSPointerEvent) {
                                        window.addEventListener('MSPointerDown', setInput);
                                        window.addEventListener('MSPointerMove', setIntent);
                                    } else {
                                        // mouse events
                                        window.addEventListener('mousedown', setInput);
                                        window.addEventListener('mousemove', setIntent);
                                        // touch events
                                        if ('ontouchstart' in window) {
                                            window.addEventListener('touchstart', setInput, options);
                                            window.addEventListener('touchend', setInput);
                                        }
                                    }
                                    // mouse wheel
                                    window.addEventListener(detectWheel(), setIntent, options);
                                    // keyboard events
                                    window.addEventListener('keydown', setInput);
                                    window.addEventListener('keyup', setInput);
                                    // focus events
                                    window.addEventListener('focusin', setElement);
                                    window.addEventListener('focusout', clearElement);
                                };
                                // checks if input persistence should happen and
                                // get saved state from session storage if true (defaults to `false`)
                                var setPersist = function setPersist() {
                                    shouldPersist = !(docElem.getAttribute('data-whatpersist') || document.body.getAttribute('data-whatpersist') === 'false');
                                    if (shouldPersist) {
                                        // check for session variables and use if available
                                        try {
                                            if (window.sessionStorage.getItem('what-input')) {
                                                currentInput = window.sessionStorage.getItem('what-input');
                                            }
                                            if (window.sessionStorage.getItem('what-intent')) {
                                                currentIntent = window.sessionStorage.getItem('what-intent');
                                            }
                                        } catch (e) {
                                            // fail silently
                                        }
                                    }
                                    // always run these so at least `initial` state is set
                                    doUpdate('input');
                                    doUpdate('intent');
                                };
                                // checks conditions before updating new input
                                var setInput = function setInput(event) {
                                    var eventKey = event.which;
                                    var value = inputMap[event.type];
                                    if (value === 'pointer') {
                                        value = pointerType(event);
                                    }
                                    var ignoreMatch = !specificMap.length && ignoreMap.indexOf(eventKey) === -1;
                                    var specificMatch = specificMap.length && specificMap.indexOf(eventKey) !== -1;
                                    var shouldUpdate = value === 'keyboard' && eventKey && (ignoreMatch || specificMatch) || value === 'mouse' || value === 'touch';
                                    // prevent touch detection from being overridden by event execution order
                                    if (validateTouch(value)) {
                                        shouldUpdate = false;
                                    }
                                    if (shouldUpdate && currentInput !== value) {
                                        currentInput = value;
                                        persistInput('input', currentInput);
                                        doUpdate('input');
                                    }
                                    if (shouldUpdate && currentIntent !== value) {
                                        // preserve intent for keyboard interaction with form fields
                                        var activeElem = document.activeElement;
                                        var notFormInput = activeElem && activeElem.nodeName && (formInputs.indexOf(activeElem.nodeName.toLowerCase()) === -1 || activeElem.nodeName.toLowerCase() === 'button' && !checkClosest(activeElem, 'form'));
                                        if (notFormInput) {
                                            currentIntent = value;
                                            persistInput('intent', currentIntent);
                                            doUpdate('intent');
                                        }
                                    }
                                };
                                // updates the doc and `inputTypes` array with new input
                                var doUpdate = function doUpdate(which) {
                                    docElem.setAttribute('data-what' + which, which === 'input' ? currentInput : currentIntent);
                                    fireFunctions(which);
                                };
                                // updates input intent for `mousemove` and `pointermove`
                                var setIntent = function setIntent(event) {
                                    var value = inputMap[event.type];
                                    if (value === 'pointer') {
                                        value = pointerType(event);
                                    }
                                    // test to see if `mousemove` happened relative to the screen to detect scrolling versus mousemove
                                    detectScrolling(event);
                                    // only execute if scrolling isn't happening
                                    if ((!isScrolling && !validateTouch(value) || isScrolling && event.type === 'wheel' || event.type === 'mousewheel' || event.type === 'DOMMouseScroll') && currentIntent !== value) {
                                        currentIntent = value;
                                        persistInput('intent', currentIntent);
                                        doUpdate('intent');
                                    }
                                };
                                var setElement = function setElement(event) {
                                    if (!event.target.nodeName) {
                                        // If nodeName is undefined, clear the element
                                        // This can happen if click inside an <svg> element.
                                        clearElement();
                                        return;
                                    }
                                    currentElement = event.target.nodeName.toLowerCase();
                                    docElem.setAttribute('data-whatelement', currentElement);
                                    if (event.target.classList && event.target.classList.length) {
                                        docElem.setAttribute('data-whatclasses', event.target.classList.toString().replace(' ', ','));
                                    }
                                };
                                var clearElement = function clearElement() {
                                    currentElement = null;
                                    docElem.removeAttribute('data-whatelement');
                                    docElem.removeAttribute('data-whatclasses');
                                };
                                var persistInput = function persistInput(which, value) {
                                    if (shouldPersist) {
                                        try {
                                            window.sessionStorage.setItem('what-' + which, value);
                                        } catch (e) {
                                            // fail silently
                                        }
                                    }
                                };
                                /*
                                 * utilities
                                 */
                                var pointerType = function pointerType(event) {
                                    if (typeof event.pointerType === 'number') {
                                        return pointerMap[event.pointerType];
                                    } else {
                                        // treat pen like touch
                                        return event.pointerType === 'pen' ? 'touch' : event.pointerType;
                                    }
                                };
                                // prevent touch detection from being overridden by event execution order
                                var validateTouch = function validateTouch(value) {
                                    var timestamp = Date.now();
                                    var touchIsValid = value === 'mouse' && currentInput === 'touch' && timestamp - currentTimestamp < 200;
                                    currentTimestamp = timestamp;
                                    return touchIsValid;
                                };
                                // detect version of mouse wheel event to use
                                // via https://developer.mozilla.org/en-US/docs/Web/API/Element/wheel_event
                                var detectWheel = function detectWheel() {
                                    var wheelType = null;
                                    // Modern browsers support "wheel"
                                    if ('onwheel' in document.createElement('div')) {
                                        wheelType = 'wheel';
                                    } else {
                                        // Webkit and IE support at least "mousewheel"
                                        // or assume that remaining browsers are older Firefox
                                        wheelType = document.onmousewheel !== undefined ? 'mousewheel' : 'DOMMouseScroll';
                                    }
                                    return wheelType;
                                };
                                // runs callback functions
                                var fireFunctions = function fireFunctions(type) {
                                    for (var i = 0, len = functionList.length; i < len; i++) {
                                        if (functionList[i].type === type) {
                                            functionList[i].fn.call(undefined, type === 'input' ? currentInput : currentIntent);
                                        }
                                    }
                                };
                                // finds matching element in an object
                                var objPos = function objPos(match) {
                                    for (var i = 0, len = functionList.length; i < len; i++) {
                                        if (functionList[i].fn === match) {
                                            return i;
                                        }
                                    }
                                };
                                var detectScrolling = function detectScrolling(event) {
                                    if (mousePos.x !== event.screenX || mousePos.y !== event.screenY) {
                                        isScrolling = false;
                                        mousePos.x = event.screenX;
                                        mousePos.y = event.screenY;
                                    } else {
                                        isScrolling = true;
                                    }
                                };
                                // manual version of `closest()`
                                var checkClosest = function checkClosest(elem, tag) {
                                    var ElementPrototype = window.Element.prototype;
                                    if (!ElementPrototype.matches) {
                                        ElementPrototype.matches = ElementPrototype.msMatchesSelector || ElementPrototype.webkitMatchesSelector;
                                    }
                                    if (!ElementPrototype.closest) {
                                        do {
                                            if (elem.matches(tag)) {
                                                return elem;
                                            }
                                            elem = elem.parentElement || elem.parentNode;
                                        } while (elem !== null && elem.nodeType === 1);
                                        return null;
                                    } else {
                                        return elem.closest(tag);
                                    }
                                };
                                /*
                                 * init
                                 */
                                // don't start script unless browser cuts the mustard
                                // (also passes if polyfills are used)
                                if ('addEventListener' in window && Array.prototype.indexOf) {
                                    setUp();
                                }
                                /*
                                 * api
                                 */
                                return {
                                    // returns string: the current input type
                                    // opt: 'intent'|'input'
                                    // 'input' (default): returns the same value as the `data-whatinput` attribute
                                    // 'intent': includes `data-whatintent` value if it's different than `data-whatinput`
                                    ask: function ask(opt) {
                                        return opt === 'intent' ? currentIntent : currentInput;
                                    },
                                    // returns string: the currently focused element or null
                                    element: function element() {
                                        return currentElement;
                                    },
                                    // overwrites ignored keys with provided array
                                    ignoreKeys: function ignoreKeys(arr) {
                                        ignoreMap = arr;
                                    },
                                    // overwrites specific char keys to update on
                                    specificKeys: function specificKeys(arr) {
                                        specificMap = arr;
                                    },
                                    // attach functions to input and intent "events"
                                    // funct: function to fire on change
                                    // eventType: 'input'|'intent'
                                    registerOnChange: function registerOnChange(fn, eventType) {
                                        functionList.push({
                                            fn: fn,
                                            type: eventType || 'input'
                                        });
                                    },
                                    unRegisterOnChange: function unRegisterOnChange(fn) {
                                        var position = objPos(fn);
                                        if (position || position === 0) {
                                            functionList.splice(position, 1);
                                        }
                                    },
                                    clearStorage: function clearStorage() {
                                        window.sessionStorage.clear();
                                    }
                                };
                            }();
                            /***/
                        })
                        /******/
                    ]);
                });;


                /***/
            }),

        /***/
        "./node_modules/wicg-inert/dist/inert.esm.js":
            /*!***************************************************!*\
              !*** ./node_modules/wicg-inert/dist/inert.esm.js ***!
              \***************************************************/
            /***/
            (function() {


                var _createClass = function() {
                    function defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor)
                                descriptor.writable = true;
                            Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }
                    return function(Constructor, protoProps, staticProps) {
                        if (protoProps)
                            defineProperties(Constructor.prototype, protoProps);
                        if (staticProps)
                            defineProperties(Constructor, staticProps);
                        return Constructor;
                    };
                }();

                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                /**
                 * This work is licensed under the W3C Software and Document License
                 * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
                 */
                (function() {
                    // Return early if we're not running inside of the browser.
                    if (typeof window === 'undefined') {
                        return;
                    }
                    // Convenience function for converting NodeLists.
                    /** @type {typeof Array.prototype.slice} */
                    var slice = Array.prototype.slice;
                    /**
                     * IE has a non-standard name for "matches".
                     * @type {typeof Element.prototype.matches}
                     */
                    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;
                    /** @type {string} */
                    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');
                    /**
                     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
                     * attribute.
                     *
                     * Its main functions are:
                     *
                     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
                     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
                     *   each focusable node in the subtree with the singleton `InertManager` which manages all known
                     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
                     *   instance exists for each focusable node which has at least one inert root as an ancestor.
                     *
                     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
                     *   attribute is removed from the root node). This is handled in the destructor, which calls the
                     *   `deregister` method on `InertManager` for each managed inert node.
                     */
                    var InertRoot = function() {
                        /**
                         * @param {!Element} rootElement The Element at the root of the inert subtree.
                         * @param {!InertManager} inertManager The global singleton InertManager object.
                         */
                        function InertRoot(rootElement, inertManager) {
                            _classCallCheck(this, InertRoot);
                            /** @type {!InertManager} */
                            this._inertManager = inertManager;
                            /** @type {!Element} */
                            this._rootElement = rootElement;
                            /**
                             * @type {!Set<!InertNode>}
                             * All managed focusable nodes in this InertRoot's subtree.
                             */
                            this._managedNodes = new Set();
                            // Make the subtree hidden from assistive technology
                            if (this._rootElement.hasAttribute('aria-hidden')) {
                                /** @type {?string} */
                                this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
                            } else {
                                this._savedAriaHidden = null;
                            }
                            this._rootElement.setAttribute('aria-hidden', 'true');
                            // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
                            this._makeSubtreeUnfocusable(this._rootElement);
                            // Watch for:
                            // - any additions in the subtree: make them unfocusable too
                            // - any removals from the subtree: remove them from this inert root's managed nodes
                            // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
                            //   element, make that node a managed node.
                            this._observer = new MutationObserver(this._onMutation.bind(this));
                            this._observer.observe(this._rootElement, {
                                attributes: true,
                                childList: true,
                                subtree: true
                            });
                        }
                        /**
                         * Call this whenever this object is about to become obsolete.  This unwinds all of the state
                         * stored in this object and updates the state of all of the managed nodes.
                         */
                        _createClass(InertRoot, [{
                            key: 'destructor',
                            value: function destructor() {
                                this._observer.disconnect();
                                if (this._rootElement) {
                                    if (this._savedAriaHidden !== null) {
                                        this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
                                    } else {
                                        this._rootElement.removeAttribute('aria-hidden');
                                    }
                                }
                                this._managedNodes.forEach(function(inertNode) {
                                    this._unmanageNode(inertNode.node);
                                }, this);
                                // Note we cast the nulls to the ANY type here because:
                                // 1) We want the class properties to be declared as non-null, or else we
                                //    need even more casts throughout this code. All bets are off if an
                                //    instance has been destroyed and a method is called.
                                // 2) We don't want to cast "this", because we want type-aware optimizations
                                //    to know which properties we're setting.
                                this._observer = /** @type {?} */ null;
                                this._rootElement = /** @type {?} */ null;
                                this._managedNodes = /** @type {?} */ null;
                                this._inertManager = /** @type {?} */ null;
                            }
                            /**
                             * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
                             */
                        }, {
                            key: '_makeSubtreeUnfocusable',
                            /**
                             * @param {!Node} startNode
                             */
                            value: function _makeSubtreeUnfocusable(startNode) {
                                var _this2 = this;
                                composedTreeWalk(startNode, function(node) {
                                    return _this2._visitNode(node);
                                });
                                var activeElement = document.activeElement;
                                if (!document.body.contains(startNode)) {
                                    // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
                                    var node = startNode;
                                    /** @type {!ShadowRoot|undefined} */
                                    var root = undefined;
                                    while (node) {
                                        if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                                            root = /** @type {!ShadowRoot} */ node;
                                            break;
                                        }
                                        node = node.parentNode;
                                    }
                                    if (root) {
                                        activeElement = root.activeElement;
                                    }
                                }
                                if (startNode.contains(activeElement)) {
                                    activeElement.blur();
                                    // In IE11, if an element is already focused, and then set to tabindex=-1
                                    // calling blur() will not actually move the focus.
                                    // To work around this we call focus() on the body instead.
                                    if (activeElement === document.activeElement) {
                                        document.body.focus();
                                    }
                                }
                            }
                            /**
                             * @param {!Node} node
                             */
                        }, {
                            key: '_visitNode',
                            value: function _visitNode(node) {
                                if (node.nodeType !== Node.ELEMENT_NODE) {
                                    return;
                                }
                                var element = /** @type {!Element} */ node;
                                // If a descendant inert root becomes un-inert, its descendants will still be inert because of
                                // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
                                if (element !== this._rootElement && element.hasAttribute('inert')) {
                                    this._adoptInertRoot(element);
                                }
                                if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
                                    this._manageNode(element);
                                }
                            }
                            /**
                             * Register the given node with this InertRoot and with InertManager.
                             * @param {!Node} node
                             */
                        }, {
                            key: '_manageNode',
                            value: function _manageNode(node) {
                                var inertNode = this._inertManager.register(node, this);
                                this._managedNodes.add(inertNode);
                            }
                            /**
                             * Unregister the given node with this InertRoot and with InertManager.
                             * @param {!Node} node
                             */
                        }, {
                            key: '_unmanageNode',
                            value: function _unmanageNode(node) {
                                var inertNode = this._inertManager.deregister(node, this);
                                if (inertNode) {
                                    this._managedNodes['delete'](inertNode);
                                }
                            }
                            /**
                             * Unregister the entire subtree starting at `startNode`.
                             * @param {!Node} startNode
                             */
                        }, {
                            key: '_unmanageSubtree',
                            value: function _unmanageSubtree(startNode) {
                                var _this3 = this;
                                composedTreeWalk(startNode, function(node) {
                                    return _this3._unmanageNode(node);
                                });
                            }
                            /**
                             * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
                             * @param {!Element} node
                             */
                        }, {
                            key: '_adoptInertRoot',
                            value: function _adoptInertRoot(node) {
                                var inertSubroot = this._inertManager.getInertRoot(node);
                                // During initialisation this inert root may not have been registered yet,
                                // so register it now if need be.
                                if (!inertSubroot) {
                                    this._inertManager.setInert(node, true);
                                    inertSubroot = this._inertManager.getInertRoot(node);
                                }
                                inertSubroot.managedNodes.forEach(function(savedInertNode) {
                                    this._manageNode(savedInertNode.node);
                                }, this);
                            }
                            /**
                             * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
                             * @param {!Array<!MutationRecord>} records
                             * @param {!MutationObserver} self
                             */
                        }, {
                            key: '_onMutation',
                            value: function _onMutation(records, self) {
                                records.forEach(function(record) {
                                    var target = /** @type {!Element} */ record.target;
                                    if (record.type === 'childList') {
                                        // Manage added nodes
                                        slice.call(record.addedNodes).forEach(function(node) {
                                            this._makeSubtreeUnfocusable(node);
                                        }, this);
                                        // Un-manage removed nodes
                                        slice.call(record.removedNodes).forEach(function(node) {
                                            this._unmanageSubtree(node);
                                        }, this);
                                    } else if (record.type === 'attributes') {
                                        if (record.attributeName === 'tabindex') {
                                            // Re-initialise inert node if tabindex changes
                                            this._manageNode(target);
                                        } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
                                            // If a new inert root is added, adopt its managed nodes and make sure it knows about the
                                            // already managed nodes from this inert subroot.
                                            this._adoptInertRoot(target);
                                            var inertSubroot = this._inertManager.getInertRoot(target);
                                            this._managedNodes.forEach(function(managedNode) {
                                                if (target.contains(managedNode.node)) {
                                                    inertSubroot._manageNode(managedNode.node);
                                                }
                                            });
                                        }
                                    }
                                }, this);
                            }
                        }, {
                            key: 'managedNodes',
                            get: function get() {
                                return new Set(this._managedNodes);
                            }
                            /** @return {boolean} */
                        }, {
                            key: 'hasSavedAriaHidden',
                            get: function get() {
                                return this._savedAriaHidden !== null;
                            }
                            /** @param {?string} ariaHidden */
                        }, {
                            key: 'savedAriaHidden',
                            set: function set(ariaHidden) {
                                    this._savedAriaHidden = ariaHidden;
                                }
                                /** @return {?string} */
                                ,
                            get: function get() {
                                return this._savedAriaHidden;
                            }
                        }]);
                        return InertRoot;
                    }();
                    /**
                     * `InertNode` initialises and manages a single inert node.
                     * A node is inert if it is a descendant of one or more inert root elements.
                     *
                     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
                     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
                     * is intrinsically focusable or not.
                     *
                     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
                     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
                     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
                     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
                     * or removes the `tabindex` attribute if the element is intrinsically focusable.
                     */
                    var InertNode = function() {
                        /**
                         * @param {!Node} node A focusable element to be made inert.
                         * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
                         */
                        function InertNode(node, inertRoot) {
                            _classCallCheck(this, InertNode);
                            /** @type {!Node} */
                            this._node = node;
                            /** @type {boolean} */
                            this._overrodeFocusMethod = false;
                            /**
                             * @type {!Set<!InertRoot>} The set of descendant inert roots.
                             *    If and only if this set becomes empty, this node is no longer inert.
                             */
                            this._inertRoots = new Set([inertRoot]);
                            /** @type {?number} */
                            this._savedTabIndex = null;
                            /** @type {boolean} */
                            this._destroyed = false;
                            // Save any prior tabindex info and make this node untabbable
                            this.ensureUntabbable();
                        }
                        /**
                         * Call this whenever this object is about to become obsolete.
                         * This makes the managed node focusable again and deletes all of the previously stored state.
                         */
                        _createClass(InertNode, [{
                            key: 'destructor',
                            value: function destructor() {
                                this._throwIfDestroyed();
                                if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
                                    var element = /** @type {!Element} */ this._node;
                                    if (this._savedTabIndex !== null) {
                                        element.setAttribute('tabindex', this._savedTabIndex);
                                    } else {
                                        element.removeAttribute('tabindex');
                                    }
                                    // Use `delete` to restore native focus method.
                                    if (this._overrodeFocusMethod) {
                                        delete element.focus;
                                    }
                                }
                                // See note in InertRoot.destructor for why we cast these nulls to ANY.
                                this._node = /** @type {?} */ null;
                                this._inertRoots = /** @type {?} */ null;
                                this._destroyed = true;
                            }
                            /**
                             * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
                             * If the object has been destroyed, any attempt to access it will cause an exception.
                             */
                        }, {
                            key: '_throwIfDestroyed',
                            /**
                             * Throw if user tries to access destroyed InertNode.
                             */
                            value: function _throwIfDestroyed() {
                                if (this.destroyed) {
                                    throw new Error('Trying to access destroyed InertNode');
                                }
                            }
                            /** @return {boolean} */
                        }, {
                            key: 'ensureUntabbable',
                            /** Save the existing tabindex value and make the node untabbable and unfocusable */
                            value: function ensureUntabbable() {
                                if (this.node.nodeType !== Node.ELEMENT_NODE) {
                                    return;
                                }
                                var element = /** @type {!Element} */ this.node;
                                if (matches.call(element, _focusableElementsString)) {
                                    if ( /** @type {!HTMLElement} */ element.tabIndex === -1 && this.hasSavedTabIndex) {
                                        return;
                                    }
                                    if (element.hasAttribute('tabindex')) {
                                        this._savedTabIndex = /** @type {!HTMLElement} */ element.tabIndex;
                                    }
                                    element.setAttribute('tabindex', '-1');
                                    if (element.nodeType === Node.ELEMENT_NODE) {
                                        element.focus = function() {};
                                        this._overrodeFocusMethod = true;
                                    }
                                } else if (element.hasAttribute('tabindex')) {
                                    this._savedTabIndex = /** @type {!HTMLElement} */ element.tabIndex;
                                    element.removeAttribute('tabindex');
                                }
                            }
                            /**
                             * Add another inert root to this inert node's set of managing inert roots.
                             * @param {!InertRoot} inertRoot
                             */
                        }, {
                            key: 'addInertRoot',
                            value: function addInertRoot(inertRoot) {
                                this._throwIfDestroyed();
                                this._inertRoots.add(inertRoot);
                            }
                            /**
                             * Remove the given inert root from this inert node's set of managing inert roots.
                             * If the set of managing inert roots becomes empty, this node is no longer inert,
                             * so the object should be destroyed.
                             * @param {!InertRoot} inertRoot
                             */
                        }, {
                            key: 'removeInertRoot',
                            value: function removeInertRoot(inertRoot) {
                                this._throwIfDestroyed();
                                this._inertRoots['delete'](inertRoot);
                                if (this._inertRoots.size === 0) {
                                    this.destructor();
                                }
                            }
                        }, {
                            key: 'destroyed',
                            get: function get() {
                                return ( /** @type {!InertNode} */ this._destroyed);
                            }
                        }, {
                            key: 'hasSavedTabIndex',
                            get: function get() {
                                return this._savedTabIndex !== null;
                            }
                            /** @return {!Node} */
                        }, {
                            key: 'node',
                            get: function get() {
                                this._throwIfDestroyed();
                                return this._node;
                            }
                            /** @param {?number} tabIndex */
                        }, {
                            key: 'savedTabIndex',
                            set: function set(tabIndex) {
                                    this._throwIfDestroyed();
                                    this._savedTabIndex = tabIndex;
                                }
                                /** @return {?number} */
                                ,
                            get: function get() {
                                this._throwIfDestroyed();
                                return this._savedTabIndex;
                            }
                        }]);
                        return InertNode;
                    }();
                    /**
                     * InertManager is a per-document singleton object which manages all inert roots and nodes.
                     *
                     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
                     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
                     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
                     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
                     * is created for each such node, via the `_managedNodes` map.
                     */
                    var InertManager = function() {
                        /**
                         * @param {!Document} document
                         */
                        function InertManager(document) {
                            _classCallCheck(this, InertManager);
                            if (!document) {
                                throw new Error('Missing required argument; InertManager needs to wrap a document.');
                            }
                            /** @type {!Document} */
                            this._document = document;
                            /**
                             * All managed nodes known to this InertManager. In a map to allow looking up by Node.
                             * @type {!Map<!Node, !InertNode>}
                             */
                            this._managedNodes = new Map();
                            /**
                             * All inert roots known to this InertManager. In a map to allow looking up by Node.
                             * @type {!Map<!Node, !InertRoot>}
                             */
                            this._inertRoots = new Map();
                            /**
                             * Observer for mutations on `document.body`.
                             * @type {!MutationObserver}
                             */
                            this._observer = new MutationObserver(this._watchForInert.bind(this));
                            // Add inert style.
                            addInertStyle(document.head || document.body || document.documentElement);
                            // Wait for document to be loaded.
                            if (document.readyState === 'loading') {
                                document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
                            } else {
                                this._onDocumentLoaded();
                            }
                        }
                        /**
                         * Set whether the given element should be an inert root or not.
                         * @param {!Element} root
                         * @param {boolean} inert
                         */
                        _createClass(InertManager, [{
                            key: 'setInert',
                            value: function setInert(root, inert) {
                                if (inert) {
                                    if (this._inertRoots.has(root)) {
                                        // element is already inert
                                        return;
                                    }
                                    var inertRoot = new InertRoot(root, this);
                                    root.setAttribute('inert', '');
                                    this._inertRoots.set(root, inertRoot);
                                    // If not contained in the document, it must be in a shadowRoot.
                                    // Ensure inert styles are added there.
                                    if (!this._document.body.contains(root)) {
                                        var parent = root.parentNode;
                                        while (parent) {
                                            if (parent.nodeType === 11) {
                                                addInertStyle(parent);
                                            }
                                            parent = parent.parentNode;
                                        }
                                    }
                                } else {
                                    if (!this._inertRoots.has(root)) {
                                        // element is already non-inert
                                        return;
                                    }
                                    var _inertRoot = this._inertRoots.get(root);
                                    _inertRoot.destructor();
                                    this._inertRoots['delete'](root);
                                    root.removeAttribute('inert');
                                }
                            }
                            /**
                             * Get the InertRoot object corresponding to the given inert root element, if any.
                             * @param {!Node} element
                             * @return {!InertRoot|undefined}
                             */
                        }, {
                            key: 'getInertRoot',
                            value: function getInertRoot(element) {
                                return this._inertRoots.get(element);
                            }
                            /**
                             * Register the given InertRoot as managing the given node.
                             * In the case where the node has a previously existing inert root, this inert root will
                             * be added to its set of inert roots.
                             * @param {!Node} node
                             * @param {!InertRoot} inertRoot
                             * @return {!InertNode} inertNode
                             */
                        }, {
                            key: 'register',
                            value: function register(node, inertRoot) {
                                var inertNode = this._managedNodes.get(node);
                                if (inertNode !== undefined) {
                                    // node was already in an inert subtree
                                    inertNode.addInertRoot(inertRoot);
                                } else {
                                    inertNode = new InertNode(node, inertRoot);
                                }
                                this._managedNodes.set(node, inertNode);
                                return inertNode;
                            }
                            /**
                             * De-register the given InertRoot as managing the given inert node.
                             * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
                             * node from the InertManager's set of managed nodes if it is destroyed.
                             * If the node is not currently managed, this is essentially a no-op.
                             * @param {!Node} node
                             * @param {!InertRoot} inertRoot
                             * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
                             */
                        }, {
                            key: 'deregister',
                            value: function deregister(node, inertRoot) {
                                var inertNode = this._managedNodes.get(node);
                                if (!inertNode) {
                                    return null;
                                }
                                inertNode.removeInertRoot(inertRoot);
                                if (inertNode.destroyed) {
                                    this._managedNodes['delete'](node);
                                }
                                return inertNode;
                            }
                            /**
                             * Callback used when document has finished loading.
                             */
                        }, {
                            key: '_onDocumentLoaded',
                            value: function _onDocumentLoaded() {
                                // Find all inert roots in document and make them actually inert.
                                var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
                                inertElements.forEach(function(inertElement) {
                                    this.setInert(inertElement, true);
                                }, this);
                                // Comment this out to use programmatic API only.
                                this._observer.observe(this._document.body || this._document.documentElement, {
                                    attributes: true,
                                    subtree: true,
                                    childList: true
                                });
                            }
                            /**
                             * Callback used when mutation observer detects attribute changes.
                             * @param {!Array<!MutationRecord>} records
                             * @param {!MutationObserver} self
                             */
                        }, {
                            key: '_watchForInert',
                            value: function _watchForInert(records, self) {
                                var _this = this;
                                records.forEach(function(record) {
                                    switch (record.type) {
                                        case 'childList':
                                            slice.call(record.addedNodes).forEach(function(node) {
                                                if (node.nodeType !== Node.ELEMENT_NODE) {
                                                    return;
                                                }
                                                var inertElements = slice.call(node.querySelectorAll('[inert]'));
                                                if (matches.call(node, '[inert]')) {
                                                    inertElements.unshift(node);
                                                }
                                                inertElements.forEach(function(inertElement) {
                                                    this.setInert(inertElement, true);
                                                }, _this);
                                            }, _this);
                                            break;
                                        case 'attributes':
                                            if (record.attributeName !== 'inert') {
                                                return;
                                            }
                                            var target = /** @type {!Element} */ record.target;
                                            var inert = target.hasAttribute('inert');
                                            _this.setInert(target, inert);
                                            break;
                                    }
                                }, this);
                            }
                        }]);
                        return InertManager;
                    }();
                    /**
                     * Recursively walk the composed tree from |node|.
                     * @param {!Node} node
                     * @param {(function (!Element))=} callback Callback to be called for each element traversed,
                     *     before descending into child nodes.
                     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
                     */
                    function composedTreeWalk(node, callback, shadowRootAncestor) {
                        if (node.nodeType == Node.ELEMENT_NODE) {
                            var element = /** @type {!Element} */ node;
                            if (callback) {
                                callback(element);
                            }
                            // Descend into node:
                            // If it has a ShadowRoot, ignore all child elements - these will be picked
                            // up by the <content> or <shadow> elements. Descend straight into the
                            // ShadowRoot.
                            var shadowRoot = /** @type {!HTMLElement} */ element.shadowRoot;
                            if (shadowRoot) {
                                composedTreeWalk(shadowRoot, callback, shadowRoot);
                                return;
                            }
                            // If it is a <content> element, descend into distributed elements - these
                            // are elements from outside the shadow root which are rendered inside the
                            // shadow DOM.
                            if (element.localName == 'content') {
                                var content = /** @type {!HTMLContentElement} */ element;
                                // Verifies if ShadowDom v0 is supported.
                                var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
                                for (var i = 0; i < distributedNodes.length; i++) {
                                    composedTreeWalk(distributedNodes[i], callback, shadowRootAncestor);
                                }
                                return;
                            }
                            // If it is a <slot> element, descend into assigned nodes - these
                            // are elements from outside the shadow root which are rendered inside the
                            // shadow DOM.
                            if (element.localName == 'slot') {
                                var slot = /** @type {!HTMLSlotElement} */ element;
                                // Verify if ShadowDom v1 is supported.
                                var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({
                                    flatten: true
                                }) : [];
                                for (var _i = 0; _i < _distributedNodes.length; _i++) {
                                    composedTreeWalk(_distributedNodes[_i], callback, shadowRootAncestor);
                                }
                                return;
                            }
                        }
                        // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
                        // element, nor a <shadow> element recurse normally.
                        var child = node.firstChild;
                        while (child != null) {
                            composedTreeWalk(child, callback, shadowRootAncestor);
                            child = child.nextSibling;
                        }
                    }
                    /**
                     * Adds a style element to the node containing the inert specific styles
                     * @param {!Node} node
                     */
                    function addInertStyle(node) {
                        if (node.querySelector('style#inert-style, link#inert-style')) {
                            return;
                        }
                        var style = document.createElement('style');
                        style.setAttribute('id', 'inert-style');
                        style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
                        node.appendChild(style);
                    }
                    if (!Element.prototype.hasOwnProperty('inert')) {
                        /** @type {!InertManager} */
                        var inertManager = new InertManager(document);
                        Object.defineProperty(Element.prototype, 'inert', {
                            enumerable: true,
                            /** @this {!Element} */
                            get: function get() {
                                return this.hasAttribute('inert');
                            },
                            /** @this {!Element} */
                            set: function set(inert) {
                                inertManager.setInert(this, inert);
                            }
                        });
                    }
                })();


                /***/
            }),

        /***/
        "./src/components/about/about-content/control.ts":
            /*!*******************************************************!*\
              !*** ./src/components/about/about-content/control.ts ***!
              \*******************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "AboutContent": function() {
                        return /* binding */ AboutContent;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useFadeinContent */ "./src/scripts/hooks/useFadeinContent.ts");


                var AboutContent = function(props) {
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        contents: []
                    }).refs;
                    (0, _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_1__.useFadeinContent)(function() {
                        return refs.unwrap().contents;
                    });
                };
                AboutContent.tag = 'AboutContent';
                AboutContent.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/about/about-layout/control.ts":
            /*!******************************************************!*\
              !*** ./src/components/about/about-layout/control.ts ***!
              \******************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "AboutLayout": function() {
                        return /* binding */ AboutLayout;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _components_page_header_control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/components/page-header/control */ "./src/components/page-header/control.ts");
                /* harmony import */
                var _about_content_control__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ../about-content/control */ "./src/components/about/about-content/control.ts");
                /* harmony import */
                var _components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/components/reading-start-sentinel/control */ "./src/components/reading-start-sentinel/control.ts");




                var AboutLayout = function(props) {
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    addChild(_components_page_header_control__WEBPACK_IMPORTED_MODULE_1__.PageHeader);
                    addChild(_about_content_control__WEBPACK_IMPORTED_MODULE_2__.AboutContent);
                    addChild(_components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_3__.ReadingStartSentinel);
                };
                AboutLayout.tag = 'AboutLayout';
                AboutLayout.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/archive-layout/control.ts":
            /*!**************************************************!*\
              !*** ./src/components/archive-layout/control.ts ***!
              \**************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "ArchiveLayout": function() {
                        return /* binding */ ArchiveLayout;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useFadeinContent */ "./src/scripts/hooks/useFadeinContent.ts");
                /* harmony import */
                var _components_page_header_control__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/components/page-header/control */ "./src/components/page-header/control.ts");
                /* harmony import */
                var _components_cards_control__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/components/cards/control */ "./src/components/cards/control.ts");
                /* harmony import */
                var _components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @/components/reading-start-sentinel/control */ "./src/components/reading-start-sentinel/control.ts");





                var ArchiveLayout = function(props) {
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        contents: []
                    }).refs;
                    (0, _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_1__.useFadeinContent)(function() {
                        return refs.unwrap().contents;
                    });
                    addChild(_components_page_header_control__WEBPACK_IMPORTED_MODULE_2__.PageHeader);
                    addChild(_components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_4__.ReadingStartSentinel);
                    addChild(_components_cards_control__WEBPACK_IMPORTED_MODULE_3__.Cards);
                };
                ArchiveLayout.tag = 'ArchiveLayout';
                ArchiveLayout.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/bg-canvas/control.ts":
            /*!*********************************************!*\
              !*** ./src/components/bg-canvas/control.ts ***!
              \*********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "BgCanvas": function() {
                        return /* binding */ BgCanvas;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_3d_hooks_useWorld3D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/3d/hooks/useWorld3D */ "./src/scripts/3d/hooks/useWorld3D.ts");


                var BgCanvas = function(props) {
                    var root = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.rootRef)();
                    var _a = (0, _scripts_3d_hooks_useWorld3D__WEBPACK_IMPORTED_MODULE_1__.useWorld3D)({
                            colorTextures: {
                                tex1: props.colorTex1,
                                tex2: props.colorTex2,
                                tex3: props.colorTex3,
                                tex4: props.colorTex4
                            }
                        }),
                        canvas = _a.canvas,
                        render = _a.render,
                        resize = _a.resize,
                        setMouse = _a.setMouse;
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.effect)(function(noDep) {
                        var el = root.unwrap();
                        if (!el) {
                            return;
                        }
                        var rect = el.getBoundingClientRect();
                        el.appendChild(canvas);
                        noDep(function() {
                            resize(rect.width, rect.height);
                        });
                        return function() {
                            el.removeChild(canvas);
                        };
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return window;
                    }, 'mousemove', function(evt, target) {
                        var event = evt;
                        var x = 2 * event.clientX / target.innerWidth - 1;
                        // Y1-1
                        var y = -2 * event.clientY / target.innerHeight + 1;
                        setMouse(x, y);
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return window;
                    }, 'resize', function() {
                        var el = root.unwrap();
                        if (!el) {
                            return;
                        }
                        var _a = el.getBoundingClientRect(),
                            width = _a.width,
                            height = _a.height;
                        resize(width, height);
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useTick)(function() {
                        render();
                    }, {
                        autoStart: true
                    });
                };
                BgCanvas.tag = "BgCanvas";
                BgCanvas.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/card/control.ts":
            /*!****************************************!*\
              !*** ./src/components/card/control.ts ***!
              \****************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "Card": function() {
                        return /* binding */ Card;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useDistortionHover__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useDistortionHover */ "./src/scripts/hooks/useDistortionHover.ts");


                var Card = function(props) {
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        hover: null,
                        image: null
                    }).refs;
                    var hover = (0, _scripts_hooks_useDistortionHover__WEBPACK_IMPORTED_MODULE_1__.useDistortionHover)(function() {
                        return refs.unwrap().image;
                    }, {
                        noiseTexture: props.noiseTexture
                    }).hover;
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return refs.unwrap().hover;
                    }, 'mouseenter', function() {
                        hover();
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return refs.unwrap().hover;
                    }, 'mouseleave', function() {});
                };
                Card.tag = "Card";
                Card.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/cards/control.ts":
            /*!*****************************************!*\
              !*** ./src/components/cards/control.ts ***!
              \*****************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "Cards": function() {
                        return /* binding */ Cards;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _components_card_control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/components/card/control */ "./src/components/card/control.ts");


                var Cards = function() {
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    addChild(_components_card_control__WEBPACK_IMPORTED_MODULE_1__.Card);
                };
                Cards.tag = 'Cards';
                Cards.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/features-single/features-single-layout/control.ts":
            /*!**************************************************************************!*\
              !*** ./src/components/features-single/features-single-layout/control.ts ***!
              \**************************************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "FeaturesSingleLayout": function() {
                        return /* binding */ FeaturesSingleLayout;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useFadeinContent */ "./src/scripts/hooks/useFadeinContent.ts");
                /* harmony import */
                var _components_page_header_control__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/components/page-header/control */ "./src/components/page-header/control.ts");
                /* harmony import */
                var _components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/components/reading-start-sentinel/control */ "./src/components/reading-start-sentinel/control.ts");




                var FeaturesSingleLayout = function(props) {
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        contents: []
                    }).refs;
                    (0, _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_1__.useFadeinContent)(function() {
                        return refs.unwrap().contents;
                    });
                    addChild(_components_page_header_control__WEBPACK_IMPORTED_MODULE_2__.PageHeader);
                    addChild(_components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_3__.ReadingStartSentinel);
                };
                FeaturesSingleLayout.tag = 'FeaturesSingleLayout';
                FeaturesSingleLayout.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/footer/back-to-top/control.ts":
            /*!******************************************************!*\
              !*** ./src/components/footer/back-to-top/control.ts ***!
              \******************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "BackToTop": function() {
                        return /* binding */ BackToTop;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var gsap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                /* harmony import */
                var _scripts_state_PageState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/state/PageState */ "./src/scripts/state/PageState.ts");



                var BackToTop = function() {
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        button: null
                    }).refs;
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return refs.unwrap().button;
                    }, 'click', function(evt) {
                        evt.preventDefault();
                        gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.to(window, {
                            duration: 1,
                            ease: 'power3.inOut',
                            scrollTo: {
                                y: 0,
                                autoKill: false
                            },
                            onStart: function() {
                                var _a;
                                (_a = _scripts_state_PageState__WEBPACK_IMPORTED_MODULE_1__.PageState.unwrap().pageTopFocusTarget) === null || _a === void 0 ? void 0 : _a.focus();
                            }
                        });
                    });
                };
                BackToTop.tag = 'BackToTop';
                BackToTop.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/hamburger-menu/control.ts":
            /*!**************************************************!*\
              !*** ./src/components/hamburger-menu/control.ts ***!
              \**************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "HamburgerMenu": function() {
                        return /* binding */ HamburgerMenu;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_state_MobileMenuState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/state/MobileMenuState */ "./src/scripts/state/MobileMenuState.ts");
                /* harmony import */
                var _hamburger_close_control__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./hamburger-close/control */ "./src/components/hamburger-menu/hamburger-close/control.ts");
                /* harmony import */
                var scroll_lock__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! scroll-lock */ "./node_modules/scroll-lock/dist/scroll-lock.js");
                /* harmony import */
                var scroll_lock__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __webpack_require__.n(scroll_lock__WEBPACK_IMPORTED_MODULE_3__);
                /* harmony import */
                var gsap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");





                var HamburgerMenu = function(props) {
                    var element = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.rootRef)();
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    addChild(_hamburger_close_control__WEBPACK_IMPORTED_MODULE_2__.HamburgerClose);
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.effect)(function() {
                        var el = element.unwrap();
                        var _a = _scripts_state_MobileMenuState__WEBPACK_IMPORTED_MODULE_1__.MobileMenuState.unwrap(),
                            isOpen = _a.isOpen,
                            originallyFocusedElement = _a.originallyFocusedElement;
                        if (!el) {
                            return;
                        }
                        el.setAttribute('aria-hidden', "".concat(!isOpen));
                        if (isOpen) {
                            gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.to(el, {
                                display: 'block',
                                opacity: 1,
                                duration: 0.3,
                                onComplete: function() {
                                    return el.focus();
                                }
                            });
                        } else {
                            gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.to(el, {
                                display: 'none',
                                opacity: 0,
                                duration: 0.3,
                                onComplete: function() {
                                    originallyFocusedElement && originallyFocusedElement.focus();
                                }
                            });
                        }
                        isOpen ? (0, scroll_lock__WEBPACK_IMPORTED_MODULE_3__.disablePageScroll)(el) : (0, scroll_lock__WEBPACK_IMPORTED_MODULE_3__.enablePageScroll)(el);
                    });
                };
                HamburgerMenu.tag = 'HamburgerMenu';
                HamburgerMenu.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/hamburger-menu/hamburger-close/control.ts":
            /*!******************************************************************!*\
              !*** ./src/components/hamburger-menu/hamburger-close/control.ts ***!
              \******************************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "HamburgerClose": function() {
                        return /* binding */ HamburgerClose;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_state_MobileMenuState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/state/MobileMenuState */ "./src/scripts/state/MobileMenuState.ts");
                var __assign = (undefined && undefined.__assign) || function() {
                    __assign = Object.assign || function(t) {
                        for (var s, i = 1, n = arguments.length; i < n; i++) {
                            s = arguments[i];
                            for (var p in s)
                                if (Object.prototype.hasOwnProperty.call(s, p))
                                    t[p] = s[p];
                        }
                        return t;
                    };
                    return __assign.apply(this, arguments);
                };


                var HamburgerClose = function() {
                    var element = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.rootRef)();
                    // clickclose
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return element.unwrap();
                    }, 'click', function(evt, target) {
                        _scripts_state_MobileMenuState__WEBPACK_IMPORTED_MODULE_1__.MobileMenuState.wrap(function(state) {
                            return Object.assign({}, state, {
                                isOpen: false
                            });
                        });
                    });
                    // esc
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return document;
                    }, 'keydown', function(evt, target) {
                        if (!_scripts_state_MobileMenuState__WEBPACK_IMPORTED_MODULE_1__.MobileMenuState.unwrap().isOpen) {
                            return;
                        }
                        if (evt.key !== 'Escape') {
                            return;
                        }
                        _scripts_state_MobileMenuState__WEBPACK_IMPORTED_MODULE_1__.MobileMenuState.wrap(function(state) {
                            return __assign(__assign({}, state), {
                                isOpen: false
                            });
                        });
                    });
                };
                HamburgerClose.tag = 'HamburgerClose';
                HamburgerClose.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/header-logo/control.ts":
            /*!***********************************************!*\
              !*** ./src/components/header-logo/control.ts ***!
              \***********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "HeaderLogo": function() {
                        return /* binding */ HeaderLogo;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var _scripts_state_ViewState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @/scripts/state/ViewState */ "./src/scripts/state/ViewState.ts");
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");


                var HeaderLogo = function() {
                    var element = (0, furnace__WEBPACK_IMPORTED_MODULE_1__.rootRef)();
                    (0, furnace__WEBPACK_IMPORTED_MODULE_1__.effect)(function() {
                        var isTopFv = _scripts_state_ViewState__WEBPACK_IMPORTED_MODULE_0__.ViewState.unwrap().isTopFv;
                        var el = element.unwrap();
                        if (!el) {
                            return;
                        }
                        isTopFv ? el.classList.add('is-white') : el.classList.remove('is-white');
                    });
                };
                HeaderLogo.tag = 'HeaderLogo';
                HeaderLogo.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/header/control.ts":
            /*!******************************************!*\
              !*** ./src/components/header/control.ts ***!
              \******************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "Header": function() {
                        return /* binding */ Header;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _components_header_hamburger_open_control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/components/header/hamburger-open/control */ "./src/components/header/hamburger-open/control.ts");
                /* harmony import */
                var _scripts_state_MobileMenuState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/state/MobileMenuState */ "./src/scripts/state/MobileMenuState.ts");
                /* harmony import */
                var _components_header_logo_control__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/components/header-logo/control */ "./src/components/header-logo/control.ts");
                /* harmony import */
                var _components_header_menu_control__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @/components/header/menu/control */ "./src/components/header/menu/control.ts");
                /* harmony import */
                var _scripts_state_ViewState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! @/scripts/state/ViewState */ "./src/scripts/state/ViewState.ts");
                /* harmony import */
                var gsap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");







                var Header = function() {
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    var element = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.rootRef)();
                    addChild(_components_header_hamburger_open_control__WEBPACK_IMPORTED_MODULE_1__.HamburgerOpen);
                    addChild(_components_header_logo_control__WEBPACK_IMPORTED_MODULE_3__.HeaderLogo);
                    addChild(_components_header_menu_control__WEBPACK_IMPORTED_MODULE_4__.Menu);
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.effect)(function() {
                        var isOpen = _scripts_state_MobileMenuState__WEBPACK_IMPORTED_MODULE_2__.MobileMenuState.unwrap().isOpen;
                        var isFooter = _scripts_state_ViewState__WEBPACK_IMPORTED_MODULE_5__.ViewState.unwrap().isFooter;
                        var el = element.unwrap();
                        if (!el) {
                            return;
                        }
                        if (isOpen || isFooter) {
                            gsap__WEBPACK_IMPORTED_MODULE_6__.gsap.to(el, {
                                opacity: 0,
                                display: 'none',
                                duration: 0.3
                            });
                        } else {
                            gsap__WEBPACK_IMPORTED_MODULE_6__.gsap.to(el, {
                                opacity: 1,
                                display: 'flex',
                                duration: 0.3
                            });
                        }
                    });
                };
                Header.tag = 'Header';
                Header.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/header/hamburger-open/control.ts":
            /*!*********************************************************!*\
              !*** ./src/components/header/hamburger-open/control.ts ***!
              \*********************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "HamburgerOpen": function() {
                        return /* binding */ HamburgerOpen;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_state_MobileMenuState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/state/MobileMenuState */ "./src/scripts/state/MobileMenuState.ts");
                /* harmony import */
                var _scripts_state_ViewState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/state/ViewState */ "./src/scripts/state/ViewState.ts");



                var HamburgerOpen = function() {
                    var element = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.rootRef)();
                    // clickopen
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return element.unwrap();
                    }, 'click', function(evt, target) {
                        _scripts_state_MobileMenuState__WEBPACK_IMPORTED_MODULE_1__.MobileMenuState.wrap(function(state) {
                            return Object.assign({}, state, {
                                isOpen: true,
                                originallyFocusedElement: document.activeElement
                            });
                        });
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.effect)(function() {
                        var isTopFv = _scripts_state_ViewState__WEBPACK_IMPORTED_MODULE_2__.ViewState.unwrap().isTopFv;
                        var el = element.unwrap();
                        if (!el) {
                            return;
                        }
                        isTopFv ? el.classList.add('is-white') : el.classList.remove('is-white');
                    });
                };
                HamburgerOpen.tag = 'HamburgerOpen';
                HamburgerOpen.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/header/menu/control.ts":
            /*!***********************************************!*\
              !*** ./src/components/header/menu/control.ts ***!
              \***********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "Menu": function() {
                        return /* binding */ Menu;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var _scripts_state_ViewState__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @/scripts/state/ViewState */ "./src/scripts/state/ViewState.ts");
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");


                var Menu = function() {
                    var element = (0, furnace__WEBPACK_IMPORTED_MODULE_1__.rootRef)();
                    (0, furnace__WEBPACK_IMPORTED_MODULE_1__.effect)(function() {
                        var isTopFv = _scripts_state_ViewState__WEBPACK_IMPORTED_MODULE_0__.ViewState.unwrap().isTopFv;
                        var el = element.unwrap();
                        if (!el) {
                            return;
                        }
                        isTopFv ? el.classList.add('is-white') : el.classList.remove('is-white');
                    });
                };
                Menu.tag = 'Menu';
                Menu.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/member/member-close/control.ts":
            /*!*******************************************************!*\
              !*** ./src/components/member/member-close/control.ts ***!
              \*******************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "MemberClose": function() {
                        return /* binding */ MemberClose;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_state_MemberDialogState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/state/MemberDialogState */ "./src/scripts/state/MemberDialogState.ts");


                var MemberClose = function() {
                    var element = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.rootRef)();
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return element.unwrap();
                    }, 'click', function(evt, target) {
                        closeDialog();
                    });
                    // esc
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return document;
                    }, 'keydown', function(evt, target) {
                        if (evt.key !== 'Escape') {
                            return;
                        }
                        closeDialog();
                    });
                    var closeDialog = function() {
                        _scripts_state_MemberDialogState__WEBPACK_IMPORTED_MODULE_1__.MemberDialogState.wrap(function(state) {
                            return Object.assign({}, state, {
                                isOpen: false
                            });
                        });
                    };
                };
                MemberClose.tag = 'MemberClose';
                MemberClose.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/member/member-dialogs/member-dialog/control.ts":
            /*!***********************************************************************!*\
              !*** ./src/components/member/member-dialogs/member-dialog/control.ts ***!
              \***********************************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "MemberDialog": function() {
                        return /* binding */ MemberDialog;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_state_MemberDialogState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/state/MemberDialogState */ "./src/scripts/state/MemberDialogState.ts");
                /* harmony import */
                var scroll_lock__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! scroll-lock */ "./node_modules/scroll-lock/dist/scroll-lock.js");
                /* harmony import */
                var scroll_lock__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __webpack_require__.n(scroll_lock__WEBPACK_IMPORTED_MODULE_2__);
                /* harmony import */
                var _member_close_control__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! ../../member-close/control */ "./src/components/member/member-close/control.ts");
                /* harmony import */
                var gsap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");





                var MemberDialog = function(props) {
                    var element = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.rootRef)();
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    addChild(_member_close_control__WEBPACK_IMPORTED_MODULE_3__.MemberClose);
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.effect)(function() {
                        var el = element.unwrap();
                        var _a = _scripts_state_MemberDialogState__WEBPACK_IMPORTED_MODULE_1__.MemberDialogState.unwrap(),
                            isOpen = _a.isOpen,
                            currentMemberId = _a.currentMemberId;
                        if (!el) {
                            return;
                        }
                        isOpen ? open(el, currentMemberId) : close(el, currentMemberId);
                    });
                    var open = function(el, currentId) {
                        if (currentId !== el.id) {
                            return;
                        }
                        gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.to(el, {
                            opacity: 1,
                            display: 'flex',
                            duration: 0.3
                        });
                        el.setAttribute('aria-hidden', 'false');
                        (0, scroll_lock__WEBPACK_IMPORTED_MODULE_2__.disablePageScroll)(el);
                    };
                    var close = function(el, currentId) {
                        var openButtonElement = document.querySelector("[aria-controls=\"".concat(currentId, "\"]"));
                        gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.to(el, {
                            opacity: 0,
                            display: 'none',
                            duration: 0.3,
                            onComplete: function() {
                                openButtonElement && openButtonElement.focus();
                            }
                        });
                        _scripts_state_MemberDialogState__WEBPACK_IMPORTED_MODULE_1__.MemberDialogState.wrap(function(state) {
                            return Object.assign({}, state, {
                                currentMemberId: null
                            });
                        });
                        el.setAttribute('aria-hidden', 'true');
                        (0, scroll_lock__WEBPACK_IMPORTED_MODULE_2__.enablePageScroll)(el);
                    };
                };
                MemberDialog.tag = 'MemberDialog';
                MemberDialog.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/member/member-layout/control.ts":
            /*!********************************************************!*\
              !*** ./src/components/member/member-layout/control.ts ***!
              \********************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "MemberLayout": function() {
                        return /* binding */ MemberLayout;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useFadeinContent */ "./src/scripts/hooks/useFadeinContent.ts");
                /* harmony import */
                var _components_page_header_control__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/components/page-header/control */ "./src/components/page-header/control.ts");
                /* harmony import */
                var _components_member_member_open_control__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/components/member/member-open/control */ "./src/components/member/member-open/control.ts");
                /* harmony import */
                var _components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @/components/reading-start-sentinel/control */ "./src/components/reading-start-sentinel/control.ts");





                var MemberLayout = function(props) {
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        contents: []
                    }).refs;
                    (0, _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_1__.useFadeinContent)(function() {
                        return refs.unwrap().contents;
                    });
                    addChild(_components_page_header_control__WEBPACK_IMPORTED_MODULE_2__.PageHeader);
                    addChild(_components_member_member_open_control__WEBPACK_IMPORTED_MODULE_3__.MemberOpen);
                    addChild(_components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_4__.ReadingStartSentinel);
                };
                MemberLayout.tag = 'MemberLayout';
                MemberLayout.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/member/member-open/control.ts":
            /*!******************************************************!*\
              !*** ./src/components/member/member-open/control.ts ***!
              \******************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "MemberOpen": function() {
                        return /* binding */ MemberOpen;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_state_MemberDialogState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/state/MemberDialogState */ "./src/scripts/state/MemberDialogState.ts");


                var MemberOpen = function() {
                    var element = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.rootRef)();
                    // clickopen
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return element.unwrap();
                    }, 'click', function(evt, target) {
                        var targetId = target.getAttribute('aria-controls');
                        _scripts_state_MemberDialogState__WEBPACK_IMPORTED_MODULE_1__.MemberDialogState.wrap(function(state) {
                            return Object.assign({}, state, {
                                isOpen: true,
                                currentMemberId: targetId
                            });
                        });
                    });
                };
                MemberOpen.tag = 'MemberOpen';
                MemberOpen.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/news-archive/news-archive-layout/control.ts":
            /*!********************************************************************!*\
              !*** ./src/components/news-archive/news-archive-layout/control.ts ***!
              \********************************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "NewsArchiveLayout": function() {
                        return /* binding */ NewsArchiveLayout;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useFadeinContent */ "./src/scripts/hooks/useFadeinContent.ts");
                /* harmony import */
                var _components_page_header_control__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/components/page-header/control */ "./src/components/page-header/control.ts");
                /* harmony import */
                var _components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/components/reading-start-sentinel/control */ "./src/components/reading-start-sentinel/control.ts");




                var NewsArchiveLayout = function(props) {
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        contents: []
                    }).refs;
                    (0, _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_1__.useFadeinContent)(function() {
                        return refs.unwrap().contents;
                    });
                    addChild(_components_page_header_control__WEBPACK_IMPORTED_MODULE_2__.PageHeader);
                    addChild(_components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_3__.ReadingStartSentinel);
                };
                NewsArchiveLayout.tag = 'NewsArchiveLayout';
                NewsArchiveLayout.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/news-single/news-single-layout/control.ts":
            /*!******************************************************************!*\
              !*** ./src/components/news-single/news-single-layout/control.ts ***!
              \******************************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "NewsSingleLayout": function() {
                        return /* binding */ NewsSingleLayout;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useFadeinContent */ "./src/scripts/hooks/useFadeinContent.ts");
                /* harmony import */
                var _components_page_header_control__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/components/page-header/control */ "./src/components/page-header/control.ts");
                /* harmony import */
                var _components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/components/reading-start-sentinel/control */ "./src/components/reading-start-sentinel/control.ts");




                var NewsSingleLayout = function(props) {
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        contents: []
                    }).refs;
                    (0, _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_1__.useFadeinContent)(function() {
                        return refs.unwrap().contents;
                    });
                    addChild(_components_page_header_control__WEBPACK_IMPORTED_MODULE_2__.PageHeader);
                    addChild(_components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_3__.ReadingStartSentinel);
                };
                NewsSingleLayout.tag = 'NewsSingleLayout';
                NewsSingleLayout.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/page-header/control.ts":
            /*!***********************************************!*\
              !*** ./src/components/page-header/control.ts ***!
              \***********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "PageHeader": function() {
                        return /* binding */ PageHeader;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useFadeinHeading__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useFadeinHeading */ "./src/scripts/hooks/useFadeinHeading.ts");


                var PageHeader = function(props) {
                    var element = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.rootRef)();
                    (0, _scripts_hooks_useFadeinHeading__WEBPACK_IMPORTED_MODULE_1__.useFadeInHeading)(function() {
                        return element.unwrap();
                    });
                };
                PageHeader.tag = 'PageHeader';
                PageHeader.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/page/control.ts":
            /*!****************************************!*\
              !*** ./src/components/page/control.ts ***!
              \****************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "Page": function() {
                        return /* binding */ Page;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _components_hamburger_menu_control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/components/hamburger-menu/control */ "./src/components/hamburger-menu/control.ts");
                /* harmony import */
                var _components_header_control__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/components/header/control */ "./src/components/header/control.ts");
                /* harmony import */
                var _scripts_state_MobileMenuState__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/scripts/state/MobileMenuState */ "./src/scripts/state/MobileMenuState.ts");
                /* harmony import */
                var _components_window_size_observer_control__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @/components/window-size-observer/control */ "./src/components/window-size-observer/control.ts");
                /* harmony import */
                var _scripts_state_ViewState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! @/scripts/state/ViewState */ "./src/scripts/state/ViewState.ts");
                /* harmony import */
                var _scripts_state_SplashState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! @/scripts/state/SplashState */ "./src/scripts/state/SplashState.ts");
                /* harmony import */
                var _scripts_state_MemberDialogState__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! @/scripts/state/MemberDialogState */ "./src/scripts/state/MemberDialogState.ts");
                /* harmony import */
                var _components_footer_back_to_top_control__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__( /*! @/components/footer/back-to-top/control */ "./src/components/footer/back-to-top/control.ts");
                /* harmony import */
                var _scripts_state_PageState__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__( /*! @/scripts/state/PageState */ "./src/scripts/state/PageState.ts");
                /* harmony import */
                var _components_top_top_layout_control__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__( /*! @/components/top/top-layout/control */ "./src/components/top/top-layout/control.ts");
                /* harmony import */
                var _components_about_about_layout_control__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__( /*! @/components/about/about-layout/control */ "./src/components/about/about-layout/control.ts");
                /* harmony import */
                var _components_archive_layout_control__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__( /*! @/components/archive-layout/control */ "./src/components/archive-layout/control.ts");
                /* harmony import */
                var _components_works_single_works_single_layout_control__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__( /*! @/components/works-single/works-single-layout/control */ "./src/components/works-single/works-single-layout/control.ts");
                /* harmony import */
                var _components_features_single_features_single_layout_control__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__( /*! @/components/features-single/features-single-layout/control */ "./src/components/features-single/features-single-layout/control.ts");
                /* harmony import */
                var _components_news_archive_news_archive_layout_control__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__( /*! @/components/news-archive/news-archive-layout/control */ "./src/components/news-archive/news-archive-layout/control.ts");
                /* harmony import */
                var _components_news_single_news_single_layout_control__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__( /*! @/components/news-single/news-single-layout/control */ "./src/components/news-single/news-single-layout/control.ts");
                /* harmony import */
                var _components_terms_terms_layout_control__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__( /*! @/components/terms/terms-layout/control */ "./src/components/terms/terms-layout/control.ts");
                /* harmony import */
                var _components_member_member_layout_control__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__( /*! @/components/member/member-layout/control */ "./src/components/member/member-layout/control.ts");
                /* harmony import */
                var _components_member_member_dialogs_member_dialog_control__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__( /*! @/components/member/member-dialogs/member-dialog/control */ "./src/components/member/member-dialogs/member-dialog/control.ts");
                /* harmony import */
                var _components_splash_control__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__( /*! @/components/splash/control */ "./src/components/splash/control.ts");
                /* harmony import */
                var _components_bg_canvas_control__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__( /*! @/components/bg-canvas/control */ "./src/components/bg-canvas/control.ts");






















                var Page = function() {
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        header: null,
                        content: null,
                        footer: null
                    }).refs;
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.effect)(function() {
                        var content = refs.unwrap().content;
                        var isOpen = _scripts_state_MobileMenuState__WEBPACK_IMPORTED_MODULE_3__.MobileMenuState.unwrap().isOpen;
                        var currentMemberId = _scripts_state_MemberDialogState__WEBPACK_IMPORTED_MODULE_7__.MemberDialogState.unwrap().currentMemberId;
                        if (!content) {
                            return;
                        }
                        if (isOpen || !!currentMemberId) {
                            content.setAttribute('inert', '');
                        } else {
                            content.removeAttribute('inert');
                        }
                        _scripts_state_PageState__WEBPACK_IMPORTED_MODULE_9__.PageState.wrap(function(state) {
                            return Object.assign({}, state, {
                                pageTopFocusTarget: content
                            });
                        });
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useWatch)(function() {
                        return _scripts_state_SplashState__WEBPACK_IMPORTED_MODULE_6__.SplashState.unwrap().isAnimated;
                    }, function(isAnimated) {
                        var header = refs.unwrap().header;
                        if (!header) {
                            return;
                        }
                        isAnimated && header.classList.remove('is-hidden');
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useIntersectionWatch)(function() {
                        return refs.unwrap().footer;
                    }, function(entry) {
                        if (entry.isIntersecting) {
                            _scripts_state_ViewState__WEBPACK_IMPORTED_MODULE_5__.ViewState.wrap(function(state) {
                                return Object.assign({}, state, {
                                    isFooter: true
                                });
                            });
                        } else {
                            _scripts_state_ViewState__WEBPACK_IMPORTED_MODULE_5__.ViewState.wrap(function(state) {
                                return Object.assign({}, state, {
                                    isFooter: false
                                });
                            });
                        }
                    }, {
                        rootMargin: '0px 0px -70% 0px'
                    });
                    // common
                    addChild(_components_header_control__WEBPACK_IMPORTED_MODULE_2__.Header);
                    addChild(_components_hamburger_menu_control__WEBPACK_IMPORTED_MODULE_1__.HamburgerMenu);
                    addChild(_components_window_size_observer_control__WEBPACK_IMPORTED_MODULE_4__.WindowSizeObserver);
                    addChild(_components_footer_back_to_top_control__WEBPACK_IMPORTED_MODULE_8__.BackToTop);
                    addChild(_components_splash_control__WEBPACK_IMPORTED_MODULE_20__.Splash);
                    // pages
                    addChild(_components_top_top_layout_control__WEBPACK_IMPORTED_MODULE_10__.TopPage);
                    addChild(_components_about_about_layout_control__WEBPACK_IMPORTED_MODULE_11__.AboutLayout);
                    addChild(_components_archive_layout_control__WEBPACK_IMPORTED_MODULE_12__.ArchiveLayout);
                    addChild(_components_works_single_works_single_layout_control__WEBPACK_IMPORTED_MODULE_13__.WorksSingleLayout);
                    addChild(_components_features_single_features_single_layout_control__WEBPACK_IMPORTED_MODULE_14__.FeaturesSingleLayout);
                    addChild(_components_news_archive_news_archive_layout_control__WEBPACK_IMPORTED_MODULE_15__.NewsArchiveLayout);
                    addChild(_components_news_single_news_single_layout_control__WEBPACK_IMPORTED_MODULE_16__.NewsSingleLayout);
                    addChild(_components_terms_terms_layout_control__WEBPACK_IMPORTED_MODULE_17__.TermsLayout);
                    addChild(_components_member_member_layout_control__WEBPACK_IMPORTED_MODULE_18__.MemberLayout);
                    addChild(_components_member_member_dialogs_member_dialog_control__WEBPACK_IMPORTED_MODULE_19__.MemberDialog);
                    addChild(_components_footer_back_to_top_control__WEBPACK_IMPORTED_MODULE_8__.BackToTop);
                    addChild(_components_bg_canvas_control__WEBPACK_IMPORTED_MODULE_21__.BgCanvas);
                };
                Page.tag = 'Page';
                Page.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/reading-start-sentinel/control.ts":
            /*!**********************************************************!*\
              !*** ./src/components/reading-start-sentinel/control.ts ***!
              \**********************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "ReadingStartSentinel": function() {
                        return /* binding */ ReadingStartSentinel;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_3d_context_world3DContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/3d/context/world3DContext */ "./src/scripts/3d/context/world3DContext.ts");


                var ReadingStartSentinel = function() {
                    var root = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.rootRef)();
                    var prefersReadableContrastValue = _scripts_3d_context_world3DContext__WEBPACK_IMPORTED_MODULE_1__.world3DContext.use().prefersReadableContrastValue;
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useIntersectionWatch)(function() {
                        return root.unwrap();
                    }, function(entry) {
                        prefersReadableContrastValue.wrap(!entry.isIntersecting && entry.boundingClientRect.y < 100);
                    }, {
                        rootMargin: '-100px 0px 0px 0px'
                    });
                };
                ReadingStartSentinel.tag = "ReadingStartSentinel";
                ReadingStartSentinel.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/splash/control.ts":
            /*!******************************************!*\
              !*** ./src/components/splash/control.ts ***!
              \******************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "Splash": function() {
                        return /* binding */ Splash;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useSplash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useSplash */ "./src/scripts/hooks/useSplash.ts");
                /* harmony import */
                var _scripts_state_SplashState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/state/SplashState */ "./src/scripts/state/SplashState.ts");



                var Splash = function(props) {
                    var element = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.rootRef)();
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        progress: null
                    }).refs;
                    var _a = (0, _scripts_hooks_useSplash__WEBPACK_IMPORTED_MODULE_1__.useSplash)(function() {
                            return element.unwrap();
                        }, function() {
                            return refs.unwrap().progress;
                        }),
                        updateProgress = _a.updateProgress,
                        skip = _a.skip;
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useWatch)(function() {
                        return _scripts_state_SplashState__WEBPACK_IMPORTED_MODULE_2__.SplashState.unwrap().needsSplash;
                    }, function(val) {
                        if (!val) {
                            skip();
                        }
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useWatch)(function() {
                        return _scripts_state_SplashState__WEBPACK_IMPORTED_MODULE_2__.SplashState.unwrap().progressCount;
                    }, function(progressCount) {
                        progressCount && updateProgress(progressCount);
                    });
                };
                Splash.tag = 'Splash';
                Splash.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/terms/terms-header/control.ts":
            /*!******************************************************!*\
              !*** ./src/components/terms/terms-header/control.ts ***!
              \******************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "TermsHeader": function() {
                        return /* binding */ TermsHeader;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useFadeinHeading__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useFadeinHeading */ "./src/scripts/hooks/useFadeinHeading.ts");


                var TermsHeader = function(props) {
                    var element = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.rootRef)();
                    (0, _scripts_hooks_useFadeinHeading__WEBPACK_IMPORTED_MODULE_1__.useFadeInHeading)(function() {
                        return element.unwrap();
                    });
                };
                TermsHeader.tag = 'TermsHeader';
                TermsHeader.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/terms/terms-layout/control.ts":
            /*!******************************************************!*\
              !*** ./src/components/terms/terms-layout/control.ts ***!
              \******************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "TermsLayout": function() {
                        return /* binding */ TermsLayout;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useFadeinContent */ "./src/scripts/hooks/useFadeinContent.ts");
                /* harmony import */
                var _components_terms_terms_header_control__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/components/terms/terms-header/control */ "./src/components/terms/terms-header/control.ts");
                /* harmony import */
                var _components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/components/reading-start-sentinel/control */ "./src/components/reading-start-sentinel/control.ts");




                var TermsLayout = function(props) {
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        contents: []
                    }).refs;
                    (0, _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_1__.useFadeinContent)(function() {
                        return refs.unwrap().contents;
                    });
                    addChild(_components_terms_terms_header_control__WEBPACK_IMPORTED_MODULE_2__.TermsHeader);
                    addChild(_components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_3__.ReadingStartSentinel);
                };
                TermsLayout.tag = 'TermsLayout';
                TermsLayout.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/top/top-features/control.ts":
            /*!****************************************************!*\
              !*** ./src/components/top/top-features/control.ts ***!
              \****************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "TopFeatures": function() {
                        return /* binding */ TopFeatures;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useFadeinHeading__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useFadeinHeading */ "./src/scripts/hooks/useFadeinHeading.ts");
                /* harmony import */
                var _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/hooks/useFadeinContent */ "./src/scripts/hooks/useFadeinContent.ts");
                /* harmony import */
                var _components_card_control__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/components/card/control */ "./src/components/card/control.ts");




                var TopFeatures = function(props) {
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        heading: null,
                        contents: []
                    }).refs;
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    (0, _scripts_hooks_useFadeinHeading__WEBPACK_IMPORTED_MODULE_1__.useFadeInHeading)(function() {
                        return refs.unwrap().heading;
                    });
                    (0, _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_2__.useFadeinContent)(function() {
                        return refs.unwrap().contents;
                    });
                    addChild(_components_card_control__WEBPACK_IMPORTED_MODULE_3__.Card);
                };
                TopFeatures.tag = 'TopFeatures';
                TopFeatures.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/top/top-kv/control.ts":
            /*!**********************************************!*\
              !*** ./src/components/top/top-kv/control.ts ***!
              \**********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "TopKv": function() {
                        return /* binding */ TopKv;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_state_SplashState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/state/SplashState */ "./src/scripts/state/SplashState.ts");
                /* harmony import */
                var _scripts_hooks_usePreloadVideo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/hooks/usePreloadVideo */ "./src/scripts/hooks/usePreloadVideo.ts");



                var TopKv = function(props) {
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        scroll: null,
                        cover: null,
                        video: null,
                        logo: null
                    }).refs;
                    var count = (0, _scripts_hooks_usePreloadVideo__WEBPACK_IMPORTED_MODULE_2__.usePreloadVideo)(function() {
                        return refs.unwrap().video;
                    }, props.videoPath).count;
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useWatch)(function() {
                        return count.unwrap();
                    }, function(count) {
                        _scripts_state_SplashState__WEBPACK_IMPORTED_MODULE_1__.SplashState.wrap(function(state) {
                            return Object.assign({}, state, {
                                progressCount: count
                            });
                        });
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useWatch)(function() {
                        return _scripts_state_SplashState__WEBPACK_IMPORTED_MODULE_1__.SplashState.unwrap().isAnimated;
                    }, function(isAnimated) {
                        var _a = refs.unwrap(),
                            logo = _a.logo,
                            scroll = _a.scroll,
                            cover = _a.cover;
                        if (!logo || !scroll || !cover) {
                            return;
                        }
                        isAnimated && logo.classList.remove('is-hidden');
                        isAnimated && scroll.classList.remove('is-hidden');
                        isAnimated && cover.classList.remove('is-show');
                    });
                };
                TopKv.tag = 'TopKv';
                TopKv.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/top/top-layout/control.ts":
            /*!**************************************************!*\
              !*** ./src/components/top/top-layout/control.ts ***!
              \**************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "TopPage": function() {
                        return /* binding */ TopPage;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_state_ViewState__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/state/ViewState */ "./src/scripts/state/ViewState.ts");
                /* harmony import */
                var _scripts_state_SplashState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/state/SplashState */ "./src/scripts/state/SplashState.ts");
                /* harmony import */
                var _components_top_top_lead_control__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/components/top/top-lead/control */ "./src/components/top/top-lead/control.ts");
                /* harmony import */
                var _components_top_top_works_control__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @/components/top/top-works/control */ "./src/components/top/top-works/control.ts");
                /* harmony import */
                var _components_top_top_features_control__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! @/components/top/top-features/control */ "./src/components/top/top-features/control.ts");
                /* harmony import */
                var _components_top_top_news_control__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! @/components/top/top-news/control */ "./src/components/top/top-news/control.ts");
                /* harmony import */
                var _components_top_top_kv_control__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! @/components/top/top-kv/control */ "./src/components/top/top-kv/control.ts");
                /* harmony import */
                var _components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__( /*! @/components/reading-start-sentinel/control */ "./src/components/reading-start-sentinel/control.ts");









                var TopPage = function(props) {
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        kv: null
                    }).refs;
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    _scripts_state_SplashState__WEBPACK_IMPORTED_MODULE_2__.SplashState.wrap(function(state) {
                        return Object.assign({}, state, {
                            needsSplash: true
                        });
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useIntersectionWatch)(function() {
                        return refs.unwrap().kv;
                    }, function(entry) {
                        if (entry.isIntersecting) {
                            _scripts_state_ViewState__WEBPACK_IMPORTED_MODULE_1__.ViewState.wrap(function(state) {
                                return Object.assign({}, state, {
                                    isTopFv: true
                                });
                            });
                        } else {
                            _scripts_state_ViewState__WEBPACK_IMPORTED_MODULE_1__.ViewState.wrap(function(state) {
                                return Object.assign({}, state, {
                                    isTopFv: false
                                });
                            });
                        }
                    });
                    addChild(_components_top_top_kv_control__WEBPACK_IMPORTED_MODULE_7__.TopKv);
                    addChild(_components_top_top_lead_control__WEBPACK_IMPORTED_MODULE_3__.TopLead);
                    addChild(_components_top_top_works_control__WEBPACK_IMPORTED_MODULE_4__.TopWorks);
                    addChild(_components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_8__.ReadingStartSentinel);
                    addChild(_components_top_top_features_control__WEBPACK_IMPORTED_MODULE_5__.TopFeatures);
                    addChild(_components_top_top_news_control__WEBPACK_IMPORTED_MODULE_6__.TopNews);
                };
                TopPage.tag = 'TopPage';
                TopPage.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/top/top-lead/control.ts":
            /*!************************************************!*\
              !*** ./src/components/top/top-lead/control.ts ***!
              \************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "TopLead": function() {
                        return /* binding */ TopLead;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useFadeinHeading__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useFadeinHeading */ "./src/scripts/hooks/useFadeinHeading.ts");
                /* harmony import */
                var _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/hooks/useFadeinContent */ "./src/scripts/hooks/useFadeinContent.ts");



                var TopLead = function(props) {
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        heading: null,
                        contents: []
                    }).refs;
                    (0, _scripts_hooks_useFadeinHeading__WEBPACK_IMPORTED_MODULE_1__.useFadeInHeading)(function() {
                        return refs.unwrap().heading;
                    });
                    (0, _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_2__.useFadeinContent)(function() {
                        return refs.unwrap().contents;
                    });
                };
                TopLead.tag = 'TopLead';
                TopLead.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/top/top-news/control.ts":
            /*!************************************************!*\
              !*** ./src/components/top/top-news/control.ts ***!
              \************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "TopNews": function() {
                        return /* binding */ TopNews;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useFadeinHeading__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useFadeinHeading */ "./src/scripts/hooks/useFadeinHeading.ts");
                /* harmony import */
                var _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/hooks/useFadeinContent */ "./src/scripts/hooks/useFadeinContent.ts");



                var TopNews = function(props) {
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        heading: null,
                        contents: []
                    }).refs;
                    (0, _scripts_hooks_useFadeinHeading__WEBPACK_IMPORTED_MODULE_1__.useFadeInHeading)(function() {
                        return refs.unwrap().heading;
                    });
                    (0, _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_2__.useFadeinContent)(function() {
                        return refs.unwrap().contents;
                    });
                };
                TopNews.tag = 'TopNews';
                TopNews.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/top/top-works/control.ts":
            /*!*************************************************!*\
              !*** ./src/components/top/top-works/control.ts ***!
              \*************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "TopWorks": function() {
                        return /* binding */ TopWorks;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useFadeinHeading__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useFadeinHeading */ "./src/scripts/hooks/useFadeinHeading.ts");
                /* harmony import */
                var _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/hooks/useFadeinContent */ "./src/scripts/hooks/useFadeinContent.ts");
                /* harmony import */
                var _components_card_control__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/components/card/control */ "./src/components/card/control.ts");




                var TopWorks = function(props) {
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        heading: null,
                        contents: []
                    }).refs;
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    (0, _scripts_hooks_useFadeinHeading__WEBPACK_IMPORTED_MODULE_1__.useFadeInHeading)(function() {
                        return refs.unwrap().heading;
                    });
                    (0, _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_2__.useFadeinContent)(function() {
                        return refs.unwrap().contents;
                    });
                    addChild(_components_card_control__WEBPACK_IMPORTED_MODULE_3__.Card);
                };
                TopWorks.tag = 'TopWorks';
                TopWorks.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/window-size-observer/control.ts":
            /*!********************************************************!*\
              !*** ./src/components/window-size-observer/control.ts ***!
              \********************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "WindowSizeObserver": function() {
                        return /* binding */ WindowSizeObserver;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! resize-observer-polyfill */ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js");
                /* harmony import */
                var _scripts_state_WindowSizeState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/state/WindowSizeState */ "./src/scripts/state/WindowSizeState.ts");
                /* harmony import */
                var throttle_debounce__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! throttle-debounce */ "./node_modules/throttle-debounce/esm/index.js");




                var WindowSizeObserver = function() {
                    var element = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.rootRef)();
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.effect)(function() {
                        var el = element.unwrap();
                        if (!el) {
                            return;
                        }
                        var handleResize = function() {
                            var height = window.innerHeight;
                            var width = window.innerWidth;
                            _scripts_state_WindowSizeState__WEBPACK_IMPORTED_MODULE_2__.WindowSizeState.wrap(function(state) {
                                return Object.assign({}, state, {
                                    height: height,
                                    width: width
                                });
                            });
                        };
                        var resizeObserver = new resize_observer_polyfill__WEBPACK_IMPORTED_MODULE_1__["default"]((0, throttle_debounce__WEBPACK_IMPORTED_MODULE_3__.debounce)(100, handleResize));
                        resizeObserver.observe(el);
                    });
                };
                WindowSizeObserver.tag = 'WindowSizeObserver';
                WindowSizeObserver.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/works-single/works-single-layout/control.ts":
            /*!********************************************************************!*\
              !*** ./src/components/works-single/works-single-layout/control.ts ***!
              \********************************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "WorksSingleLayout": function() {
                        return /* binding */ WorksSingleLayout;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useFadeinContent */ "./src/scripts/hooks/useFadeinContent.ts");
                /* harmony import */
                var _components_page_header_control__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/components/page-header/control */ "./src/components/page-header/control.ts");
                /* harmony import */
                var _components_works_single_works_slider_control__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/components/works-single/works-slider/control */ "./src/components/works-single/works-slider/control.ts");
                /* harmony import */
                var _components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @/components/reading-start-sentinel/control */ "./src/components/reading-start-sentinel/control.ts");





                var WorksSingleLayout = function(props) {
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        contents: []
                    }).refs;
                    (0, _scripts_hooks_useFadeinContent__WEBPACK_IMPORTED_MODULE_1__.useFadeinContent)(function() {
                        return refs.unwrap().contents;
                    });
                    addChild(_components_page_header_control__WEBPACK_IMPORTED_MODULE_2__.PageHeader);
                    addChild(_components_works_single_works_slider_control__WEBPACK_IMPORTED_MODULE_3__.WorksSlider);
                    addChild(_components_reading_start_sentinel_control__WEBPACK_IMPORTED_MODULE_4__.ReadingStartSentinel);
                };
                WorksSingleLayout.tag = 'WorksSingleLayout';
                WorksSingleLayout.defaultProps = {};



                /***/
            }),

        /***/
        "./src/components/works-single/works-slider/control.ts":
            /*!*************************************************************!*\
              !*** ./src/components/works-single/works-slider/control.ts ***!
              \*************************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "WorksSlider": function() {
                        return /* binding */ WorksSlider;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useSlide__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useSlide */ "./src/scripts/hooks/useSlide.ts");
                /* harmony import */
                var what_input__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! what-input */ "./node_modules/what-input/dist/what-input.js");
                /* harmony import */
                var what_input__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __webpack_require__.n(what_input__WEBPACK_IMPORTED_MODULE_2__);
                /* harmony import */
                var _scripts_hooks_useBlurredSlide__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/scripts/hooks/useBlurredSlide */ "./src/scripts/hooks/useBlurredSlide.ts");




                var WorksSlider = function() {
                    var element = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.rootRef)();
                    var refs = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useDomRef)({
                        slider: null,
                        slide: [],
                        slideImage: [],
                        pagination: null,
                        prev: null,
                        next: null,
                        background: null
                    }).refs;
                    var touchPositionX = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)(0);
                    var onSlideChange = function(index) {
                        blurredSlide.goto(index);
                    };
                    var _a = (0, _scripts_hooks_useSlide__WEBPACK_IMPORTED_MODULE_1__.useSlide)(function() {
                            return refs.unwrap().slide;
                        }, function() {
                            return refs.unwrap().pagination;
                        }, {
                            interval: 3000,
                            progressCircle: {
                                diameter: 18,
                                strokeWidth: 1
                            },
                            onSlideChange: onSlideChange
                        }),
                        slideNext = _a.slideNext,
                        slidePrev = _a.slidePrev,
                        discardAutoPlay = _a.discardAutoPlay;
                    var blurredSlide = (0, _scripts_hooks_useBlurredSlide__WEBPACK_IMPORTED_MODULE_3__.useBlurredSlide)(function() {
                        return refs.unwrap().slideImage;
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useWatch)(function() {
                        return refs.unwrap().background;
                    }, function(el) {
                        if (!el) {
                            return;
                        }
                        var rect = el.getBoundingClientRect();
                        blurredSlide.setSize(rect.width, rect.height);
                        el.insertAdjacentElement('afterbegin', blurredSlide.canvas);
                        return function() {
                            el.removeChild(blurredSlide.canvas);
                        };
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return window;
                    }, 'resize', function() {
                        var el = refs.unwrap().background;
                        if (!el) {
                            return;
                        }
                        var rect = el.getBoundingClientRect();
                        blurredSlide.setSize(rect.width, rect.height);
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useTick)(function() {
                        blurredSlide.render();
                    }, {
                        autoStart: true
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return refs.unwrap().prev;
                    }, 'click', function() {
                        slidePrev();
                        discardAutoPlay();
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return refs.unwrap().next;
                    }, 'click', function() {
                        slideNext();
                        discardAutoPlay();
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return refs.unwrap().slider;
                    }, what_input__WEBPACK_IMPORTED_MODULE_2___default().ask() === 'touch' ? 'touchstart' : 'pointerdown', function(evt) {
                        var pageX = evt.type == 'touchstart' ?
                            evt.changedTouches[evt.changedTouches.length - 1].pageX :
                            evt.pageX;
                        touchPositionX.wrap(pageX);
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return refs.unwrap().slider;
                    }, what_input__WEBPACK_IMPORTED_MODULE_2___default().ask() === 'touch' ? 'touchend' : 'pointerup', function(evt) {
                        var pageX = evt.type == 'touchend' ?
                            evt.changedTouches[evt.changedTouches.length - 1].pageX :
                            evt.pageX;
                        var d = pageX - touchPositionX.unwrap();
                        if (d === 0) {
                            return;
                        }
                        0 > d ? slideNext() : slidePrev();
                        discardAutoPlay();
                    });
                };
                WorksSlider.tag = 'WorksSlider';
                WorksSlider.defaultProps = {};



                /***/
            }),

        /***/
        "./src/scripts/3d/buffer/createPointSizeBuffer.ts":
            /*!********************************************************!*\
              !*** ./src/scripts/3d/buffer/createPointSizeBuffer.ts ***!
              \********************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "createPointSizeBuffer": function() {
                        return /* binding */ createPointSizeBuffer;
                    }
                    /* harmony export */
                });
                var createPointSizeBuffer = function(amount, minSize, maxSize) {
                    var buffer = new Float32Array(amount);
                    for (var i = 0; i < amount; i++) {
                        buffer[i] = (maxSize - minSize) * Math.random() + minSize;
                    }
                    return buffer;
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/buffer/createPositionBufferFromGeometry.ts":
            /*!*******************************************************************!*\
              !*** ./src/scripts/3d/buffer/createPositionBufferFromGeometry.ts ***!
              \*******************************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "createPositionBufferFromGeometry": function() {
                        return /* binding */ createPositionBufferFromGeometry;
                    }
                    /* harmony export */
                });
                var createPositionBufferFromGeometry = function(geometry) {
                    var position = geometry.attributes.position;
                    var buffer = new Float32Array(position.count * 3);
                    for (var i = 0; i < position.count; i++) {
                        buffer[i * 3] = position.getX(i);
                        buffer[i * 3 + 1] = position.getY(i);
                        buffer[i * 3 + 2] = position.getZ(i);
                    }
                    return buffer;
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/buffer/createPositionUVBuffer.ts":
            /*!*********************************************************!*\
              !*** ./src/scripts/3d/buffer/createPositionUVBuffer.ts ***!
              \*********************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "createPositionUVBuffer": function() {
                        return /* binding */ createPositionUVBuffer;
                    }
                    /* harmony export */
                });
                var createPositionUVBuffer = function(amount, textureWidth, textureHeight) {
                    var buffer = new Float32Array(amount * 2);
                    var total = textureWidth * textureHeight;
                    if (amount > total) {
                        throw new Error('amount is bigger than textureWidth * textureHeight');
                    }
                    for (var i = 0; i < amount; i++) {
                        buffer[i * 2] = (i % textureWidth) / textureWidth; // u
                        buffer[i * 2 + 1] = Math.floor(i / textureWidth) / textureHeight; // v
                    }
                    return buffer;
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/buffer/createRandomPositionBuffer.ts":
            /*!*************************************************************!*\
              !*** ./src/scripts/3d/buffer/createRandomPositionBuffer.ts ***!
              \*************************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "createRandomPositionBuffer": function() {
                        return /* binding */ createRandomPositionBuffer;
                    }
                    /* harmony export */
                });
                var createRandomPositionBuffer = function(amount, zone) {
                    var buffer = new Float32Array(amount * 3);
                    var random = function() {
                        return (Math.random() + Math.random()) / 2;
                    };
                    for (var i = 0; i < amount; i++) {
                        buffer[i * 3] = zone.width * random() - zone.width * 0.5;
                        buffer[i * 3 + 1] = zone.height * random() - zone.height * 0.5;
                        buffer[i * 3 + 2] = zone.depth * random() - zone.depth * 0.5;
                    }
                    return buffer;
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/buffer/padPositionBuffer.ts":
            /*!****************************************************!*\
              !*** ./src/scripts/3d/buffer/padPositionBuffer.ts ***!
              \****************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "padPositionBuffer": function() {
                        return /* binding */ padPositionBuffer;
                    }
                    /* harmony export */
                });
                var __read = (undefined && undefined.__read) || function(o, n) {
                    var m = typeof Symbol === "function" && o[Symbol.iterator];
                    if (!m) return o;
                    var i = m.call(o),
                        r, ar = [],
                        e;
                    try {
                        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
                    } catch (error) {
                        e = {
                            error: error
                        };
                    } finally {
                        try {
                            if (r && !r.done && (m = i["return"])) m.call(i);
                        } finally {
                            if (e) throw e.error;
                        }
                    }
                    return ar;
                };
                var __spreadArray = (undefined && undefined.__spreadArray) || function(to, from, pack) {
                    if (pack || arguments.length === 2)
                        for (var i = 0, l = from.length, ar; i < l; i++) {
                            if (ar || !(i in from)) {
                                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                                ar[i] = from[i];
                            }
                        }
                    return to.concat(ar || Array.prototype.slice.call(from));
                };
                var padPositionBuffer = function(buffer, paddingBuffer) {
                    return buffer.length < paddingBuffer.length ? new Float32Array(__spreadArray(__spreadArray([], __read(buffer), false), __read(paddingBuffer.slice(buffer.length - 1, paddingBuffer.length)), false)) : buffer.slice();
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/context/world3DContext.ts":
            /*!**************************************************!*\
              !*** ./src/scripts/3d/context/world3DContext.ts ***!
              \**************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "world3DContext": function() {
                        return /* binding */ world3DContext;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_3d_hooks_usePerspectiveCamera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/3d/hooks/usePerspectiveCamera */ "./src/scripts/3d/hooks/usePerspectiveCamera.ts");
                /* harmony import */
                var _scripts_3d_hooks_useWebGLRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/3d/hooks/useWebGLRenderer */ "./src/scripts/3d/hooks/useWebGLRenderer.ts");
                /* harmony import */
                var _scripts_3d_hooks_useScene__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/scripts/3d/hooks/useScene */ "./src/scripts/3d/hooks/useScene.ts");




                var world3DContext = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.createContext)(function() {
                    var scene = (0, _scripts_3d_hooks_useScene__WEBPACK_IMPORTED_MODULE_3__.useScene)().scene;
                    var _a = (0, _scripts_3d_hooks_useWebGLRenderer__WEBPACK_IMPORTED_MODULE_2__.useWebGLRenderer)(),
                        renderer = _a.renderer,
                        setRendererSize = _a.setSize;
                    var _b = (0, _scripts_3d_hooks_usePerspectiveCamera__WEBPACK_IMPORTED_MODULE_1__.usePerspectiveCamera)({
                            fov: 60,
                            aspect: window.innerWidth / window.innerHeight,
                            near: 0.1,
                            far: 3000
                        }),
                        camera = _b.camera,
                        setCameraAspect = _b.setCameraAspect;
                    var prefersReadableContrastValue = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)(false);
                    var setSize = function(width, height) {
                        setRendererSize(width, height);
                        setCameraAspect(width / height);
                    };
                    return {
                        scene: scene,
                        camera: camera,
                        renderer: renderer,
                        prefersReadableContrastValue: prefersReadableContrastValue,
                        setSize: setSize
                    };
                });



                /***/
            }),

        /***/
        "./src/scripts/3d/geometries/createConeGeometry.ts":
            /*!*********************************************************!*\
              !*** ./src/scripts/3d/geometries/createConeGeometry.ts ***!
              \*********************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "createConeGeometry": function() {
                        return /* binding */ createConeGeometry;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three_examples_jsm_modifiers_TessellateModifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! three/examples/jsm/modifiers/TessellateModifier */ "./node_modules/three/examples/jsm/modifiers/TessellateModifier.js");
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");


                var createConeGeometry = function(props) {
                    var tessellator = new three_examples_jsm_modifiers_TessellateModifier__WEBPACK_IMPORTED_MODULE_0__.TessellateModifier(props.tessellation.maxEdgeLength, props.tessellation.maxIterations);
                    var geometry = new three__WEBPACK_IMPORTED_MODULE_1__.ConeGeometry(props.radius, props.height, props.radialSegments, props.heightSegments);
                    return tessellator.modify(geometry);
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/geometries/createPolyhedronGeometry.ts":
            /*!***************************************************************!*\
              !*** ./src/scripts/3d/geometries/createPolyhedronGeometry.ts ***!
              \***************************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "createPolyhedronGeometry": function() {
                        return /* binding */ createPolyhedronGeometry;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three_examples_jsm_modifiers_TessellateModifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! three/examples/jsm/modifiers/TessellateModifier */ "./node_modules/three/examples/jsm/modifiers/TessellateModifier.js");
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");


                var createPolyhedronGeometry = function(props) {
                    var tessellator = new three_examples_jsm_modifiers_TessellateModifier__WEBPACK_IMPORTED_MODULE_0__.TessellateModifier(props.tessellation.maxEdgeLength, props.tessellation.maxIterations);
                    var geometry = new three__WEBPACK_IMPORTED_MODULE_1__.IcosahedronGeometry(props.radius, props.detail);
                    return tessellator.modify(geometry);
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/geometries/createSphereGeometry.ts":
            /*!***********************************************************!*\
              !*** ./src/scripts/3d/geometries/createSphereGeometry.ts ***!
              \***********************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "createSphereGeometry": function() {
                        return /* binding */ createSphereGeometry;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three_examples_jsm_modifiers_TessellateModifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! three/examples/jsm/modifiers/TessellateModifier */ "./node_modules/three/examples/jsm/modifiers/TessellateModifier.js");
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");


                var createSphereGeometry = function(props) {
                    var tessellator = new three_examples_jsm_modifiers_TessellateModifier__WEBPACK_IMPORTED_MODULE_0__.TessellateModifier(props.tessellation.maxEdgeLength, props.tessellation.maxIterations);
                    var geometry = new three__WEBPACK_IMPORTED_MODULE_1__.SphereGeometry(props.radius, props.widthSegments, props.heightSegment);
                    return tessellator.modify(geometry);
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/geometries/createXGeometry.ts":
            /*!******************************************************!*\
              !*** ./src/scripts/3d/geometries/createXGeometry.ts ***!
              \******************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "createXGeometry": function() {
                        return /* binding */ createXGeometry;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three_examples_jsm_modifiers_TessellateModifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! three/examples/jsm/modifiers/TessellateModifier */ "./node_modules/three/examples/jsm/modifiers/TessellateModifier.js");
                /* harmony import */
                var three_examples_jsm_loaders_FontLoader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! three/examples/jsm/loaders/FontLoader */ "./node_modules/three/examples/jsm/loaders/FontLoader.js");
                /* harmony import */
                var _font_TypefaceHelvetikerBold_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ../font/TypefaceHelvetikerBold.json */ "./src/scripts/3d/font/TypefaceHelvetikerBold.json");
                /* harmony import */
                var three_examples_jsm_geometries_TextGeometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! three/examples/jsm/geometries/TextGeometry */ "./node_modules/three/examples/jsm/geometries/TextGeometry.js");




                var createXGeometry = function(props) {
                    var tessellator = new three_examples_jsm_modifiers_TessellateModifier__WEBPACK_IMPORTED_MODULE_0__.TessellateModifier(props.tessellation.maxEdgeLength, props.tessellation.maxIterations);
                    var geometry = new three_examples_jsm_geometries_TextGeometry__WEBPACK_IMPORTED_MODULE_3__.TextGeometry('X', {
                        font: new three_examples_jsm_loaders_FontLoader__WEBPACK_IMPORTED_MODULE_1__.Font(_font_TypefaceHelvetikerBold_json__WEBPACK_IMPORTED_MODULE_2__),
                        size: 700,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelSegments: 1
                    });
                    geometry.translate(-325, -325, 0);
                    return tessellator.modify(geometry);
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/hooks/useCameraControl.ts":
            /*!**************************************************!*\
              !*** ./src/scripts/3d/hooks/useCameraControl.ts ***!
              \**************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useCameraControl": function() {
                        return /* binding */ useCameraControl;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");

                var PI = Math.PI;
                var TAU = PI * 2;
                var PI_HALF = Math.PI * 0.5;
                var PI_QUARTER = Math.PI * 0.25;
                var useCameraControl = function(camera, controlProps) {
                    var thetaRatioValue = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)(0);
                    var phiRatioValue = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)(0);
                    var propValue = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)(controlProps);
                    var currentThetaRatio = thetaRatioValue.unwrap();
                    var currentPhiRatio = phiRatioValue.unwrap();
                    var update = function() {
                        var _a = propValue.unwrap(),
                            distance = _a.distance,
                            maxTheta = _a.maxTheta,
                            maxPhi = _a.maxPhi;
                        var thetaRatio = thetaRatioValue.unwrap();
                        var phiRatio = phiRatioValue.unwrap();
                        if (thetaRatio === currentThetaRatio && phiRatio === currentPhiRatio) {
                            return;
                        }
                        var thetaDiff = thetaRatio - currentThetaRatio;
                        var phiDiff = phiRatio - currentPhiRatio;
                        currentThetaRatio += thetaDiff * 0.01;
                        currentPhiRatio += phiDiff * 0.01;
                        var sinTheta = Math.sin(-maxTheta * currentThetaRatio * 0.5);
                        var sinPhi = Math.sin(PI_HALF + maxPhi * currentPhiRatio * 0.5);
                        var cosTheta = Math.cos(-maxTheta * currentThetaRatio * 0.5);
                        var cosPhi = Math.cos(PI_HALF + maxPhi * currentPhiRatio * 0.5);
                        camera.position.x = distance * sinPhi * sinTheta;
                        camera.position.y = distance * cosPhi;
                        camera.position.z = distance * sinPhi * cosTheta;
                        if (Math.abs(thetaDiff) < 0.001) {
                            currentThetaRatio = thetaRatio;
                        }
                        if (Math.abs(phiDiff) < 0.001) {
                            currentPhiRatio = phiRatio;
                        }
                    };
                    return {
                        thetaRatioValue: thetaRatioValue,
                        phiRatioValue: phiRatioValue,
                        propValue: propValue,
                        update: update
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/hooks/useConeShape.ts":
            /*!**********************************************!*\
              !*** ./src/scripts/3d/hooks/useConeShape.ts ***!
              \**********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useConeShape": function() {
                        return /* binding */ useConeShape;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var _scripts_3d_buffer_padPositionBuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @/scripts/3d/buffer/padPositionBuffer */ "./src/scripts/3d/buffer/padPositionBuffer.ts");
                /* harmony import */
                var _scripts_3d_buffer_createPositionBufferFromGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/3d/buffer/createPositionBufferFromGeometry */ "./src/scripts/3d/buffer/createPositionBufferFromGeometry.ts");
                /* harmony import */
                var _scripts_3d_geometries_createConeGeometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/3d/geometries/createConeGeometry */ "./src/scripts/3d/geometries/createConeGeometry.ts");



                var useConeShape = function(padSourceBuffer) {
                    var geometry = (0, _scripts_3d_geometries_createConeGeometry__WEBPACK_IMPORTED_MODULE_2__.createConeGeometry)({
                        radius: 250,
                        height: 700,
                        radialSegments: 14,
                        heightSegments: 16,
                        tessellation: {
                            maxEdgeLength: 1,
                            maxIterations: 3
                        }
                    });
                    geometry.rotateZ(Math.PI * 0.15);
                    geometry.translate(-50, 100, 0);
                    var buffer = (0, _scripts_3d_buffer_padPositionBuffer__WEBPACK_IMPORTED_MODULE_0__.padPositionBuffer)((0, _scripts_3d_buffer_createPositionBufferFromGeometry__WEBPACK_IMPORTED_MODULE_1__.createPositionBufferFromGeometry)(geometry), padSourceBuffer);
                    return {
                        rawBuffer: buffer
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/hooks/useMorph.ts":
            /*!******************************************!*\
              !*** ./src/scripts/3d/hooks/useMorph.ts ***!
              \******************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useMorph": function() {
                        return /* binding */ useMorph;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");


                var useMorph = function(particle) {
                    var enablesMorphValue = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)(true);
                    var isMorphingValue = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)(false);
                    var lastMorphTime = 0;
                    var morph = function() {
                        var now = Date.now();
                        return new Promise(function(resolve, reject) {
                            if (now - lastMorphTime < 5000 || !enablesMorphValue.unwrap() || isMorphingValue.unwrap()) {
                                reject();
                                return;
                            }
                            isMorphingValue.wrap(true);
                            var timeline = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.timeline({
                                onComplete: function() {
                                    isMorphingValue.wrap(false);
                                    resolve();
                                }
                            });
                            timeline.add(gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.to(particle.material.uniforms.uOrderliness, {
                                value: 0,
                                duration: 2,
                                ease: 'quad.inOut',
                                delay: 0.2,
                                onComplete: function() {
                                    particle.material.uniforms.uShape.value = (particle.material.uniforms.uShape.value + 1) % 4;
                                }
                            }));
                            particle.rotation.y = particle.rotation.y % (2 * Math.PI);
                            timeline.add(gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.to(particle.rotation, {
                                y: 2 * Math.PI,
                                duration: 4.4,
                                ease: 'quad.inOut'
                            }), 0);
                            timeline.add(gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.to(particle.material.uniforms.uOrderliness, {
                                value: 0.97,
                                duration: 2.2,
                                ease: 'quad.inOut',
                            }), 2.2);
                            timeline.add(gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.to(particle.material.uniforms.uColorAlpha, {
                                value: 1,
                                duration: 1,
                                delay: 3.2,
                                ease: 'quad.out',
                                onComplete: function() {
                                    particle.material.uniforms.uColor.value = ++particle.material.uniforms.uColor.value % 4;
                                    particle.material.uniforms.uColorAlpha.value = 0;
                                }
                            }), 0);
                        });
                    };
                    return {
                        enablesMorphValue: enablesMorphValue,
                        isMorphingValue: isMorphingValue,
                        morph: morph
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/hooks/useParticle.ts":
            /*!*********************************************!*\
              !*** ./src/scripts/3d/hooks/useParticle.ts ***!
              \*********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useParticle": function() {
                        return /* binding */ useParticle;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");
                /* harmony import */
                var _scripts_3d_hooks_useParticleMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @/scripts/3d/hooks/useParticleMaterial */ "./src/scripts/3d/hooks/useParticleMaterial.ts");
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_3d_context_world3DContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/3d/context/world3DContext */ "./src/scripts/3d/context/world3DContext.ts");
                /* harmony import */
                var _scripts_3d_hooks_useParticleGeometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/scripts/3d/hooks/useParticleGeometry */ "./src/scripts/3d/hooks/useParticleGeometry.ts");
                /* harmony import */
                var _scripts_hooks_useMobileMediaQuery__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @/scripts/hooks/useMobileMediaQuery */ "./src/scripts/hooks/useMobileMediaQuery.ts");
                /* harmony import */
                var _scripts_hooks_useDesktopMediaQuery__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! @/scripts/hooks/useDesktopMediaQuery */ "./src/scripts/hooks/useDesktopMediaQuery.ts");
                /* harmony import */
                var _scripts_3d_hooks_useMorph__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! @/scripts/3d/hooks/useMorph */ "./src/scripts/3d/hooks/useMorph.ts");








                var shapeTypes = {
                    sphere: 0,
                    cone: 1,
                    polyhedron: 2,
                    xLetter: 3
                };
                var useParticle = function(props) {
                    var renderer = _scripts_3d_context_world3DContext__WEBPACK_IMPORTED_MODULE_2__.world3DContext.use().renderer;
                    var rotationVelocityValue = (0, furnace__WEBPACK_IMPORTED_MODULE_1__.dict)({
                        x: 0,
                        y: 0,
                        z: 0
                    });
                    var currentRotationVelocity = {
                        x: 0,
                        y: 0,
                        z: 0
                    };
                    var particleMaterial = (0, _scripts_3d_hooks_useParticleMaterial__WEBPACK_IMPORTED_MODULE_0__.useParticleMaterial)({
                        bounding: props.bounding,
                        colorTextures: props.colorTextures
                    }).material;
                    var _a = (0, _scripts_3d_hooks_useParticleGeometry__WEBPACK_IMPORTED_MODULE_3__.useParticleGeometry)({
                            count: 128 * 128,
                            bounding: props.bounding,
                            sizes: {
                                max: 4,
                                min: 2
                            }
                        }),
                        particleGeometry = _a.geometry,
                        rawRandomBuffer = _a.rawRandomBuffer;
                    var particle = new three__WEBPACK_IMPORTED_MODULE_7__.Points(particleGeometry, particleMaterial);
                    var $$debugTexturePlane = new three__WEBPACK_IMPORTED_MODULE_7__.Mesh(new three__WEBPACK_IMPORTED_MODULE_7__.PlaneGeometry(300, 300), new three__WEBPACK_IMPORTED_MODULE_7__.MeshBasicMaterial({
                        wireframe: true,
                        color: 0xff0000
                    }));
                    var _b = (0, _scripts_3d_hooks_useMorph__WEBPACK_IMPORTED_MODULE_6__.useMorph)(particle),
                        morph = _b.morph,
                        enablesMorphValue = _b.enablesMorphValue;
                    var morphTimerId = 0;
                    (0, furnace__WEBPACK_IMPORTED_MODULE_1__.effect)(function() {
                        var enableMorph = enablesMorphValue.unwrap();
                        if (!enableMorph) {
                            return;
                        }
                        var loopMorph = function() {
                            morphTimerId = window.setTimeout(function() {
                                morph().then(function() {
                                    loopMorph();
                                });
                            }, 7000);
                        };
                        loopMorph();
                        return function() {
                            clearTimeout(morphTimerId);
                        };
                    });
                    var update = function() {
                        currentRotationVelocity.x += (rotationVelocityValue.unwrap().x - currentRotationVelocity.x) * 0.0014;
                        currentRotationVelocity.y += (rotationVelocityValue.unwrap().y - currentRotationVelocity.y) * 0.0014;
                        particle.rotation.x += currentRotationVelocity.x;
                        particle.rotation.y += currentRotationVelocity.y;
                        particleMaterial.uniforms.uTime.value += 0.0085;
                    };
                    (0, _scripts_hooks_useMobileMediaQuery__WEBPACK_IMPORTED_MODULE_4__.useMobileMediaQuery)(function(_a) {
                        var matches = _a.matches;
                        if (!matches) {
                            return;
                        }
                        particle.scale.set(0.65, 0.65, 0.65);
                    });
                    (0, _scripts_hooks_useDesktopMediaQuery__WEBPACK_IMPORTED_MODULE_5__.useDesktopMediaQuery)(function(_a) {
                        var matches = _a.matches;
                        if (!matches) {
                            return;
                        }
                        particle.scale.set(1, 1, 1);
                    });
                    return {
                        particle: particle,
                        $$debugTexturePlane: $$debugTexturePlane,
                        rotationVelocityValue: rotationVelocityValue,
                        enablesMorphValue: enablesMorphValue,
                        update: update
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/hooks/useParticleGeometry.ts":
            /*!*****************************************************!*\
              !*** ./src/scripts/3d/hooks/useParticleGeometry.ts ***!
              \*****************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useParticleGeometry": function() {
                        return /* binding */ useParticleGeometry;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");
                /* harmony import */
                var _scripts_3d_buffer_createPositionUVBuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @/scripts/3d/buffer/createPositionUVBuffer */ "./src/scripts/3d/buffer/createPositionUVBuffer.ts");
                /* harmony import */
                var _scripts_3d_buffer_createPointSizeBuffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/3d/buffer/createPointSizeBuffer */ "./src/scripts/3d/buffer/createPointSizeBuffer.ts");
                /* harmony import */
                var _scripts_3d_hooks_useRandomShape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/3d/hooks/useRandomShape */ "./src/scripts/3d/hooks/useRandomShape.ts");
                /* harmony import */
                var _scripts_3d_hooks_useSphereShape__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/scripts/3d/hooks/useSphereShape */ "./src/scripts/3d/hooks/useSphereShape.ts");
                /* harmony import */
                var _scripts_3d_hooks_useXLetterShape__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @/scripts/3d/hooks/useXLetterShape */ "./src/scripts/3d/hooks/useXLetterShape.ts");
                /* harmony import */
                var _scripts_3d_hooks_useConeShape__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! @/scripts/3d/hooks/useConeShape */ "./src/scripts/3d/hooks/useConeShape.ts");
                /* harmony import */
                var _scripts_3d_hooks_usePolyhedronShape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! @/scripts/3d/hooks/usePolyhedronShape */ "./src/scripts/3d/hooks/usePolyhedronShape.ts");








                var useParticleGeometry = function(props) {
                    var count = props.count,
                        sizes = props.sizes,
                        bounding = props.bounding;
                    var _a = (0, _scripts_3d_hooks_useRandomShape__WEBPACK_IMPORTED_MODULE_2__.useRandomShape)(count, bounding),
                        rawRandomBuffer = _a.rawBuffer,
                        fillRandomTexture = _a.fillTexture;
                    var rawSphereBuffer = (0, _scripts_3d_hooks_useSphereShape__WEBPACK_IMPORTED_MODULE_3__.useSphereShape)(count, rawRandomBuffer).rawBuffer;
                    var rawXLetterBuffer = (0, _scripts_3d_hooks_useXLetterShape__WEBPACK_IMPORTED_MODULE_4__.useXLetterShape)(rawRandomBuffer).rawBuffer;
                    var rawConeBuffer = (0, _scripts_3d_hooks_useConeShape__WEBPACK_IMPORTED_MODULE_5__.useConeShape)(rawRandomBuffer).rawBuffer;
                    var rawPolyhedronBuffer = (0, _scripts_3d_hooks_usePolyhedronShape__WEBPACK_IMPORTED_MODULE_6__.usePolyhedronShape)(rawRandomBuffer).rawBuffer;
                    var uvBuffer = (0, _scripts_3d_buffer_createPositionUVBuffer__WEBPACK_IMPORTED_MODULE_0__.createPositionUVBuffer)(count, 128, 128);
                    var sizeBuffer = (0, _scripts_3d_buffer_createPointSizeBuffer__WEBPACK_IMPORTED_MODULE_1__.createPointSizeBuffer)(count, sizes.min, sizes.max);
                    var geometry = new three__WEBPACK_IMPORTED_MODULE_7__.BufferGeometry();
                    geometry.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_7__.BufferAttribute(rawRandomBuffer, 3));
                    geometry.setAttribute('spherePosition', new three__WEBPACK_IMPORTED_MODULE_7__.BufferAttribute(rawSphereBuffer, 3));
                    geometry.setAttribute('conePosition', new three__WEBPACK_IMPORTED_MODULE_7__.BufferAttribute(rawConeBuffer, 3));
                    geometry.setAttribute('polyhedronPosition', new three__WEBPACK_IMPORTED_MODULE_7__.BufferAttribute(rawPolyhedronBuffer, 3));
                    geometry.setAttribute('xLetterPosition', new three__WEBPACK_IMPORTED_MODULE_7__.BufferAttribute(rawXLetterBuffer, 3));
                    geometry.setAttribute('positionUV', new three__WEBPACK_IMPORTED_MODULE_7__.BufferAttribute(uvBuffer, 2));
                    geometry.setAttribute('size', new three__WEBPACK_IMPORTED_MODULE_7__.BufferAttribute(sizeBuffer, 1));
                    return {
                        geometry: geometry,
                        rawRandomBuffer: rawRandomBuffer,
                        rawSphereBuffer: rawSphereBuffer,
                        rawXLetterBuffer: rawXLetterBuffer,
                        rawConeBuffer: rawConeBuffer,
                        rawPolyhedronBuffer: rawPolyhedronBuffer
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/hooks/useParticleMaterial.ts":
            /*!*****************************************************!*\
              !*** ./src/scripts/3d/hooks/useParticleMaterial.ts ***!
              \*****************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useParticleMaterial": function() {
                        return /* binding */ useParticleMaterial;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");
                /* harmony import */
                var _scripts_3d_shader_particleVertexShader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @/scripts/3d/shader/particleVertexShader */ "./src/scripts/3d/shader/particleVertexShader.ts");
                /* harmony import */
                var _scripts_3d_shader_particleFragmentShader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/3d/shader/particleFragmentShader */ "./src/scripts/3d/shader/particleFragmentShader.ts");
                /* harmony import */
                var _scripts_hooks_useMobileMediaQuery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/hooks/useMobileMediaQuery */ "./src/scripts/hooks/useMobileMediaQuery.ts");
                /* harmony import */
                var _scripts_hooks_useDesktopMediaQuery__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/scripts/hooks/useDesktopMediaQuery */ "./src/scripts/hooks/useDesktopMediaQuery.ts");





                var useParticleMaterial = function(props) {
                    var uniforms = {
                        uShape: {
                            value: 0
                        },
                        uOrderliness: {
                            value: 0.97
                        },
                        uTime: {
                            value: 0
                        },
                        uAlpha: {
                            value: 1
                        },
                        uReadableContrast: {
                            value: 0
                        },
                        uRandomPositionTexture: {
                            value: new three__WEBPACK_IMPORTED_MODULE_4__.Texture()
                        },
                        uColor: {
                            value: 0
                        },
                        uColorAlpha: {
                            value: 0
                        },
                        uColorTexture1: {
                            value: new three__WEBPACK_IMPORTED_MODULE_4__.TextureLoader().load(props.colorTextures.tex1)
                        },
                        uColorTexture2: {
                            value: new three__WEBPACK_IMPORTED_MODULE_4__.TextureLoader().load(props.colorTextures.tex2)
                        },
                        uColorTexture3: {
                            value: new three__WEBPACK_IMPORTED_MODULE_4__.TextureLoader().load(props.colorTextures.tex3)
                        },
                        uColorTexture4: {
                            value: new three__WEBPACK_IMPORTED_MODULE_4__.TextureLoader().load(props.colorTextures.tex4)
                        }
                    };
                    var material = new three__WEBPACK_IMPORTED_MODULE_4__.ShaderMaterial({
                        uniforms: uniforms,
                        transparent: true,
                        depthTest: false,
                        vertexShader: _scripts_3d_shader_particleVertexShader__WEBPACK_IMPORTED_MODULE_0__.particleVertexShader,
                        fragmentShader: _scripts_3d_shader_particleFragmentShader__WEBPACK_IMPORTED_MODULE_1__.particleFragmentShader
                    });
                    (0, _scripts_hooks_useMobileMediaQuery__WEBPACK_IMPORTED_MODULE_2__.useMobileMediaQuery)(function(evt) {
                        if (!evt.matches) {
                            return;
                        }
                        material.uniforms.uAlpha.value = 0.25;
                    });
                    (0, _scripts_hooks_useDesktopMediaQuery__WEBPACK_IMPORTED_MODULE_3__.useDesktopMediaQuery)(function(evt) {
                        if (!evt.matches) {
                            return;
                        }
                        material.uniforms.uAlpha.value = 0.4;
                    });
                    return {
                        material: material
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/hooks/usePerspectiveCamera.ts":
            /*!******************************************************!*\
              !*** ./src/scripts/3d/hooks/usePerspectiveCamera.ts ***!
              \******************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "usePerspectiveCamera": function() {
                        return /* binding */ usePerspectiveCamera;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");

                var usePerspectiveCamera = function(parameter) {
                    var camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(parameter.fov, parameter.aspect, parameter.near, parameter.far);
                    var setCameraAspect = function(value) {
                        camera.aspect = value;
                        camera.updateProjectionMatrix();
                    }; {
                        camera.position.z = 1000;
                        camera.lookAt(0, 0, 0);
                    }
                    return {
                        get camera() {
                            return camera;
                        },
                        setCameraAspect: setCameraAspect
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/hooks/usePolyhedronShape.ts":
            /*!****************************************************!*\
              !*** ./src/scripts/3d/hooks/usePolyhedronShape.ts ***!
              \****************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "usePolyhedronShape": function() {
                        return /* binding */ usePolyhedronShape;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var _scripts_3d_buffer_padPositionBuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @/scripts/3d/buffer/padPositionBuffer */ "./src/scripts/3d/buffer/padPositionBuffer.ts");
                /* harmony import */
                var _scripts_3d_buffer_createPositionBufferFromGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/3d/buffer/createPositionBufferFromGeometry */ "./src/scripts/3d/buffer/createPositionBufferFromGeometry.ts");
                /* harmony import */
                var _scripts_3d_geometries_createPolyhedronGeometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/3d/geometries/createPolyhedronGeometry */ "./src/scripts/3d/geometries/createPolyhedronGeometry.ts");



                var usePolyhedronShape = function(padSourceBuffer) {
                    var buffer = (0, _scripts_3d_buffer_padPositionBuffer__WEBPACK_IMPORTED_MODULE_0__.padPositionBuffer)((0, _scripts_3d_buffer_createPositionBufferFromGeometry__WEBPACK_IMPORTED_MODULE_1__.createPositionBufferFromGeometry)(((0, _scripts_3d_geometries_createPolyhedronGeometry__WEBPACK_IMPORTED_MODULE_2__.createPolyhedronGeometry)({
                        radius: 450,
                        detail: 0,
                        tessellation: {
                            maxEdgeLength: 1,
                            maxIterations: 8
                        }
                    }))), padSourceBuffer);
                    return {
                        rawBuffer: buffer
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/hooks/usePostprocess.ts":
            /*!************************************************!*\
              !*** ./src/scripts/3d/hooks/usePostprocess.ts ***!
              \************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "usePostprocess": function() {
                        return /* binding */ usePostprocess;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! three/examples/jsm/postprocessing/EffectComposer */ "./node_modules/three/examples/jsm/postprocessing/EffectComposer.js");
                /* harmony import */
                var three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! three/examples/jsm/postprocessing/RenderPass */ "./node_modules/three/examples/jsm/postprocessing/RenderPass.js");
                /* harmony import */
                var three_examples_jsm_shaders_FXAAShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! three/examples/jsm/shaders/FXAAShader */ "./node_modules/three/examples/jsm/shaders/FXAAShader.js");
                /* harmony import */
                var three_examples_jsm_postprocessing_ShaderPass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! three/examples/jsm/postprocessing/ShaderPass */ "./node_modules/three/examples/jsm/postprocessing/ShaderPass.js");
                /* harmony import */
                var three_examples_jsm_shaders_HorizontalBlurShader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! three/examples/jsm/shaders/HorizontalBlurShader */ "./node_modules/three/examples/jsm/shaders/HorizontalBlurShader.js");
                /* harmony import */
                var three_examples_jsm_shaders_VerticalBlurShader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! three/examples/jsm/shaders/VerticalBlurShader */ "./node_modules/three/examples/jsm/shaders/VerticalBlurShader.js");
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");







                var usePostprocess = function(scene, camera, renderer) {
                    var composer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_0__.EffectComposer(renderer);
                    var renderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_1__.RenderPass(scene, camera);
                    var antialiasPass = new three_examples_jsm_postprocessing_ShaderPass__WEBPACK_IMPORTED_MODULE_3__.ShaderPass(three_examples_jsm_shaders_FXAAShader__WEBPACK_IMPORTED_MODULE_2__.FXAAShader);
                    var blurXPass = new three_examples_jsm_postprocessing_ShaderPass__WEBPACK_IMPORTED_MODULE_3__.ShaderPass(three_examples_jsm_shaders_HorizontalBlurShader__WEBPACK_IMPORTED_MODULE_4__.HorizontalBlurShader);
                    var blurYPass = new three_examples_jsm_postprocessing_ShaderPass__WEBPACK_IMPORTED_MODULE_3__.ShaderPass(three_examples_jsm_shaders_VerticalBlurShader__WEBPACK_IMPORTED_MODULE_5__.VerticalBlurShader);
                    var blurValue = (0, furnace__WEBPACK_IMPORTED_MODULE_6__.val)(0);
                    antialiasPass.renderToScreen = true;
                    composer.addPass(renderPass);
                    composer.addPass(blurXPass);
                    composer.addPass(blurYPass);
                    composer.addPass(antialiasPass);
                    var setSize = function(width, height) {
                        var blur = blurValue.unwrap();
                        antialiasPass.uniforms.resolution.value.set(width, height);
                        blurXPass.uniforms.h.value = blur / (width * 2);
                        blurYPass.uniforms.v.value = blur / (height * 2);
                        composer.setSize(width, height);
                    };
                    var render = function() {
                        composer.render();
                    };
                    (0, furnace__WEBPACK_IMPORTED_MODULE_6__.effect)(function() {
                        var blur = blurValue.unwrap();
                        var width = renderer.domElement.width;
                        var height = renderer.domElement.height;
                        blurXPass.enabled = blurYPass.enabled = (blur !== 0);
                        blurXPass.uniforms.h.value = blur / (width * 2);
                        blurYPass.uniforms.v.value = blur / (height * 2);
                    });
                    return {
                        blurValue: blurValue,
                        setSize: setSize,
                        render: render
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/hooks/useRandomShape.ts":
            /*!************************************************!*\
              !*** ./src/scripts/3d/hooks/useRandomShape.ts ***!
              \************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useRandomShape": function() {
                        return /* binding */ useRandomShape;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var _scripts_3d_buffer_createRandomPositionBuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @/scripts/3d/buffer/createRandomPositionBuffer */ "./src/scripts/3d/buffer/createRandomPositionBuffer.ts");

                var useRandomShape = function(count, props) {
                    var buffer = (0, _scripts_3d_buffer_createRandomPositionBuffer__WEBPACK_IMPORTED_MODULE_0__.createRandomPositionBuffer)(count, {
                        width: props.width,
                        height: props.height,
                        depth: props.depth
                    });
                    var fillTexture = function(texture) {
                        var pixels = texture.image.data;
                        var count = buffer.length / 3;
                        for (var i = 0; i < count; i++) {
                            pixels[i * 4] = buffer[i * 3];
                            pixels[i * 4 + 1] = buffer[i * 3 + 1];
                            pixels[i * 4 + 2] = buffer[i * 3 + 2];
                            pixels[i * 4 + 3] = i;
                        }
                        return texture;
                    };
                    return {
                        rawBuffer: buffer,
                        fillTexture: fillTexture
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/hooks/useScene.ts":
            /*!******************************************!*\
              !*** ./src/scripts/3d/hooks/useScene.ts ***!
              \******************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useScene": function() {
                        return /* binding */ useScene;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");

                var useScene = function() {
                    var scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();
                    return {
                        scene: scene
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/hooks/useSphereShape.ts":
            /*!************************************************!*\
              !*** ./src/scripts/3d/hooks/useSphereShape.ts ***!
              \************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useSphereShape": function() {
                        return /* binding */ useSphereShape;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var _scripts_3d_buffer_padPositionBuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @/scripts/3d/buffer/padPositionBuffer */ "./src/scripts/3d/buffer/padPositionBuffer.ts");
                /* harmony import */
                var _scripts_3d_buffer_createPositionBufferFromGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/3d/buffer/createPositionBufferFromGeometry */ "./src/scripts/3d/buffer/createPositionBufferFromGeometry.ts");
                /* harmony import */
                var _scripts_3d_geometries_createSphereGeometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/3d/geometries/createSphereGeometry */ "./src/scripts/3d/geometries/createSphereGeometry.ts");



                var useSphereShape = function(amount, padSourceBuffer) {
                    var buffer = (0, _scripts_3d_buffer_padPositionBuffer__WEBPACK_IMPORTED_MODULE_0__.padPositionBuffer)((0, _scripts_3d_buffer_createPositionBufferFromGeometry__WEBPACK_IMPORTED_MODULE_1__.createPositionBufferFromGeometry)((0, _scripts_3d_geometries_createSphereGeometry__WEBPACK_IMPORTED_MODULE_2__.createSphereGeometry)({
                        radius: 400,
                        widthSegments: 16,
                        heightSegment: 16,
                        tessellation: {
                            maxEdgeLength: 1,
                            maxIterations: 3
                        }
                    })), padSourceBuffer);
                    return {
                        rawBuffer: buffer
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/hooks/useWebGLRenderer.ts":
            /*!**************************************************!*\
              !*** ./src/scripts/3d/hooks/useWebGLRenderer.ts ***!
              \**************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useWebGLRenderer": function() {
                        return /* binding */ useWebGLRenderer;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");

                var useWebGLRenderer = function(parameter) {
                    var renderer = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderer(parameter);
                    var setSize = function(width, height, updateStyle) {
                        renderer.setSize(width, height, updateStyle);
                    };
                    var render = function(scene, camera) {
                        renderer.render(scene, camera);
                    }; {
                        renderer.setClearColor(new three__WEBPACK_IMPORTED_MODULE_0__.Color(255, 255, 255));
                    }
                    return {
                        get renderer() {
                            return renderer;
                        },
                        setSize: setSize,
                        render: render
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/hooks/useWorld3D.ts":
            /*!********************************************!*\
              !*** ./src/scripts/3d/hooks/useWorld3D.ts ***!
              \********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useWorld3D": function() {
                        return /* binding */ useWorld3D;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var _scripts_3d_hooks_useParticle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @/scripts/3d/hooks/useParticle */ "./src/scripts/3d/hooks/useParticle.ts");
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_3d_context_world3DContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/3d/context/world3DContext */ "./src/scripts/3d/context/world3DContext.ts");
                /* harmony import */
                var _scripts_3d_hooks_useCameraControl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/scripts/3d/hooks/useCameraControl */ "./src/scripts/3d/hooks/useCameraControl.ts");
                /* harmony import */
                var gsap__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                /* harmony import */
                var _scripts_3d_hooks_usePostprocess__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @/scripts/3d/hooks/usePostprocess */ "./src/scripts/3d/hooks/usePostprocess.ts");
                var __assign = (undefined && undefined.__assign) || function() {
                    __assign = Object.assign || function(t) {
                        for (var s, i = 1, n = arguments.length; i < n; i++) {
                            s = arguments[i];
                            for (var p in s)
                                if (Object.prototype.hasOwnProperty.call(s, p))
                                    t[p] = s[p];
                        }
                        return t;
                    };
                    return __assign.apply(this, arguments);
                };






                var useWorld3D = function(props) {
                    var _a = _scripts_3d_context_world3DContext__WEBPACK_IMPORTED_MODULE_2__.world3DContext.use(),
                        scene = _a.scene,
                        camera = _a.camera,
                        renderer = _a.renderer,
                        prefersReadableContrastValue = _a.prefersReadableContrastValue,
                        setSize = _a.setSize;
                    var _b = (0, _scripts_3d_hooks_usePostprocess__WEBPACK_IMPORTED_MODULE_4__.usePostprocess)(scene, camera, renderer),
                        internallyRender = _b.render,
                        setPostprocessSize = _b.setSize,
                        blurValue = _b.blurValue;
                    var _c = (0, _scripts_3d_hooks_useParticle__WEBPACK_IMPORTED_MODULE_0__.useParticle)({
                            bounding: {
                                width: 2000,
                                height: 2000,
                                depth: 2000
                            },
                            colorTextures: props.colorTextures
                        }),
                        particle = _c.particle,
                        $$debugTexturePlane = _c.$$debugTexturePlane,
                        rotationVelocityValue = _c.rotationVelocityValue,
                        updateParticle = _c.update,
                        enablesMorphValue = _c.enablesMorphValue;
                    var _d = (0, _scripts_3d_hooks_useCameraControl__WEBPACK_IMPORTED_MODULE_3__.useCameraControl)(camera, {
                            distance: 1000,
                            maxTheta: Math.PI * 0.25,
                            maxPhi: Math.PI * 0.25
                        }),
                        thetaRatioValue = _d.thetaRatioValue,
                        phiRatioValue = _d.phiRatioValue,
                        propValue = _d.propValue,
                        updateCameraControl = _d.update;
                    var resize = function(width, height) {
                        setSize(width, height);
                        setPostprocessSize(width, height);
                    };
                    var render = function() {
                        updateCameraControl();
                        updateParticle();
                        camera.lookAt(scene.position);
                        internallyRender();
                    };
                    var setMouse = function(x, y) {
                        rotationVelocityValue.wrap(function(value) {
                            return __assign(__assign({}, value), {
                                y: x * 0.0005
                            });
                        });
                        thetaRatioValue.wrap(x);
                        phiRatioValue.wrap(y);
                    };
                    (0, furnace__WEBPACK_IMPORTED_MODULE_1__.effect)(function() {
                        scene.add(particle);
                        // scene.add($$debugTexturePlane)
                        return function() {
                            scene.remove(particle);
                        };
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_1__.useWatch)(function() {
                        return prefersReadableContrastValue.unwrap();
                    }, function(prefersReadableContrast, prevPrefersReadableContrast) {
                        if (prevPrefersReadableContrast === undefined) {
                            return;
                        }
                        var timeline = gsap__WEBPACK_IMPORTED_MODULE_5__.gsap.timeline();
                        timeline.add(gsap__WEBPACK_IMPORTED_MODULE_5__.gsap.to(particle.material.uniforms.uReadableContrast, {
                            value: prefersReadableContrast ? 1 : 0,
                            duration: 0.5,
                            ease: 'expo.out'
                        }), 0);
                        timeline.add(gsap__WEBPACK_IMPORTED_MODULE_5__.gsap.to({
                            value: 0
                        }, {
                            value: 1,
                            duration: 0.5,
                            ease: 'expo.out',
                            onUpdate: function() {
                                var value = this.targets()[0].value;
                                blurValue.wrap(function() {
                                    return prefersReadableContrast ? value : 1 - value;
                                });
                            }
                        }), 0);
                        enablesMorphValue.wrap(!prefersReadableContrast);
                        return function() {
                            if (timeline.isActive()) {
                                timeline.kill();
                            }
                        };
                    });
                    return {
                        canvas: renderer.domElement,
                        prefersReadableContrastValue: prefersReadableContrastValue,
                        setMouse: setMouse,
                        render: render,
                        resize: resize,
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/hooks/useXLetterShape.ts":
            /*!*************************************************!*\
              !*** ./src/scripts/3d/hooks/useXLetterShape.ts ***!
              \*************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useXLetterShape": function() {
                        return /* binding */ useXLetterShape;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var _scripts_3d_buffer_padPositionBuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @/scripts/3d/buffer/padPositionBuffer */ "./src/scripts/3d/buffer/padPositionBuffer.ts");
                /* harmony import */
                var _scripts_3d_buffer_createPositionBufferFromGeometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/3d/buffer/createPositionBufferFromGeometry */ "./src/scripts/3d/buffer/createPositionBufferFromGeometry.ts");
                /* harmony import */
                var _scripts_3d_geometries_createXGeometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/3d/geometries/createXGeometry */ "./src/scripts/3d/geometries/createXGeometry.ts");



                var useXLetterShape = function(padSourceBuffer) {
                    var geometry = (0, _scripts_3d_geometries_createXGeometry__WEBPACK_IMPORTED_MODULE_2__.createXGeometry)({
                        tessellation: {
                            maxEdgeLength: 1,
                            maxIterations: 5
                        }
                    });
                    var buffer = (0, _scripts_3d_buffer_padPositionBuffer__WEBPACK_IMPORTED_MODULE_0__.padPositionBuffer)((0, _scripts_3d_buffer_createPositionBufferFromGeometry__WEBPACK_IMPORTED_MODULE_1__.createPositionBufferFromGeometry)(geometry), padSourceBuffer);
                    return {
                        rawBuffer: buffer
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/3d/shader/particleFragmentShader.ts":
            /*!*********************************************************!*\
              !*** ./src/scripts/3d/shader/particleFragmentShader.ts ***!
              \*********************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "particleFragmentShader": function() {
                        return /* binding */ particleFragmentShader;
                    }
                    /* harmony export */
                });
                var particleFragmentShader = "\n  uniform mat3 normalMatrix;\n  uniform int uColor;\n  uniform float uColorAlpha;\n  uniform float uOrderliness;\n  uniform float uReadableContrast;\n  uniform sampler2D uColorTexture1;\n  uniform sampler2D uColorTexture2;\n  uniform sampler2D uColorTexture3;\n  uniform sampler2D uColorTexture4;\n  varying vec2 vPositionUV;\n  uniform float uTime;\n  uniform float uAlpha;\n\n  void main() {\n    vec2 res = gl_PointCoord * 2.0 - 1.0;\n    vec2 uv = mod(vPositionUV + vec2(cos(uTime), sin(uTime)), 1.0);\n    vec3 rgb1 = vec3(0.0);\n    vec3 rgb2 = vec3(0.0);\n\n    if(uColor == 0) {\n      rgb1 = texture2D(uColorTexture1, uv).xyz;\n      rgb2 = texture2D(uColorTexture2, uv).xyz;\n    } else if(uColor == 1) {\n      rgb1 = texture2D(uColorTexture2, uv).xyz;\n      rgb2 = texture2D(uColorTexture3, uv).xyz;\n    } else if(uColor == 2) {\n      rgb1 = texture2D(uColorTexture3, uv).xyz;\n      rgb2 = texture2D(uColorTexture4, uv).xyz;\n    } else if(uColor == 3) {\n      rgb1 = texture2D(uColorTexture4, uv).xyz;\n      rgb2 = texture2D(uColorTexture1, uv).xyz;\n    }\n\n    float alpha = (1.0 - smoothstep(0.8, 0.99, length(res)));\n    alpha *= clamp(0.0, 1.0, uAlpha);\n    alpha *= (0.1 + mix(0.35, 0.9, uOrderliness));\n    alpha *= (1.0 / 3.0) * mix(3.0, 1.0, uReadableContrast);\n\n    gl_FragColor = vec4(mix(rgb1, rgb2, uColorAlpha), alpha);\n  }\n";



                /***/
            }),

        /***/
        "./src/scripts/3d/shader/particleVertexShader.ts":
            /*!*******************************************************!*\
              !*** ./src/scripts/3d/shader/particleVertexShader.ts ***!
              \*******************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "particleVertexShader": function() {
                        return /* binding */ particleVertexShader;
                    }
                    /* harmony export */
                });
                var particleVertexShader = "\n  uniform int uShape;\n  uniform float uOrderliness;\n  uniform sampler2D uForceTexture;\n  uniform sampler2D uRandomPositionTexture;\n\n  attribute vec3 spherePosition;\n  attribute vec3 conePosition;\n  attribute vec3 polyhedronPosition;\n  attribute vec3 xLetterPosition;\n  attribute float size;\n  attribute vec2 positionUV;\n\n  varying vec2 vPositionUV;\n\n  void main() {\n    vec3 targetPosition = vec3(0.0);\n\n    if(uShape == 0) {\n      targetPosition = spherePosition;\n    } else if (uShape == 1) {\n      targetPosition = conePosition;\n    } else if (uShape == 2) {\n      targetPosition = polyhedronPosition;\n    } else if (uShape == 3) {\n      targetPosition = xLetterPosition;\n    } else {\n      targetPosition = position;\n    }\n\n    vec3 newPos = mix(mix(position, vec3(position.x * 0.5, position.y * 0.4, position.z), 1.0 - uOrderliness) , targetPosition, uOrderliness);\n\n    vPositionUV = positionUV;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);\n    gl_PointSize = size;\n  }\n";



                /***/
            }),

        /***/
        "./src/scripts/app.ts":
            /*!****************************!*\
              !*** ./src/scripts/app.ts ***!
              \****************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "Application": function() {
                        return /* binding */ Application;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _components_page_control__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/components/page/control */ "./src/components/page/control.ts");
                /* harmony import */
                var _state_WindowSizeState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./state/WindowSizeState */ "./src/scripts/state/WindowSizeState.ts");
                /* harmony import */
                var _scripts_3d_context_world3DContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @/scripts/3d/context/world3DContext */ "./src/scripts/3d/context/world3DContext.ts");




                var Application = function() {
                    var addChild = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.childHandle)().addChild;
                    addChild((0, furnace__WEBPACK_IMPORTED_MODULE_0__.withContext)(_components_page_control__WEBPACK_IMPORTED_MODULE_1__.Page, _scripts_3d_context_world3DContext__WEBPACK_IMPORTED_MODULE_3__.world3DContext));
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.effect)(function() {
                        var height = _state_WindowSizeState__WEBPACK_IMPORTED_MODULE_2__.WindowSizeState.unwrap().height;
                        document.documentElement.style.setProperty('--vh', "".concat(height * 0.01, "px"));
                    });
                };
                Application.defaultProps = {};



                /***/
            }),

        /***/
        "./src/scripts/hooks/useBlurredSlide.ts":
            /*!**********************************************!*\
              !*** ./src/scripts/hooks/useBlurredSlide.ts ***!
              \**********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useBlurredSlide": function() {
                        return /* binding */ useBlurredSlide;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");
                /* harmony import */
                var three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! three/examples/jsm/postprocessing/EffectComposer */ "./node_modules/three/examples/jsm/postprocessing/EffectComposer.js");
                /* harmony import */
                var three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! three/examples/jsm/postprocessing/RenderPass */ "./node_modules/three/examples/jsm/postprocessing/RenderPass.js");
                /* harmony import */
                var three_examples_jsm_shaders_HorizontalBlurShader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! three/examples/jsm/shaders/HorizontalBlurShader */ "./node_modules/three/examples/jsm/shaders/HorizontalBlurShader.js");
                /* harmony import */
                var three_examples_jsm_postprocessing_ShaderPass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! three/examples/jsm/postprocessing/ShaderPass */ "./node_modules/three/examples/jsm/postprocessing/ShaderPass.js");
                /* harmony import */
                var three_examples_jsm_shaders_VerticalBlurShader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! three/examples/jsm/shaders/VerticalBlurShader */ "./node_modules/three/examples/jsm/shaders/VerticalBlurShader.js");
                /* harmony import */
                var gsap__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");








                var fragmentShader = "\n  uniform sampler2D currentTexture;\n  uniform sampler2D nextTexture;\n  uniform float alpha;\n  varying vec2 vUv;\n\n  void main() {\n    vec4 color = mix(texture2D(currentTexture, vUv), texture2D(nextTexture, vUv), alpha);\n    gl_FragColor = color;\n  }\n";
                var vertexShader = "\n  varying vec2 vUv;\n  void main() {\n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n";
                var useBlurredSlide = function(refGet) {
                    var textureSource = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)([]);
                    var scene = new three__WEBPACK_IMPORTED_MODULE_6__.Scene();
                    var camera = new three__WEBPACK_IMPORTED_MODULE_6__.Camera();
                    var renderer = new three__WEBPACK_IMPORTED_MODULE_6__.WebGLRenderer();
                    var effectComposer = new three_examples_jsm_postprocessing_EffectComposer__WEBPACK_IMPORTED_MODULE_1__.EffectComposer(renderer);
                    var geometry = new three__WEBPACK_IMPORTED_MODULE_6__.PlaneGeometry(2, 2);
                    var material = new three__WEBPACK_IMPORTED_MODULE_6__.ShaderMaterial({
                        uniforms: {
                            currentTexture: {
                                value: null
                            },
                            nextTexture: {
                                value: null
                            },
                            alpha: {
                                value: 0
                            }
                        },
                        side: three__WEBPACK_IMPORTED_MODULE_6__.DoubleSide,
                        fragmentShader: fragmentShader,
                        vertexShader: vertexShader
                    });
                    var currentIndex = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)(0);
                    var setup = function() {
                        camera.position.z = 1;
                        scene.add(new three__WEBPACK_IMPORTED_MODULE_6__.Mesh(geometry, material));
                        var renderPass = new three_examples_jsm_postprocessing_RenderPass__WEBPACK_IMPORTED_MODULE_2__.RenderPass(scene, camera);
                        var hBlurPass = new three_examples_jsm_postprocessing_ShaderPass__WEBPACK_IMPORTED_MODULE_4__.ShaderPass(three_examples_jsm_shaders_HorizontalBlurShader__WEBPACK_IMPORTED_MODULE_3__.HorizontalBlurShader);
                        var vBlurPass = new three_examples_jsm_postprocessing_ShaderPass__WEBPACK_IMPORTED_MODULE_4__.ShaderPass(three_examples_jsm_shaders_VerticalBlurShader__WEBPACK_IMPORTED_MODULE_5__.VerticalBlurShader);
                        hBlurPass.uniforms.h.value = 1 / renderer.domElement.width * 0.5;
                        vBlurPass.uniforms.v.value = 1 / renderer.domElement.height * 0.5;
                        effectComposer.addPass(renderPass);
                        effectComposer.addPass(hBlurPass);
                        effectComposer.addPass(vBlurPass);
                    };
                    var setSize = function(width, height) {
                        renderer.setSize(width, height);
                    };
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.effect)(function() {
                        setup();
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useWatch)(refGet, function(value) {
                        var texture = value.map(function(image) {
                            return new three__WEBPACK_IMPORTED_MODULE_6__.TextureLoader().load(image.src);
                        });
                        material.uniforms.currentTexture.value = texture[currentIndex.unwrap()];
                        textureSource.wrap(texture);
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useWatch)(function() {
                        return textureSource.unwrap();
                    }, function(source) {
                        material.uniforms.currentTexture.value = source[currentIndex.unwrap()];
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useWatch)(function() {
                        return currentIndex.unwrap();
                    }, function(value) {
                        material.uniforms.nextTexture.value = textureSource.unwrap()[value];
                        var tween = gsap__WEBPACK_IMPORTED_MODULE_7__.gsap.to(material.uniforms.alpha, {
                            value: 1,
                            duration: 1,
                            ease: 'quad.out',
                            onComplete: function() {
                                material.uniforms.currentTexture.value = material.uniforms.nextTexture.value;
                                material.uniforms.nextTexture.value = null;
                                material.uniforms.alpha.value = 0;
                            },
                            onInterrupt: function() {
                                material.uniforms.currentTexture.value = material.uniforms.nextTexture.value;
                                material.uniforms.nextTexture.value = null;
                                material.uniforms.alpha.value = 0;
                            }
                        });
                        return function() {
                            tween.kill();
                        };
                    });
                    var goto = function(index) {
                        if (currentIndex.unwrap() === index) {
                            return;
                        }
                        currentIndex.wrap(index);
                    };
                    var render = function() {
                        effectComposer.render();
                    };
                    return {
                        canvas: renderer.domElement,
                        goto: goto,
                        setSize: setSize,
                        render: render
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/hooks/useDesktopMediaQuery.ts":
            /*!***************************************************!*\
              !*** ./src/scripts/hooks/useDesktopMediaQuery.ts ***!
              \***************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useDesktopMediaQuery": function() {
                        return /* binding */ useDesktopMediaQuery;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var _scripts_hooks_useMediaQuery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @/scripts/hooks/useMediaQuery */ "./src/scripts/hooks/useMediaQuery.ts");

                var useDesktopMediaQuery = function(callback) {
                    return (0, _scripts_hooks_useMediaQuery__WEBPACK_IMPORTED_MODULE_0__.useMediaQuery)('(min-width: 835px)', callback);
                };



                /***/
            }),

        /***/
        "./src/scripts/hooks/useDistortion.ts":
            /*!********************************************!*\
              !*** ./src/scripts/hooks/useDistortion.ts ***!
              \********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useDistortion": function() {
                        return /* binding */ useDistortion;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");
                /* harmony import */
                var gsap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                /* harmony import */
                var ua_parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ua-parser-js */ "./node_modules/ua-parser-js/src/ua-parser.js");
                /* harmony import */
                var ua_parser_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(ua_parser_js__WEBPACK_IMPORTED_MODULE_1__);




                var fragmentShader = "\n  uniform sampler2D distortedTexture;\n  uniform sampler2D displacementMapTexture;\n  uniform float x;\n  uniform float y;\n  uniform float t;\n  uniform float mapScale;\n  varying vec2 vUv;\n\n  const float PI = 3.14159265;\n  const float TAU = PI * 2.0;\n\n  vec2 rotate(vec2 vec, float angle) {\n    mat2 mat = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    return mat * vec;\n  }\n\n  void main() {\n    vec2 div = floor(gl_FragCoord.xy * 0.5);\n    vec4 src = texture2D(distortedTexture, vUv);\n\n    vec2 uvt = rotate(vec2(vUv.s, vUv.t), PI * 0.01 * t);\n    vec4 displace = texture2D(displacementMapTexture, uvt / (1.0 + (mapScale - 1.0) * t));\n    float offset1 = (-0.5 + displace.g) * t;\n    float offset2 = (-0.5 + displace.r) * (1.0 - t);\n    vec2 uvDisplaced1 = vec2(vUv.x + offset1 * x * (1.0 - t), vUv.y + offset1 * y * cos(PI * 0.01 * t));\n    vec2 uvDisplaced2 = vec2(vUv.x + offset2 * x * (1.0 - t), vUv.y + offset2 * y * sin(PI * 0.01 * t));\n    vec4 dest = texture2D(distortedTexture, uvDisplaced1) * (1.0 - t) + texture2D(distortedTexture, uvDisplaced2) * t;\n\n    gl_FragColor = dest;\n  }\n";
                var vertexShader = "\n  varying vec2 vUv;\n  uniform float t;\n  void main() {\n    vUv = uv;\n    gl_Position = vec4(position, 1.0);\n  }\n";
                var useDistortion = function(imageRefGetter, options) {
                    var scene = new three__WEBPACK_IMPORTED_MODULE_2__.Scene();
                    var camera = new three__WEBPACK_IMPORTED_MODULE_2__.Camera();
                    var geometry = new three__WEBPACK_IMPORTED_MODULE_2__.PlaneGeometry(2, 2);
                    var material = new three__WEBPACK_IMPORTED_MODULE_2__.ShaderMaterial({
                        uniforms: {
                            distortedTexture: {
                                value: null
                            },
                            displacementMapTexture: {
                                value: null
                            },
                            mapScale: {
                                value: 0.8,
                            },
                            x: {
                                value: 2.5
                            },
                            y: {
                                value: 0.1
                            },
                            t: {
                                value: 0
                            }
                        },
                        side: three__WEBPACK_IMPORTED_MODULE_2__.DoubleSide,
                        fragmentShader: fragmentShader,
                        vertexShader: vertexShader
                    });
                    var mesh = new three__WEBPACK_IMPORTED_MODULE_2__.Mesh(geometry, material);
                    var canvasValue = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)(null);
                    var disabledValue = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)(/mobile|tablet/.test(new(ua_parser_js__WEBPACK_IMPORTED_MODULE_1___default())().getDevice().type || ''));
                    var renderer;
                    var setSize = function(width, height) {
                        renderer === null || renderer === void 0 ? void 0 : renderer.setSize(width, height);
                    };
                    var render = function() {
                        renderer === null || renderer === void 0 ? void 0 : renderer.render(scene, camera);
                    };
                    var setup = function() {
                        new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader().load(options.noiseTexture, function(texture) {
                            texture.wrapS = three__WEBPACK_IMPORTED_MODULE_2__.RepeatWrapping;
                            texture.wrapT = three__WEBPACK_IMPORTED_MODULE_2__.RepeatWrapping;
                            material.uniforms.displacementMapTexture.value = texture;
                            render();
                        });
                        scene.add(mesh);
                    };
                    var distort = function() {
                        gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.to(material.uniforms.t, {
                            value: 1,
                            duration: 0.8,
                            ease: 'linear',
                            onUpdate: function() {
                                render();
                            },
                            onComplete: function() {
                                material.uniforms.t.value = 0;
                            }
                        });
                    };
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useWatch)(imageRefGetter, function(image) {
                        if (!image) {
                            return;
                        }
                        new three__WEBPACK_IMPORTED_MODULE_2__.TextureLoader().load(image.src, function(texture) {
                            texture.wrapS = three__WEBPACK_IMPORTED_MODULE_2__.MirroredRepeatWrapping;
                            texture.wrapT = three__WEBPACK_IMPORTED_MODULE_2__.MirroredRepeatWrapping;
                            material.uniforms.distortedTexture.value = texture;
                            render();
                        });
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.effect)(function() {
                        var disabled = disabledValue.unwrap();
                        if (disabled) {
                            return;
                        }
                        renderer = new three__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderer();
                        canvasValue.wrap(renderer.domElement);
                        return function() {
                            renderer.dispose();
                            canvasValue.wrap(null);
                        };
                    });
                    setup();
                    return {
                        canvasValue: canvasValue,
                        disabledValue: disabledValue,
                        setSize: setSize,
                        render: render,
                        distort: distort
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/hooks/useDistortionHover.ts":
            /*!*************************************************!*\
              !*** ./src/scripts/hooks/useDistortionHover.ts ***!
              \*************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useDistortionHover": function() {
                        return /* binding */ useDistortionHover;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var _scripts_hooks_useDistortion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @/scripts/hooks/useDistortion */ "./src/scripts/hooks/useDistortion.ts");


                var useDistortionHover = function(refGet, options) {
                    var _a = (0, _scripts_hooks_useDistortion__WEBPACK_IMPORTED_MODULE_1__.useDistortion)(refGet, {
                            noiseTexture: options.noiseTexture
                        }),
                        canvasValue = _a.canvasValue,
                        disabledValue = _a.disabledValue,
                        render = _a.render,
                        setSize = _a.setSize,
                        distort = _a.distort;
                    var hover = function() {
                        distort();
                    };
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.effect)(function() {
                        var image = refGet();
                        var canvas = canvasValue.unwrap();
                        var disabled = disabledValue.unwrap();
                        if (!image || !canvas || disabled) {
                            return;
                        }
                        var _a = image.getBoundingClientRect(),
                            width = _a.width,
                            height = _a.height;
                        image.style.visibility = 'hidden';
                        image.insertAdjacentElement('beforebegin', canvas);
                        canvas.style.position = 'absolute';
                        canvas.style.top = '0';
                        canvas.style.left = '0';
                        setSize(width, height);
                        render();
                        return function() {
                            var _a;
                            image.style.visibility = '';
                            (_a = canvas.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(canvas);
                        };
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return window;
                    }, 'resize', function() {
                        var image = refGet();
                        if (!image) {
                            return;
                        }
                        var _a = image.getBoundingClientRect(),
                            width = _a.width,
                            height = _a.height;
                        setSize(width, height);
                        render();
                    });
                    return {
                        hover: hover
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/hooks/useFadeinContent.ts":
            /*!***********************************************!*\
              !*** ./src/scripts/hooks/useFadeinContent.ts ***!
              \***********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useFadeinContent": function() {
                        return /* binding */ useFadeinContent;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");

                var useFadeinContent = function(refGetter) {
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useIntersectionWatch)(refGetter, function(entry) {
                        if (entry.isIntersecting) {
                            entry.target.classList.add('is-show');
                        }
                    }, {
                        rootMargin: '-25% 0px'
                    });
                };



                /***/
            }),

        /***/
        "./src/scripts/hooks/useFadeinHeading.ts":
            /*!***********************************************!*\
              !*** ./src/scripts/hooks/useFadeinHeading.ts ***!
              \***********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useFadeInHeading": function() {
                        return /* binding */ useFadeInHeading;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                var __read = (undefined && undefined.__read) || function(o, n) {
                    var m = typeof Symbol === "function" && o[Symbol.iterator];
                    if (!m) return o;
                    var i = m.call(o),
                        r, ar = [],
                        e;
                    try {
                        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
                    } catch (error) {
                        e = {
                            error: error
                        };
                    } finally {
                        try {
                            if (r && !r.done && (m = i["return"])) m.call(i);
                        } finally {
                            if (e) throw e.error;
                        }
                    }
                    return ar;
                };
                var __spreadArray = (undefined && undefined.__spreadArray) || function(to, from, pack) {
                    if (pack || arguments.length === 2)
                        for (var i = 0, l = from.length, ar; i < l; i++) {
                            if (ar || !(i in from)) {
                                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                                ar[i] = from[i];
                            }
                        }
                    return to.concat(ar || Array.prototype.slice.call(from));
                };


                var useFadeInHeading = function(headingGetter, animation) {
                    if (animation === void 0) {
                        animation = {
                            duration: 0.4,
                            delayGap: 0.04
                        };
                    }
                    var animationTl;
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useWatch)(headingGetter, function(val) {
                        if (Array.isArray(val)) {
                            val.forEach(function(item) {
                                return init(item);
                            });
                        } else {
                            val && init(val);
                        }
                        return function() {
                            animationTl === null || animationTl === void 0 ? void 0 : animationTl.kill();
                            animationTl = undefined;
                        };
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useIntersectionWatch)(headingGetter, function(entry) {
                        if (entry.isIntersecting) {
                            animate(entry.target, animation);
                        }
                    }, {
                        root: null,
                        rootMargin: '0px 0px -25% 0px'
                    });
                    var init = function(element) {
                        var animationTarget = element.children;
                        animationTarget.length ?
                            __spreadArray([], __read(animationTarget), false).map(function(item, i) {
                                return addAnimateTargets(item);
                            }) :
                            addAnimateTargets(element);
                    };
                    var addAnimateTargets = function(el) {
                        var fragment = document.createDocumentFragment();
                        var spanElements = splitBySpanElement(el);
                        spanElements === null || spanElements === void 0 ? void 0 : spanElements.forEach(function(spanElement) {
                            var _a;
                            var isEmpty = !((_a = spanElement.textContent) === null || _a === void 0 ? void 0 : _a.match(/\S/g));
                            spanElement.style.display = isEmpty ? 'inline' : 'inline-block';
                            spanElement.style.opacity = '0';
                            spanElement.style.transform = 'translateY(1em)';
                            spanElement.setAttribute('aria-hidden', 'true');
                            fragment.appendChild(spanElement);
                        });
                        el.textContent && el.setAttribute('aria-label', el.textContent);
                        el.innerHTML = '';
                        el.appendChild(fragment);
                    };
                    var animate = function(element, _a) {
                        var duration = _a.duration,
                            delayGap = _a.delayGap;
                        var targets = __spreadArray([], __read(element.querySelectorAll('span')), false);
                        element.classList.add('is-show');
                        targets.forEach(function(el, i) {
                            animationTl = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.to(el, {
                                opacity: 1,
                                y: 0,
                                duration: duration,
                                delay: delayGap * i,
                                ease: 'Expo.inOut'
                            });
                        });
                    };
                    return {
                        animate: animate
                    };
                };
                var splitBySpanElement = function(el) {
                    var texts = el.textContent;
                    if (!texts) {
                        return;
                    }
                    return __spreadArray([], __read(texts), false).map(function(item, j) {
                        var spanElement = document.createElement('span');
                        spanElement.innerHTML = item;
                        return spanElement;
                    });
                };



                /***/
            }),

        /***/
        "./src/scripts/hooks/useMediaQuery.ts":
            /*!********************************************!*\
              !*** ./src/scripts/hooks/useMediaQuery.ts ***!
              \********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useMediaQuery": function() {
                        return /* binding */ useMediaQuery;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");

                var useMediaQuery = function(query, callback) {
                    var mediaQueryList = window.matchMedia(query);
                    var matchesValue = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)(mediaQueryList.matches);
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.effect)(function() {
                        mediaQueryList.addEventListener('change', callback);
                        callback(new MediaQueryListEvent('change', {
                            matches: mediaQueryList.matches,
                            media: query
                        }));
                        return function() {
                            mediaQueryList.removeEventListener('change', callback);
                        };
                    });
                    return {
                        matchesValue: matchesValue
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/hooks/useMobileMediaQuery.ts":
            /*!**************************************************!*\
              !*** ./src/scripts/hooks/useMobileMediaQuery.ts ***!
              \**************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useMobileMediaQuery": function() {
                        return /* binding */ useMobileMediaQuery;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var _scripts_hooks_useMediaQuery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @/scripts/hooks/useMediaQuery */ "./src/scripts/hooks/useMediaQuery.ts");

                var useMobileMediaQuery = function(callback) {
                    return (0, _scripts_hooks_useMediaQuery__WEBPACK_IMPORTED_MODULE_0__.useMediaQuery)('(max-width: 834px)', callback);
                };



                /***/
            }),

        /***/
        "./src/scripts/hooks/usePreloadVideo.ts":
            /*!**********************************************!*\
              !*** ./src/scripts/hooks/usePreloadVideo.ts ***!
              \**********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "usePreloadVideo": function() {
                        return /* binding */ usePreloadVideo;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");

                var usePreloadVideo = function(wrapperGetter, path) {
                    var xhr = new XMLHttpRequest();
                    var count = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)(0);
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.effect)(function() {
                        xhr.open('GET', path, true);
                        xhr.responseType = 'blob';
                        xhr.addEventListener('load', onLoad);
                        xhr.addEventListener('progress', onProgress);
                        xhr.send();
                    });
                    var onProgress = function(e) {
                        if (e.lengthComputable) {
                            var current = Math.floor((e.loaded / e.total) * 100);
                            count.wrap(current);
                        } else {
                            var timer_1 = setInterval(function() {
                                count.unwrap() >= 100 && clearInterval(timer_1);
                                count.wrap(function(val) {
                                    return ++val;
                                });
                            }, 60);
                        }
                    };
                    var onLoad = function() {
                        if (xhr.readyState === 4 && xhr.status !== 0) {
                            appendVideo(URL.createObjectURL(xhr.response));
                        } else {
                            appendVideo(path);
                        }
                    };
                    var appendVideo = function(videoSrc) {
                        var videoWrapper = wrapperGetter();
                        if (!videoWrapper) {
                            return;
                        }
                        var videoEl = document.createElement('video');
                        videoEl.src = videoSrc;
                        videoEl.muted = true;
                        videoEl.playsInline = true;
                        videoEl.loop = true;
                        videoEl.autoplay = true;
                        videoWrapper.appendChild(videoEl);
                    };
                    return {
                        count: count
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/hooks/useSlide.ts":
            /*!***************************************!*\
              !*** ./src/scripts/hooks/useSlide.ts ***!
              \***************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useSlide": function() {
                        return /* binding */ useSlide;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                var __read = (undefined && undefined.__read) || function(o, n) {
                    var m = typeof Symbol === "function" && o[Symbol.iterator];
                    if (!m) return o;
                    var i = m.call(o),
                        r, ar = [],
                        e;
                    try {
                        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
                    } catch (error) {
                        e = {
                            error: error
                        };
                    } finally {
                        try {
                            if (r && !r.done && (m = i["return"])) m.call(i);
                        } finally {
                            if (e) throw e.error;
                        }
                    }
                    return ar;
                };
                var __spreadArray = (undefined && undefined.__spreadArray) || function(to, from, pack) {
                    if (pack || arguments.length === 2)
                        for (var i = 0, l = from.length, ar; i < l; i++) {
                            if (ar || !(i in from)) {
                                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                                ar[i] = from[i];
                            }
                        }
                    return to.concat(ar || Array.prototype.slice.call(from));
                };


                var useSlide = function(slidesGetter, paginationWrapperGetter, option) {
                    var animationTl;
                    var timer;
                    var lastIndex = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)(0);
                    var currentIndex = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)(0);
                    var slideLength = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)(0);
                    var slides = slidesGetter();
                    var paginationItems = [];
                    var paginationButtons = [];
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useWatch)(function() {
                        return slidesGetter();
                    }, function(value) {
                        slides = value;
                        var paginationWrapper = paginationWrapperGetter();
                        slideLength.wrap(slides.length);
                        slides[0].classList.add('is-show');
                        slides.forEach(function(slide, i) {
                            slide.setAttribute('aria-hidden', "".concat(i !== 0));
                        });
                        if (paginationWrapper) {
                            var paginations = addPagination(paginationWrapper);
                            paginations === null || paginations === void 0 ? void 0 : paginations.map(function(item, i) {
                                paginationItems.push(item);
                            });
                        }
                        startAutoPlay();
                        return function() {
                            animationTl && animationTl.kill();
                            animationTl = undefined;
                            timer && clearInterval(timer);
                        };
                    });
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useEvent)(function() {
                        return paginationButtons;
                    }, 'click', function(evt) {
                        onClickPagination(evt);
                    });
                    var onClickPagination = function(evt) {
                        lastIndex.wrap(currentIndex.unwrap());
                        currentIndex.wrap(__spreadArray([], __read(paginationButtons), false).indexOf(evt.currentTarget));
                        changeSlide();
                        discardAutoPlay();
                    };
                    var addPagination = function(paginationWrapper) {
                        if (!(option === null || option === void 0 ? void 0 : option.progressCircle)) {
                            return;
                        }
                        var fragment = document.createDocumentFragment();
                        var diameter = option.progressCircle.diameter;
                        var strokeWidth = option.progressCircle.strokeWidth;
                        var liElements = slides.map(function(slide, i) {
                            var _a = createPagination({
                                    label: "".concat(i + 1, " / ").concat(slideLength.unwrap()),
                                    diameter: diameter,
                                    strokeWidth: strokeWidth
                                }),
                                liElement = _a.liElement,
                                buttonElement = _a.buttonElement;
                            fragment.appendChild(liElement);
                            paginationButtons.push(buttonElement);
                            return liElement;
                        });
                        paginationWrapper.appendChild(fragment);
                        return liElements;
                    };
                    var startAutoPlay = function() {
                        changeSlide();
                        resetTimer();
                    };
                    var discardAutoPlay = function() {
                        if (!(option === null || option === void 0 ? void 0 : option.progressCircle) || !paginationItems) {
                            return;
                        }
                        var lastPaginationItem = paginationItems[lastIndex.unwrap()];
                        var lastCircle = lastPaginationItem.querySelector('circle');
                        var _a = option.progressCircle,
                            diameter = _a.diameter,
                            strokeWidth = _a.strokeWidth;
                        lastCircle && initializeCircle(lastCircle, diameter, strokeWidth);
                        animationTl && animationTl.pause();
                        timer && clearInterval(timer);
                    };
                    var changeSlide = function() {
                        var _a;
                        var duration = (option === null || option === void 0 ? void 0 : option.interval) ? (option === null || option === void 0 ? void 0 : option.interval) * 0.001 : 3;
                        slides[lastIndex.unwrap()].classList.remove('is-show');
                        slides[lastIndex.unwrap()].setAttribute('aria-hidden', 'true');
                        slides[currentIndex.unwrap()].classList.add('is-show');
                        slides[currentIndex.unwrap()].setAttribute('aria-hidden', 'false');
                        if (option === null || option === void 0 ? void 0 : option.progressCircle) {
                            changePagination(option === null || option === void 0 ? void 0 : option.progressCircle.diameter, option === null || option === void 0 ? void 0 : option.progressCircle.strokeWidth, duration);
                        }
                        (_a = option === null || option === void 0 ? void 0 : option.onSlideChange) === null || _a === void 0 ? void 0 : _a.call(option, currentIndex.unwrap());
                    };
                    var changePagination = function(diameter, strokeWidth, duration) {
                        var lastPaginationItem = paginationItems[lastIndex.unwrap()];
                        var currentPaginationItem = paginationItems[currentIndex.unwrap()];
                        var lastCircle = lastPaginationItem.querySelector('circle');
                        var currentCircle = currentPaginationItem.querySelector('circle');
                        // change class
                        lastPaginationItem.classList.remove('is-active');
                        currentPaginationItem.classList.add('is-active');
                        // reset
                        if (lastCircle) {
                            initializeCircle(lastCircle, diameter, strokeWidth);
                            animationTl && animationTl.pause();
                        }
                        // animate
                        animationTl = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.to(currentCircle, {
                            strokeDashoffset: 0,
                            duration: duration
                        });
                    };
                    var resetTimer = function() {
                        timer && clearInterval(timer);
                        timer = window.setInterval(function() {
                            slideNext();
                        }, option === null || option === void 0 ? void 0 : option.interval);
                    };
                    var slideNext = function() {
                        lastIndex.wrap(currentIndex.unwrap());
                        var isEndIndex = currentIndex.unwrap() === slideLength.unwrap() - 1;
                        var newIndex = isEndIndex ? 0 : currentIndex.unwrap() + 1;
                        currentIndex.wrap(newIndex);
                        changeSlide();
                    };
                    var slidePrev = function() {
                        lastIndex.wrap(currentIndex.unwrap());
                        var isFirstIndex = currentIndex.unwrap() === 0;
                        var newIndex = isFirstIndex ? slideLength.unwrap() - 1 : currentIndex.unwrap() - 1;
                        currentIndex.wrap(newIndex);
                        changeSlide();
                    };
                    return {
                        slideNext: slideNext,
                        slidePrev: slidePrev,
                        discardAutoPlay: discardAutoPlay
                    };
                };
                var initializeCircle = function(circle, diameter, strokeWidth) {
                    var circumference = (diameter - strokeWidth * 2) * Math.PI + '';
                    circle.style.strokeDashoffset = circumference;
                    circle.style.strokeDasharray = circumference;
                };
                var createCircleSvg = function(diameter, strokeWidth) {
                    var radius = diameter * 0.5;
                    var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    svg.setAttribute('viewBox', "0 0 ".concat(diameter, " ").concat(diameter));
                    var circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', "".concat(radius));
                    circle.setAttribute('cy', "".concat(radius));
                    circle.setAttribute('r', "".concat((diameter - strokeWidth * 2) * 0.5));
                    initializeCircle(circle, diameter, strokeWidth);
                    svg.appendChild(circle);
                    return svg;
                };
                var createPagination = function(_a) {
                    var label = _a.label,
                        diameter = _a.diameter,
                        strokeWidth = _a.strokeWidth;
                    var fragment = document.createDocumentFragment();
                    var liElement = document.createElement('li');
                    var buttonElement = document.createElement('button');
                    var svg = createCircleSvg(diameter, strokeWidth);
                    buttonElement.setAttribute('aria-label', label);
                    fragment.appendChild(buttonElement);
                    fragment.appendChild(svg);
                    liElement.appendChild(fragment);
                    return {
                        liElement: liElement,
                        buttonElement: buttonElement
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/hooks/useSplash.ts":
            /*!****************************************!*\
              !*** ./src/scripts/hooks/useSplash.ts ***!
              \****************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "useSplash": function() {
                        return /* binding */ useSplash;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
                /* harmony import */
                var gsap__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                /* harmony import */
                var scroll_lock__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! scroll-lock */ "./node_modules/scroll-lock/dist/scroll-lock.js");
                /* harmony import */
                var scroll_lock__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(scroll_lock__WEBPACK_IMPORTED_MODULE_1__);
                /* harmony import */
                var _scripts_state_SplashState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @/scripts/state/SplashState */ "./src/scripts/state/SplashState.ts");




                var useSplash = function(wrapperGetter, progressGetter) {
                    var isAnimating = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.val)(false);
                    var skip = function() {
                        var el = wrapperGetter();
                        if (!el) {
                            return;
                        }
                        el.style.display = 'none';
                        setStateAnimated();
                        sessionStorage.setItem('isVisited', 'true');
                    };
                    var updateProgress = function(counter) {
                        if (sessionStorage.getItem('isVisited')) {
                            skip();
                            return;
                        }
                        var progress = progressGetter();
                        if (!progress) {
                            return;
                        }
                        isAnimating.wrap(true);
                        if (100 > counter) {
                            progress.textContent = String(counter);
                            return;
                        }
                        sessionStorage.setItem('isVisited', 'true');
                        play();
                    };
                    var play = function() {
                        var el = wrapperGetter();
                        var progress = progressGetter();
                        if (!el || !progress) {
                            return;
                        }
                        var timeline = gsap__WEBPACK_IMPORTED_MODULE_3__.gsap.timeline();
                        timeline.to(el, {
                            opacity: 0,
                            display: 'none',
                            duration: 0.3
                        });
                        timeline.call(function() {
                            isAnimating.wrap(false);
                            setStateAnimated();
                        }, [], '>-0.25');
                    };
                    (0, furnace__WEBPACK_IMPORTED_MODULE_0__.useWatch)(function() {
                        return isAnimating.unwrap();
                    }, function(isAnimating) {
                        var el = wrapperGetter();
                        if (!el) {
                            return;
                        }
                        isAnimating ? (0, scroll_lock__WEBPACK_IMPORTED_MODULE_1__.disablePageScroll)(el) : (0, scroll_lock__WEBPACK_IMPORTED_MODULE_1__.enablePageScroll)(el);
                    });
                    var setStateAnimated = function() {
                        _scripts_state_SplashState__WEBPACK_IMPORTED_MODULE_2__.SplashState.wrap(function(state) {
                            return Object.assign({}, state, {
                                isAnimated: true
                            });
                        });
                    };
                    return {
                        updateProgress: updateProgress,
                        skip: skip
                    };
                };



                /***/
            }),

        /***/
        "./src/scripts/state/MemberDialogState.ts":
            /*!************************************************!*\
              !*** ./src/scripts/state/MemberDialogState.ts ***!
              \************************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "MemberDialogState": function() {
                        return /* binding */ MemberDialogState;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");

                var MemberDialogState = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.dict)({
                    currentMemberId: null,
                    isOpen: false
                });



                /***/
            }),

        /***/
        "./src/scripts/state/MobileMenuState.ts":
            /*!**********************************************!*\
              !*** ./src/scripts/state/MobileMenuState.ts ***!
              \**********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "MobileMenuState": function() {
                        return /* binding */ MobileMenuState;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");

                var MobileMenuState = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.dict)({
                    isOpen: false,
                    originallyFocusedElement: null
                });



                /***/
            }),

        /***/
        "./src/scripts/state/PageState.ts":
            /*!****************************************!*\
              !*** ./src/scripts/state/PageState.ts ***!
              \****************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "PageState": function() {
                        return /* binding */ PageState;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");

                var PageState = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.dict)({
                    pageTopFocusTarget: null
                });



                /***/
            }),

        /***/
        "./src/scripts/state/SplashState.ts":
            /*!******************************************!*\
              !*** ./src/scripts/state/SplashState.ts ***!
              \******************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "SplashState": function() {
                        return /* binding */ SplashState;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");

                var SplashState = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.dict)({
                    progressCount: null,
                    needsSplash: false,
                    isAnimated: false
                });



                /***/
            }),

        /***/
        "./src/scripts/state/ViewState.ts":
            /*!****************************************!*\
              !*** ./src/scripts/state/ViewState.ts ***!
              \****************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "ViewState": function() {
                        return /* binding */ ViewState;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");

                var ViewState = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.dict)({
                    isTopFv: false,
                    isFooter: false
                });



                /***/
            }),

        /***/
        "./src/scripts/state/WindowSizeState.ts":
            /*!**********************************************!*\
              !*** ./src/scripts/state/WindowSizeState.ts ***!
              \**********************************************/
            /***/
            (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "WindowSizeState": function() {
                        return /* binding */ WindowSizeState;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var furnace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");

                var WindowSizeState = (0, furnace__WEBPACK_IMPORTED_MODULE_0__.dict)({
                    width: window.innerWidth,
                    height: window.innerHeight
                });



                /***/
            }),

        /***/
        "./node_modules/three/build/three.module.js":
            /*!**************************************************!*\
              !*** ./node_modules/three/build/three.module.js ***!
              \**************************************************/
            /***/
            (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "ACESFilmicToneMapping": function() {
                        return /* binding */ ACESFilmicToneMapping;
                    },
                    /* harmony export */
                    "AddEquation": function() {
                        return /* binding */ AddEquation;
                    },
                    /* harmony export */
                    "AddOperation": function() {
                        return /* binding */ AddOperation;
                    },
                    /* harmony export */
                    "AdditiveAnimationBlendMode": function() {
                        return /* binding */ AdditiveAnimationBlendMode;
                    },
                    /* harmony export */
                    "AdditiveBlending": function() {
                        return /* binding */ AdditiveBlending;
                    },
                    /* harmony export */
                    "AlphaFormat": function() {
                        return /* binding */ AlphaFormat;
                    },
                    /* harmony export */
                    "AlwaysDepth": function() {
                        return /* binding */ AlwaysDepth;
                    },
                    /* harmony export */
                    "AlwaysStencilFunc": function() {
                        return /* binding */ AlwaysStencilFunc;
                    },
                    /* harmony export */
                    "AmbientLight": function() {
                        return /* binding */ AmbientLight;
                    },
                    /* harmony export */
                    "AmbientLightProbe": function() {
                        return /* binding */ AmbientLightProbe;
                    },
                    /* harmony export */
                    "AnimationClip": function() {
                        return /* binding */ AnimationClip;
                    },
                    /* harmony export */
                    "AnimationLoader": function() {
                        return /* binding */ AnimationLoader;
                    },
                    /* harmony export */
                    "AnimationMixer": function() {
                        return /* binding */ AnimationMixer;
                    },
                    /* harmony export */
                    "AnimationObjectGroup": function() {
                        return /* binding */ AnimationObjectGroup;
                    },
                    /* harmony export */
                    "AnimationUtils": function() {
                        return /* binding */ AnimationUtils;
                    },
                    /* harmony export */
                    "ArcCurve": function() {
                        return /* binding */ ArcCurve;
                    },
                    /* harmony export */
                    "ArrayCamera": function() {
                        return /* binding */ ArrayCamera;
                    },
                    /* harmony export */
                    "ArrowHelper": function() {
                        return /* binding */ ArrowHelper;
                    },
                    /* harmony export */
                    "Audio": function() {
                        return /* binding */ Audio;
                    },
                    /* harmony export */
                    "AudioAnalyser": function() {
                        return /* binding */ AudioAnalyser;
                    },
                    /* harmony export */
                    "AudioContext": function() {
                        return /* binding */ AudioContext;
                    },
                    /* harmony export */
                    "AudioListener": function() {
                        return /* binding */ AudioListener;
                    },
                    /* harmony export */
                    "AudioLoader": function() {
                        return /* binding */ AudioLoader;
                    },
                    /* harmony export */
                    "AxesHelper": function() {
                        return /* binding */ AxesHelper;
                    },
                    /* harmony export */
                    "AxisHelper": function() {
                        return /* binding */ AxisHelper;
                    },
                    /* harmony export */
                    "BackSide": function() {
                        return /* binding */ BackSide;
                    },
                    /* harmony export */
                    "BasicDepthPacking": function() {
                        return /* binding */ BasicDepthPacking;
                    },
                    /* harmony export */
                    "BasicShadowMap": function() {
                        return /* binding */ BasicShadowMap;
                    },
                    /* harmony export */
                    "BinaryTextureLoader": function() {
                        return /* binding */ BinaryTextureLoader;
                    },
                    /* harmony export */
                    "Bone": function() {
                        return /* binding */ Bone;
                    },
                    /* harmony export */
                    "BooleanKeyframeTrack": function() {
                        return /* binding */ BooleanKeyframeTrack;
                    },
                    /* harmony export */
                    "BoundingBoxHelper": function() {
                        return /* binding */ BoundingBoxHelper;
                    },
                    /* harmony export */
                    "Box2": function() {
                        return /* binding */ Box2;
                    },
                    /* harmony export */
                    "Box3": function() {
                        return /* binding */ Box3;
                    },
                    /* harmony export */
                    "Box3Helper": function() {
                        return /* binding */ Box3Helper;
                    },
                    /* harmony export */
                    "BoxBufferGeometry": function() {
                        return /* binding */ BoxGeometry;
                    },
                    /* harmony export */
                    "BoxGeometry": function() {
                        return /* binding */ BoxGeometry;
                    },
                    /* harmony export */
                    "BoxHelper": function() {
                        return /* binding */ BoxHelper;
                    },
                    /* harmony export */
                    "BufferAttribute": function() {
                        return /* binding */ BufferAttribute;
                    },
                    /* harmony export */
                    "BufferGeometry": function() {
                        return /* binding */ BufferGeometry;
                    },
                    /* harmony export */
                    "BufferGeometryLoader": function() {
                        return /* binding */ BufferGeometryLoader;
                    },
                    /* harmony export */
                    "ByteType": function() {
                        return /* binding */ ByteType;
                    },
                    /* harmony export */
                    "Cache": function() {
                        return /* binding */ Cache;
                    },
                    /* harmony export */
                    "Camera": function() {
                        return /* binding */ Camera;
                    },
                    /* harmony export */
                    "CameraHelper": function() {
                        return /* binding */ CameraHelper;
                    },
                    /* harmony export */
                    "CanvasRenderer": function() {
                        return /* binding */ CanvasRenderer;
                    },
                    /* harmony export */
                    "CanvasTexture": function() {
                        return /* binding */ CanvasTexture;
                    },
                    /* harmony export */
                    "CapsuleBufferGeometry": function() {
                        return /* binding */ CapsuleGeometry;
                    },
                    /* harmony export */
                    "CapsuleGeometry": function() {
                        return /* binding */ CapsuleGeometry;
                    },
                    /* harmony export */
                    "CatmullRomCurve3": function() {
                        return /* binding */ CatmullRomCurve3;
                    },
                    /* harmony export */
                    "CineonToneMapping": function() {
                        return /* binding */ CineonToneMapping;
                    },
                    /* harmony export */
                    "CircleBufferGeometry": function() {
                        return /* binding */ CircleGeometry;
                    },
                    /* harmony export */
                    "CircleGeometry": function() {
                        return /* binding */ CircleGeometry;
                    },
                    /* harmony export */
                    "ClampToEdgeWrapping": function() {
                        return /* binding */ ClampToEdgeWrapping;
                    },
                    /* harmony export */
                    "Clock": function() {
                        return /* binding */ Clock;
                    },
                    /* harmony export */
                    "Color": function() {
                        return /* binding */ Color;
                    },
                    /* harmony export */
                    "ColorKeyframeTrack": function() {
                        return /* binding */ ColorKeyframeTrack;
                    },
                    /* harmony export */
                    "ColorManagement": function() {
                        return /* binding */ ColorManagement;
                    },
                    /* harmony export */
                    "CompressedTexture": function() {
                        return /* binding */ CompressedTexture;
                    },
                    /* harmony export */
                    "CompressedTextureLoader": function() {
                        return /* binding */ CompressedTextureLoader;
                    },
                    /* harmony export */
                    "ConeBufferGeometry": function() {
                        return /* binding */ ConeGeometry;
                    },
                    /* harmony export */
                    "ConeGeometry": function() {
                        return /* binding */ ConeGeometry;
                    },
                    /* harmony export */
                    "CubeCamera": function() {
                        return /* binding */ CubeCamera;
                    },
                    /* harmony export */
                    "CubeReflectionMapping": function() {
                        return /* binding */ CubeReflectionMapping;
                    },
                    /* harmony export */
                    "CubeRefractionMapping": function() {
                        return /* binding */ CubeRefractionMapping;
                    },
                    /* harmony export */
                    "CubeTexture": function() {
                        return /* binding */ CubeTexture;
                    },
                    /* harmony export */
                    "CubeTextureLoader": function() {
                        return /* binding */ CubeTextureLoader;
                    },
                    /* harmony export */
                    "CubeUVReflectionMapping": function() {
                        return /* binding */ CubeUVReflectionMapping;
                    },
                    /* harmony export */
                    "CubicBezierCurve": function() {
                        return /* binding */ CubicBezierCurve;
                    },
                    /* harmony export */
                    "CubicBezierCurve3": function() {
                        return /* binding */ CubicBezierCurve3;
                    },
                    /* harmony export */
                    "CubicInterpolant": function() {
                        return /* binding */ CubicInterpolant;
                    },
                    /* harmony export */
                    "CullFaceBack": function() {
                        return /* binding */ CullFaceBack;
                    },
                    /* harmony export */
                    "CullFaceFront": function() {
                        return /* binding */ CullFaceFront;
                    },
                    /* harmony export */
                    "CullFaceFrontBack": function() {
                        return /* binding */ CullFaceFrontBack;
                    },
                    /* harmony export */
                    "CullFaceNone": function() {
                        return /* binding */ CullFaceNone;
                    },
                    /* harmony export */
                    "Curve": function() {
                        return /* binding */ Curve;
                    },
                    /* harmony export */
                    "CurvePath": function() {
                        return /* binding */ CurvePath;
                    },
                    /* harmony export */
                    "CustomBlending": function() {
                        return /* binding */ CustomBlending;
                    },
                    /* harmony export */
                    "CustomToneMapping": function() {
                        return /* binding */ CustomToneMapping;
                    },
                    /* harmony export */
                    "CylinderBufferGeometry": function() {
                        return /* binding */ CylinderGeometry;
                    },
                    /* harmony export */
                    "CylinderGeometry": function() {
                        return /* binding */ CylinderGeometry;
                    },
                    /* harmony export */
                    "Cylindrical": function() {
                        return /* binding */ Cylindrical;
                    },
                    /* harmony export */
                    "Data3DTexture": function() {
                        return /* binding */ Data3DTexture;
                    },
                    /* harmony export */
                    "DataArrayTexture": function() {
                        return /* binding */ DataArrayTexture;
                    },
                    /* harmony export */
                    "DataTexture": function() {
                        return /* binding */ DataTexture;
                    },
                    /* harmony export */
                    "DataTexture2DArray": function() {
                        return /* binding */ DataTexture2DArray;
                    },
                    /* harmony export */
                    "DataTexture3D": function() {
                        return /* binding */ DataTexture3D;
                    },
                    /* harmony export */
                    "DataTextureLoader": function() {
                        return /* binding */ DataTextureLoader;
                    },
                    /* harmony export */
                    "DataUtils": function() {
                        return /* binding */ DataUtils;
                    },
                    /* harmony export */
                    "DecrementStencilOp": function() {
                        return /* binding */ DecrementStencilOp;
                    },
                    /* harmony export */
                    "DecrementWrapStencilOp": function() {
                        return /* binding */ DecrementWrapStencilOp;
                    },
                    /* harmony export */
                    "DefaultLoadingManager": function() {
                        return /* binding */ DefaultLoadingManager;
                    },
                    /* harmony export */
                    "DepthFormat": function() {
                        return /* binding */ DepthFormat;
                    },
                    /* harmony export */
                    "DepthStencilFormat": function() {
                        return /* binding */ DepthStencilFormat;
                    },
                    /* harmony export */
                    "DepthTexture": function() {
                        return /* binding */ DepthTexture;
                    },
                    /* harmony export */
                    "DirectionalLight": function() {
                        return /* binding */ DirectionalLight;
                    },
                    /* harmony export */
                    "DirectionalLightHelper": function() {
                        return /* binding */ DirectionalLightHelper;
                    },
                    /* harmony export */
                    "DiscreteInterpolant": function() {
                        return /* binding */ DiscreteInterpolant;
                    },
                    /* harmony export */
                    "DodecahedronBufferGeometry": function() {
                        return /* binding */ DodecahedronGeometry;
                    },
                    /* harmony export */
                    "DodecahedronGeometry": function() {
                        return /* binding */ DodecahedronGeometry;
                    },
                    /* harmony export */
                    "DoubleSide": function() {
                        return /* binding */ DoubleSide;
                    },
                    /* harmony export */
                    "DstAlphaFactor": function() {
                        return /* binding */ DstAlphaFactor;
                    },
                    /* harmony export */
                    "DstColorFactor": function() {
                        return /* binding */ DstColorFactor;
                    },
                    /* harmony export */
                    "DynamicBufferAttribute": function() {
                        return /* binding */ DynamicBufferAttribute;
                    },
                    /* harmony export */
                    "DynamicCopyUsage": function() {
                        return /* binding */ DynamicCopyUsage;
                    },
                    /* harmony export */
                    "DynamicDrawUsage": function() {
                        return /* binding */ DynamicDrawUsage;
                    },
                    /* harmony export */
                    "DynamicReadUsage": function() {
                        return /* binding */ DynamicReadUsage;
                    },
                    /* harmony export */
                    "EdgesGeometry": function() {
                        return /* binding */ EdgesGeometry;
                    },
                    /* harmony export */
                    "EdgesHelper": function() {
                        return /* binding */ EdgesHelper;
                    },
                    /* harmony export */
                    "EllipseCurve": function() {
                        return /* binding */ EllipseCurve;
                    },
                    /* harmony export */
                    "EqualDepth": function() {
                        return /* binding */ EqualDepth;
                    },
                    /* harmony export */
                    "EqualStencilFunc": function() {
                        return /* binding */ EqualStencilFunc;
                    },
                    /* harmony export */
                    "EquirectangularReflectionMapping": function() {
                        return /* binding */ EquirectangularReflectionMapping;
                    },
                    /* harmony export */
                    "EquirectangularRefractionMapping": function() {
                        return /* binding */ EquirectangularRefractionMapping;
                    },
                    /* harmony export */
                    "Euler": function() {
                        return /* binding */ Euler;
                    },
                    /* harmony export */
                    "EventDispatcher": function() {
                        return /* binding */ EventDispatcher;
                    },
                    /* harmony export */
                    "ExtrudeBufferGeometry": function() {
                        return /* binding */ ExtrudeGeometry;
                    },
                    /* harmony export */
                    "ExtrudeGeometry": function() {
                        return /* binding */ ExtrudeGeometry;
                    },
                    /* harmony export */
                    "FaceColors": function() {
                        return /* binding */ FaceColors;
                    },
                    /* harmony export */
                    "FileLoader": function() {
                        return /* binding */ FileLoader;
                    },
                    /* harmony export */
                    "FlatShading": function() {
                        return /* binding */ FlatShading;
                    },
                    /* harmony export */
                    "Float16BufferAttribute": function() {
                        return /* binding */ Float16BufferAttribute;
                    },
                    /* harmony export */
                    "Float32Attribute": function() {
                        return /* binding */ Float32Attribute;
                    },
                    /* harmony export */
                    "Float32BufferAttribute": function() {
                        return /* binding */ Float32BufferAttribute;
                    },
                    /* harmony export */
                    "Float64Attribute": function() {
                        return /* binding */ Float64Attribute;
                    },
                    /* harmony export */
                    "Float64BufferAttribute": function() {
                        return /* binding */ Float64BufferAttribute;
                    },
                    /* harmony export */
                    "FloatType": function() {
                        return /* binding */ FloatType;
                    },
                    /* harmony export */
                    "Fog": function() {
                        return /* binding */ Fog;
                    },
                    /* harmony export */
                    "FogExp2": function() {
                        return /* binding */ FogExp2;
                    },
                    /* harmony export */
                    "Font": function() {
                        return /* binding */ Font;
                    },
                    /* harmony export */
                    "FontLoader": function() {
                        return /* binding */ FontLoader;
                    },
                    /* harmony export */
                    "FramebufferTexture": function() {
                        return /* binding */ FramebufferTexture;
                    },
                    /* harmony export */
                    "FrontSide": function() {
                        return /* binding */ FrontSide;
                    },
                    /* harmony export */
                    "Frustum": function() {
                        return /* binding */ Frustum;
                    },
                    /* harmony export */
                    "GLBufferAttribute": function() {
                        return /* binding */ GLBufferAttribute;
                    },
                    /* harmony export */
                    "GLSL1": function() {
                        return /* binding */ GLSL1;
                    },
                    /* harmony export */
                    "GLSL3": function() {
                        return /* binding */ GLSL3;
                    },
                    /* harmony export */
                    "GreaterDepth": function() {
                        return /* binding */ GreaterDepth;
                    },
                    /* harmony export */
                    "GreaterEqualDepth": function() {
                        return /* binding */ GreaterEqualDepth;
                    },
                    /* harmony export */
                    "GreaterEqualStencilFunc": function() {
                        return /* binding */ GreaterEqualStencilFunc;
                    },
                    /* harmony export */
                    "GreaterStencilFunc": function() {
                        return /* binding */ GreaterStencilFunc;
                    },
                    /* harmony export */
                    "GridHelper": function() {
                        return /* binding */ GridHelper;
                    },
                    /* harmony export */
                    "Group": function() {
                        return /* binding */ Group;
                    },
                    /* harmony export */
                    "HalfFloatType": function() {
                        return /* binding */ HalfFloatType;
                    },
                    /* harmony export */
                    "HemisphereLight": function() {
                        return /* binding */ HemisphereLight;
                    },
                    /* harmony export */
                    "HemisphereLightHelper": function() {
                        return /* binding */ HemisphereLightHelper;
                    },
                    /* harmony export */
                    "HemisphereLightProbe": function() {
                        return /* binding */ HemisphereLightProbe;
                    },
                    /* harmony export */
                    "IcosahedronBufferGeometry": function() {
                        return /* binding */ IcosahedronGeometry;
                    },
                    /* harmony export */
                    "IcosahedronGeometry": function() {
                        return /* binding */ IcosahedronGeometry;
                    },
                    /* harmony export */
                    "ImageBitmapLoader": function() {
                        return /* binding */ ImageBitmapLoader;
                    },
                    /* harmony export */
                    "ImageLoader": function() {
                        return /* binding */ ImageLoader;
                    },
                    /* harmony export */
                    "ImageUtils": function() {
                        return /* binding */ ImageUtils;
                    },
                    /* harmony export */
                    "ImmediateRenderObject": function() {
                        return /* binding */ ImmediateRenderObject;
                    },
                    /* harmony export */
                    "IncrementStencilOp": function() {
                        return /* binding */ IncrementStencilOp;
                    },
                    /* harmony export */
                    "IncrementWrapStencilOp": function() {
                        return /* binding */ IncrementWrapStencilOp;
                    },
                    /* harmony export */
                    "InstancedBufferAttribute": function() {
                        return /* binding */ InstancedBufferAttribute;
                    },
                    /* harmony export */
                    "InstancedBufferGeometry": function() {
                        return /* binding */ InstancedBufferGeometry;
                    },
                    /* harmony export */
                    "InstancedInterleavedBuffer": function() {
                        return /* binding */ InstancedInterleavedBuffer;
                    },
                    /* harmony export */
                    "InstancedMesh": function() {
                        return /* binding */ InstancedMesh;
                    },
                    /* harmony export */
                    "Int16Attribute": function() {
                        return /* binding */ Int16Attribute;
                    },
                    /* harmony export */
                    "Int16BufferAttribute": function() {
                        return /* binding */ Int16BufferAttribute;
                    },
                    /* harmony export */
                    "Int32Attribute": function() {
                        return /* binding */ Int32Attribute;
                    },
                    /* harmony export */
                    "Int32BufferAttribute": function() {
                        return /* binding */ Int32BufferAttribute;
                    },
                    /* harmony export */
                    "Int8Attribute": function() {
                        return /* binding */ Int8Attribute;
                    },
                    /* harmony export */
                    "Int8BufferAttribute": function() {
                        return /* binding */ Int8BufferAttribute;
                    },
                    /* harmony export */
                    "IntType": function() {
                        return /* binding */ IntType;
                    },
                    /* harmony export */
                    "InterleavedBuffer": function() {
                        return /* binding */ InterleavedBuffer;
                    },
                    /* harmony export */
                    "InterleavedBufferAttribute": function() {
                        return /* binding */ InterleavedBufferAttribute;
                    },
                    /* harmony export */
                    "Interpolant": function() {
                        return /* binding */ Interpolant;
                    },
                    /* harmony export */
                    "InterpolateDiscrete": function() {
                        return /* binding */ InterpolateDiscrete;
                    },
                    /* harmony export */
                    "InterpolateLinear": function() {
                        return /* binding */ InterpolateLinear;
                    },
                    /* harmony export */
                    "InterpolateSmooth": function() {
                        return /* binding */ InterpolateSmooth;
                    },
                    /* harmony export */
                    "InvertStencilOp": function() {
                        return /* binding */ InvertStencilOp;
                    },
                    /* harmony export */
                    "JSONLoader": function() {
                        return /* binding */ JSONLoader;
                    },
                    /* harmony export */
                    "KeepStencilOp": function() {
                        return /* binding */ KeepStencilOp;
                    },
                    /* harmony export */
                    "KeyframeTrack": function() {
                        return /* binding */ KeyframeTrack;
                    },
                    /* harmony export */
                    "LOD": function() {
                        return /* binding */ LOD;
                    },
                    /* harmony export */
                    "LatheBufferGeometry": function() {
                        return /* binding */ LatheGeometry;
                    },
                    /* harmony export */
                    "LatheGeometry": function() {
                        return /* binding */ LatheGeometry;
                    },
                    /* harmony export */
                    "Layers": function() {
                        return /* binding */ Layers;
                    },
                    /* harmony export */
                    "LensFlare": function() {
                        return /* binding */ LensFlare;
                    },
                    /* harmony export */
                    "LessDepth": function() {
                        return /* binding */ LessDepth;
                    },
                    /* harmony export */
                    "LessEqualDepth": function() {
                        return /* binding */ LessEqualDepth;
                    },
                    /* harmony export */
                    "LessEqualStencilFunc": function() {
                        return /* binding */ LessEqualStencilFunc;
                    },
                    /* harmony export */
                    "LessStencilFunc": function() {
                        return /* binding */ LessStencilFunc;
                    },
                    /* harmony export */
                    "Light": function() {
                        return /* binding */ Light;
                    },
                    /* harmony export */
                    "LightProbe": function() {
                        return /* binding */ LightProbe;
                    },
                    /* harmony export */
                    "Line": function() {
                        return /* binding */ Line;
                    },
                    /* harmony export */
                    "Line3": function() {
                        return /* binding */ Line3;
                    },
                    /* harmony export */
                    "LineBasicMaterial": function() {
                        return /* binding */ LineBasicMaterial;
                    },
                    /* harmony export */
                    "LineCurve": function() {
                        return /* binding */ LineCurve;
                    },
                    /* harmony export */
                    "LineCurve3": function() {
                        return /* binding */ LineCurve3;
                    },
                    /* harmony export */
                    "LineDashedMaterial": function() {
                        return /* binding */ LineDashedMaterial;
                    },
                    /* harmony export */
                    "LineLoop": function() {
                        return /* binding */ LineLoop;
                    },
                    /* harmony export */
                    "LinePieces": function() {
                        return /* binding */ LinePieces;
                    },
                    /* harmony export */
                    "LineSegments": function() {
                        return /* binding */ LineSegments;
                    },
                    /* harmony export */
                    "LineStrip": function() {
                        return /* binding */ LineStrip;
                    },
                    /* harmony export */
                    "LinearEncoding": function() {
                        return /* binding */ LinearEncoding;
                    },
                    /* harmony export */
                    "LinearFilter": function() {
                        return /* binding */ LinearFilter;
                    },
                    /* harmony export */
                    "LinearInterpolant": function() {
                        return /* binding */ LinearInterpolant;
                    },
                    /* harmony export */
                    "LinearMipMapLinearFilter": function() {
                        return /* binding */ LinearMipMapLinearFilter;
                    },
                    /* harmony export */
                    "LinearMipMapNearestFilter": function() {
                        return /* binding */ LinearMipMapNearestFilter;
                    },
                    /* harmony export */
                    "LinearMipmapLinearFilter": function() {
                        return /* binding */ LinearMipmapLinearFilter;
                    },
                    /* harmony export */
                    "LinearMipmapNearestFilter": function() {
                        return /* binding */ LinearMipmapNearestFilter;
                    },
                    /* harmony export */
                    "LinearSRGBColorSpace": function() {
                        return /* binding */ LinearSRGBColorSpace;
                    },
                    /* harmony export */
                    "LinearToneMapping": function() {
                        return /* binding */ LinearToneMapping;
                    },
                    /* harmony export */
                    "Loader": function() {
                        return /* binding */ Loader;
                    },
                    /* harmony export */
                    "LoaderUtils": function() {
                        return /* binding */ LoaderUtils;
                    },
                    /* harmony export */
                    "LoadingManager": function() {
                        return /* binding */ LoadingManager;
                    },
                    /* harmony export */
                    "LoopOnce": function() {
                        return /* binding */ LoopOnce;
                    },
                    /* harmony export */
                    "LoopPingPong": function() {
                        return /* binding */ LoopPingPong;
                    },
                    /* harmony export */
                    "LoopRepeat": function() {
                        return /* binding */ LoopRepeat;
                    },
                    /* harmony export */
                    "LuminanceAlphaFormat": function() {
                        return /* binding */ LuminanceAlphaFormat;
                    },
                    /* harmony export */
                    "LuminanceFormat": function() {
                        return /* binding */ LuminanceFormat;
                    },
                    /* harmony export */
                    "MOUSE": function() {
                        return /* binding */ MOUSE;
                    },
                    /* harmony export */
                    "Material": function() {
                        return /* binding */ Material;
                    },
                    /* harmony export */
                    "MaterialLoader": function() {
                        return /* binding */ MaterialLoader;
                    },
                    /* harmony export */
                    "Math": function() {
                        return /* binding */ MathUtils;
                    },
                    /* harmony export */
                    "MathUtils": function() {
                        return /* binding */ MathUtils;
                    },
                    /* harmony export */
                    "Matrix3": function() {
                        return /* binding */ Matrix3;
                    },
                    /* harmony export */
                    "Matrix4": function() {
                        return /* binding */ Matrix4;
                    },
                    /* harmony export */
                    "MaxEquation": function() {
                        return /* binding */ MaxEquation;
                    },
                    /* harmony export */
                    "Mesh": function() {
                        return /* binding */ Mesh;
                    },
                    /* harmony export */
                    "MeshBasicMaterial": function() {
                        return /* binding */ MeshBasicMaterial;
                    },
                    /* harmony export */
                    "MeshDepthMaterial": function() {
                        return /* binding */ MeshDepthMaterial;
                    },
                    /* harmony export */
                    "MeshDistanceMaterial": function() {
                        return /* binding */ MeshDistanceMaterial;
                    },
                    /* harmony export */
                    "MeshFaceMaterial": function() {
                        return /* binding */ MeshFaceMaterial;
                    },
                    /* harmony export */
                    "MeshLambertMaterial": function() {
                        return /* binding */ MeshLambertMaterial;
                    },
                    /* harmony export */
                    "MeshMatcapMaterial": function() {
                        return /* binding */ MeshMatcapMaterial;
                    },
                    /* harmony export */
                    "MeshNormalMaterial": function() {
                        return /* binding */ MeshNormalMaterial;
                    },
                    /* harmony export */
                    "MeshPhongMaterial": function() {
                        return /* binding */ MeshPhongMaterial;
                    },
                    /* harmony export */
                    "MeshPhysicalMaterial": function() {
                        return /* binding */ MeshPhysicalMaterial;
                    },
                    /* harmony export */
                    "MeshStandardMaterial": function() {
                        return /* binding */ MeshStandardMaterial;
                    },
                    /* harmony export */
                    "MeshToonMaterial": function() {
                        return /* binding */ MeshToonMaterial;
                    },
                    /* harmony export */
                    "MinEquation": function() {
                        return /* binding */ MinEquation;
                    },
                    /* harmony export */
                    "MirroredRepeatWrapping": function() {
                        return /* binding */ MirroredRepeatWrapping;
                    },
                    /* harmony export */
                    "MixOperation": function() {
                        return /* binding */ MixOperation;
                    },
                    /* harmony export */
                    "MultiMaterial": function() {
                        return /* binding */ MultiMaterial;
                    },
                    /* harmony export */
                    "MultiplyBlending": function() {
                        return /* binding */ MultiplyBlending;
                    },
                    /* harmony export */
                    "MultiplyOperation": function() {
                        return /* binding */ MultiplyOperation;
                    },
                    /* harmony export */
                    "NearestFilter": function() {
                        return /* binding */ NearestFilter;
                    },
                    /* harmony export */
                    "NearestMipMapLinearFilter": function() {
                        return /* binding */ NearestMipMapLinearFilter;
                    },
                    /* harmony export */
                    "NearestMipMapNearestFilter": function() {
                        return /* binding */ NearestMipMapNearestFilter;
                    },
                    /* harmony export */
                    "NearestMipmapLinearFilter": function() {
                        return /* binding */ NearestMipmapLinearFilter;
                    },
                    /* harmony export */
                    "NearestMipmapNearestFilter": function() {
                        return /* binding */ NearestMipmapNearestFilter;
                    },
                    /* harmony export */
                    "NeverDepth": function() {
                        return /* binding */ NeverDepth;
                    },
                    /* harmony export */
                    "NeverStencilFunc": function() {
                        return /* binding */ NeverStencilFunc;
                    },
                    /* harmony export */
                    "NoBlending": function() {
                        return /* binding */ NoBlending;
                    },
                    /* harmony export */
                    "NoColorSpace": function() {
                        return /* binding */ NoColorSpace;
                    },
                    /* harmony export */
                    "NoColors": function() {
                        return /* binding */ NoColors;
                    },
                    /* harmony export */
                    "NoToneMapping": function() {
                        return /* binding */ NoToneMapping;
                    },
                    /* harmony export */
                    "NormalAnimationBlendMode": function() {
                        return /* binding */ NormalAnimationBlendMode;
                    },
                    /* harmony export */
                    "NormalBlending": function() {
                        return /* binding */ NormalBlending;
                    },
                    /* harmony export */
                    "NotEqualDepth": function() {
                        return /* binding */ NotEqualDepth;
                    },
                    /* harmony export */
                    "NotEqualStencilFunc": function() {
                        return /* binding */ NotEqualStencilFunc;
                    },
                    /* harmony export */
                    "NumberKeyframeTrack": function() {
                        return /* binding */ NumberKeyframeTrack;
                    },
                    /* harmony export */
                    "Object3D": function() {
                        return /* binding */ Object3D;
                    },
                    /* harmony export */
                    "ObjectLoader": function() {
                        return /* binding */ ObjectLoader;
                    },
                    /* harmony export */
                    "ObjectSpaceNormalMap": function() {
                        return /* binding */ ObjectSpaceNormalMap;
                    },
                    /* harmony export */
                    "OctahedronBufferGeometry": function() {
                        return /* binding */ OctahedronGeometry;
                    },
                    /* harmony export */
                    "OctahedronGeometry": function() {
                        return /* binding */ OctahedronGeometry;
                    },
                    /* harmony export */
                    "OneFactor": function() {
                        return /* binding */ OneFactor;
                    },
                    /* harmony export */
                    "OneMinusDstAlphaFactor": function() {
                        return /* binding */ OneMinusDstAlphaFactor;
                    },
                    /* harmony export */
                    "OneMinusDstColorFactor": function() {
                        return /* binding */ OneMinusDstColorFactor;
                    },
                    /* harmony export */
                    "OneMinusSrcAlphaFactor": function() {
                        return /* binding */ OneMinusSrcAlphaFactor;
                    },
                    /* harmony export */
                    "OneMinusSrcColorFactor": function() {
                        return /* binding */ OneMinusSrcColorFactor;
                    },
                    /* harmony export */
                    "OrthographicCamera": function() {
                        return /* binding */ OrthographicCamera;
                    },
                    /* harmony export */
                    "PCFShadowMap": function() {
                        return /* binding */ PCFShadowMap;
                    },
                    /* harmony export */
                    "PCFSoftShadowMap": function() {
                        return /* binding */ PCFSoftShadowMap;
                    },
                    /* harmony export */
                    "PMREMGenerator": function() {
                        return /* binding */ PMREMGenerator;
                    },
                    /* harmony export */
                    "ParametricGeometry": function() {
                        return /* binding */ ParametricGeometry;
                    },
                    /* harmony export */
                    "Particle": function() {
                        return /* binding */ Particle;
                    },
                    /* harmony export */
                    "ParticleBasicMaterial": function() {
                        return /* binding */ ParticleBasicMaterial;
                    },
                    /* harmony export */
                    "ParticleSystem": function() {
                        return /* binding */ ParticleSystem;
                    },
                    /* harmony export */
                    "ParticleSystemMaterial": function() {
                        return /* binding */ ParticleSystemMaterial;
                    },
                    /* harmony export */
                    "Path": function() {
                        return /* binding */ Path;
                    },
                    /* harmony export */
                    "PerspectiveCamera": function() {
                        return /* binding */ PerspectiveCamera;
                    },
                    /* harmony export */
                    "Plane": function() {
                        return /* binding */ Plane;
                    },
                    /* harmony export */
                    "PlaneBufferGeometry": function() {
                        return /* binding */ PlaneGeometry;
                    },
                    /* harmony export */
                    "PlaneGeometry": function() {
                        return /* binding */ PlaneGeometry;
                    },
                    /* harmony export */
                    "PlaneHelper": function() {
                        return /* binding */ PlaneHelper;
                    },
                    /* harmony export */
                    "PointCloud": function() {
                        return /* binding */ PointCloud;
                    },
                    /* harmony export */
                    "PointCloudMaterial": function() {
                        return /* binding */ PointCloudMaterial;
                    },
                    /* harmony export */
                    "PointLight": function() {
                        return /* binding */ PointLight;
                    },
                    /* harmony export */
                    "PointLightHelper": function() {
                        return /* binding */ PointLightHelper;
                    },
                    /* harmony export */
                    "Points": function() {
                        return /* binding */ Points;
                    },
                    /* harmony export */
                    "PointsMaterial": function() {
                        return /* binding */ PointsMaterial;
                    },
                    /* harmony export */
                    "PolarGridHelper": function() {
                        return /* binding */ PolarGridHelper;
                    },
                    /* harmony export */
                    "PolyhedronBufferGeometry": function() {
                        return /* binding */ PolyhedronGeometry;
                    },
                    /* harmony export */
                    "PolyhedronGeometry": function() {
                        return /* binding */ PolyhedronGeometry;
                    },
                    /* harmony export */
                    "PositionalAudio": function() {
                        return /* binding */ PositionalAudio;
                    },
                    /* harmony export */
                    "PropertyBinding": function() {
                        return /* binding */ PropertyBinding;
                    },
                    /* harmony export */
                    "PropertyMixer": function() {
                        return /* binding */ PropertyMixer;
                    },
                    /* harmony export */
                    "QuadraticBezierCurve": function() {
                        return /* binding */ QuadraticBezierCurve;
                    },
                    /* harmony export */
                    "QuadraticBezierCurve3": function() {
                        return /* binding */ QuadraticBezierCurve3;
                    },
                    /* harmony export */
                    "Quaternion": function() {
                        return /* binding */ Quaternion;
                    },
                    /* harmony export */
                    "QuaternionKeyframeTrack": function() {
                        return /* binding */ QuaternionKeyframeTrack;
                    },
                    /* harmony export */
                    "QuaternionLinearInterpolant": function() {
                        return /* binding */ QuaternionLinearInterpolant;
                    },
                    /* harmony export */
                    "REVISION": function() {
                        return /* binding */ REVISION;
                    },
                    /* harmony export */
                    "RGBADepthPacking": function() {
                        return /* binding */ RGBADepthPacking;
                    },
                    /* harmony export */
                    "RGBAFormat": function() {
                        return /* binding */ RGBAFormat;
                    },
                    /* harmony export */
                    "RGBAIntegerFormat": function() {
                        return /* binding */ RGBAIntegerFormat;
                    },
                    /* harmony export */
                    "RGBA_ASTC_10x10_Format": function() {
                        return /* binding */ RGBA_ASTC_10x10_Format;
                    },
                    /* harmony export */
                    "RGBA_ASTC_10x5_Format": function() {
                        return /* binding */ RGBA_ASTC_10x5_Format;
                    },
                    /* harmony export */
                    "RGBA_ASTC_10x6_Format": function() {
                        return /* binding */ RGBA_ASTC_10x6_Format;
                    },
                    /* harmony export */
                    "RGBA_ASTC_10x8_Format": function() {
                        return /* binding */ RGBA_ASTC_10x8_Format;
                    },
                    /* harmony export */
                    "RGBA_ASTC_12x10_Format": function() {
                        return /* binding */ RGBA_ASTC_12x10_Format;
                    },
                    /* harmony export */
                    "RGBA_ASTC_12x12_Format": function() {
                        return /* binding */ RGBA_ASTC_12x12_Format;
                    },
                    /* harmony export */
                    "RGBA_ASTC_4x4_Format": function() {
                        return /* binding */ RGBA_ASTC_4x4_Format;
                    },
                    /* harmony export */
                    "RGBA_ASTC_5x4_Format": function() {
                        return /* binding */ RGBA_ASTC_5x4_Format;
                    },
                    /* harmony export */
                    "RGBA_ASTC_5x5_Format": function() {
                        return /* binding */ RGBA_ASTC_5x5_Format;
                    },
                    /* harmony export */
                    "RGBA_ASTC_6x5_Format": function() {
                        return /* binding */ RGBA_ASTC_6x5_Format;
                    },
                    /* harmony export */
                    "RGBA_ASTC_6x6_Format": function() {
                        return /* binding */ RGBA_ASTC_6x6_Format;
                    },
                    /* harmony export */
                    "RGBA_ASTC_8x5_Format": function() {
                        return /* binding */ RGBA_ASTC_8x5_Format;
                    },
                    /* harmony export */
                    "RGBA_ASTC_8x6_Format": function() {
                        return /* binding */ RGBA_ASTC_8x6_Format;
                    },
                    /* harmony export */
                    "RGBA_ASTC_8x8_Format": function() {
                        return /* binding */ RGBA_ASTC_8x8_Format;
                    },
                    /* harmony export */
                    "RGBA_BPTC_Format": function() {
                        return /* binding */ RGBA_BPTC_Format;
                    },
                    /* harmony export */
                    "RGBA_ETC2_EAC_Format": function() {
                        return /* binding */ RGBA_ETC2_EAC_Format;
                    },
                    /* harmony export */
                    "RGBA_PVRTC_2BPPV1_Format": function() {
                        return /* binding */ RGBA_PVRTC_2BPPV1_Format;
                    },
                    /* harmony export */
                    "RGBA_PVRTC_4BPPV1_Format": function() {
                        return /* binding */ RGBA_PVRTC_4BPPV1_Format;
                    },
                    /* harmony export */
                    "RGBA_S3TC_DXT1_Format": function() {
                        return /* binding */ RGBA_S3TC_DXT1_Format;
                    },
                    /* harmony export */
                    "RGBA_S3TC_DXT3_Format": function() {
                        return /* binding */ RGBA_S3TC_DXT3_Format;
                    },
                    /* harmony export */
                    "RGBA_S3TC_DXT5_Format": function() {
                        return /* binding */ RGBA_S3TC_DXT5_Format;
                    },
                    /* harmony export */
                    "RGBFormat": function() {
                        return /* binding */ RGBFormat;
                    },
                    /* harmony export */
                    "RGB_ETC1_Format": function() {
                        return /* binding */ RGB_ETC1_Format;
                    },
                    /* harmony export */
                    "RGB_ETC2_Format": function() {
                        return /* binding */ RGB_ETC2_Format;
                    },
                    /* harmony export */
                    "RGB_PVRTC_2BPPV1_Format": function() {
                        return /* binding */ RGB_PVRTC_2BPPV1_Format;
                    },
                    /* harmony export */
                    "RGB_PVRTC_4BPPV1_Format": function() {
                        return /* binding */ RGB_PVRTC_4BPPV1_Format;
                    },
                    /* harmony export */
                    "RGB_S3TC_DXT1_Format": function() {
                        return /* binding */ RGB_S3TC_DXT1_Format;
                    },
                    /* harmony export */
                    "RGFormat": function() {
                        return /* binding */ RGFormat;
                    },
                    /* harmony export */
                    "RGIntegerFormat": function() {
                        return /* binding */ RGIntegerFormat;
                    },
                    /* harmony export */
                    "RawShaderMaterial": function() {
                        return /* binding */ RawShaderMaterial;
                    },
                    /* harmony export */
                    "Ray": function() {
                        return /* binding */ Ray;
                    },
                    /* harmony export */
                    "Raycaster": function() {
                        return /* binding */ Raycaster;
                    },
                    /* harmony export */
                    "RectAreaLight": function() {
                        return /* binding */ RectAreaLight;
                    },
                    /* harmony export */
                    "RedFormat": function() {
                        return /* binding */ RedFormat;
                    },
                    /* harmony export */
                    "RedIntegerFormat": function() {
                        return /* binding */ RedIntegerFormat;
                    },
                    /* harmony export */
                    "ReinhardToneMapping": function() {
                        return /* binding */ ReinhardToneMapping;
                    },
                    /* harmony export */
                    "RepeatWrapping": function() {
                        return /* binding */ RepeatWrapping;
                    },
                    /* harmony export */
                    "ReplaceStencilOp": function() {
                        return /* binding */ ReplaceStencilOp;
                    },
                    /* harmony export */
                    "ReverseSubtractEquation": function() {
                        return /* binding */ ReverseSubtractEquation;
                    },
                    /* harmony export */
                    "RingBufferGeometry": function() {
                        return /* binding */ RingGeometry;
                    },
                    /* harmony export */
                    "RingGeometry": function() {
                        return /* binding */ RingGeometry;
                    },
                    /* harmony export */
                    "SRGBColorSpace": function() {
                        return /* binding */ SRGBColorSpace;
                    },
                    /* harmony export */
                    "Scene": function() {
                        return /* binding */ Scene;
                    },
                    /* harmony export */
                    "SceneUtils": function() {
                        return /* binding */ SceneUtils;
                    },
                    /* harmony export */
                    "ShaderChunk": function() {
                        return /* binding */ ShaderChunk;
                    },
                    /* harmony export */
                    "ShaderLib": function() {
                        return /* binding */ ShaderLib;
                    },
                    /* harmony export */
                    "ShaderMaterial": function() {
                        return /* binding */ ShaderMaterial;
                    },
                    /* harmony export */
                    "ShadowMaterial": function() {
                        return /* binding */ ShadowMaterial;
                    },
                    /* harmony export */
                    "Shape": function() {
                        return /* binding */ Shape;
                    },
                    /* harmony export */
                    "ShapeBufferGeometry": function() {
                        return /* binding */ ShapeGeometry;
                    },
                    /* harmony export */
                    "ShapeGeometry": function() {
                        return /* binding */ ShapeGeometry;
                    },
                    /* harmony export */
                    "ShapePath": function() {
                        return /* binding */ ShapePath;
                    },
                    /* harmony export */
                    "ShapeUtils": function() {
                        return /* binding */ ShapeUtils;
                    },
                    /* harmony export */
                    "ShortType": function() {
                        return /* binding */ ShortType;
                    },
                    /* harmony export */
                    "Skeleton": function() {
                        return /* binding */ Skeleton;
                    },
                    /* harmony export */
                    "SkeletonHelper": function() {
                        return /* binding */ SkeletonHelper;
                    },
                    /* harmony export */
                    "SkinnedMesh": function() {
                        return /* binding */ SkinnedMesh;
                    },
                    /* harmony export */
                    "SmoothShading": function() {
                        return /* binding */ SmoothShading;
                    },
                    /* harmony export */
                    "Source": function() {
                        return /* binding */ Source;
                    },
                    /* harmony export */
                    "Sphere": function() {
                        return /* binding */ Sphere;
                    },
                    /* harmony export */
                    "SphereBufferGeometry": function() {
                        return /* binding */ SphereGeometry;
                    },
                    /* harmony export */
                    "SphereGeometry": function() {
                        return /* binding */ SphereGeometry;
                    },
                    /* harmony export */
                    "Spherical": function() {
                        return /* binding */ Spherical;
                    },
                    /* harmony export */
                    "SphericalHarmonics3": function() {
                        return /* binding */ SphericalHarmonics3;
                    },
                    /* harmony export */
                    "SplineCurve": function() {
                        return /* binding */ SplineCurve;
                    },
                    /* harmony export */
                    "SpotLight": function() {
                        return /* binding */ SpotLight;
                    },
                    /* harmony export */
                    "SpotLightHelper": function() {
                        return /* binding */ SpotLightHelper;
                    },
                    /* harmony export */
                    "Sprite": function() {
                        return /* binding */ Sprite;
                    },
                    /* harmony export */
                    "SpriteMaterial": function() {
                        return /* binding */ SpriteMaterial;
                    },
                    /* harmony export */
                    "SrcAlphaFactor": function() {
                        return /* binding */ SrcAlphaFactor;
                    },
                    /* harmony export */
                    "SrcAlphaSaturateFactor": function() {
                        return /* binding */ SrcAlphaSaturateFactor;
                    },
                    /* harmony export */
                    "SrcColorFactor": function() {
                        return /* binding */ SrcColorFactor;
                    },
                    /* harmony export */
                    "StaticCopyUsage": function() {
                        return /* binding */ StaticCopyUsage;
                    },
                    /* harmony export */
                    "StaticDrawUsage": function() {
                        return /* binding */ StaticDrawUsage;
                    },
                    /* harmony export */
                    "StaticReadUsage": function() {
                        return /* binding */ StaticReadUsage;
                    },
                    /* harmony export */
                    "StereoCamera": function() {
                        return /* binding */ StereoCamera;
                    },
                    /* harmony export */
                    "StreamCopyUsage": function() {
                        return /* binding */ StreamCopyUsage;
                    },
                    /* harmony export */
                    "StreamDrawUsage": function() {
                        return /* binding */ StreamDrawUsage;
                    },
                    /* harmony export */
                    "StreamReadUsage": function() {
                        return /* binding */ StreamReadUsage;
                    },
                    /* harmony export */
                    "StringKeyframeTrack": function() {
                        return /* binding */ StringKeyframeTrack;
                    },
                    /* harmony export */
                    "SubtractEquation": function() {
                        return /* binding */ SubtractEquation;
                    },
                    /* harmony export */
                    "SubtractiveBlending": function() {
                        return /* binding */ SubtractiveBlending;
                    },
                    /* harmony export */
                    "TOUCH": function() {
                        return /* binding */ TOUCH;
                    },
                    /* harmony export */
                    "TangentSpaceNormalMap": function() {
                        return /* binding */ TangentSpaceNormalMap;
                    },
                    /* harmony export */
                    "TetrahedronBufferGeometry": function() {
                        return /* binding */ TetrahedronGeometry;
                    },
                    /* harmony export */
                    "TetrahedronGeometry": function() {
                        return /* binding */ TetrahedronGeometry;
                    },
                    /* harmony export */
                    "TextGeometry": function() {
                        return /* binding */ TextGeometry;
                    },
                    /* harmony export */
                    "Texture": function() {
                        return /* binding */ Texture;
                    },
                    /* harmony export */
                    "TextureLoader": function() {
                        return /* binding */ TextureLoader;
                    },
                    /* harmony export */
                    "TorusBufferGeometry": function() {
                        return /* binding */ TorusGeometry;
                    },
                    /* harmony export */
                    "TorusGeometry": function() {
                        return /* binding */ TorusGeometry;
                    },
                    /* harmony export */
                    "TorusKnotBufferGeometry": function() {
                        return /* binding */ TorusKnotGeometry;
                    },
                    /* harmony export */
                    "TorusKnotGeometry": function() {
                        return /* binding */ TorusKnotGeometry;
                    },
                    /* harmony export */
                    "Triangle": function() {
                        return /* binding */ Triangle;
                    },
                    /* harmony export */
                    "TriangleFanDrawMode": function() {
                        return /* binding */ TriangleFanDrawMode;
                    },
                    /* harmony export */
                    "TriangleStripDrawMode": function() {
                        return /* binding */ TriangleStripDrawMode;
                    },
                    /* harmony export */
                    "TrianglesDrawMode": function() {
                        return /* binding */ TrianglesDrawMode;
                    },
                    /* harmony export */
                    "TubeBufferGeometry": function() {
                        return /* binding */ TubeGeometry;
                    },
                    /* harmony export */
                    "TubeGeometry": function() {
                        return /* binding */ TubeGeometry;
                    },
                    /* harmony export */
                    "UVMapping": function() {
                        return /* binding */ UVMapping;
                    },
                    /* harmony export */
                    "Uint16Attribute": function() {
                        return /* binding */ Uint16Attribute;
                    },
                    /* harmony export */
                    "Uint16BufferAttribute": function() {
                        return /* binding */ Uint16BufferAttribute;
                    },
                    /* harmony export */
                    "Uint32Attribute": function() {
                        return /* binding */ Uint32Attribute;
                    },
                    /* harmony export */
                    "Uint32BufferAttribute": function() {
                        return /* binding */ Uint32BufferAttribute;
                    },
                    /* harmony export */
                    "Uint8Attribute": function() {
                        return /* binding */ Uint8Attribute;
                    },
                    /* harmony export */
                    "Uint8BufferAttribute": function() {
                        return /* binding */ Uint8BufferAttribute;
                    },
                    /* harmony export */
                    "Uint8ClampedAttribute": function() {
                        return /* binding */ Uint8ClampedAttribute;
                    },
                    /* harmony export */
                    "Uint8ClampedBufferAttribute": function() {
                        return /* binding */ Uint8ClampedBufferAttribute;
                    },
                    /* harmony export */
                    "Uniform": function() {
                        return /* binding */ Uniform;
                    },
                    /* harmony export */
                    "UniformsLib": function() {
                        return /* binding */ UniformsLib;
                    },
                    /* harmony export */
                    "UniformsUtils": function() {
                        return /* binding */ UniformsUtils;
                    },
                    /* harmony export */
                    "UnsignedByteType": function() {
                        return /* binding */ UnsignedByteType;
                    },
                    /* harmony export */
                    "UnsignedInt248Type": function() {
                        return /* binding */ UnsignedInt248Type;
                    },
                    /* harmony export */
                    "UnsignedIntType": function() {
                        return /* binding */ UnsignedIntType;
                    },
                    /* harmony export */
                    "UnsignedShort4444Type": function() {
                        return /* binding */ UnsignedShort4444Type;
                    },
                    /* harmony export */
                    "UnsignedShort5551Type": function() {
                        return /* binding */ UnsignedShort5551Type;
                    },
                    /* harmony export */
                    "UnsignedShortType": function() {
                        return /* binding */ UnsignedShortType;
                    },
                    /* harmony export */
                    "VSMShadowMap": function() {
                        return /* binding */ VSMShadowMap;
                    },
                    /* harmony export */
                    "Vector2": function() {
                        return /* binding */ Vector2;
                    },
                    /* harmony export */
                    "Vector3": function() {
                        return /* binding */ Vector3;
                    },
                    /* harmony export */
                    "Vector4": function() {
                        return /* binding */ Vector4;
                    },
                    /* harmony export */
                    "VectorKeyframeTrack": function() {
                        return /* binding */ VectorKeyframeTrack;
                    },
                    /* harmony export */
                    "Vertex": function() {
                        return /* binding */ Vertex;
                    },
                    /* harmony export */
                    "VertexColors": function() {
                        return /* binding */ VertexColors;
                    },
                    /* harmony export */
                    "VideoTexture": function() {
                        return /* binding */ VideoTexture;
                    },
                    /* harmony export */
                    "WebGL1Renderer": function() {
                        return /* binding */ WebGL1Renderer;
                    },
                    /* harmony export */
                    "WebGL3DRenderTarget": function() {
                        return /* binding */ WebGL3DRenderTarget;
                    },
                    /* harmony export */
                    "WebGLArrayRenderTarget": function() {
                        return /* binding */ WebGLArrayRenderTarget;
                    },
                    /* harmony export */
                    "WebGLCubeRenderTarget": function() {
                        return /* binding */ WebGLCubeRenderTarget;
                    },
                    /* harmony export */
                    "WebGLMultipleRenderTargets": function() {
                        return /* binding */ WebGLMultipleRenderTargets;
                    },
                    /* harmony export */
                    "WebGLMultisampleRenderTarget": function() {
                        return /* binding */ WebGLMultisampleRenderTarget;
                    },
                    /* harmony export */
                    "WebGLRenderTarget": function() {
                        return /* binding */ WebGLRenderTarget;
                    },
                    /* harmony export */
                    "WebGLRenderTargetCube": function() {
                        return /* binding */ WebGLRenderTargetCube;
                    },
                    /* harmony export */
                    "WebGLRenderer": function() {
                        return /* binding */ WebGLRenderer;
                    },
                    /* harmony export */
                    "WebGLUtils": function() {
                        return /* binding */ WebGLUtils;
                    },
                    /* harmony export */
                    "WireframeGeometry": function() {
                        return /* binding */ WireframeGeometry;
                    },
                    /* harmony export */
                    "WireframeHelper": function() {
                        return /* binding */ WireframeHelper;
                    },
                    /* harmony export */
                    "WrapAroundEnding": function() {
                        return /* binding */ WrapAroundEnding;
                    },
                    /* harmony export */
                    "XHRLoader": function() {
                        return /* binding */ XHRLoader;
                    },
                    /* harmony export */
                    "ZeroCurvatureEnding": function() {
                        return /* binding */ ZeroCurvatureEnding;
                    },
                    /* harmony export */
                    "ZeroFactor": function() {
                        return /* binding */ ZeroFactor;
                    },
                    /* harmony export */
                    "ZeroSlopeEnding": function() {
                        return /* binding */ ZeroSlopeEnding;
                    },
                    /* harmony export */
                    "ZeroStencilOp": function() {
                        return /* binding */ ZeroStencilOp;
                    },
                    /* harmony export */
                    "_SRGBAFormat": function() {
                        return /* binding */ _SRGBAFormat;
                    },
                    /* harmony export */
                    "sRGBEncoding": function() {
                        return /* binding */ sRGBEncoding;
                    }
                    /* harmony export */
                });
                var __extends = (undefined && undefined.__extends) || (function() {
                    var extendStatics = function(d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({
                                    __proto__: []
                                }
                                instanceof Array && function(d, b) {
                                    d.__proto__ = b;
                                }) ||
                            function(d, b) {
                                for (var p in b)
                                    if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
                            };
                        return extendStatics(d, b);
                    };
                    return function(d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);

                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();
                var __awaiter = (undefined && undefined.__awaiter) || function(thisArg, _arguments, P, generator) {
                    function adopt(value) {
                        return value instanceof P ? value : new P(function(resolve) {
                            resolve(value);
                        });
                    }
                    return new(P || (P = Promise))(function(resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }

                        function rejected(value) {
                            try {
                                step(generator["throw"](value));
                            } catch (e) {
                                reject(e);
                            }
                        }

                        function step(result) {
                            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                        }
                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                };
                var __generator = (undefined && undefined.__generator) || function(thisArg, body) {
                    var _ = {
                            label: 0,
                            sent: function() {
                                if (t[0] & 1) throw t[1];
                                return t[1];
                            },
                            trys: [],
                            ops: []
                        },
                        f, y, t, g;
                    return g = {
                        next: verb(0),
                        "throw": verb(1),
                        "return": verb(2)
                    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
                        return this;
                    }), g;

                    function verb(n) {
                        return function(v) {
                            return step([n, v]);
                        };
                    }

                    function step(op) {
                        if (f) throw new TypeError("Generator is already executing.");
                        while (_) try {
                            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                            if (y = 0, t) op = [op[0] & 2, t.value];
                            switch (op[0]) {
                                case 0:
                                case 1:
                                    t = op;
                                    break;
                                case 4:
                                    _.label++;
                                    return {
                                        value: op[1],
                                        done: false
                                    };
                                case 5:
                                    _.label++;
                                    y = op[1];
                                    op = [0];
                                    continue;
                                case 7:
                                    op = _.ops.pop();
                                    _.trys.pop();
                                    continue;
                                default:
                                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                        _ = 0;
                                        continue;
                                    }
                                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                        _.label = op[1];
                                        break;
                                    }
                                    if (op[0] === 6 && _.label < t[1]) {
                                        _.label = t[1];
                                        t = op;
                                        break;
                                    }
                                    if (t && _.label < t[2]) {
                                        _.label = t[2];
                                        _.ops.push(op);
                                        break;
                                    }
                                    if (t[2]) _.ops.pop();
                                    _.trys.pop();
                                    continue;
                            }
                            op = body.call(thisArg, _);
                        } catch (e) {
                            op = [6, e];
                            y = 0;
                        } finally {
                            f = t = 0;
                        }
                        if (op[0] & 5) throw op[1];
                        return {
                            value: op[0] ? op[1] : void 0,
                            done: true
                        };
                    }
                };
                var __read = (undefined && undefined.__read) || function(o, n) {
                    var m = typeof Symbol === "function" && o[Symbol.iterator];
                    if (!m) return o;
                    var i = m.call(o),
                        r, ar = [],
                        e;
                    try {
                        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
                    } catch (error) {
                        e = {
                            error: error
                        };
                    } finally {
                        try {
                            if (r && !r.done && (m = i["return"])) m.call(i);
                        } finally {
                            if (e) throw e.error;
                        }
                    }
                    return ar;
                };
                var __values = (undefined && undefined.__values) || function(o) {
                    var s = typeof Symbol === "function" && Symbol.iterator,
                        m = s && o[s],
                        i = 0;
                    if (m) return m.call(o);
                    if (o && typeof o.length === "number") return {
                        next: function() {
                            if (o && i >= o.length) o = void 0;
                            return {
                                value: o && o[i++],
                                done: !o
                            };
                        }
                    };
                    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
                };
                var _a, _b, _c;
                /**
                 * @license
                 * Copyright 2010-2022 Three.js Authors
                 * SPDX-License-Identifier: MIT
                 */
                var REVISION = '139';
                var MOUSE = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2
                };
                var TOUCH = {
                    ROTATE: 0,
                    PAN: 1,
                    DOLLY_PAN: 2,
                    DOLLY_ROTATE: 3
                };
                var CullFaceNone = 0;
                var CullFaceBack = 1;
                var CullFaceFront = 2;
                var CullFaceFrontBack = 3;
                var BasicShadowMap = 0;
                var PCFShadowMap = 1;
                var PCFSoftShadowMap = 2;
                var VSMShadowMap = 3;
                var FrontSide = 0;
                var BackSide = 1;
                var DoubleSide = 2;
                var FlatShading = 1;
                var SmoothShading = 2;
                var NoBlending = 0;
                var NormalBlending = 1;
                var AdditiveBlending = 2;
                var SubtractiveBlending = 3;
                var MultiplyBlending = 4;
                var CustomBlending = 5;
                var AddEquation = 100;
                var SubtractEquation = 101;
                var ReverseSubtractEquation = 102;
                var MinEquation = 103;
                var MaxEquation = 104;
                var ZeroFactor = 200;
                var OneFactor = 201;
                var SrcColorFactor = 202;
                var OneMinusSrcColorFactor = 203;
                var SrcAlphaFactor = 204;
                var OneMinusSrcAlphaFactor = 205;
                var DstAlphaFactor = 206;
                var OneMinusDstAlphaFactor = 207;
                var DstColorFactor = 208;
                var OneMinusDstColorFactor = 209;
                var SrcAlphaSaturateFactor = 210;
                var NeverDepth = 0;
                var AlwaysDepth = 1;
                var LessDepth = 2;
                var LessEqualDepth = 3;
                var EqualDepth = 4;
                var GreaterEqualDepth = 5;
                var GreaterDepth = 6;
                var NotEqualDepth = 7;
                var MultiplyOperation = 0;
                var MixOperation = 1;
                var AddOperation = 2;
                var NoToneMapping = 0;
                var LinearToneMapping = 1;
                var ReinhardToneMapping = 2;
                var CineonToneMapping = 3;
                var ACESFilmicToneMapping = 4;
                var CustomToneMapping = 5;
                var UVMapping = 300;
                var CubeReflectionMapping = 301;
                var CubeRefractionMapping = 302;
                var EquirectangularReflectionMapping = 303;
                var EquirectangularRefractionMapping = 304;
                var CubeUVReflectionMapping = 306;
                var RepeatWrapping = 1000;
                var ClampToEdgeWrapping = 1001;
                var MirroredRepeatWrapping = 1002;
                var NearestFilter = 1003;
                var NearestMipmapNearestFilter = 1004;
                var NearestMipMapNearestFilter = 1004;
                var NearestMipmapLinearFilter = 1005;
                var NearestMipMapLinearFilter = 1005;
                var LinearFilter = 1006;
                var LinearMipmapNearestFilter = 1007;
                var LinearMipMapNearestFilter = 1007;
                var LinearMipmapLinearFilter = 1008;
                var LinearMipMapLinearFilter = 1008;
                var UnsignedByteType = 1009;
                var ByteType = 1010;
                var ShortType = 1011;
                var UnsignedShortType = 1012;
                var IntType = 1013;
                var UnsignedIntType = 1014;
                var FloatType = 1015;
                var HalfFloatType = 1016;
                var UnsignedShort4444Type = 1017;
                var UnsignedShort5551Type = 1018;
                var UnsignedInt248Type = 1020;
                var AlphaFormat = 1021;
                var RGBFormat = 1022;
                var RGBAFormat = 1023;
                var LuminanceFormat = 1024;
                var LuminanceAlphaFormat = 1025;
                var DepthFormat = 1026;
                var DepthStencilFormat = 1027;
                var RedFormat = 1028;
                var RedIntegerFormat = 1029;
                var RGFormat = 1030;
                var RGIntegerFormat = 1031;
                var RGBAIntegerFormat = 1033;
                var RGB_S3TC_DXT1_Format = 33776;
                var RGBA_S3TC_DXT1_Format = 33777;
                var RGBA_S3TC_DXT3_Format = 33778;
                var RGBA_S3TC_DXT5_Format = 33779;
                var RGB_PVRTC_4BPPV1_Format = 35840;
                var RGB_PVRTC_2BPPV1_Format = 35841;
                var RGBA_PVRTC_4BPPV1_Format = 35842;
                var RGBA_PVRTC_2BPPV1_Format = 35843;
                var RGB_ETC1_Format = 36196;
                var RGB_ETC2_Format = 37492;
                var RGBA_ETC2_EAC_Format = 37496;
                var RGBA_ASTC_4x4_Format = 37808;
                var RGBA_ASTC_5x4_Format = 37809;
                var RGBA_ASTC_5x5_Format = 37810;
                var RGBA_ASTC_6x5_Format = 37811;
                var RGBA_ASTC_6x6_Format = 37812;
                var RGBA_ASTC_8x5_Format = 37813;
                var RGBA_ASTC_8x6_Format = 37814;
                var RGBA_ASTC_8x8_Format = 37815;
                var RGBA_ASTC_10x5_Format = 37816;
                var RGBA_ASTC_10x6_Format = 37817;
                var RGBA_ASTC_10x8_Format = 37818;
                var RGBA_ASTC_10x10_Format = 37819;
                var RGBA_ASTC_12x10_Format = 37820;
                var RGBA_ASTC_12x12_Format = 37821;
                var RGBA_BPTC_Format = 36492;
                var LoopOnce = 2200;
                var LoopRepeat = 2201;
                var LoopPingPong = 2202;
                var InterpolateDiscrete = 2300;
                var InterpolateLinear = 2301;
                var InterpolateSmooth = 2302;
                var ZeroCurvatureEnding = 2400;
                var ZeroSlopeEnding = 2401;
                var WrapAroundEnding = 2402;
                var NormalAnimationBlendMode = 2500;
                var AdditiveAnimationBlendMode = 2501;
                var TrianglesDrawMode = 0;
                var TriangleStripDrawMode = 1;
                var TriangleFanDrawMode = 2;
                var LinearEncoding = 3000;
                var sRGBEncoding = 3001;
                var BasicDepthPacking = 3200;
                var RGBADepthPacking = 3201;
                var TangentSpaceNormalMap = 0;
                var ObjectSpaceNormalMap = 1;
                // Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
                var NoColorSpace = '';
                var SRGBColorSpace = 'srgb';
                var LinearSRGBColorSpace = 'srgb-linear';
                var ZeroStencilOp = 0;
                var KeepStencilOp = 7680;
                var ReplaceStencilOp = 7681;
                var IncrementStencilOp = 7682;
                var DecrementStencilOp = 7683;
                var IncrementWrapStencilOp = 34055;
                var DecrementWrapStencilOp = 34056;
                var InvertStencilOp = 5386;
                var NeverStencilFunc = 512;
                var LessStencilFunc = 513;
                var EqualStencilFunc = 514;
                var LessEqualStencilFunc = 515;
                var GreaterStencilFunc = 516;
                var NotEqualStencilFunc = 517;
                var GreaterEqualStencilFunc = 518;
                var AlwaysStencilFunc = 519;
                var StaticDrawUsage = 35044;
                var DynamicDrawUsage = 35048;
                var StreamDrawUsage = 35040;
                var StaticReadUsage = 35045;
                var DynamicReadUsage = 35049;
                var StreamReadUsage = 35041;
                var StaticCopyUsage = 35046;
                var DynamicCopyUsage = 35050;
                var StreamCopyUsage = 35042;
                var GLSL1 = '100';
                var GLSL3 = '300 es';
                var _SRGBAFormat = 1035; // fallback for WebGL 1
                /**
                 * https://github.com/mrdoob/eventdispatcher.js/
                 */
                var EventDispatcher = /** @class */ (function() {
                    function EventDispatcher() {}
                    EventDispatcher.prototype.addEventListener = function(type, listener) {
                        if (this._listeners === undefined)
                            this._listeners = {};
                        var listeners = this._listeners;
                        if (listeners[type] === undefined) {
                            listeners[type] = [];
                        }
                        if (listeners[type].indexOf(listener) === -1) {
                            listeners[type].push(listener);
                        }
                    };
                    EventDispatcher.prototype.hasEventListener = function(type, listener) {
                        if (this._listeners === undefined)
                            return false;
                        var listeners = this._listeners;
                        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
                    };
                    EventDispatcher.prototype.removeEventListener = function(type, listener) {
                        if (this._listeners === undefined)
                            return;
                        var listeners = this._listeners;
                        var listenerArray = listeners[type];
                        if (listenerArray !== undefined) {
                            var index = listenerArray.indexOf(listener);
                            if (index !== -1) {
                                listenerArray.splice(index, 1);
                            }
                        }
                    };
                    EventDispatcher.prototype.dispatchEvent = function(event) {
                        if (this._listeners === undefined)
                            return;
                        var listeners = this._listeners;
                        var listenerArray = listeners[event.type];
                        if (listenerArray !== undefined) {
                            event.target = this;
                            // Make a copy, in case listeners are removed while iterating.
                            var array = listenerArray.slice(0);
                            for (var i = 0, l = array.length; i < l; i++) {
                                array[i].call(this, event);
                            }
                            event.target = null;
                        }
                    };
                    return EventDispatcher;
                }());
                var _lut = [];
                for (var i = 0; i < 256; i++) {
                    _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);
                }
                var _seed = 1234567;
                var DEG2RAD = Math.PI / 180;
                var RAD2DEG = 180 / Math.PI;
                // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
                function generateUUID() {
                    var d0 = Math.random() * 0xffffffff | 0;
                    var d1 = Math.random() * 0xffffffff | 0;
                    var d2 = Math.random() * 0xffffffff | 0;
                    var d3 = Math.random() * 0xffffffff | 0;
                    var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +
                        _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +
                        _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +
                        _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];
                    // .toLowerCase() here flattens concatenated strings to save heap memory space.
                    return uuid.toLowerCase();
                }

                function clamp(value, min, max) {
                    return Math.max(min, Math.min(max, value));
                }
                // compute euclidean modulo of m % n
                // https://en.wikipedia.org/wiki/Modulo_operation
                function euclideanModulo(n, m) {
                    return ((n % m) + m) % m;
                }
                // Linear mapping from range <a1, a2> to range <b1, b2>
                function mapLinear(x, a1, a2, b1, b2) {
                    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
                }
                // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
                function inverseLerp(x, y, value) {
                    if (x !== y) {
                        return (value - x) / (y - x);
                    } else {
                        return 0;
                    }
                }
                // https://en.wikipedia.org/wiki/Linear_interpolation
                function lerp(x, y, t) {
                    return (1 - t) * x + t * y;
                }
                // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
                function damp(x, y, lambda, dt) {
                    return lerp(x, y, 1 - Math.exp(-lambda * dt));
                }
                // https://www.desmos.com/calculator/vcsjnyz7x4
                function pingpong(x, length) {
                    if (length === void 0) {
                        length = 1;
                    }
                    return length - Math.abs(euclideanModulo(x, length * 2) - length);
                }
                // http://en.wikipedia.org/wiki/Smoothstep
                function smoothstep(x, min, max) {
                    if (x <= min)
                        return 0;
                    if (x >= max)
                        return 1;
                    x = (x - min) / (max - min);
                    return x * x * (3 - 2 * x);
                }

                function smootherstep(x, min, max) {
                    if (x <= min)
                        return 0;
                    if (x >= max)
                        return 1;
                    x = (x - min) / (max - min);
                    return x * x * x * (x * (x * 6 - 15) + 10);
                }
                // Random integer from <low, high> interval
                function randInt(low, high) {
                    return low + Math.floor(Math.random() * (high - low + 1));
                }
                // Random float from <low, high> interval
                function randFloat(low, high) {
                    return low + Math.random() * (high - low);
                }
                // Random float from <-range/2, range/2> interval
                function randFloatSpread(range) {
                    return range * (0.5 - Math.random());
                }
                // Deterministic pseudo-random float in the interval [ 0, 1 ]
                function seededRandom(s) {
                    if (s !== undefined)
                        _seed = s;
                    // Mulberry32 generator
                    var t = _seed += 0x6D2B79F5;
                    t = Math.imul(t ^ t >>> 15, t | 1);
                    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                    return ((t ^ t >>> 14) >>> 0) / 4294967296;
                }

                function degToRad(degrees) {
                    return degrees * DEG2RAD;
                }

                function radToDeg(radians) {
                    return radians * RAD2DEG;
                }

                function isPowerOfTwo(value) {
                    return (value & (value - 1)) === 0 && value !== 0;
                }

                function ceilPowerOfTwo(value) {
                    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
                }

                function floorPowerOfTwo(value) {
                    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
                }

                function setQuaternionFromProperEuler(q, a, b, c, order) {
                    // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
                    // rotations are applied to the axes in the order specified by 'order'
                    // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
                    // angles are in radians
                    var cos = Math.cos;
                    var sin = Math.sin;
                    var c2 = cos(b / 2);
                    var s2 = sin(b / 2);
                    var c13 = cos((a + c) / 2);
                    var s13 = sin((a + c) / 2);
                    var c1_3 = cos((a - c) / 2);
                    var s1_3 = sin((a - c) / 2);
                    var c3_1 = cos((c - a) / 2);
                    var s3_1 = sin((c - a) / 2);
                    switch (order) {
                        case 'XYX':
                            q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
                            break;
                        case 'YZY':
                            q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
                            break;
                        case 'ZXZ':
                            q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
                            break;
                        case 'XZX':
                            q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
                            break;
                        case 'YXY':
                            q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
                            break;
                        case 'ZYZ':
                            q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
                            break;
                        default:
                            console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
                    }
                }

                function denormalize$1(value, array) {
                    switch (array.constructor) {
                        case Float32Array:
                            return value;
                        case Uint16Array:
                            return value / 65535.0;
                        case Uint8Array:
                            return value / 255.0;
                        case Int16Array:
                            return Math.max(value / 32767.0, -1.0);
                        case Int8Array:
                            return Math.max(value / 127.0, -1.0);
                        default:
                            throw new Error('Invalid component type.');
                    }
                }

                function normalize(value, array) {
                    switch (array.constructor) {
                        case Float32Array:
                            return value;
                        case Uint16Array:
                            return Math.round(value * 65535.0);
                        case Uint8Array:
                            return Math.round(value * 255.0);
                        case Int16Array:
                            return Math.round(value * 32767.0);
                        case Int8Array:
                            return Math.round(value * 127.0);
                        default:
                            throw new Error('Invalid component type.');
                    }
                }
                var MathUtils = /*#__PURE__*/ Object.freeze({
                    __proto__: null,
                    DEG2RAD: DEG2RAD,
                    RAD2DEG: RAD2DEG,
                    generateUUID: generateUUID,
                    clamp: clamp,
                    euclideanModulo: euclideanModulo,
                    mapLinear: mapLinear,
                    inverseLerp: inverseLerp,
                    lerp: lerp,
                    damp: damp,
                    pingpong: pingpong,
                    smoothstep: smoothstep,
                    smootherstep: smootherstep,
                    randInt: randInt,
                    randFloat: randFloat,
                    randFloatSpread: randFloatSpread,
                    seededRandom: seededRandom,
                    degToRad: degToRad,
                    radToDeg: radToDeg,
                    isPowerOfTwo: isPowerOfTwo,
                    ceilPowerOfTwo: ceilPowerOfTwo,
                    floorPowerOfTwo: floorPowerOfTwo,
                    setQuaternionFromProperEuler: setQuaternionFromProperEuler,
                    normalize: normalize,
                    denormalize: denormalize$1
                });
                var Vector2 = /** @class */ (function() {
                    function Vector2(x, y) {
                        if (x === void 0) {
                            x = 0;
                        }
                        if (y === void 0) {
                            y = 0;
                        }
                        this.x = x;
                        this.y = y;
                    }
                    Object.defineProperty(Vector2.prototype, "width", {
                        get: function() {
                            return this.x;
                        },
                        set: function(value) {
                            this.x = value;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(Vector2.prototype, "height", {
                        get: function() {
                            return this.y;
                        },
                        set: function(value) {
                            this.y = value;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Vector2.prototype.set = function(x, y) {
                        this.x = x;
                        this.y = y;
                        return this;
                    };
                    Vector2.prototype.setScalar = function(scalar) {
                        this.x = scalar;
                        this.y = scalar;
                        return this;
                    };
                    Vector2.prototype.setX = function(x) {
                        this.x = x;
                        return this;
                    };
                    Vector2.prototype.setY = function(y) {
                        this.y = y;
                        return this;
                    };
                    Vector2.prototype.setComponent = function(index, value) {
                        switch (index) {
                            case 0:
                                this.x = value;
                                break;
                            case 1:
                                this.y = value;
                                break;
                            default:
                                throw new Error('index is out of range: ' + index);
                        }
                        return this;
                    };
                    Vector2.prototype.getComponent = function(index) {
                        switch (index) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            default:
                                throw new Error('index is out of range: ' + index);
                        }
                    };
                    Vector2.prototype.clone = function() {
                        return new this.constructor(this.x, this.y);
                    };
                    Vector2.prototype.copy = function(v) {
                        this.x = v.x;
                        this.y = v.y;
                        return this;
                    };
                    Vector2.prototype.add = function(v, w) {
                        if (w !== undefined) {
                            console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                            return this.addVectors(v, w);
                        }
                        this.x += v.x;
                        this.y += v.y;
                        return this;
                    };
                    Vector2.prototype.addScalar = function(s) {
                        this.x += s;
                        this.y += s;
                        return this;
                    };
                    Vector2.prototype.addVectors = function(a, b) {
                        this.x = a.x + b.x;
                        this.y = a.y + b.y;
                        return this;
                    };
                    Vector2.prototype.addScaledVector = function(v, s) {
                        this.x += v.x * s;
                        this.y += v.y * s;
                        return this;
                    };
                    Vector2.prototype.sub = function(v, w) {
                        if (w !== undefined) {
                            console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                            return this.subVectors(v, w);
                        }
                        this.x -= v.x;
                        this.y -= v.y;
                        return this;
                    };
                    Vector2.prototype.subScalar = function(s) {
                        this.x -= s;
                        this.y -= s;
                        return this;
                    };
                    Vector2.prototype.subVectors = function(a, b) {
                        this.x = a.x - b.x;
                        this.y = a.y - b.y;
                        return this;
                    };
                    Vector2.prototype.multiply = function(v) {
                        this.x *= v.x;
                        this.y *= v.y;
                        return this;
                    };
                    Vector2.prototype.multiplyScalar = function(scalar) {
                        this.x *= scalar;
                        this.y *= scalar;
                        return this;
                    };
                    Vector2.prototype.divide = function(v) {
                        this.x /= v.x;
                        this.y /= v.y;
                        return this;
                    };
                    Vector2.prototype.divideScalar = function(scalar) {
                        return this.multiplyScalar(1 / scalar);
                    };
                    Vector2.prototype.applyMatrix3 = function(m) {
                        var x = this.x,
                            y = this.y;
                        var e = m.elements;
                        this.x = e[0] * x + e[3] * y + e[6];
                        this.y = e[1] * x + e[4] * y + e[7];
                        return this;
                    };
                    Vector2.prototype.min = function(v) {
                        this.x = Math.min(this.x, v.x);
                        this.y = Math.min(this.y, v.y);
                        return this;
                    };
                    Vector2.prototype.max = function(v) {
                        this.x = Math.max(this.x, v.x);
                        this.y = Math.max(this.y, v.y);
                        return this;
                    };
                    Vector2.prototype.clamp = function(min, max) {
                        // assumes min < max, componentwise
                        this.x = Math.max(min.x, Math.min(max.x, this.x));
                        this.y = Math.max(min.y, Math.min(max.y, this.y));
                        return this;
                    };
                    Vector2.prototype.clampScalar = function(minVal, maxVal) {
                        this.x = Math.max(minVal, Math.min(maxVal, this.x));
                        this.y = Math.max(minVal, Math.min(maxVal, this.y));
                        return this;
                    };
                    Vector2.prototype.clampLength = function(min, max) {
                        var length = this.length();
                        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
                    };
                    Vector2.prototype.floor = function() {
                        this.x = Math.floor(this.x);
                        this.y = Math.floor(this.y);
                        return this;
                    };
                    Vector2.prototype.ceil = function() {
                        this.x = Math.ceil(this.x);
                        this.y = Math.ceil(this.y);
                        return this;
                    };
                    Vector2.prototype.round = function() {
                        this.x = Math.round(this.x);
                        this.y = Math.round(this.y);
                        return this;
                    };
                    Vector2.prototype.roundToZero = function() {
                        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
                        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
                        return this;
                    };
                    Vector2.prototype.negate = function() {
                        this.x = -this.x;
                        this.y = -this.y;
                        return this;
                    };
                    Vector2.prototype.dot = function(v) {
                        return this.x * v.x + this.y * v.y;
                    };
                    Vector2.prototype.cross = function(v) {
                        return this.x * v.y - this.y * v.x;
                    };
                    Vector2.prototype.lengthSq = function() {
                        return this.x * this.x + this.y * this.y;
                    };
                    Vector2.prototype.length = function() {
                        return Math.sqrt(this.x * this.x + this.y * this.y);
                    };
                    Vector2.prototype.manhattanLength = function() {
                        return Math.abs(this.x) + Math.abs(this.y);
                    };
                    Vector2.prototype.normalize = function() {
                        return this.divideScalar(this.length() || 1);
                    };
                    Vector2.prototype.angle = function() {
                        // computes the angle in radians with respect to the positive x-axis
                        var angle = Math.atan2(-this.y, -this.x) + Math.PI;
                        return angle;
                    };
                    Vector2.prototype.distanceTo = function(v) {
                        return Math.sqrt(this.distanceToSquared(v));
                    };
                    Vector2.prototype.distanceToSquared = function(v) {
                        var dx = this.x - v.x,
                            dy = this.y - v.y;
                        return dx * dx + dy * dy;
                    };
                    Vector2.prototype.manhattanDistanceTo = function(v) {
                        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
                    };
                    Vector2.prototype.setLength = function(length) {
                        return this.normalize().multiplyScalar(length);
                    };
                    Vector2.prototype.lerp = function(v, alpha) {
                        this.x += (v.x - this.x) * alpha;
                        this.y += (v.y - this.y) * alpha;
                        return this;
                    };
                    Vector2.prototype.lerpVectors = function(v1, v2, alpha) {
                        this.x = v1.x + (v2.x - v1.x) * alpha;
                        this.y = v1.y + (v2.y - v1.y) * alpha;
                        return this;
                    };
                    Vector2.prototype.equals = function(v) {
                        return ((v.x === this.x) && (v.y === this.y));
                    };
                    Vector2.prototype.fromArray = function(array, offset) {
                        if (offset === void 0) {
                            offset = 0;
                        }
                        this.x = array[offset];
                        this.y = array[offset + 1];
                        return this;
                    };
                    Vector2.prototype.toArray = function(array, offset) {
                        if (array === void 0) {
                            array = [];
                        }
                        if (offset === void 0) {
                            offset = 0;
                        }
                        array[offset] = this.x;
                        array[offset + 1] = this.y;
                        return array;
                    };
                    Vector2.prototype.fromBufferAttribute = function(attribute, index, offset) {
                        if (offset !== undefined) {
                            console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
                        }
                        this.x = attribute.getX(index);
                        this.y = attribute.getY(index);
                        return this;
                    };
                    Vector2.prototype.rotateAround = function(center, angle) {
                        var c = Math.cos(angle),
                            s = Math.sin(angle);
                        var x = this.x - center.x;
                        var y = this.y - center.y;
                        this.x = x * c - y * s + center.x;
                        this.y = x * s + y * c + center.y;
                        return this;
                    };
                    Vector2.prototype.random = function() {
                        this.x = Math.random();
                        this.y = Math.random();
                        return this;
                    };
                    Vector2.prototype[Symbol.iterator] = function() {
                        return __generator(this, function(_a) {
                            switch (_a.label) {
                                case 0:
                                    return [4 /*yield*/ , this.x];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/ , this.y];
                                case 2:
                                    _a.sent();
                                    return [2 /*return*/ ];
                            }
                        });
                    };
                    return Vector2;
                }());
                Vector2.prototype.isVector2 = true;
                var Matrix3 = /** @class */ (function() {
                    function Matrix3() {
                        this.elements = [
                            1, 0, 0,
                            0, 1, 0,
                            0, 0, 1
                        ];
                        if (arguments.length > 0) {
                            console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
                        }
                    }
                    Matrix3.prototype.set = function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
                        var te = this.elements;
                        te[0] = n11;
                        te[1] = n21;
                        te[2] = n31;
                        te[3] = n12;
                        te[4] = n22;
                        te[5] = n32;
                        te[6] = n13;
                        te[7] = n23;
                        te[8] = n33;
                        return this;
                    };
                    Matrix3.prototype.identity = function() {
                        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
                        return this;
                    };
                    Matrix3.prototype.copy = function(m) {
                        var te = this.elements;
                        var me = m.elements;
                        te[0] = me[0];
                        te[1] = me[1];
                        te[2] = me[2];
                        te[3] = me[3];
                        te[4] = me[4];
                        te[5] = me[5];
                        te[6] = me[6];
                        te[7] = me[7];
                        te[8] = me[8];
                        return this;
                    };
                    Matrix3.prototype.extractBasis = function(xAxis, yAxis, zAxis) {
                        xAxis.setFromMatrix3Column(this, 0);
                        yAxis.setFromMatrix3Column(this, 1);
                        zAxis.setFromMatrix3Column(this, 2);
                        return this;
                    };
                    Matrix3.prototype.setFromMatrix4 = function(m) {
                        var me = m.elements;
                        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
                        return this;
                    };
                    Matrix3.prototype.multiply = function(m) {
                        return this.multiplyMatrices(this, m);
                    };
                    Matrix3.prototype.premultiply = function(m) {
                        return this.multiplyMatrices(m, this);
                    };
                    Matrix3.prototype.multiplyMatrices = function(a, b) {
                        var ae = a.elements;
                        var be = b.elements;
                        var te = this.elements;
                        var a11 = ae[0],
                            a12 = ae[3],
                            a13 = ae[6];
                        var a21 = ae[1],
                            a22 = ae[4],
                            a23 = ae[7];
                        var a31 = ae[2],
                            a32 = ae[5],
                            a33 = ae[8];
                        var b11 = be[0],
                            b12 = be[3],
                            b13 = be[6];
                        var b21 = be[1],
                            b22 = be[4],
                            b23 = be[7];
                        var b31 = be[2],
                            b32 = be[5],
                            b33 = be[8];
                        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
                        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
                        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
                        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
                        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
                        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
                        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
                        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
                        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
                        return this;
                    };
                    Matrix3.prototype.multiplyScalar = function(s) {
                        var te = this.elements;
                        te[0] *= s;
                        te[3] *= s;
                        te[6] *= s;
                        te[1] *= s;
                        te[4] *= s;
                        te[7] *= s;
                        te[2] *= s;
                        te[5] *= s;
                        te[8] *= s;
                        return this;
                    };
                    Matrix3.prototype.determinant = function() {
                        var te = this.elements;
                        var a = te[0],
                            b = te[1],
                            c = te[2],
                            d = te[3],
                            e = te[4],
                            f = te[5],
                            g = te[6],
                            h = te[7],
                            i = te[8];
                        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
                    };
                    Matrix3.prototype.invert = function() {
                        var te = this.elements,
                            n11 = te[0],
                            n21 = te[1],
                            n31 = te[2],
                            n12 = te[3],
                            n22 = te[4],
                            n32 = te[5],
                            n13 = te[6],
                            n23 = te[7],
                            n33 = te[8],
                            t11 = n33 * n22 - n32 * n23,
                            t12 = n32 * n13 - n33 * n12,
                            t13 = n23 * n12 - n22 * n13,
                            det = n11 * t11 + n21 * t12 + n31 * t13;
                        if (det === 0)
                            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        var detInv = 1 / det;
                        te[0] = t11 * detInv;
                        te[1] = (n31 * n23 - n33 * n21) * detInv;
                        te[2] = (n32 * n21 - n31 * n22) * detInv;
                        te[3] = t12 * detInv;
                        te[4] = (n33 * n11 - n31 * n13) * detInv;
                        te[5] = (n31 * n12 - n32 * n11) * detInv;
                        te[6] = t13 * detInv;
                        te[7] = (n21 * n13 - n23 * n11) * detInv;
                        te[8] = (n22 * n11 - n21 * n12) * detInv;
                        return this;
                    };
                    Matrix3.prototype.transpose = function() {
                        var tmp;
                        var m = this.elements;
                        tmp = m[1];
                        m[1] = m[3];
                        m[3] = tmp;
                        tmp = m[2];
                        m[2] = m[6];
                        m[6] = tmp;
                        tmp = m[5];
                        m[5] = m[7];
                        m[7] = tmp;
                        return this;
                    };
                    Matrix3.prototype.getNormalMatrix = function(matrix4) {
                        return this.setFromMatrix4(matrix4).invert().transpose();
                    };
                    Matrix3.prototype.transposeIntoArray = function(r) {
                        var m = this.elements;
                        r[0] = m[0];
                        r[1] = m[3];
                        r[2] = m[6];
                        r[3] = m[1];
                        r[4] = m[4];
                        r[5] = m[7];
                        r[6] = m[2];
                        r[7] = m[5];
                        r[8] = m[8];
                        return this;
                    };
                    Matrix3.prototype.setUvTransform = function(tx, ty, sx, sy, rotation, cx, cy) {
                        var c = Math.cos(rotation);
                        var s = Math.sin(rotation);
                        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
                        return this;
                    };
                    Matrix3.prototype.scale = function(sx, sy) {
                        var te = this.elements;
                        te[0] *= sx;
                        te[3] *= sx;
                        te[6] *= sx;
                        te[1] *= sy;
                        te[4] *= sy;
                        te[7] *= sy;
                        return this;
                    };
                    Matrix3.prototype.rotate = function(theta) {
                        var c = Math.cos(theta);
                        var s = Math.sin(theta);
                        var te = this.elements;
                        var a11 = te[0],
                            a12 = te[3],
                            a13 = te[6];
                        var a21 = te[1],
                            a22 = te[4],
                            a23 = te[7];
                        te[0] = c * a11 + s * a21;
                        te[3] = c * a12 + s * a22;
                        te[6] = c * a13 + s * a23;
                        te[1] = -s * a11 + c * a21;
                        te[4] = -s * a12 + c * a22;
                        te[7] = -s * a13 + c * a23;
                        return this;
                    };
                    Matrix3.prototype.translate = function(tx, ty) {
                        var te = this.elements;
                        te[0] += tx * te[2];
                        te[3] += tx * te[5];
                        te[6] += tx * te[8];
                        te[1] += ty * te[2];
                        te[4] += ty * te[5];
                        te[7] += ty * te[8];
                        return this;
                    };
                    Matrix3.prototype.equals = function(matrix) {
                        var te = this.elements;
                        var me = matrix.elements;
                        for (var i = 0; i < 9; i++) {
                            if (te[i] !== me[i])
                                return false;
                        }
                        return true;
                    };
                    Matrix3.prototype.fromArray = function(array, offset) {
                        if (offset === void 0) {
                            offset = 0;
                        }
                        for (var i = 0; i < 9; i++) {
                            this.elements[i] = array[i + offset];
                        }
                        return this;
                    };
                    Matrix3.prototype.toArray = function(array, offset) {
                        if (array === void 0) {
                            array = [];
                        }
                        if (offset === void 0) {
                            offset = 0;
                        }
                        var te = this.elements;
                        array[offset] = te[0];
                        array[offset + 1] = te[1];
                        array[offset + 2] = te[2];
                        array[offset + 3] = te[3];
                        array[offset + 4] = te[4];
                        array[offset + 5] = te[5];
                        array[offset + 6] = te[6];
                        array[offset + 7] = te[7];
                        array[offset + 8] = te[8];
                        return array;
                    };
                    Matrix3.prototype.clone = function() {
                        return new this.constructor().fromArray(this.elements);
                    };
                    return Matrix3;
                }());
                Matrix3.prototype.isMatrix3 = true;

                function arrayNeedsUint32(array) {
                    // assumes larger values usually on last
                    for (var i = array.length - 1; i >= 0; --i) {
                        if (array[i] > 65535)
                            return true;
                    }
                    return false;
                }
                var TYPED_ARRAYS = {
                    Int8Array: Int8Array,
                    Uint8Array: Uint8Array,
                    Uint8ClampedArray: Uint8ClampedArray,
                    Int16Array: Int16Array,
                    Uint16Array: Uint16Array,
                    Int32Array: Int32Array,
                    Uint32Array: Uint32Array,
                    Float32Array: Float32Array,
                    Float64Array: Float64Array
                };

                function getTypedArray(type, buffer) {
                    return new TYPED_ARRAYS[type](buffer);
                }

                function createElementNS(name) {
                    return document.createElementNS('http://www.w3.org/1999/xhtml', name);
                }

                function SRGBToLinear(c) {
                    return (c < 0.04045) ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
                }

                function LinearToSRGB(c) {
                    return (c < 0.0031308) ? c * 12.92 : 1.055 * (Math.pow(c, 0.41666)) - 0.055;
                }
                // JavaScript RGB-to-RGB transforms, defined as
                // FN[InputColorSpace][OutputColorSpace] callback functions.
                var FN = (_a = {},
                    _a[SRGBColorSpace] = (_b = {}, _b[LinearSRGBColorSpace] = SRGBToLinear, _b),
                    _a[LinearSRGBColorSpace] = (_c = {}, _c[SRGBColorSpace] = LinearToSRGB, _c),
                    _a);
                var ColorManagement = {
                    legacyMode: true,
                    get workingColorSpace() {
                        return LinearSRGBColorSpace;
                    },
                    set workingColorSpace(colorSpace) {
                        console.warn('THREE.ColorManagement: .workingColorSpace is readonly.');
                    },
                    convert: function(color, sourceColorSpace, targetColorSpace) {
                        if (this.legacyMode || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
                            return color;
                        }
                        if (FN[sourceColorSpace] && FN[sourceColorSpace][targetColorSpace] !== undefined) {
                            var fn = FN[sourceColorSpace][targetColorSpace];
                            color.r = fn(color.r);
                            color.g = fn(color.g);
                            color.b = fn(color.b);
                            return color;
                        }
                        throw new Error('Unsupported color space conversion.');
                    },
                    fromWorkingColorSpace: function(color, targetColorSpace) {
                        return this.convert(color, this.workingColorSpace, targetColorSpace);
                    },
                    toWorkingColorSpace: function(color, sourceColorSpace) {
                        return this.convert(color, sourceColorSpace, this.workingColorSpace);
                    },
                };
                var _colorKeywords = {
                    'aliceblue': 0xF0F8FF,
                    'antiquewhite': 0xFAEBD7,
                    'aqua': 0x00FFFF,
                    'aquamarine': 0x7FFFD4,
                    'azure': 0xF0FFFF,
                    'beige': 0xF5F5DC,
                    'bisque': 0xFFE4C4,
                    'black': 0x000000,
                    'blanchedalmond': 0xFFEBCD,
                    'blue': 0x0000FF,
                    'blueviolet': 0x8A2BE2,
                    'brown': 0xA52A2A,
                    'burlywood': 0xDEB887,
                    'cadetblue': 0x5F9EA0,
                    'chartreuse': 0x7FFF00,
                    'chocolate': 0xD2691E,
                    'coral': 0xFF7F50,
                    'cornflowerblue': 0x6495ED,
                    'cornsilk': 0xFFF8DC,
                    'crimson': 0xDC143C,
                    'cyan': 0x00FFFF,
                    'darkblue': 0x00008B,
                    'darkcyan': 0x008B8B,
                    'darkgoldenrod': 0xB8860B,
                    'darkgray': 0xA9A9A9,
                    'darkgreen': 0x006400,
                    'darkgrey': 0xA9A9A9,
                    'darkkhaki': 0xBDB76B,
                    'darkmagenta': 0x8B008B,
                    'darkolivegreen': 0x556B2F,
                    'darkorange': 0xFF8C00,
                    'darkorchid': 0x9932CC,
                    'darkred': 0x8B0000,
                    'darksalmon': 0xE9967A,
                    'darkseagreen': 0x8FBC8F,
                    'darkslateblue': 0x483D8B,
                    'darkslategray': 0x2F4F4F,
                    'darkslategrey': 0x2F4F4F,
                    'darkturquoise': 0x00CED1,
                    'darkviolet': 0x9400D3,
                    'deeppink': 0xFF1493,
                    'deepskyblue': 0x00BFFF,
                    'dimgray': 0x696969,
                    'dimgrey': 0x696969,
                    'dodgerblue': 0x1E90FF,
                    'firebrick': 0xB22222,
                    'floralwhite': 0xFFFAF0,
                    'forestgreen': 0x228B22,
                    'fuchsia': 0xFF00FF,
                    'gainsboro': 0xDCDCDC,
                    'ghostwhite': 0xF8F8FF,
                    'gold': 0xFFD700,
                    'goldenrod': 0xDAA520,
                    'gray': 0x808080,
                    'green': 0x008000,
                    'greenyellow': 0xADFF2F,
                    'grey': 0x808080,
                    'honeydew': 0xF0FFF0,
                    'hotpink': 0xFF69B4,
                    'indianred': 0xCD5C5C,
                    'indigo': 0x4B0082,
                    'ivory': 0xFFFFF0,
                    'khaki': 0xF0E68C,
                    'lavender': 0xE6E6FA,
                    'lavenderblush': 0xFFF0F5,
                    'lawngreen': 0x7CFC00,
                    'lemonchiffon': 0xFFFACD,
                    'lightblue': 0xADD8E6,
                    'lightcoral': 0xF08080,
                    'lightcyan': 0xE0FFFF,
                    'lightgoldenrodyellow': 0xFAFAD2,
                    'lightgray': 0xD3D3D3,
                    'lightgreen': 0x90EE90,
                    'lightgrey': 0xD3D3D3,
                    'lightpink': 0xFFB6C1,
                    'lightsalmon': 0xFFA07A,
                    'lightseagreen': 0x20B2AA,
                    'lightskyblue': 0x87CEFA,
                    'lightslategray': 0x778899,
                    'lightslategrey': 0x778899,
                    'lightsteelblue': 0xB0C4DE,
                    'lightyellow': 0xFFFFE0,
                    'lime': 0x00FF00,
                    'limegreen': 0x32CD32,
                    'linen': 0xFAF0E6,
                    'magenta': 0xFF00FF,
                    'maroon': 0x800000,
                    'mediumaquamarine': 0x66CDAA,
                    'mediumblue': 0x0000CD,
                    'mediumorchid': 0xBA55D3,
                    'mediumpurple': 0x9370DB,
                    'mediumseagreen': 0x3CB371,
                    'mediumslateblue': 0x7B68EE,
                    'mediumspringgreen': 0x00FA9A,
                    'mediumturquoise': 0x48D1CC,
                    'mediumvioletred': 0xC71585,
                    'midnightblue': 0x191970,
                    'mintcream': 0xF5FFFA,
                    'mistyrose': 0xFFE4E1,
                    'moccasin': 0xFFE4B5,
                    'navajowhite': 0xFFDEAD,
                    'navy': 0x000080,
                    'oldlace': 0xFDF5E6,
                    'olive': 0x808000,
                    'olivedrab': 0x6B8E23,
                    'orange': 0xFFA500,
                    'orangered': 0xFF4500,
                    'orchid': 0xDA70D6,
                    'palegoldenrod': 0xEEE8AA,
                    'palegreen': 0x98FB98,
                    'paleturquoise': 0xAFEEEE,
                    'palevioletred': 0xDB7093,
                    'papayawhip': 0xFFEFD5,
                    'peachpuff': 0xFFDAB9,
                    'peru': 0xCD853F,
                    'pink': 0xFFC0CB,
                    'plum': 0xDDA0DD,
                    'powderblue': 0xB0E0E6,
                    'purple': 0x800080,
                    'rebeccapurple': 0x663399,
                    'red': 0xFF0000,
                    'rosybrown': 0xBC8F8F,
                    'royalblue': 0x4169E1,
                    'saddlebrown': 0x8B4513,
                    'salmon': 0xFA8072,
                    'sandybrown': 0xF4A460,
                    'seagreen': 0x2E8B57,
                    'seashell': 0xFFF5EE,
                    'sienna': 0xA0522D,
                    'silver': 0xC0C0C0,
                    'skyblue': 0x87CEEB,
                    'slateblue': 0x6A5ACD,
                    'slategray': 0x708090,
                    'slategrey': 0x708090,
                    'snow': 0xFFFAFA,
                    'springgreen': 0x00FF7F,
                    'steelblue': 0x4682B4,
                    'tan': 0xD2B48C,
                    'teal': 0x008080,
                    'thistle': 0xD8BFD8,
                    'tomato': 0xFF6347,
                    'turquoise': 0x40E0D0,
                    'violet': 0xEE82EE,
                    'wheat': 0xF5DEB3,
                    'white': 0xFFFFFF,
                    'whitesmoke': 0xF5F5F5,
                    'yellow': 0xFFFF00,
                    'yellowgreen': 0x9ACD32
                };
                var _rgb = {
                    r: 0,
                    g: 0,
                    b: 0
                };
                var _hslA = {
                    h: 0,
                    s: 0,
                    l: 0
                };
                var _hslB = {
                    h: 0,
                    s: 0,
                    l: 0
                };

                function hue2rgb(p, q, t) {
                    if (t < 0)
                        t += 1;
                    if (t > 1)
                        t -= 1;
                    if (t < 1 / 6)
                        return p + (q - p) * 6 * t;
                    if (t < 1 / 2)
                        return q;
                    if (t < 2 / 3)
                        return p + (q - p) * 6 * (2 / 3 - t);
                    return p;
                }

                function toComponents(source, target) {
                    target.r = source.r;
                    target.g = source.g;
                    target.b = source.b;
                    return target;
                }
                var Color = /** @class */ (function() {
                    function Color(r, g, b) {
                        if (g === undefined && b === undefined) {
                            // r is THREE.Color, hex or string
                            return this.set(r);
                        }
                        return this.setRGB(r, g, b);
                    }
                    Color.prototype.set = function(value) {
                        if (value && value.isColor) {
                            this.copy(value);
                        } else if (typeof value === 'number') {
                            this.setHex(value);
                        } else if (typeof value === 'string') {
                            this.setStyle(value);
                        }
                        return this;
                    };
                    Color.prototype.setScalar = function(scalar) {
                        this.r = scalar;
                        this.g = scalar;
                        this.b = scalar;
                        return this;
                    };
                    Color.prototype.setHex = function(hex, colorSpace) {
                        if (colorSpace === void 0) {
                            colorSpace = SRGBColorSpace;
                        }
                        hex = Math.floor(hex);
                        this.r = (hex >> 16 & 255) / 255;
                        this.g = (hex >> 8 & 255) / 255;
                        this.b = (hex & 255) / 255;
                        ColorManagement.toWorkingColorSpace(this, colorSpace);
                        return this;
                    };
                    Color.prototype.setRGB = function(r, g, b, colorSpace) {
                        if (colorSpace === void 0) {
                            colorSpace = LinearSRGBColorSpace;
                        }
                        this.r = r;
                        this.g = g;
                        this.b = b;
                        ColorManagement.toWorkingColorSpace(this, colorSpace);
                        return this;
                    };
                    Color.prototype.setHSL = function(h, s, l, colorSpace) {
                        if (colorSpace === void 0) {
                            colorSpace = LinearSRGBColorSpace;
                        }
                        // h,s,l ranges are in 0.0 - 1.0
                        h = euclideanModulo(h, 1);
                        s = clamp(s, 0, 1);
                        l = clamp(l, 0, 1);
                        if (s === 0) {
                            this.r = this.g = this.b = l;
                        } else {
                            var p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
                            var q = (2 * l) - p;
                            this.r = hue2rgb(q, p, h + 1 / 3);
                            this.g = hue2rgb(q, p, h);
                            this.b = hue2rgb(q, p, h - 1 / 3);
                        }
                        ColorManagement.toWorkingColorSpace(this, colorSpace);
                        return this;
                    };
                    Color.prototype.setStyle = function(style, colorSpace) {
                        if (colorSpace === void 0) {
                            colorSpace = SRGBColorSpace;
                        }

                        function handleAlpha(string) {
                            if (string === undefined)
                                return;
                            if (parseFloat(string) < 1) {
                                console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
                            }
                        }
                        var m;
                        if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
                            // rgb / hsl
                            var color = void 0;
                            var name = m[1];
                            var components = m[2];
                            switch (name) {
                                case 'rgb':
                                case 'rgba':
                                    if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                                        // rgb(255,0,0) rgba(255,0,0,0.5)
                                        this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                                        this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                                        this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                                        ColorManagement.toWorkingColorSpace(this, colorSpace);
                                        handleAlpha(color[4]);
                                        return this;
                                    }
                                    if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                                        // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
                                        this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                                        this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                                        this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                                        ColorManagement.toWorkingColorSpace(this, colorSpace);
                                        handleAlpha(color[4]);
                                        return this;
                                    }
                                    break;
                                case 'hsl':
                                case 'hsla':
                                    if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                                        // hsl(120,50%,50%) hsla(120,50%,50%,0.5)
                                        var h = parseFloat(color[1]) / 360;
                                        var s = parseInt(color[2], 10) / 100;
                                        var l = parseInt(color[3], 10) / 100;
                                        handleAlpha(color[4]);
                                        return this.setHSL(h, s, l, colorSpace);
                                    }
                                    break;
                            }
                        } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
                            // hex color
                            var hex = m[1];
                            var size = hex.length;
                            if (size === 3) {
                                // #ff0
                                this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
                                this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
                                this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
                                ColorManagement.toWorkingColorSpace(this, colorSpace);
                                return this;
                            } else if (size === 6) {
                                // #ff0000
                                this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
                                this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
                                this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
                                ColorManagement.toWorkingColorSpace(this, colorSpace);
                                return this;
                            }
                        }
                        if (style && style.length > 0) {
                            return this.setColorName(style, colorSpace);
                        }
                        return this;
                    };
                    Color.prototype.setColorName = function(style, colorSpace) {
                        if (colorSpace === void 0) {
                            colorSpace = SRGBColorSpace;
                        }
                        // color keywords
                        var hex = _colorKeywords[style.toLowerCase()];
                        if (hex !== undefined) {
                            // red
                            this.setHex(hex, colorSpace);
                        } else {
                            // unknown color
                            console.warn('THREE.Color: Unknown color ' + style);
                        }
                        return this;
                    };
                    Color.prototype.clone = function() {
                        return new this.constructor(this.r, this.g, this.b);
                    };
                    Color.prototype.copy = function(color) {
                        this.r = color.r;
                        this.g = color.g;
                        this.b = color.b;
                        return this;
                    };
                    Color.prototype.copySRGBToLinear = function(color) {
                        this.r = SRGBToLinear(color.r);
                        this.g = SRGBToLinear(color.g);
                        this.b = SRGBToLinear(color.b);
                        return this;
                    };
                    Color.prototype.copyLinearToSRGB = function(color) {
                        this.r = LinearToSRGB(color.r);
                        this.g = LinearToSRGB(color.g);
                        this.b = LinearToSRGB(color.b);
                        return this;
                    };
                    Color.prototype.convertSRGBToLinear = function() {
                        this.copySRGBToLinear(this);
                        return this;
                    };
                    Color.prototype.convertLinearToSRGB = function() {
                        this.copyLinearToSRGB(this);
                        return this;
                    };
                    Color.prototype.getHex = function(colorSpace) {
                        if (colorSpace === void 0) {
                            colorSpace = SRGBColorSpace;
                        }
                        ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
                        return clamp(_rgb.r * 255, 0, 255) << 16 ^ clamp(_rgb.g * 255, 0, 255) << 8 ^ clamp(_rgb.b * 255, 0, 255) << 0;
                    };
                    Color.prototype.getHexString = function(colorSpace) {
                        if (colorSpace === void 0) {
                            colorSpace = SRGBColorSpace;
                        }
                        return ('000000' + this.getHex(colorSpace).toString(16)).slice(-6);
                    };
                    Color.prototype.getHSL = function(target, colorSpace) {
                        // h,s,l ranges are in 0.0 - 1.0
                        if (colorSpace === void 0) {
                            colorSpace = LinearSRGBColorSpace;
                        }
                        ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
                        var r = _rgb.r,
                            g = _rgb.g,
                            b = _rgb.b;
                        var max = Math.max(r, g, b);
                        var min = Math.min(r, g, b);
                        var hue, saturation;
                        var lightness = (min + max) / 2.0;
                        if (min === max) {
                            hue = 0;
                            saturation = 0;
                        } else {
                            var delta = max - min;
                            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
                            switch (max) {
                                case r:
                                    hue = (g - b) / delta + (g < b ? 6 : 0);
                                    break;
                                case g:
                                    hue = (b - r) / delta + 2;
                                    break;
                                case b:
                                    hue = (r - g) / delta + 4;
                                    break;
                            }
                            hue /= 6;
                        }
                        target.h = hue;
                        target.s = saturation;
                        target.l = lightness;
                        return target;
                    };
                    Color.prototype.getRGB = function(target, colorSpace) {
                        if (colorSpace === void 0) {
                            colorSpace = LinearSRGBColorSpace;
                        }
                        ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
                        target.r = _rgb.r;
                        target.g = _rgb.g;
                        target.b = _rgb.b;
                        return target;
                    };
                    Color.prototype.getStyle = function(colorSpace) {
                        if (colorSpace === void 0) {
                            colorSpace = SRGBColorSpace;
                        }
                        ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
                        if (colorSpace !== SRGBColorSpace) {
                            // Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
                            return "color(".concat(colorSpace, " ").concat(_rgb.r, " ").concat(_rgb.g, " ").concat(_rgb.b, ")");
                        }
                        return "rgb(".concat((_rgb.r * 255) | 0, ",").concat((_rgb.g * 255) | 0, ",").concat((_rgb.b * 255) | 0, ")");
                    };
                    Color.prototype.offsetHSL = function(h, s, l) {
                        this.getHSL(_hslA);
                        _hslA.h += h;
                        _hslA.s += s;
                        _hslA.l += l;
                        this.setHSL(_hslA.h, _hslA.s, _hslA.l);
                        return this;
                    };
                    Color.prototype.add = function(color) {
                        this.r += color.r;
                        this.g += color.g;
                        this.b += color.b;
                        return this;
                    };
                    Color.prototype.addColors = function(color1, color2) {
                        this.r = color1.r + color2.r;
                        this.g = color1.g + color2.g;
                        this.b = color1.b + color2.b;
                        return this;
                    };
                    Color.prototype.addScalar = function(s) {
                        this.r += s;
                        this.g += s;
                        this.b += s;
                        return this;
                    };
                    Color.prototype.sub = function(color) {
                        this.r = Math.max(0, this.r - color.r);
                        this.g = Math.max(0, this.g - color.g);
                        this.b = Math.max(0, this.b - color.b);
                        return this;
                    };
                    Color.prototype.multiply = function(color) {
                        this.r *= color.r;
                        this.g *= color.g;
                        this.b *= color.b;
                        return this;
                    };
                    Color.prototype.multiplyScalar = function(s) {
                        this.r *= s;
                        this.g *= s;
                        this.b *= s;
                        return this;
                    };
                    Color.prototype.lerp = function(color, alpha) {
                        this.r += (color.r - this.r) * alpha;
                        this.g += (color.g - this.g) * alpha;
                        this.b += (color.b - this.b) * alpha;
                        return this;
                    };
                    Color.prototype.lerpColors = function(color1, color2, alpha) {
                        this.r = color1.r + (color2.r - color1.r) * alpha;
                        this.g = color1.g + (color2.g - color1.g) * alpha;
                        this.b = color1.b + (color2.b - color1.b) * alpha;
                        return this;
                    };
                    Color.prototype.lerpHSL = function(color, alpha) {
                        this.getHSL(_hslA);
                        color.getHSL(_hslB);
                        var h = lerp(_hslA.h, _hslB.h, alpha);
                        var s = lerp(_hslA.s, _hslB.s, alpha);
                        var l = lerp(_hslA.l, _hslB.l, alpha);
                        this.setHSL(h, s, l);
                        return this;
                    };
                    Color.prototype.equals = function(c) {
                        return (c.r === this.r) && (c.g === this.g) && (c.b === this.b);
                    };
                    Color.prototype.fromArray = function(array, offset) {
                        if (offset === void 0) {
                            offset = 0;
                        }
                        this.r = array[offset];
                        this.g = array[offset + 1];
                        this.b = array[offset + 2];
                        return this;
                    };
                    Color.prototype.toArray = function(array, offset) {
                        if (array === void 0) {
                            array = [];
                        }
                        if (offset === void 0) {
                            offset = 0;
                        }
                        array[offset] = this.r;
                        array[offset + 1] = this.g;
                        array[offset + 2] = this.b;
                        return array;
                    };
                    Color.prototype.fromBufferAttribute = function(attribute, index) {
                        this.r = attribute.getX(index);
                        this.g = attribute.getY(index);
                        this.b = attribute.getZ(index);
                        if (attribute.normalized === true) {
                            // assuming Uint8Array
                            this.r /= 255;
                            this.g /= 255;
                            this.b /= 255;
                        }
                        return this;
                    };
                    Color.prototype.toJSON = function() {
                        return this.getHex();
                    };
                    return Color;
                }());
                Color.NAMES = _colorKeywords;
                Color.prototype.isColor = true;
                Color.prototype.r = 1;
                Color.prototype.g = 1;
                Color.prototype.b = 1;
                var _canvas;
                var ImageUtils = /** @class */ (function() {
                    function ImageUtils() {}
                    ImageUtils.getDataURL = function(image) {
                        if (/^data:/i.test(image.src)) {
                            return image.src;
                        }
                        if (typeof HTMLCanvasElement == 'undefined') {
                            return image.src;
                        }
                        var canvas;
                        if (image instanceof HTMLCanvasElement) {
                            canvas = image;
                        } else {
                            if (_canvas === undefined)
                                _canvas = createElementNS('canvas');
                            _canvas.width = image.width;
                            _canvas.height = image.height;
                            var context = _canvas.getContext('2d');
                            if (image instanceof ImageData) {
                                context.putImageData(image, 0, 0);
                            } else {
                                context.drawImage(image, 0, 0, image.width, image.height);
                            }
                            canvas = _canvas;
                        }
                        if (canvas.width > 2048 || canvas.height > 2048) {
                            console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
                            return canvas.toDataURL('image/jpeg', 0.6);
                        } else {
                            return canvas.toDataURL('image/png');
                        }
                    };
                    ImageUtils.sRGBToLinear = function(image) {
                        if ((typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||
                            (typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||
                            (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)) {
                            var canvas = createElementNS('canvas');
                            canvas.width = image.width;
                            canvas.height = image.height;
                            var context = canvas.getContext('2d');
                            context.drawImage(image, 0, 0, image.width, image.height);
                            var imageData = context.getImageData(0, 0, image.width, image.height);
                            var data = imageData.data;
                            for (var i = 0; i < data.length; i++) {
                                data[i] = SRGBToLinear(data[i] / 255) * 255;
                            }
                            context.putImageData(imageData, 0, 0);
                            return canvas;
                        } else if (image.data) {
                            var data = image.data.slice(0);
                            for (var i = 0; i < data.length; i++) {
                                if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
                                    data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
                                } else {
                                    // assuming float
                                    data[i] = SRGBToLinear(data[i]);
                                }
                            }
                            return {
                                data: data,
                                width: image.width,
                                height: image.height
                            };
                        } else {
                            console.warn('THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.');
                            return image;
                        }
                    };
                    return ImageUtils;
                }());
                var Source = /** @class */ (function() {
                    function Source(data) {
                        if (data === void 0) {
                            data = null;
                        }
                        this.uuid = generateUUID();
                        this.data = data;
                        this.version = 0;
                    }
                    Object.defineProperty(Source.prototype, "needsUpdate", {
                        set: function(value) {
                            if (value === true)
                                this.version++;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Source.prototype.toJSON = function(meta) {
                        var isRootObject = (meta === undefined || typeof meta === 'string');
                        if (!isRootObject && meta.images[this.uuid] !== undefined) {
                            return meta.images[this.uuid];
                        }
                        var output = {
                            uuid: this.uuid,
                            url: ''
                        };
                        var data = this.data;
                        if (data !== null) {
                            var url = void 0;
                            if (Array.isArray(data)) {
                                // cube texture
                                url = [];
                                for (var i = 0, l = data.length; i < l; i++) {
                                    if (data[i].isDataTexture) {
                                        url.push(serializeImage(data[i].image));
                                    } else {
                                        url.push(serializeImage(data[i]));
                                    }
                                }
                            } else {
                                // texture
                                url = serializeImage(data);
                            }
                            output.url = url;
                        }
                        if (!isRootObject) {
                            meta.images[this.uuid] = output;
                        }
                        return output;
                    };
                    return Source;
                }());

                function serializeImage(image) {
                    if ((typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||
                        (typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||
                        (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)) {
                        // default images
                        return ImageUtils.getDataURL(image);
                    } else {
                        if (image.data) {
                            // images of DataTexture
                            return {
                                data: Array.prototype.slice.call(image.data),
                                width: image.width,
                                height: image.height,
                                type: image.data.constructor.name
                            };
                        } else {
                            console.warn('THREE.Texture: Unable to serialize Texture.');
                            return {};
                        }
                    }
                }
                Source.prototype.isSource = true;
                var textureId = 0;
                var Texture = /** @class */ (function(_super) {
                    __extends(Texture, _super);

                    function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
                        if (image === void 0) {
                            image = Texture.DEFAULT_IMAGE;
                        }
                        if (mapping === void 0) {
                            mapping = Texture.DEFAULT_MAPPING;
                        }
                        if (wrapS === void 0) {
                            wrapS = ClampToEdgeWrapping;
                        }
                        if (wrapT === void 0) {
                            wrapT = ClampToEdgeWrapping;
                        }
                        if (magFilter === void 0) {
                            magFilter = LinearFilter;
                        }
                        if (minFilter === void 0) {
                            minFilter = LinearMipmapLinearFilter;
                        }
                        if (format === void 0) {
                            format = RGBAFormat;
                        }
                        if (type === void 0) {
                            type = UnsignedByteType;
                        }
                        if (anisotropy === void 0) {
                            anisotropy = 1;
                        }
                        if (encoding === void 0) {
                            encoding = LinearEncoding;
                        }
                        var _this_1 = _super.call(this) || this;
                        Object.defineProperty(_this_1, 'id', {
                            value: textureId++
                        });
                        _this_1.uuid = generateUUID();
                        _this_1.name = '';
                        _this_1.source = new Source(image);
                        _this_1.mipmaps = [];
                        _this_1.mapping = mapping;
                        _this_1.wrapS = wrapS;
                        _this_1.wrapT = wrapT;
                        _this_1.magFilter = magFilter;
                        _this_1.minFilter = minFilter;
                        _this_1.anisotropy = anisotropy;
                        _this_1.format = format;
                        _this_1.internalFormat = null;
                        _this_1.type = type;
                        _this_1.offset = new Vector2(0, 0);
                        _this_1.repeat = new Vector2(1, 1);
                        _this_1.center = new Vector2(0, 0);
                        _this_1.rotation = 0;
                        _this_1.matrixAutoUpdate = true;
                        _this_1.matrix = new Matrix3();
                        _this_1.generateMipmaps = true;
                        _this_1.premultiplyAlpha = false;
                        _this_1.flipY = true;
                        _this_1.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
                        // Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
                        //
                        // Also changing the encoding after already used by a Material will not automatically make the Material
                        // update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
                        _this_1.encoding = encoding;
                        _this_1.userData = {};
                        _this_1.version = 0;
                        _this_1.onUpdate = null;
                        _this_1.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
                        _this_1.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)
                        return _this_1;
                    }
                    Object.defineProperty(Texture.prototype, "image", {
                        get: function() {
                            return this.source.data;
                        },
                        set: function(value) {
                            this.source.data = value;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Texture.prototype.updateMatrix = function() {
                        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
                    };
                    Texture.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    Texture.prototype.copy = function(source) {
                        this.name = source.name;
                        this.source = source.source;
                        this.mipmaps = source.mipmaps.slice(0);
                        this.mapping = source.mapping;
                        this.wrapS = source.wrapS;
                        this.wrapT = source.wrapT;
                        this.magFilter = source.magFilter;
                        this.minFilter = source.minFilter;
                        this.anisotropy = source.anisotropy;
                        this.format = source.format;
                        this.internalFormat = source.internalFormat;
                        this.type = source.type;
                        this.offset.copy(source.offset);
                        this.repeat.copy(source.repeat);
                        this.center.copy(source.center);
                        this.rotation = source.rotation;
                        this.matrixAutoUpdate = source.matrixAutoUpdate;
                        this.matrix.copy(source.matrix);
                        this.generateMipmaps = source.generateMipmaps;
                        this.premultiplyAlpha = source.premultiplyAlpha;
                        this.flipY = source.flipY;
                        this.unpackAlignment = source.unpackAlignment;
                        this.encoding = source.encoding;
                        this.userData = JSON.parse(JSON.stringify(source.userData));
                        this.needsUpdate = true;
                        return this;
                    };
                    Texture.prototype.toJSON = function(meta) {
                        var isRootObject = (meta === undefined || typeof meta === 'string');
                        if (!isRootObject && meta.textures[this.uuid] !== undefined) {
                            return meta.textures[this.uuid];
                        }
                        var output = {
                            metadata: {
                                version: 4.5,
                                type: 'Texture',
                                generator: 'Texture.toJSON'
                            },
                            uuid: this.uuid,
                            name: this.name,
                            image: this.source.toJSON(meta).uuid,
                            mapping: this.mapping,
                            repeat: [this.repeat.x, this.repeat.y],
                            offset: [this.offset.x, this.offset.y],
                            center: [this.center.x, this.center.y],
                            rotation: this.rotation,
                            wrap: [this.wrapS, this.wrapT],
                            format: this.format,
                            type: this.type,
                            encoding: this.encoding,
                            minFilter: this.minFilter,
                            magFilter: this.magFilter,
                            anisotropy: this.anisotropy,
                            flipY: this.flipY,
                            premultiplyAlpha: this.premultiplyAlpha,
                            unpackAlignment: this.unpackAlignment
                        };
                        if (JSON.stringify(this.userData) !== '{}')
                            output.userData = this.userData;
                        if (!isRootObject) {
                            meta.textures[this.uuid] = output;
                        }
                        return output;
                    };
                    Texture.prototype.dispose = function() {
                        this.dispatchEvent({
                            type: 'dispose'
                        });
                    };
                    Texture.prototype.transformUv = function(uv) {
                        if (this.mapping !== UVMapping)
                            return uv;
                        uv.applyMatrix3(this.matrix);
                        if (uv.x < 0 || uv.x > 1) {
                            switch (this.wrapS) {
                                case RepeatWrapping:
                                    uv.x = uv.x - Math.floor(uv.x);
                                    break;
                                case ClampToEdgeWrapping:
                                    uv.x = uv.x < 0 ? 0 : 1;
                                    break;
                                case MirroredRepeatWrapping:
                                    if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                                        uv.x = Math.ceil(uv.x) - uv.x;
                                    } else {
                                        uv.x = uv.x - Math.floor(uv.x);
                                    }
                                    break;
                            }
                        }
                        if (uv.y < 0 || uv.y > 1) {
                            switch (this.wrapT) {
                                case RepeatWrapping:
                                    uv.y = uv.y - Math.floor(uv.y);
                                    break;
                                case ClampToEdgeWrapping:
                                    uv.y = uv.y < 0 ? 0 : 1;
                                    break;
                                case MirroredRepeatWrapping:
                                    if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                                        uv.y = Math.ceil(uv.y) - uv.y;
                                    } else {
                                        uv.y = uv.y - Math.floor(uv.y);
                                    }
                                    break;
                            }
                        }
                        if (this.flipY) {
                            uv.y = 1 - uv.y;
                        }
                        return uv;
                    };
                    Object.defineProperty(Texture.prototype, "needsUpdate", {
                        set: function(value) {
                            if (value === true) {
                                this.version++;
                                this.source.needsUpdate = true;
                            }
                        },
                        enumerable: false,
                        configurable: true
                    });
                    return Texture;
                }(EventDispatcher));
                Texture.DEFAULT_IMAGE = null;
                Texture.DEFAULT_MAPPING = UVMapping;
                Texture.prototype.isTexture = true;
                var Vector4 = /** @class */ (function() {
                    function Vector4(x, y, z, w) {
                        if (x === void 0) {
                            x = 0;
                        }
                        if (y === void 0) {
                            y = 0;
                        }
                        if (z === void 0) {
                            z = 0;
                        }
                        if (w === void 0) {
                            w = 1;
                        }
                        this.x = x;
                        this.y = y;
                        this.z = z;
                        this.w = w;
                    }
                    Object.defineProperty(Vector4.prototype, "width", {
                        get: function() {
                            return this.z;
                        },
                        set: function(value) {
                            this.z = value;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(Vector4.prototype, "height", {
                        get: function() {
                            return this.w;
                        },
                        set: function(value) {
                            this.w = value;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Vector4.prototype.set = function(x, y, z, w) {
                        this.x = x;
                        this.y = y;
                        this.z = z;
                        this.w = w;
                        return this;
                    };
                    Vector4.prototype.setScalar = function(scalar) {
                        this.x = scalar;
                        this.y = scalar;
                        this.z = scalar;
                        this.w = scalar;
                        return this;
                    };
                    Vector4.prototype.setX = function(x) {
                        this.x = x;
                        return this;
                    };
                    Vector4.prototype.setY = function(y) {
                        this.y = y;
                        return this;
                    };
                    Vector4.prototype.setZ = function(z) {
                        this.z = z;
                        return this;
                    };
                    Vector4.prototype.setW = function(w) {
                        this.w = w;
                        return this;
                    };
                    Vector4.prototype.setComponent = function(index, value) {
                        switch (index) {
                            case 0:
                                this.x = value;
                                break;
                            case 1:
                                this.y = value;
                                break;
                            case 2:
                                this.z = value;
                                break;
                            case 3:
                                this.w = value;
                                break;
                            default:
                                throw new Error('index is out of range: ' + index);
                        }
                        return this;
                    };
                    Vector4.prototype.getComponent = function(index) {
                        switch (index) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            case 3:
                                return this.w;
                            default:
                                throw new Error('index is out of range: ' + index);
                        }
                    };
                    Vector4.prototype.clone = function() {
                        return new this.constructor(this.x, this.y, this.z, this.w);
                    };
                    Vector4.prototype.copy = function(v) {
                        this.x = v.x;
                        this.y = v.y;
                        this.z = v.z;
                        this.w = (v.w !== undefined) ? v.w : 1;
                        return this;
                    };
                    Vector4.prototype.add = function(v, w) {
                        if (w !== undefined) {
                            console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                            return this.addVectors(v, w);
                        }
                        this.x += v.x;
                        this.y += v.y;
                        this.z += v.z;
                        this.w += v.w;
                        return this;
                    };
                    Vector4.prototype.addScalar = function(s) {
                        this.x += s;
                        this.y += s;
                        this.z += s;
                        this.w += s;
                        return this;
                    };
                    Vector4.prototype.addVectors = function(a, b) {
                        this.x = a.x + b.x;
                        this.y = a.y + b.y;
                        this.z = a.z + b.z;
                        this.w = a.w + b.w;
                        return this;
                    };
                    Vector4.prototype.addScaledVector = function(v, s) {
                        this.x += v.x * s;
                        this.y += v.y * s;
                        this.z += v.z * s;
                        this.w += v.w * s;
                        return this;
                    };
                    Vector4.prototype.sub = function(v, w) {
                        if (w !== undefined) {
                            console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                            return this.subVectors(v, w);
                        }
                        this.x -= v.x;
                        this.y -= v.y;
                        this.z -= v.z;
                        this.w -= v.w;
                        return this;
                    };
                    Vector4.prototype.subScalar = function(s) {
                        this.x -= s;
                        this.y -= s;
                        this.z -= s;
                        this.w -= s;
                        return this;
                    };
                    Vector4.prototype.subVectors = function(a, b) {
                        this.x = a.x - b.x;
                        this.y = a.y - b.y;
                        this.z = a.z - b.z;
                        this.w = a.w - b.w;
                        return this;
                    };
                    Vector4.prototype.multiply = function(v) {
                        this.x *= v.x;
                        this.y *= v.y;
                        this.z *= v.z;
                        this.w *= v.w;
                        return this;
                    };
                    Vector4.prototype.multiplyScalar = function(scalar) {
                        this.x *= scalar;
                        this.y *= scalar;
                        this.z *= scalar;
                        this.w *= scalar;
                        return this;
                    };
                    Vector4.prototype.applyMatrix4 = function(m) {
                        var x = this.x,
                            y = this.y,
                            z = this.z,
                            w = this.w;
                        var e = m.elements;
                        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
                        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
                        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
                        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
                        return this;
                    };
                    Vector4.prototype.divideScalar = function(scalar) {
                        return this.multiplyScalar(1 / scalar);
                    };
                    Vector4.prototype.setAxisAngleFromQuaternion = function(q) {
                        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
                        // q is assumed to be normalized
                        this.w = 2 * Math.acos(q.w);
                        var s = Math.sqrt(1 - q.w * q.w);
                        if (s < 0.0001) {
                            this.x = 1;
                            this.y = 0;
                            this.z = 0;
                        } else {
                            this.x = q.x / s;
                            this.y = q.y / s;
                            this.z = q.z / s;
                        }
                        return this;
                    };
                    Vector4.prototype.setAxisAngleFromRotationMatrix = function(m) {
                        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
                        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
                        var angle, x, y, z; // variables for result
                        var epsilon = 0.01, // margin to allow for rounding errors
                            epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees
                            te = m.elements,
                            m11 = te[0],
                            m12 = te[4],
                            m13 = te[8],
                            m21 = te[1],
                            m22 = te[5],
                            m23 = te[9],
                            m31 = te[2],
                            m32 = te[6],
                            m33 = te[10];
                        if ((Math.abs(m12 - m21) < epsilon) &&
                            (Math.abs(m13 - m31) < epsilon) &&
                            (Math.abs(m23 - m32) < epsilon)) {
                            // singularity found
                            // first check for identity matrix which must have +1 for all terms
                            // in leading diagonal and zero in other terms
                            if ((Math.abs(m12 + m21) < epsilon2) &&
                                (Math.abs(m13 + m31) < epsilon2) &&
                                (Math.abs(m23 + m32) < epsilon2) &&
                                (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
                                // this singularity is identity matrix so angle = 0
                                this.set(1, 0, 0, 0);
                                return this; // zero angle, arbitrary axis
                            }
                            // otherwise this singularity is angle = 180
                            angle = Math.PI;
                            var xx = (m11 + 1) / 2;
                            var yy = (m22 + 1) / 2;
                            var zz = (m33 + 1) / 2;
                            var xy = (m12 + m21) / 4;
                            var xz = (m13 + m31) / 4;
                            var yz = (m23 + m32) / 4;
                            if ((xx > yy) && (xx > zz)) {
                                // m11 is the largest diagonal term
                                if (xx < epsilon) {
                                    x = 0;
                                    y = 0.707106781;
                                    z = 0.707106781;
                                } else {
                                    x = Math.sqrt(xx);
                                    y = xy / x;
                                    z = xz / x;
                                }
                            } else if (yy > zz) {
                                // m22 is the largest diagonal term
                                if (yy < epsilon) {
                                    x = 0.707106781;
                                    y = 0;
                                    z = 0.707106781;
                                } else {
                                    y = Math.sqrt(yy);
                                    x = xy / y;
                                    z = yz / y;
                                }
                            } else {
                                // m33 is the largest diagonal term so base result on this
                                if (zz < epsilon) {
                                    x = 0.707106781;
                                    y = 0.707106781;
                                    z = 0;
                                } else {
                                    z = Math.sqrt(zz);
                                    x = xz / z;
                                    y = yz / z;
                                }
                            }
                            this.set(x, y, z, angle);
                            return this; // return 180 deg rotation
                        }
                        // as we have reached here there are no singularities so we can handle normally
                        var s = Math.sqrt((m32 - m23) * (m32 - m23) +
                            (m13 - m31) * (m13 - m31) +
                            (m21 - m12) * (m21 - m12)); // used to normalize
                        if (Math.abs(s) < 0.001)
                            s = 1;
                        // prevent divide by zero, should not happen if matrix is orthogonal and should be
                        // caught by singularity test above, but I've left it in just in case
                        this.x = (m32 - m23) / s;
                        this.y = (m13 - m31) / s;
                        this.z = (m21 - m12) / s;
                        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
                        return this;
                    };
                    Vector4.prototype.min = function(v) {
                        this.x = Math.min(this.x, v.x);
                        this.y = Math.min(this.y, v.y);
                        this.z = Math.min(this.z, v.z);
                        this.w = Math.min(this.w, v.w);
                        return this;
                    };
                    Vector4.prototype.max = function(v) {
                        this.x = Math.max(this.x, v.x);
                        this.y = Math.max(this.y, v.y);
                        this.z = Math.max(this.z, v.z);
                        this.w = Math.max(this.w, v.w);
                        return this;
                    };
                    Vector4.prototype.clamp = function(min, max) {
                        // assumes min < max, componentwise
                        this.x = Math.max(min.x, Math.min(max.x, this.x));
                        this.y = Math.max(min.y, Math.min(max.y, this.y));
                        this.z = Math.max(min.z, Math.min(max.z, this.z));
                        this.w = Math.max(min.w, Math.min(max.w, this.w));
                        return this;
                    };
                    Vector4.prototype.clampScalar = function(minVal, maxVal) {
                        this.x = Math.max(minVal, Math.min(maxVal, this.x));
                        this.y = Math.max(minVal, Math.min(maxVal, this.y));
                        this.z = Math.max(minVal, Math.min(maxVal, this.z));
                        this.w = Math.max(minVal, Math.min(maxVal, this.w));
                        return this;
                    };
                    Vector4.prototype.clampLength = function(min, max) {
                        var length = this.length();
                        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
                    };
                    Vector4.prototype.floor = function() {
                        this.x = Math.floor(this.x);
                        this.y = Math.floor(this.y);
                        this.z = Math.floor(this.z);
                        this.w = Math.floor(this.w);
                        return this;
                    };
                    Vector4.prototype.ceil = function() {
                        this.x = Math.ceil(this.x);
                        this.y = Math.ceil(this.y);
                        this.z = Math.ceil(this.z);
                        this.w = Math.ceil(this.w);
                        return this;
                    };
                    Vector4.prototype.round = function() {
                        this.x = Math.round(this.x);
                        this.y = Math.round(this.y);
                        this.z = Math.round(this.z);
                        this.w = Math.round(this.w);
                        return this;
                    };
                    Vector4.prototype.roundToZero = function() {
                        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
                        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
                        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
                        this.w = (this.w < 0) ? Math.ceil(this.w) : Math.floor(this.w);
                        return this;
                    };
                    Vector4.prototype.negate = function() {
                        this.x = -this.x;
                        this.y = -this.y;
                        this.z = -this.z;
                        this.w = -this.w;
                        return this;
                    };
                    Vector4.prototype.dot = function(v) {
                        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
                    };
                    Vector4.prototype.lengthSq = function() {
                        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
                    };
                    Vector4.prototype.length = function() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                    };
                    Vector4.prototype.manhattanLength = function() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
                    };
                    Vector4.prototype.normalize = function() {
                        return this.divideScalar(this.length() || 1);
                    };
                    Vector4.prototype.setLength = function(length) {
                        return this.normalize().multiplyScalar(length);
                    };
                    Vector4.prototype.lerp = function(v, alpha) {
                        this.x += (v.x - this.x) * alpha;
                        this.y += (v.y - this.y) * alpha;
                        this.z += (v.z - this.z) * alpha;
                        this.w += (v.w - this.w) * alpha;
                        return this;
                    };
                    Vector4.prototype.lerpVectors = function(v1, v2, alpha) {
                        this.x = v1.x + (v2.x - v1.x) * alpha;
                        this.y = v1.y + (v2.y - v1.y) * alpha;
                        this.z = v1.z + (v2.z - v1.z) * alpha;
                        this.w = v1.w + (v2.w - v1.w) * alpha;
                        return this;
                    };
                    Vector4.prototype.equals = function(v) {
                        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w));
                    };
                    Vector4.prototype.fromArray = function(array, offset) {
                        if (offset === void 0) {
                            offset = 0;
                        }
                        this.x = array[offset];
                        this.y = array[offset + 1];
                        this.z = array[offset + 2];
                        this.w = array[offset + 3];
                        return this;
                    };
                    Vector4.prototype.toArray = function(array, offset) {
                        if (array === void 0) {
                            array = [];
                        }
                        if (offset === void 0) {
                            offset = 0;
                        }
                        array[offset] = this.x;
                        array[offset + 1] = this.y;
                        array[offset + 2] = this.z;
                        array[offset + 3] = this.w;
                        return array;
                    };
                    Vector4.prototype.fromBufferAttribute = function(attribute, index, offset) {
                        if (offset !== undefined) {
                            console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
                        }
                        this.x = attribute.getX(index);
                        this.y = attribute.getY(index);
                        this.z = attribute.getZ(index);
                        this.w = attribute.getW(index);
                        return this;
                    };
                    Vector4.prototype.random = function() {
                        this.x = Math.random();
                        this.y = Math.random();
                        this.z = Math.random();
                        this.w = Math.random();
                        return this;
                    };
                    Vector4.prototype[Symbol.iterator] = function() {
                        return __generator(this, function(_a) {
                            switch (_a.label) {
                                case 0:
                                    return [4 /*yield*/ , this.x];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/ , this.y];
                                case 2:
                                    _a.sent();
                                    return [4 /*yield*/ , this.z];
                                case 3:
                                    _a.sent();
                                    return [4 /*yield*/ , this.w];
                                case 4:
                                    _a.sent();
                                    return [2 /*return*/ ];
                            }
                        });
                    };
                    return Vector4;
                }());
                Vector4.prototype.isVector4 = true;
                /*
                 In options, we can specify:
                 * Texture parameters for an auto-generated target texture
                 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
                */
                var WebGLRenderTarget = /** @class */ (function(_super) {
                    __extends(WebGLRenderTarget, _super);

                    function WebGLRenderTarget(width, height, options) {
                        if (options === void 0) {
                            options = {};
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.width = width;
                        _this_1.height = height;
                        _this_1.depth = 1;
                        _this_1.scissor = new Vector4(0, 0, width, height);
                        _this_1.scissorTest = false;
                        _this_1.viewport = new Vector4(0, 0, width, height);
                        var image = {
                            width: width,
                            height: height,
                            depth: 1
                        };
                        _this_1.texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
                        _this_1.texture.isRenderTargetTexture = true;
                        _this_1.texture.flipY = false;
                        _this_1.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
                        _this_1.texture.internalFormat = options.internalFormat !== undefined ? options.internalFormat : null;
                        _this_1.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
                        _this_1.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
                        _this_1.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
                        _this_1.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
                        _this_1.samples = options.samples !== undefined ? options.samples : 0;
                        return _this_1;
                    }
                    WebGLRenderTarget.prototype.setSize = function(width, height, depth) {
                        if (depth === void 0) {
                            depth = 1;
                        }
                        if (this.width !== width || this.height !== height || this.depth !== depth) {
                            this.width = width;
                            this.height = height;
                            this.depth = depth;
                            this.texture.image.width = width;
                            this.texture.image.height = height;
                            this.texture.image.depth = depth;
                            this.dispose();
                        }
                        this.viewport.set(0, 0, width, height);
                        this.scissor.set(0, 0, width, height);
                    };
                    WebGLRenderTarget.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    WebGLRenderTarget.prototype.copy = function(source) {
                        this.width = source.width;
                        this.height = source.height;
                        this.depth = source.depth;
                        this.viewport.copy(source.viewport);
                        this.texture = source.texture.clone();
                        this.texture.isRenderTargetTexture = true;
                        // ensure image object is not shared, see #20328
                        this.texture.image = Object.assign({}, source.texture.image);
                        this.depthBuffer = source.depthBuffer;
                        this.stencilBuffer = source.stencilBuffer;
                        if (source.depthTexture !== null)
                            this.depthTexture = source.depthTexture.clone();
                        this.samples = source.samples;
                        return this;
                    };
                    WebGLRenderTarget.prototype.dispose = function() {
                        this.dispatchEvent({
                            type: 'dispose'
                        });
                    };
                    return WebGLRenderTarget;
                }(EventDispatcher));
                WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
                var DataArrayTexture = /** @class */ (function(_super) {
                    __extends(DataArrayTexture, _super);

                    function DataArrayTexture(data, width, height, depth) {
                        if (data === void 0) {
                            data = null;
                        }
                        if (width === void 0) {
                            width = 1;
                        }
                        if (height === void 0) {
                            height = 1;
                        }
                        if (depth === void 0) {
                            depth = 1;
                        }
                        var _this_1 = _super.call(this, null) || this;
                        _this_1.image = {
                            data: data,
                            width: width,
                            height: height,
                            depth: depth
                        };
                        _this_1.magFilter = NearestFilter;
                        _this_1.minFilter = NearestFilter;
                        _this_1.wrapR = ClampToEdgeWrapping;
                        _this_1.generateMipmaps = false;
                        _this_1.flipY = false;
                        _this_1.unpackAlignment = 1;
                        return _this_1;
                    }
                    return DataArrayTexture;
                }(Texture));
                DataArrayTexture.prototype.isDataArrayTexture = true;
                var WebGLArrayRenderTarget = /** @class */ (function(_super) {
                    __extends(WebGLArrayRenderTarget, _super);

                    function WebGLArrayRenderTarget(width, height, depth) {
                        var _this_1 = _super.call(this, width, height) || this;
                        _this_1.depth = depth;
                        _this_1.texture = new DataArrayTexture(null, width, height, depth);
                        _this_1.texture.isRenderTargetTexture = true;
                        return _this_1;
                    }
                    return WebGLArrayRenderTarget;
                }(WebGLRenderTarget));
                WebGLArrayRenderTarget.prototype.isWebGLArrayRenderTarget = true;
                var Data3DTexture = /** @class */ (function(_super) {
                    __extends(Data3DTexture, _super);

                    function Data3DTexture(data, width, height, depth) {
                        // We're going to add .setXXX() methods for setting properties later.
                        // Users can still set in DataTexture3D directly.
                        //
                        //	const texture = new THREE.DataTexture3D( data, width, height, depth );
                        // 	texture.anisotropy = 16;
                        //
                        // See #14839
                        if (data === void 0) {
                            data = null;
                        }
                        if (width === void 0) {
                            width = 1;
                        }
                        if (height === void 0) {
                            height = 1;
                        }
                        if (depth === void 0) {
                            depth = 1;
                        }
                        var _this_1 = _super.call(this, null) || this;
                        _this_1.image = {
                            data: data,
                            width: width,
                            height: height,
                            depth: depth
                        };
                        _this_1.magFilter = NearestFilter;
                        _this_1.minFilter = NearestFilter;
                        _this_1.wrapR = ClampToEdgeWrapping;
                        _this_1.generateMipmaps = false;
                        _this_1.flipY = false;
                        _this_1.unpackAlignment = 1;
                        return _this_1;
                    }
                    return Data3DTexture;
                }(Texture));
                Data3DTexture.prototype.isData3DTexture = true;
                var WebGL3DRenderTarget = /** @class */ (function(_super) {
                    __extends(WebGL3DRenderTarget, _super);

                    function WebGL3DRenderTarget(width, height, depth) {
                        var _this_1 = _super.call(this, width, height) || this;
                        _this_1.depth = depth;
                        _this_1.texture = new Data3DTexture(null, width, height, depth);
                        _this_1.texture.isRenderTargetTexture = true;
                        return _this_1;
                    }
                    return WebGL3DRenderTarget;
                }(WebGLRenderTarget));
                WebGL3DRenderTarget.prototype.isWebGL3DRenderTarget = true;
                var WebGLMultipleRenderTargets = /** @class */ (function(_super) {
                    __extends(WebGLMultipleRenderTargets, _super);

                    function WebGLMultipleRenderTargets(width, height, count, options) {
                        if (options === void 0) {
                            options = {};
                        }
                        var _this_1 = _super.call(this, width, height, options) || this;
                        var texture = _this_1.texture;
                        _this_1.texture = [];
                        for (var i = 0; i < count; i++) {
                            _this_1.texture[i] = texture.clone();
                            _this_1.texture[i].isRenderTargetTexture = true;
                        }
                        return _this_1;
                    }
                    WebGLMultipleRenderTargets.prototype.setSize = function(width, height, depth) {
                        if (depth === void 0) {
                            depth = 1;
                        }
                        if (this.width !== width || this.height !== height || this.depth !== depth) {
                            this.width = width;
                            this.height = height;
                            this.depth = depth;
                            for (var i = 0, il = this.texture.length; i < il; i++) {
                                this.texture[i].image.width = width;
                                this.texture[i].image.height = height;
                                this.texture[i].image.depth = depth;
                            }
                            this.dispose();
                        }
                        this.viewport.set(0, 0, width, height);
                        this.scissor.set(0, 0, width, height);
                        return this;
                    };
                    WebGLMultipleRenderTargets.prototype.copy = function(source) {
                        this.dispose();
                        this.width = source.width;
                        this.height = source.height;
                        this.depth = source.depth;
                        this.viewport.set(0, 0, this.width, this.height);
                        this.scissor.set(0, 0, this.width, this.height);
                        this.depthBuffer = source.depthBuffer;
                        this.stencilBuffer = source.stencilBuffer;
                        this.depthTexture = source.depthTexture;
                        this.texture.length = 0;
                        for (var i = 0, il = source.texture.length; i < il; i++) {
                            this.texture[i] = source.texture[i].clone();
                        }
                        return this;
                    };
                    return WebGLMultipleRenderTargets;
                }(WebGLRenderTarget));
                WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
                var Quaternion = /** @class */ (function() {
                    function Quaternion(x, y, z, w) {
                        if (x === void 0) {
                            x = 0;
                        }
                        if (y === void 0) {
                            y = 0;
                        }
                        if (z === void 0) {
                            z = 0;
                        }
                        if (w === void 0) {
                            w = 1;
                        }
                        this._x = x;
                        this._y = y;
                        this._z = z;
                        this._w = w;
                    }
                    Quaternion.slerp = function(qa, qb, qm, t) {
                        console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');
                        return qm.slerpQuaternions(qa, qb, t);
                    };
                    Quaternion.slerpFlat = function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
                        // fuzz-free, array-based Quaternion SLERP operation
                        var x0 = src0[srcOffset0 + 0],
                            y0 = src0[srcOffset0 + 1],
                            z0 = src0[srcOffset0 + 2],
                            w0 = src0[srcOffset0 + 3];
                        var x1 = src1[srcOffset1 + 0],
                            y1 = src1[srcOffset1 + 1],
                            z1 = src1[srcOffset1 + 2],
                            w1 = src1[srcOffset1 + 3];
                        if (t === 0) {
                            dst[dstOffset + 0] = x0;
                            dst[dstOffset + 1] = y0;
                            dst[dstOffset + 2] = z0;
                            dst[dstOffset + 3] = w0;
                            return;
                        }
                        if (t === 1) {
                            dst[dstOffset + 0] = x1;
                            dst[dstOffset + 1] = y1;
                            dst[dstOffset + 2] = z1;
                            dst[dstOffset + 3] = w1;
                            return;
                        }
                        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                            var s = 1 - t;
                            var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
                                dir = (cos >= 0 ? 1 : -1),
                                sqrSin = 1 - cos * cos;
                            // Skip the Slerp for tiny steps to avoid numeric problems:
                            if (sqrSin > Number.EPSILON) {
                                var sin = Math.sqrt(sqrSin),
                                    len = Math.atan2(sin, cos * dir);
                                s = Math.sin(s * len) / sin;
                                t = Math.sin(t * len) / sin;
                            }
                            var tDir = t * dir;
                            x0 = x0 * s + x1 * tDir;
                            y0 = y0 * s + y1 * tDir;
                            z0 = z0 * s + z1 * tDir;
                            w0 = w0 * s + w1 * tDir;
                            // Normalize in case we just did a lerp:
                            if (s === 1 - t) {
                                var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                                x0 *= f;
                                y0 *= f;
                                z0 *= f;
                                w0 *= f;
                            }
                        }
                        dst[dstOffset] = x0;
                        dst[dstOffset + 1] = y0;
                        dst[dstOffset + 2] = z0;
                        dst[dstOffset + 3] = w0;
                    };
                    Quaternion.multiplyQuaternionsFlat = function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
                        var x0 = src0[srcOffset0];
                        var y0 = src0[srcOffset0 + 1];
                        var z0 = src0[srcOffset0 + 2];
                        var w0 = src0[srcOffset0 + 3];
                        var x1 = src1[srcOffset1];
                        var y1 = src1[srcOffset1 + 1];
                        var z1 = src1[srcOffset1 + 2];
                        var w1 = src1[srcOffset1 + 3];
                        dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
                        dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
                        dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
                        dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
                        return dst;
                    };
                    Object.defineProperty(Quaternion.prototype, "x", {
                        get: function() {
                            return this._x;
                        },
                        set: function(value) {
                            this._x = value;
                            this._onChangeCallback();
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(Quaternion.prototype, "y", {
                        get: function() {
                            return this._y;
                        },
                        set: function(value) {
                            this._y = value;
                            this._onChangeCallback();
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(Quaternion.prototype, "z", {
                        get: function() {
                            return this._z;
                        },
                        set: function(value) {
                            this._z = value;
                            this._onChangeCallback();
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(Quaternion.prototype, "w", {
                        get: function() {
                            return this._w;
                        },
                        set: function(value) {
                            this._w = value;
                            this._onChangeCallback();
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Quaternion.prototype.set = function(x, y, z, w) {
                        this._x = x;
                        this._y = y;
                        this._z = z;
                        this._w = w;
                        this._onChangeCallback();
                        return this;
                    };
                    Quaternion.prototype.clone = function() {
                        return new this.constructor(this._x, this._y, this._z, this._w);
                    };
                    Quaternion.prototype.copy = function(quaternion) {
                        this._x = quaternion.x;
                        this._y = quaternion.y;
                        this._z = quaternion.z;
                        this._w = quaternion.w;
                        this._onChangeCallback();
                        return this;
                    };
                    Quaternion.prototype.setFromEuler = function(euler, update) {
                        if (!(euler && euler.isEuler)) {
                            throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
                        }
                        var x = euler._x,
                            y = euler._y,
                            z = euler._z,
                            order = euler._order;
                        // http://www.mathworks.com/matlabcentral/fileexchange/
                        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
                        //	content/SpinCalc.m
                        var cos = Math.cos;
                        var sin = Math.sin;
                        var c1 = cos(x / 2);
                        var c2 = cos(y / 2);
                        var c3 = cos(z / 2);
                        var s1 = sin(x / 2);
                        var s2 = sin(y / 2);
                        var s3 = sin(z / 2);
                        switch (order) {
                            case 'XYZ':
                                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                                break;
                            case 'YXZ':
                                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                                break;
                            case 'ZXY':
                                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                                break;
                            case 'ZYX':
                                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                                break;
                            case 'YZX':
                                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                                break;
                            case 'XZY':
                                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                                break;
                            default:
                                console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
                        }
                        if (update !== false)
                            this._onChangeCallback();
                        return this;
                    };
                    Quaternion.prototype.setFromAxisAngle = function(axis, angle) {
                        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
                        // assumes axis is normalized
                        var halfAngle = angle / 2,
                            s = Math.sin(halfAngle);
                        this._x = axis.x * s;
                        this._y = axis.y * s;
                        this._z = axis.z * s;
                        this._w = Math.cos(halfAngle);
                        this._onChangeCallback();
                        return this;
                    };
                    Quaternion.prototype.setFromRotationMatrix = function(m) {
                        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
                        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
                        var te = m.elements,
                            m11 = te[0],
                            m12 = te[4],
                            m13 = te[8],
                            m21 = te[1],
                            m22 = te[5],
                            m23 = te[9],
                            m31 = te[2],
                            m32 = te[6],
                            m33 = te[10],
                            trace = m11 + m22 + m33;
                        if (trace > 0) {
                            var s = 0.5 / Math.sqrt(trace + 1.0);
                            this._w = 0.25 / s;
                            this._x = (m32 - m23) * s;
                            this._y = (m13 - m31) * s;
                            this._z = (m21 - m12) * s;
                        } else if (m11 > m22 && m11 > m33) {
                            var s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                            this._w = (m32 - m23) / s;
                            this._x = 0.25 * s;
                            this._y = (m12 + m21) / s;
                            this._z = (m13 + m31) / s;
                        } else if (m22 > m33) {
                            var s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                            this._w = (m13 - m31) / s;
                            this._x = (m12 + m21) / s;
                            this._y = 0.25 * s;
                            this._z = (m23 + m32) / s;
                        } else {
                            var s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                            this._w = (m21 - m12) / s;
                            this._x = (m13 + m31) / s;
                            this._y = (m23 + m32) / s;
                            this._z = 0.25 * s;
                        }
                        this._onChangeCallback();
                        return this;
                    };
                    Quaternion.prototype.setFromUnitVectors = function(vFrom, vTo) {
                        // assumes direction vectors vFrom and vTo are normalized
                        var r = vFrom.dot(vTo) + 1;
                        if (r < Number.EPSILON) {
                            // vFrom and vTo point in opposite directions
                            r = 0;
                            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                                this._x = -vFrom.y;
                                this._y = vFrom.x;
                                this._z = 0;
                                this._w = r;
                            } else {
                                this._x = 0;
                                this._y = -vFrom.z;
                                this._z = vFrom.y;
                                this._w = r;
                            }
                        } else {
                            // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
                            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
                            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
                            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
                            this._w = r;
                        }
                        return this.normalize();
                    };
                    Quaternion.prototype.angleTo = function(q) {
                        return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
                    };
                    Quaternion.prototype.rotateTowards = function(q, step) {
                        var angle = this.angleTo(q);
                        if (angle === 0)
                            return this;
                        var t = Math.min(1, step / angle);
                        this.slerp(q, t);
                        return this;
                    };
                    Quaternion.prototype.identity = function() {
                        return this.set(0, 0, 0, 1);
                    };
                    Quaternion.prototype.invert = function() {
                        // quaternion is assumed to have unit length
                        return this.conjugate();
                    };
                    Quaternion.prototype.conjugate = function() {
                        this._x *= -1;
                        this._y *= -1;
                        this._z *= -1;
                        this._onChangeCallback();
                        return this;
                    };
                    Quaternion.prototype.dot = function(v) {
                        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
                    };
                    Quaternion.prototype.lengthSq = function() {
                        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
                    };
                    Quaternion.prototype.length = function() {
                        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
                    };
                    Quaternion.prototype.normalize = function() {
                        var l = this.length();
                        if (l === 0) {
                            this._x = 0;
                            this._y = 0;
                            this._z = 0;
                            this._w = 1;
                        } else {
                            l = 1 / l;
                            this._x = this._x * l;
                            this._y = this._y * l;
                            this._z = this._z * l;
                            this._w = this._w * l;
                        }
                        this._onChangeCallback();
                        return this;
                    };
                    Quaternion.prototype.multiply = function(q, p) {
                        if (p !== undefined) {
                            console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
                            return this.multiplyQuaternions(q, p);
                        }
                        return this.multiplyQuaternions(this, q);
                    };
                    Quaternion.prototype.premultiply = function(q) {
                        return this.multiplyQuaternions(q, this);
                    };
                    Quaternion.prototype.multiplyQuaternions = function(a, b) {
                        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
                        var qax = a._x,
                            qay = a._y,
                            qaz = a._z,
                            qaw = a._w;
                        var qbx = b._x,
                            qby = b._y,
                            qbz = b._z,
                            qbw = b._w;
                        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
                        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
                        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
                        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
                        this._onChangeCallback();
                        return this;
                    };
                    Quaternion.prototype.slerp = function(qb, t) {
                        if (t === 0)
                            return this;
                        if (t === 1)
                            return this.copy(qb);
                        var x = this._x,
                            y = this._y,
                            z = this._z,
                            w = this._w;
                        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
                        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
                        if (cosHalfTheta < 0) {
                            this._w = -qb._w;
                            this._x = -qb._x;
                            this._y = -qb._y;
                            this._z = -qb._z;
                            cosHalfTheta = -cosHalfTheta;
                        } else {
                            this.copy(qb);
                        }
                        if (cosHalfTheta >= 1.0) {
                            this._w = w;
                            this._x = x;
                            this._y = y;
                            this._z = z;
                            return this;
                        }
                        var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
                        if (sqrSinHalfTheta <= Number.EPSILON) {
                            var s = 1 - t;
                            this._w = s * w + t * this._w;
                            this._x = s * x + t * this._x;
                            this._y = s * y + t * this._y;
                            this._z = s * z + t * this._z;
                            this.normalize();
                            this._onChangeCallback();
                            return this;
                        }
                        var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
                        var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
                        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
                            ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
                        this._w = (w * ratioA + this._w * ratioB);
                        this._x = (x * ratioA + this._x * ratioB);
                        this._y = (y * ratioA + this._y * ratioB);
                        this._z = (z * ratioA + this._z * ratioB);
                        this._onChangeCallback();
                        return this;
                    };
                    Quaternion.prototype.slerpQuaternions = function(qa, qb, t) {
                        return this.copy(qa).slerp(qb, t);
                    };
                    Quaternion.prototype.random = function() {
                        // Derived from http://planning.cs.uiuc.edu/node198.html
                        // Note, this source uses w, x, y, z ordering,
                        // so we swap the order below.
                        var u1 = Math.random();
                        var sqrt1u1 = Math.sqrt(1 - u1);
                        var sqrtu1 = Math.sqrt(u1);
                        var u2 = 2 * Math.PI * Math.random();
                        var u3 = 2 * Math.PI * Math.random();
                        return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
                    };
                    Quaternion.prototype.equals = function(quaternion) {
                        return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w);
                    };
                    Quaternion.prototype.fromArray = function(array, offset) {
                        if (offset === void 0) {
                            offset = 0;
                        }
                        this._x = array[offset];
                        this._y = array[offset + 1];
                        this._z = array[offset + 2];
                        this._w = array[offset + 3];
                        this._onChangeCallback();
                        return this;
                    };
                    Quaternion.prototype.toArray = function(array, offset) {
                        if (array === void 0) {
                            array = [];
                        }
                        if (offset === void 0) {
                            offset = 0;
                        }
                        array[offset] = this._x;
                        array[offset + 1] = this._y;
                        array[offset + 2] = this._z;
                        array[offset + 3] = this._w;
                        return array;
                    };
                    Quaternion.prototype.fromBufferAttribute = function(attribute, index) {
                        this._x = attribute.getX(index);
                        this._y = attribute.getY(index);
                        this._z = attribute.getZ(index);
                        this._w = attribute.getW(index);
                        return this;
                    };
                    Quaternion.prototype._onChange = function(callback) {
                        this._onChangeCallback = callback;
                        return this;
                    };
                    Quaternion.prototype._onChangeCallback = function() {};
                    return Quaternion;
                }());
                Quaternion.prototype.isQuaternion = true;
                var Vector3 = /** @class */ (function() {
                    function Vector3(x, y, z) {
                        if (x === void 0) {
                            x = 0;
                        }
                        if (y === void 0) {
                            y = 0;
                        }
                        if (z === void 0) {
                            z = 0;
                        }
                        this.x = x;
                        this.y = y;
                        this.z = z;
                    }
                    Vector3.prototype.set = function(x, y, z) {
                        if (z === undefined)
                            z = this.z; // sprite.scale.set(x,y)
                        this.x = x;
                        this.y = y;
                        this.z = z;
                        return this;
                    };
                    Vector3.prototype.setScalar = function(scalar) {
                        this.x = scalar;
                        this.y = scalar;
                        this.z = scalar;
                        return this;
                    };
                    Vector3.prototype.setX = function(x) {
                        this.x = x;
                        return this;
                    };
                    Vector3.prototype.setY = function(y) {
                        this.y = y;
                        return this;
                    };
                    Vector3.prototype.setZ = function(z) {
                        this.z = z;
                        return this;
                    };
                    Vector3.prototype.setComponent = function(index, value) {
                        switch (index) {
                            case 0:
                                this.x = value;
                                break;
                            case 1:
                                this.y = value;
                                break;
                            case 2:
                                this.z = value;
                                break;
                            default:
                                throw new Error('index is out of range: ' + index);
                        }
                        return this;
                    };
                    Vector3.prototype.getComponent = function(index) {
                        switch (index) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            default:
                                throw new Error('index is out of range: ' + index);
                        }
                    };
                    Vector3.prototype.clone = function() {
                        return new this.constructor(this.x, this.y, this.z);
                    };
                    Vector3.prototype.copy = function(v) {
                        this.x = v.x;
                        this.y = v.y;
                        this.z = v.z;
                        return this;
                    };
                    Vector3.prototype.add = function(v, w) {
                        if (w !== undefined) {
                            console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
                            return this.addVectors(v, w);
                        }
                        this.x += v.x;
                        this.y += v.y;
                        this.z += v.z;
                        return this;
                    };
                    Vector3.prototype.addScalar = function(s) {
                        this.x += s;
                        this.y += s;
                        this.z += s;
                        return this;
                    };
                    Vector3.prototype.addVectors = function(a, b) {
                        this.x = a.x + b.x;
                        this.y = a.y + b.y;
                        this.z = a.z + b.z;
                        return this;
                    };
                    Vector3.prototype.addScaledVector = function(v, s) {
                        this.x += v.x * s;
                        this.y += v.y * s;
                        this.z += v.z * s;
                        return this;
                    };
                    Vector3.prototype.sub = function(v, w) {
                        if (w !== undefined) {
                            console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
                            return this.subVectors(v, w);
                        }
                        this.x -= v.x;
                        this.y -= v.y;
                        this.z -= v.z;
                        return this;
                    };
                    Vector3.prototype.subScalar = function(s) {
                        this.x -= s;
                        this.y -= s;
                        this.z -= s;
                        return this;
                    };
                    Vector3.prototype.subVectors = function(a, b) {
                        this.x = a.x - b.x;
                        this.y = a.y - b.y;
                        this.z = a.z - b.z;
                        return this;
                    };
                    Vector3.prototype.multiply = function(v, w) {
                        if (w !== undefined) {
                            console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
                            return this.multiplyVectors(v, w);
                        }
                        this.x *= v.x;
                        this.y *= v.y;
                        this.z *= v.z;
                        return this;
                    };
                    Vector3.prototype.multiplyScalar = function(scalar) {
                        this.x *= scalar;
                        this.y *= scalar;
                        this.z *= scalar;
                        return this;
                    };
                    Vector3.prototype.multiplyVectors = function(a, b) {
                        this.x = a.x * b.x;
                        this.y = a.y * b.y;
                        this.z = a.z * b.z;
                        return this;
                    };
                    Vector3.prototype.applyEuler = function(euler) {
                        if (!(euler && euler.isEuler)) {
                            console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
                        }
                        return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
                    };
                    Vector3.prototype.applyAxisAngle = function(axis, angle) {
                        return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
                    };
                    Vector3.prototype.applyMatrix3 = function(m) {
                        var x = this.x,
                            y = this.y,
                            z = this.z;
                        var e = m.elements;
                        this.x = e[0] * x + e[3] * y + e[6] * z;
                        this.y = e[1] * x + e[4] * y + e[7] * z;
                        this.z = e[2] * x + e[5] * y + e[8] * z;
                        return this;
                    };
                    Vector3.prototype.applyNormalMatrix = function(m) {
                        return this.applyMatrix3(m).normalize();
                    };
                    Vector3.prototype.applyMatrix4 = function(m) {
                        var x = this.x,
                            y = this.y,
                            z = this.z;
                        var e = m.elements;
                        var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
                        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
                        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
                        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
                        return this;
                    };
                    Vector3.prototype.applyQuaternion = function(q) {
                        var x = this.x,
                            y = this.y,
                            z = this.z;
                        var qx = q.x,
                            qy = q.y,
                            qz = q.z,
                            qw = q.w;
                        // calculate quat * vector
                        var ix = qw * x + qy * z - qz * y;
                        var iy = qw * y + qz * x - qx * z;
                        var iz = qw * z + qx * y - qy * x;
                        var iw = -qx * x - qy * y - qz * z;
                        // calculate result * inverse quat
                        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
                        return this;
                    };
                    Vector3.prototype.project = function(camera) {
                        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
                    };
                    Vector3.prototype.unproject = function(camera) {
                        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
                    };
                    Vector3.prototype.transformDirection = function(m) {
                        // input: THREE.Matrix4 affine matrix
                        // vector interpreted as a direction
                        var x = this.x,
                            y = this.y,
                            z = this.z;
                        var e = m.elements;
                        this.x = e[0] * x + e[4] * y + e[8] * z;
                        this.y = e[1] * x + e[5] * y + e[9] * z;
                        this.z = e[2] * x + e[6] * y + e[10] * z;
                        return this.normalize();
                    };
                    Vector3.prototype.divide = function(v) {
                        this.x /= v.x;
                        this.y /= v.y;
                        this.z /= v.z;
                        return this;
                    };
                    Vector3.prototype.divideScalar = function(scalar) {
                        return this.multiplyScalar(1 / scalar);
                    };
                    Vector3.prototype.min = function(v) {
                        this.x = Math.min(this.x, v.x);
                        this.y = Math.min(this.y, v.y);
                        this.z = Math.min(this.z, v.z);
                        return this;
                    };
                    Vector3.prototype.max = function(v) {
                        this.x = Math.max(this.x, v.x);
                        this.y = Math.max(this.y, v.y);
                        this.z = Math.max(this.z, v.z);
                        return this;
                    };
                    Vector3.prototype.clamp = function(min, max) {
                        // assumes min < max, componentwise
                        this.x = Math.max(min.x, Math.min(max.x, this.x));
                        this.y = Math.max(min.y, Math.min(max.y, this.y));
                        this.z = Math.max(min.z, Math.min(max.z, this.z));
                        return this;
                    };
                    Vector3.prototype.clampScalar = function(minVal, maxVal) {
                        this.x = Math.max(minVal, Math.min(maxVal, this.x));
                        this.y = Math.max(minVal, Math.min(maxVal, this.y));
                        this.z = Math.max(minVal, Math.min(maxVal, this.z));
                        return this;
                    };
                    Vector3.prototype.clampLength = function(min, max) {
                        var length = this.length();
                        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
                    };
                    Vector3.prototype.floor = function() {
                        this.x = Math.floor(this.x);
                        this.y = Math.floor(this.y);
                        this.z = Math.floor(this.z);
                        return this;
                    };
                    Vector3.prototype.ceil = function() {
                        this.x = Math.ceil(this.x);
                        this.y = Math.ceil(this.y);
                        this.z = Math.ceil(this.z);
                        return this;
                    };
                    Vector3.prototype.round = function() {
                        this.x = Math.round(this.x);
                        this.y = Math.round(this.y);
                        this.z = Math.round(this.z);
                        return this;
                    };
                    Vector3.prototype.roundToZero = function() {
                        this.x = (this.x < 0) ? Math.ceil(this.x) : Math.floor(this.x);
                        this.y = (this.y < 0) ? Math.ceil(this.y) : Math.floor(this.y);
                        this.z = (this.z < 0) ? Math.ceil(this.z) : Math.floor(this.z);
                        return this;
                    };
                    Vector3.prototype.negate = function() {
                        this.x = -this.x;
                        this.y = -this.y;
                        this.z = -this.z;
                        return this;
                    };
                    Vector3.prototype.dot = function(v) {
                        return this.x * v.x + this.y * v.y + this.z * v.z;
                    };
                    // TODO lengthSquared?
                    Vector3.prototype.lengthSq = function() {
                        return this.x * this.x + this.y * this.y + this.z * this.z;
                    };
                    Vector3.prototype.length = function() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
                    };
                    Vector3.prototype.manhattanLength = function() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
                    };
                    Vector3.prototype.normalize = function() {
                        return this.divideScalar(this.length() || 1);
                    };
                    Vector3.prototype.setLength = function(length) {
                        return this.normalize().multiplyScalar(length);
                    };
                    Vector3.prototype.lerp = function(v, alpha) {
                        this.x += (v.x - this.x) * alpha;
                        this.y += (v.y - this.y) * alpha;
                        this.z += (v.z - this.z) * alpha;
                        return this;
                    };
                    Vector3.prototype.lerpVectors = function(v1, v2, alpha) {
                        this.x = v1.x + (v2.x - v1.x) * alpha;
                        this.y = v1.y + (v2.y - v1.y) * alpha;
                        this.z = v1.z + (v2.z - v1.z) * alpha;
                        return this;
                    };
                    Vector3.prototype.cross = function(v, w) {
                        if (w !== undefined) {
                            console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
                            return this.crossVectors(v, w);
                        }
                        return this.crossVectors(this, v);
                    };
                    Vector3.prototype.crossVectors = function(a, b) {
                        var ax = a.x,
                            ay = a.y,
                            az = a.z;
                        var bx = b.x,
                            by = b.y,
                            bz = b.z;
                        this.x = ay * bz - az * by;
                        this.y = az * bx - ax * bz;
                        this.z = ax * by - ay * bx;
                        return this;
                    };
                    Vector3.prototype.projectOnVector = function(v) {
                        var denominator = v.lengthSq();
                        if (denominator === 0)
                            return this.set(0, 0, 0);
                        var scalar = v.dot(this) / denominator;
                        return this.copy(v).multiplyScalar(scalar);
                    };
                    Vector3.prototype.projectOnPlane = function(planeNormal) {
                        _vector$c.copy(this).projectOnVector(planeNormal);
                        return this.sub(_vector$c);
                    };
                    Vector3.prototype.reflect = function(normal) {
                        // reflect incident vector off plane orthogonal to normal
                        // normal is assumed to have unit length
                        return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
                    };
                    Vector3.prototype.angleTo = function(v) {
                        var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
                        if (denominator === 0)
                            return Math.PI / 2;
                        var theta = this.dot(v) / denominator;
                        // clamp, to handle numerical problems
                        return Math.acos(clamp(theta, -1, 1));
                    };
                    Vector3.prototype.distanceTo = function(v) {
                        return Math.sqrt(this.distanceToSquared(v));
                    };
                    Vector3.prototype.distanceToSquared = function(v) {
                        var dx = this.x - v.x,
                            dy = this.y - v.y,
                            dz = this.z - v.z;
                        return dx * dx + dy * dy + dz * dz;
                    };
                    Vector3.prototype.manhattanDistanceTo = function(v) {
                        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
                    };
                    Vector3.prototype.setFromSpherical = function(s) {
                        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
                    };
                    Vector3.prototype.setFromSphericalCoords = function(radius, phi, theta) {
                        var sinPhiRadius = Math.sin(phi) * radius;
                        this.x = sinPhiRadius * Math.sin(theta);
                        this.y = Math.cos(phi) * radius;
                        this.z = sinPhiRadius * Math.cos(theta);
                        return this;
                    };
                    Vector3.prototype.setFromCylindrical = function(c) {
                        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
                    };
                    Vector3.prototype.setFromCylindricalCoords = function(radius, theta, y) {
                        this.x = radius * Math.sin(theta);
                        this.y = y;
                        this.z = radius * Math.cos(theta);
                        return this;
                    };
                    Vector3.prototype.setFromMatrixPosition = function(m) {
                        var e = m.elements;
                        this.x = e[12];
                        this.y = e[13];
                        this.z = e[14];
                        return this;
                    };
                    Vector3.prototype.setFromMatrixScale = function(m) {
                        var sx = this.setFromMatrixColumn(m, 0).length();
                        var sy = this.setFromMatrixColumn(m, 1).length();
                        var sz = this.setFromMatrixColumn(m, 2).length();
                        this.x = sx;
                        this.y = sy;
                        this.z = sz;
                        return this;
                    };
                    Vector3.prototype.setFromMatrixColumn = function(m, index) {
                        return this.fromArray(m.elements, index * 4);
                    };
                    Vector3.prototype.setFromMatrix3Column = function(m, index) {
                        return this.fromArray(m.elements, index * 3);
                    };
                    Vector3.prototype.setFromEuler = function(e) {
                        this.x = e._x;
                        this.y = e._y;
                        this.z = e._z;
                        return this;
                    };
                    Vector3.prototype.equals = function(v) {
                        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z));
                    };
                    Vector3.prototype.fromArray = function(array, offset) {
                        if (offset === void 0) {
                            offset = 0;
                        }
                        this.x = array[offset];
                        this.y = array[offset + 1];
                        this.z = array[offset + 2];
                        return this;
                    };
                    Vector3.prototype.toArray = function(array, offset) {
                        if (array === void 0) {
                            array = [];
                        }
                        if (offset === void 0) {
                            offset = 0;
                        }
                        array[offset] = this.x;
                        array[offset + 1] = this.y;
                        array[offset + 2] = this.z;
                        return array;
                    };
                    Vector3.prototype.fromBufferAttribute = function(attribute, index, offset) {
                        if (offset !== undefined) {
                            console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
                        }
                        this.x = attribute.getX(index);
                        this.y = attribute.getY(index);
                        this.z = attribute.getZ(index);
                        return this;
                    };
                    Vector3.prototype.random = function() {
                        this.x = Math.random();
                        this.y = Math.random();
                        this.z = Math.random();
                        return this;
                    };
                    Vector3.prototype.randomDirection = function() {
                        // Derived from https://mathworld.wolfram.com/SpherePointPicking.html
                        var u = (Math.random() - 0.5) * 2;
                        var t = Math.random() * Math.PI * 2;
                        var f = Math.sqrt(1 - Math.pow(u, 2));
                        this.x = f * Math.cos(t);
                        this.y = f * Math.sin(t);
                        this.z = u;
                        return this;
                    };
                    Vector3.prototype[Symbol.iterator] = function() {
                        return __generator(this, function(_a) {
                            switch (_a.label) {
                                case 0:
                                    return [4 /*yield*/ , this.x];
                                case 1:
                                    _a.sent();
                                    return [4 /*yield*/ , this.y];
                                case 2:
                                    _a.sent();
                                    return [4 /*yield*/ , this.z];
                                case 3:
                                    _a.sent();
                                    return [2 /*return*/ ];
                            }
                        });
                    };
                    return Vector3;
                }());
                Vector3.prototype.isVector3 = true;
                var _vector$c = /*@__PURE__*/ new Vector3();
                var _quaternion$4 = /*@__PURE__*/ new Quaternion();
                var Box3 = /** @class */ (function() {
                    function Box3(min, max) {
                        if (min === void 0) {
                            min = new Vector3(+Infinity, +Infinity, +Infinity);
                        }
                        if (max === void 0) {
                            max = new Vector3(-Infinity, -Infinity, -Infinity);
                        }
                        this.min = min;
                        this.max = max;
                    }
                    Box3.prototype.set = function(min, max) {
                        this.min.copy(min);
                        this.max.copy(max);
                        return this;
                    };
                    Box3.prototype.setFromArray = function(array) {
                        var minX = +Infinity;
                        var minY = +Infinity;
                        var minZ = +Infinity;
                        var maxX = -Infinity;
                        var maxY = -Infinity;
                        var maxZ = -Infinity;
                        for (var i = 0, l = array.length; i < l; i += 3) {
                            var x = array[i];
                            var y = array[i + 1];
                            var z = array[i + 2];
                            if (x < minX)
                                minX = x;
                            if (y < minY)
                                minY = y;
                            if (z < minZ)
                                minZ = z;
                            if (x > maxX)
                                maxX = x;
                            if (y > maxY)
                                maxY = y;
                            if (z > maxZ)
                                maxZ = z;
                        }
                        this.min.set(minX, minY, minZ);
                        this.max.set(maxX, maxY, maxZ);
                        return this;
                    };
                    Box3.prototype.setFromBufferAttribute = function(attribute) {
                        var minX = +Infinity;
                        var minY = +Infinity;
                        var minZ = +Infinity;
                        var maxX = -Infinity;
                        var maxY = -Infinity;
                        var maxZ = -Infinity;
                        for (var i = 0, l = attribute.count; i < l; i++) {
                            var x = attribute.getX(i);
                            var y = attribute.getY(i);
                            var z = attribute.getZ(i);
                            if (x < minX)
                                minX = x;
                            if (y < minY)
                                minY = y;
                            if (z < minZ)
                                minZ = z;
                            if (x > maxX)
                                maxX = x;
                            if (y > maxY)
                                maxY = y;
                            if (z > maxZ)
                                maxZ = z;
                        }
                        this.min.set(minX, minY, minZ);
                        this.max.set(maxX, maxY, maxZ);
                        return this;
                    };
                    Box3.prototype.setFromPoints = function(points) {
                        this.makeEmpty();
                        for (var i = 0, il = points.length; i < il; i++) {
                            this.expandByPoint(points[i]);
                        }
                        return this;
                    };
                    Box3.prototype.setFromCenterAndSize = function(center, size) {
                        var halfSize = _vector$b.copy(size).multiplyScalar(0.5);
                        this.min.copy(center).sub(halfSize);
                        this.max.copy(center).add(halfSize);
                        return this;
                    };
                    Box3.prototype.setFromObject = function(object, precise) {
                        if (precise === void 0) {
                            precise = false;
                        }
                        this.makeEmpty();
                        return this.expandByObject(object, precise);
                    };
                    Box3.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    Box3.prototype.copy = function(box) {
                        this.min.copy(box.min);
                        this.max.copy(box.max);
                        return this;
                    };
                    Box3.prototype.makeEmpty = function() {
                        this.min.x = this.min.y = this.min.z = +Infinity;
                        this.max.x = this.max.y = this.max.z = -Infinity;
                        return this;
                    };
                    Box3.prototype.isEmpty = function() {
                        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
                        return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z);
                    };
                    Box3.prototype.getCenter = function(target) {
                        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
                    };
                    Box3.prototype.getSize = function(target) {
                        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
                    };
                    Box3.prototype.expandByPoint = function(point) {
                        this.min.min(point);
                        this.max.max(point);
                        return this;
                    };
                    Box3.prototype.expandByVector = function(vector) {
                        this.min.sub(vector);
                        this.max.add(vector);
                        return this;
                    };
                    Box3.prototype.expandByScalar = function(scalar) {
                        this.min.addScalar(-scalar);
                        this.max.addScalar(scalar);
                        return this;
                    };
                    Box3.prototype.expandByObject = function(object, precise) {
                        // Computes the world-axis-aligned bounding box of an object (including its children),
                        // accounting for both the object's, and children's, world transforms
                        if (precise === void 0) {
                            precise = false;
                        }
                        object.updateWorldMatrix(false, false);
                        var geometry = object.geometry;
                        if (geometry !== undefined) {
                            if (precise && geometry.attributes != undefined && geometry.attributes.position !== undefined) {
                                var position = geometry.attributes.position;
                                for (var i = 0, l = position.count; i < l; i++) {
                                    _vector$b.fromBufferAttribute(position, i).applyMatrix4(object.matrixWorld);
                                    this.expandByPoint(_vector$b);
                                }
                            } else {
                                if (geometry.boundingBox === null) {
                                    geometry.computeBoundingBox();
                                }
                                _box$3.copy(geometry.boundingBox);
                                _box$3.applyMatrix4(object.matrixWorld);
                                this.union(_box$3);
                            }
                        }
                        var children = object.children;
                        for (var i = 0, l = children.length; i < l; i++) {
                            this.expandByObject(children[i], precise);
                        }
                        return this;
                    };
                    Box3.prototype.containsPoint = function(point) {
                        return point.x < this.min.x || point.x > this.max.x ||
                            point.y < this.min.y || point.y > this.max.y ||
                            point.z < this.min.z || point.z > this.max.z ? false : true;
                    };
                    Box3.prototype.containsBox = function(box) {
                        return this.min.x <= box.min.x && box.max.x <= this.max.x &&
                            this.min.y <= box.min.y && box.max.y <= this.max.y &&
                            this.min.z <= box.min.z && box.max.z <= this.max.z;
                    };
                    Box3.prototype.getParameter = function(point, target) {
                        // This can potentially have a divide by zero if the box
                        // has a size dimension of 0.
                        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
                    };
                    Box3.prototype.intersectsBox = function(box) {
                        // using 6 splitting planes to rule out intersections.
                        return box.max.x < this.min.x || box.min.x > this.max.x ||
                            box.max.y < this.min.y || box.min.y > this.max.y ||
                            box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
                    };
                    Box3.prototype.intersectsSphere = function(sphere) {
                        // Find the point on the AABB closest to the sphere center.
                        this.clampPoint(sphere.center, _vector$b);
                        // If that point is inside the sphere, the AABB and sphere intersect.
                        return _vector$b.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius);
                    };
                    Box3.prototype.intersectsPlane = function(plane) {
                        // We compute the minimum and maximum dot product values. If those values
                        // are on the same side (back or front) of the plane, then there is no intersection.
                        var min, max;
                        if (plane.normal.x > 0) {
                            min = plane.normal.x * this.min.x;
                            max = plane.normal.x * this.max.x;
                        } else {
                            min = plane.normal.x * this.max.x;
                            max = plane.normal.x * this.min.x;
                        }
                        if (plane.normal.y > 0) {
                            min += plane.normal.y * this.min.y;
                            max += plane.normal.y * this.max.y;
                        } else {
                            min += plane.normal.y * this.max.y;
                            max += plane.normal.y * this.min.y;
                        }
                        if (plane.normal.z > 0) {
                            min += plane.normal.z * this.min.z;
                            max += plane.normal.z * this.max.z;
                        } else {
                            min += plane.normal.z * this.max.z;
                            max += plane.normal.z * this.min.z;
                        }
                        return (min <= -plane.constant && max >= -plane.constant);
                    };
                    Box3.prototype.intersectsTriangle = function(triangle) {
                        if (this.isEmpty()) {
                            return false;
                        }
                        // compute box center and extents
                        this.getCenter(_center);
                        _extents.subVectors(this.max, _center);
                        // translate triangle to aabb origin
                        _v0$2.subVectors(triangle.a, _center);
                        _v1$7.subVectors(triangle.b, _center);
                        _v2$3.subVectors(triangle.c, _center);
                        // compute edge vectors for triangle
                        _f0.subVectors(_v1$7, _v0$2);
                        _f1.subVectors(_v2$3, _v1$7);
                        _f2.subVectors(_v0$2, _v2$3);
                        // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
                        // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
                        // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
                        var axes = [
                            0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y,
                            _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0
                        ];
                        if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
                            return false;
                        }
                        // test 3 face normals from the aabb
                        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
                        if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
                            return false;
                        }
                        // finally testing the face normal of the triangle
                        // use already existing triangle edge vectors here
                        _triangleNormal.crossVectors(_f0, _f1);
                        axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
                        return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
                    };
                    Box3.prototype.clampPoint = function(point, target) {
                        return target.copy(point).clamp(this.min, this.max);
                    };
                    Box3.prototype.distanceToPoint = function(point) {
                        var clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
                        return clampedPoint.sub(point).length();
                    };
                    Box3.prototype.getBoundingSphere = function(target) {
                        this.getCenter(target.center);
                        target.radius = this.getSize(_vector$b).length() * 0.5;
                        return target;
                    };
                    Box3.prototype.intersect = function(box) {
                        this.min.max(box.min);
                        this.max.min(box.max);
                        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
                        if (this.isEmpty())
                            this.makeEmpty();
                        return this;
                    };
                    Box3.prototype.union = function(box) {
                        this.min.min(box.min);
                        this.max.max(box.max);
                        return this;
                    };
                    Box3.prototype.applyMatrix4 = function(matrix) {
                        // transform of empty box is an empty box.
                        if (this.isEmpty())
                            return this;
                        // NOTE: I am using a binary pattern to specify all 2^3 combinations below
                        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
                        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
                        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
                        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
                        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
                        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
                        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
                        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111
                        this.setFromPoints(_points);
                        return this;
                    };
                    Box3.prototype.translate = function(offset) {
                        this.min.add(offset);
                        this.max.add(offset);
                        return this;
                    };
                    Box3.prototype.equals = function(box) {
                        return box.min.equals(this.min) && box.max.equals(this.max);
                    };
                    return Box3;
                }());
                Box3.prototype.isBox3 = true;
                var _points = [
                    /*@__PURE__*/
                    new Vector3(),
                    /*@__PURE__*/
                    new Vector3(),
                    /*@__PURE__*/
                    new Vector3(),
                    /*@__PURE__*/
                    new Vector3(),
                    /*@__PURE__*/
                    new Vector3(),
                    /*@__PURE__*/
                    new Vector3(),
                    /*@__PURE__*/
                    new Vector3(),
                    /*@__PURE__*/
                    new Vector3()
                ];
                var _vector$b = /*@__PURE__*/ new Vector3();
                var _box$3 = /*@__PURE__*/ new Box3();
                // triangle centered vertices
                var _v0$2 = /*@__PURE__*/ new Vector3();
                var _v1$7 = /*@__PURE__*/ new Vector3();
                var _v2$3 = /*@__PURE__*/ new Vector3();
                // triangle edge vectors
                var _f0 = /*@__PURE__*/ new Vector3();
                var _f1 = /*@__PURE__*/ new Vector3();
                var _f2 = /*@__PURE__*/ new Vector3();
                var _center = /*@__PURE__*/ new Vector3();
                var _extents = /*@__PURE__*/ new Vector3();
                var _triangleNormal = /*@__PURE__*/ new Vector3();
                var _testAxis = /*@__PURE__*/ new Vector3();

                function satForAxes(axes, v0, v1, v2, extents) {
                    for (var i = 0, j = axes.length - 3; i <= j; i += 3) {
                        _testAxis.fromArray(axes, i);
                        // project the aabb onto the separating axis
                        var r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
                        // project all 3 vertices of the triangle onto the separating axis
                        var p0 = v0.dot(_testAxis);
                        var p1 = v1.dot(_testAxis);
                        var p2 = v2.dot(_testAxis);
                        // actual test, basically see if either of the most extreme of the triangle points intersects r
                        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
                            // points of the projected triangle are outside the projected half-length of the aabb
                            // the axis is separating and we can exit
                            return false;
                        }
                    }
                    return true;
                }
                var _box$2 = /*@__PURE__*/ new Box3();
                var _v1$6 = /*@__PURE__*/ new Vector3();
                var _toFarthestPoint = /*@__PURE__*/ new Vector3();
                var _toPoint = /*@__PURE__*/ new Vector3();
                var Sphere = /** @class */ (function() {
                    function Sphere(center, radius) {
                        if (center === void 0) {
                            center = new Vector3();
                        }
                        if (radius === void 0) {
                            radius = -1;
                        }
                        this.center = center;
                        this.radius = radius;
                    }
                    Sphere.prototype.set = function(center, radius) {
                        this.center.copy(center);
                        this.radius = radius;
                        return this;
                    };
                    Sphere.prototype.setFromPoints = function(points, optionalCenter) {
                        var center = this.center;
                        if (optionalCenter !== undefined) {
                            center.copy(optionalCenter);
                        } else {
                            _box$2.setFromPoints(points).getCenter(center);
                        }
                        var maxRadiusSq = 0;
                        for (var i = 0, il = points.length; i < il; i++) {
                            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
                        }
                        this.radius = Math.sqrt(maxRadiusSq);
                        return this;
                    };
                    Sphere.prototype.copy = function(sphere) {
                        this.center.copy(sphere.center);
                        this.radius = sphere.radius;
                        return this;
                    };
                    Sphere.prototype.isEmpty = function() {
                        return (this.radius < 0);
                    };
                    Sphere.prototype.makeEmpty = function() {
                        this.center.set(0, 0, 0);
                        this.radius = -1;
                        return this;
                    };
                    Sphere.prototype.containsPoint = function(point) {
                        return (point.distanceToSquared(this.center) <= (this.radius * this.radius));
                    };
                    Sphere.prototype.distanceToPoint = function(point) {
                        return (point.distanceTo(this.center) - this.radius);
                    };
                    Sphere.prototype.intersectsSphere = function(sphere) {
                        var radiusSum = this.radius + sphere.radius;
                        return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum);
                    };
                    Sphere.prototype.intersectsBox = function(box) {
                        return box.intersectsSphere(this);
                    };
                    Sphere.prototype.intersectsPlane = function(plane) {
                        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
                    };
                    Sphere.prototype.clampPoint = function(point, target) {
                        var deltaLengthSq = this.center.distanceToSquared(point);
                        target.copy(point);
                        if (deltaLengthSq > (this.radius * this.radius)) {
                            target.sub(this.center).normalize();
                            target.multiplyScalar(this.radius).add(this.center);
                        }
                        return target;
                    };
                    Sphere.prototype.getBoundingBox = function(target) {
                        if (this.isEmpty()) {
                            // Empty sphere produces empty bounding box
                            target.makeEmpty();
                            return target;
                        }
                        target.set(this.center, this.center);
                        target.expandByScalar(this.radius);
                        return target;
                    };
                    Sphere.prototype.applyMatrix4 = function(matrix) {
                        this.center.applyMatrix4(matrix);
                        this.radius = this.radius * matrix.getMaxScaleOnAxis();
                        return this;
                    };
                    Sphere.prototype.translate = function(offset) {
                        this.center.add(offset);
                        return this;
                    };
                    Sphere.prototype.expandByPoint = function(point) {
                        // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
                        _toPoint.subVectors(point, this.center);
                        var lengthSq = _toPoint.lengthSq();
                        if (lengthSq > (this.radius * this.radius)) {
                            var length = Math.sqrt(lengthSq);
                            var missingRadiusHalf = (length - this.radius) * 0.5;
                            // Nudge this sphere towards the target point. Add half the missing distance to radius,
                            // and the other half to position. This gives a tighter enclosure, instead of if
                            // the whole missing distance were just added to radius.
                            this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
                            this.radius += missingRadiusHalf;
                        }
                        return this;
                    };
                    Sphere.prototype.union = function(sphere) {
                        // from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
                        // To enclose another sphere into this sphere, we only need to enclose two points:
                        // 1) Enclose the farthest point on the other sphere into this sphere.
                        // 2) Enclose the opposite point of the farthest point into this sphere.
                        if (this.center.equals(sphere.center) === true) {
                            _toFarthestPoint.set(0, 0, 1).multiplyScalar(sphere.radius);
                        } else {
                            _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
                        }
                        this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
                        this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
                        return this;
                    };
                    Sphere.prototype.equals = function(sphere) {
                        return sphere.center.equals(this.center) && (sphere.radius === this.radius);
                    };
                    Sphere.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    return Sphere;
                }());
                var _vector$a = /*@__PURE__*/ new Vector3();
                var _segCenter = /*@__PURE__*/ new Vector3();
                var _segDir = /*@__PURE__*/ new Vector3();
                var _diff = /*@__PURE__*/ new Vector3();
                var _edge1 = /*@__PURE__*/ new Vector3();
                var _edge2 = /*@__PURE__*/ new Vector3();
                var _normal$1 = /*@__PURE__*/ new Vector3();
                var Ray = /** @class */ (function() {
                    function Ray(origin, direction) {
                        if (origin === void 0) {
                            origin = new Vector3();
                        }
                        if (direction === void 0) {
                            direction = new Vector3(0, 0, -1);
                        }
                        this.origin = origin;
                        this.direction = direction;
                    }
                    Ray.prototype.set = function(origin, direction) {
                        this.origin.copy(origin);
                        this.direction.copy(direction);
                        return this;
                    };
                    Ray.prototype.copy = function(ray) {
                        this.origin.copy(ray.origin);
                        this.direction.copy(ray.direction);
                        return this;
                    };
                    Ray.prototype.at = function(t, target) {
                        return target.copy(this.direction).multiplyScalar(t).add(this.origin);
                    };
                    Ray.prototype.lookAt = function(v) {
                        this.direction.copy(v).sub(this.origin).normalize();
                        return this;
                    };
                    Ray.prototype.recast = function(t) {
                        this.origin.copy(this.at(t, _vector$a));
                        return this;
                    };
                    Ray.prototype.closestPointToPoint = function(point, target) {
                        target.subVectors(point, this.origin);
                        var directionDistance = target.dot(this.direction);
                        if (directionDistance < 0) {
                            return target.copy(this.origin);
                        }
                        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
                    };
                    Ray.prototype.distanceToPoint = function(point) {
                        return Math.sqrt(this.distanceSqToPoint(point));
                    };
                    Ray.prototype.distanceSqToPoint = function(point) {
                        var directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
                        // point behind the ray
                        if (directionDistance < 0) {
                            return this.origin.distanceToSquared(point);
                        }
                        _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
                        return _vector$a.distanceToSquared(point);
                    };
                    Ray.prototype.distanceSqToSegment = function(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
                        // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
                        // It returns the min distance between the ray and the segment
                        // defined by v0 and v1
                        // It can also set two optional targets :
                        // - The closest point on the ray
                        // - The closest point on the segment
                        _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
                        _segDir.copy(v1).sub(v0).normalize();
                        _diff.copy(this.origin).sub(_segCenter);
                        var segExtent = v0.distanceTo(v1) * 0.5;
                        var a01 = -this.direction.dot(_segDir);
                        var b0 = _diff.dot(this.direction);
                        var b1 = -_diff.dot(_segDir);
                        var c = _diff.lengthSq();
                        var det = Math.abs(1 - a01 * a01);
                        var s0, s1, sqrDist, extDet;
                        if (det > 0) {
                            // The ray and segment are not parallel.
                            s0 = a01 * b1 - b0;
                            s1 = a01 * b0 - b1;
                            extDet = segExtent * det;
                            if (s0 >= 0) {
                                if (s1 >= -extDet) {
                                    if (s1 <= extDet) {
                                        // region 0
                                        // Minimum at interior points of ray and segment.
                                        var invDet = 1 / det;
                                        s0 *= invDet;
                                        s1 *= invDet;
                                        sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
                                    } else {
                                        // region 1
                                        s1 = segExtent;
                                        s0 = Math.max(0, -(a01 * s1 + b0));
                                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                                    }
                                } else {
                                    // region 5
                                    s1 = -segExtent;
                                    s0 = Math.max(0, -(a01 * s1 + b0));
                                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                                }
                            } else {
                                if (s1 <= -extDet) {
                                    // region 4
                                    s0 = Math.max(0, -(-a01 * segExtent + b0));
                                    s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                                } else if (s1 <= extDet) {
                                    // region 3
                                    s0 = 0;
                                    s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                                    sqrDist = s1 * (s1 + 2 * b1) + c;
                                } else {
                                    // region 2
                                    s0 = Math.max(0, -(a01 * segExtent + b0));
                                    s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                                }
                            }
                        } else {
                            // Ray and segment are parallel.
                            s1 = (a01 > 0) ? -segExtent : segExtent;
                            s0 = Math.max(0, -(a01 * s1 + b0));
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
                        }
                        if (optionalPointOnRay) {
                            optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
                        }
                        if (optionalPointOnSegment) {
                            optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
                        }
                        return sqrDist;
                    };
                    Ray.prototype.intersectSphere = function(sphere, target) {
                        _vector$a.subVectors(sphere.center, this.origin);
                        var tca = _vector$a.dot(this.direction);
                        var d2 = _vector$a.dot(_vector$a) - tca * tca;
                        var radius2 = sphere.radius * sphere.radius;
                        if (d2 > radius2)
                            return null;
                        var thc = Math.sqrt(radius2 - d2);
                        // t0 = first intersect point - entrance on front of sphere
                        var t0 = tca - thc;
                        // t1 = second intersect point - exit point on back of sphere
                        var t1 = tca + thc;
                        // test to see if both t0 and t1 are behind the ray - if so, return null
                        if (t0 < 0 && t1 < 0)
                            return null;
                        // test to see if t0 is behind the ray:
                        // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
                        // in order to always return an intersect point that is in front of the ray.
                        if (t0 < 0)
                            return this.at(t1, target);
                        // else t0 is in front of the ray, so return the first collision point scaled by t0
                        return this.at(t0, target);
                    };
                    Ray.prototype.intersectsSphere = function(sphere) {
                        return this.distanceSqToPoint(sphere.center) <= (sphere.radius * sphere.radius);
                    };
                    Ray.prototype.distanceToPlane = function(plane) {
                        var denominator = plane.normal.dot(this.direction);
                        if (denominator === 0) {
                            // line is coplanar, return origin
                            if (plane.distanceToPoint(this.origin) === 0) {
                                return 0;
                            }
                            // Null is preferable to undefined since undefined means.... it is undefined
                            return null;
                        }
                        var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
                        // Return if the ray never intersects the plane
                        return t >= 0 ? t : null;
                    };
                    Ray.prototype.intersectPlane = function(plane, target) {
                        var t = this.distanceToPlane(plane);
                        if (t === null) {
                            return null;
                        }
                        return this.at(t, target);
                    };
                    Ray.prototype.intersectsPlane = function(plane) {
                        // check if the ray lies on the plane first
                        var distToPoint = plane.distanceToPoint(this.origin);
                        if (distToPoint === 0) {
                            return true;
                        }
                        var denominator = plane.normal.dot(this.direction);
                        if (denominator * distToPoint < 0) {
                            return true;
                        }
                        // ray origin is behind the plane (and is pointing behind it)
                        return false;
                    };
                    Ray.prototype.intersectBox = function(box, target) {
                        var tmin, tmax, tymin, tymax, tzmin, tzmax;
                        var invdirx = 1 / this.direction.x,
                            invdiry = 1 / this.direction.y,
                            invdirz = 1 / this.direction.z;
                        var origin = this.origin;
                        if (invdirx >= 0) {
                            tmin = (box.min.x - origin.x) * invdirx;
                            tmax = (box.max.x - origin.x) * invdirx;
                        } else {
                            tmin = (box.max.x - origin.x) * invdirx;
                            tmax = (box.min.x - origin.x) * invdirx;
                        }
                        if (invdiry >= 0) {
                            tymin = (box.min.y - origin.y) * invdiry;
                            tymax = (box.max.y - origin.y) * invdiry;
                        } else {
                            tymin = (box.max.y - origin.y) * invdiry;
                            tymax = (box.min.y - origin.y) * invdiry;
                        }
                        if ((tmin > tymax) || (tymin > tmax))
                            return null;
                        // These lines also handle the case where tmin or tmax is NaN
                        // (result of 0 * Infinity). x !== x returns true if x is NaN
                        if (tymin > tmin || tmin !== tmin)
                            tmin = tymin;
                        if (tymax < tmax || tmax !== tmax)
                            tmax = tymax;
                        if (invdirz >= 0) {
                            tzmin = (box.min.z - origin.z) * invdirz;
                            tzmax = (box.max.z - origin.z) * invdirz;
                        } else {
                            tzmin = (box.max.z - origin.z) * invdirz;
                            tzmax = (box.min.z - origin.z) * invdirz;
                        }
                        if ((tmin > tzmax) || (tzmin > tmax))
                            return null;
                        if (tzmin > tmin || tmin !== tmin)
                            tmin = tzmin;
                        if (tzmax < tmax || tmax !== tmax)
                            tmax = tzmax;
                        //return point closest to the ray (positive side)
                        if (tmax < 0)
                            return null;
                        return this.at(tmin >= 0 ? tmin : tmax, target);
                    };
                    Ray.prototype.intersectsBox = function(box) {
                        return this.intersectBox(box, _vector$a) !== null;
                    };
                    Ray.prototype.intersectTriangle = function(a, b, c, backfaceCulling, target) {
                        // Compute the offset origin, edges, and normal.
                        // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
                        _edge1.subVectors(b, a);
                        _edge2.subVectors(c, a);
                        _normal$1.crossVectors(_edge1, _edge2);
                        // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
                        // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
                        //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
                        //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
                        //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
                        var DdN = this.direction.dot(_normal$1);
                        var sign;
                        if (DdN > 0) {
                            if (backfaceCulling)
                                return null;
                            sign = 1;
                        } else if (DdN < 0) {
                            sign = -1;
                            DdN = -DdN;
                        } else {
                            return null;
                        }
                        _diff.subVectors(this.origin, a);
                        var DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
                        // b1 < 0, no intersection
                        if (DdQxE2 < 0) {
                            return null;
                        }
                        var DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
                        // b2 < 0, no intersection
                        if (DdE1xQ < 0) {
                            return null;
                        }
                        // b1+b2 > 1, no intersection
                        if (DdQxE2 + DdE1xQ > DdN) {
                            return null;
                        }
                        // Line intersects triangle, check if ray does.
                        var QdN = -sign * _diff.dot(_normal$1);
                        // t < 0, no intersection
                        if (QdN < 0) {
                            return null;
                        }
                        // Ray intersects triangle.
                        return this.at(QdN / DdN, target);
                    };
                    Ray.prototype.applyMatrix4 = function(matrix4) {
                        this.origin.applyMatrix4(matrix4);
                        this.direction.transformDirection(matrix4);
                        return this;
                    };
                    Ray.prototype.equals = function(ray) {
                        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
                    };
                    Ray.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    return Ray;
                }());
                var Matrix4 = /** @class */ (function() {
                    function Matrix4() {
                        this.elements = [
                            1, 0, 0, 0,
                            0, 1, 0, 0,
                            0, 0, 1, 0,
                            0, 0, 0, 1
                        ];
                        if (arguments.length > 0) {
                            console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
                        }
                    }
                    Matrix4.prototype.set = function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
                        var te = this.elements;
                        te[0] = n11;
                        te[4] = n12;
                        te[8] = n13;
                        te[12] = n14;
                        te[1] = n21;
                        te[5] = n22;
                        te[9] = n23;
                        te[13] = n24;
                        te[2] = n31;
                        te[6] = n32;
                        te[10] = n33;
                        te[14] = n34;
                        te[3] = n41;
                        te[7] = n42;
                        te[11] = n43;
                        te[15] = n44;
                        return this;
                    };
                    Matrix4.prototype.identity = function() {
                        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                        return this;
                    };
                    Matrix4.prototype.clone = function() {
                        return new Matrix4().fromArray(this.elements);
                    };
                    Matrix4.prototype.copy = function(m) {
                        var te = this.elements;
                        var me = m.elements;
                        te[0] = me[0];
                        te[1] = me[1];
                        te[2] = me[2];
                        te[3] = me[3];
                        te[4] = me[4];
                        te[5] = me[5];
                        te[6] = me[6];
                        te[7] = me[7];
                        te[8] = me[8];
                        te[9] = me[9];
                        te[10] = me[10];
                        te[11] = me[11];
                        te[12] = me[12];
                        te[13] = me[13];
                        te[14] = me[14];
                        te[15] = me[15];
                        return this;
                    };
                    Matrix4.prototype.copyPosition = function(m) {
                        var te = this.elements,
                            me = m.elements;
                        te[12] = me[12];
                        te[13] = me[13];
                        te[14] = me[14];
                        return this;
                    };
                    Matrix4.prototype.setFromMatrix3 = function(m) {
                        var me = m.elements;
                        this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
                        return this;
                    };
                    Matrix4.prototype.extractBasis = function(xAxis, yAxis, zAxis) {
                        xAxis.setFromMatrixColumn(this, 0);
                        yAxis.setFromMatrixColumn(this, 1);
                        zAxis.setFromMatrixColumn(this, 2);
                        return this;
                    };
                    Matrix4.prototype.makeBasis = function(xAxis, yAxis, zAxis) {
                        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
                        return this;
                    };
                    Matrix4.prototype.extractRotation = function(m) {
                        // this method does not support reflection matrices
                        var te = this.elements;
                        var me = m.elements;
                        var scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
                        var scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
                        var scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
                        te[0] = me[0] * scaleX;
                        te[1] = me[1] * scaleX;
                        te[2] = me[2] * scaleX;
                        te[3] = 0;
                        te[4] = me[4] * scaleY;
                        te[5] = me[5] * scaleY;
                        te[6] = me[6] * scaleY;
                        te[7] = 0;
                        te[8] = me[8] * scaleZ;
                        te[9] = me[9] * scaleZ;
                        te[10] = me[10] * scaleZ;
                        te[11] = 0;
                        te[12] = 0;
                        te[13] = 0;
                        te[14] = 0;
                        te[15] = 1;
                        return this;
                    };
                    Matrix4.prototype.makeRotationFromEuler = function(euler) {
                        if (!(euler && euler.isEuler)) {
                            console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
                        }
                        var te = this.elements;
                        var x = euler.x,
                            y = euler.y,
                            z = euler.z;
                        var a = Math.cos(x),
                            b = Math.sin(x);
                        var c = Math.cos(y),
                            d = Math.sin(y);
                        var e = Math.cos(z),
                            f = Math.sin(z);
                        if (euler.order === 'XYZ') {
                            var ae = a * e,
                                af = a * f,
                                be = b * e,
                                bf = b * f;
                            te[0] = c * e;
                            te[4] = -c * f;
                            te[8] = d;
                            te[1] = af + be * d;
                            te[5] = ae - bf * d;
                            te[9] = -b * c;
                            te[2] = bf - ae * d;
                            te[6] = be + af * d;
                            te[10] = a * c;
                        } else if (euler.order === 'YXZ') {
                            var ce = c * e,
                                cf = c * f,
                                de = d * e,
                                df = d * f;
                            te[0] = ce + df * b;
                            te[4] = de * b - cf;
                            te[8] = a * d;
                            te[1] = a * f;
                            te[5] = a * e;
                            te[9] = -b;
                            te[2] = cf * b - de;
                            te[6] = df + ce * b;
                            te[10] = a * c;
                        } else if (euler.order === 'ZXY') {
                            var ce = c * e,
                                cf = c * f,
                                de = d * e,
                                df = d * f;
                            te[0] = ce - df * b;
                            te[4] = -a * f;
                            te[8] = de + cf * b;
                            te[1] = cf + de * b;
                            te[5] = a * e;
                            te[9] = df - ce * b;
                            te[2] = -a * d;
                            te[6] = b;
                            te[10] = a * c;
                        } else if (euler.order === 'ZYX') {
                            var ae = a * e,
                                af = a * f,
                                be = b * e,
                                bf = b * f;
                            te[0] = c * e;
                            te[4] = be * d - af;
                            te[8] = ae * d + bf;
                            te[1] = c * f;
                            te[5] = bf * d + ae;
                            te[9] = af * d - be;
                            te[2] = -d;
                            te[6] = b * c;
                            te[10] = a * c;
                        } else if (euler.order === 'YZX') {
                            var ac = a * c,
                                ad = a * d,
                                bc = b * c,
                                bd = b * d;
                            te[0] = c * e;
                            te[4] = bd - ac * f;
                            te[8] = bc * f + ad;
                            te[1] = f;
                            te[5] = a * e;
                            te[9] = -b * e;
                            te[2] = -d * e;
                            te[6] = ad * f + bc;
                            te[10] = ac - bd * f;
                        } else if (euler.order === 'XZY') {
                            var ac = a * c,
                                ad = a * d,
                                bc = b * c,
                                bd = b * d;
                            te[0] = c * e;
                            te[4] = -f;
                            te[8] = d * e;
                            te[1] = ac * f + bd;
                            te[5] = a * e;
                            te[9] = ad * f - bc;
                            te[2] = bc * f - ad;
                            te[6] = b * e;
                            te[10] = bd * f + ac;
                        }
                        // bottom row
                        te[3] = 0;
                        te[7] = 0;
                        te[11] = 0;
                        // last column
                        te[12] = 0;
                        te[13] = 0;
                        te[14] = 0;
                        te[15] = 1;
                        return this;
                    };
                    Matrix4.prototype.makeRotationFromQuaternion = function(q) {
                        return this.compose(_zero, q, _one);
                    };
                    Matrix4.prototype.lookAt = function(eye, target, up) {
                        var te = this.elements;
                        _z.subVectors(eye, target);
                        if (_z.lengthSq() === 0) {
                            // eye and target are in the same position
                            _z.z = 1;
                        }
                        _z.normalize();
                        _x.crossVectors(up, _z);
                        if (_x.lengthSq() === 0) {
                            // up and z are parallel
                            if (Math.abs(up.z) === 1) {
                                _z.x += 0.0001;
                            } else {
                                _z.z += 0.0001;
                            }
                            _z.normalize();
                            _x.crossVectors(up, _z);
                        }
                        _x.normalize();
                        _y.crossVectors(_z, _x);
                        te[0] = _x.x;
                        te[4] = _y.x;
                        te[8] = _z.x;
                        te[1] = _x.y;
                        te[5] = _y.y;
                        te[9] = _z.y;
                        te[2] = _x.z;
                        te[6] = _y.z;
                        te[10] = _z.z;
                        return this;
                    };
                    Matrix4.prototype.multiply = function(m, n) {
                        if (n !== undefined) {
                            console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
                            return this.multiplyMatrices(m, n);
                        }
                        return this.multiplyMatrices(this, m);
                    };
                    Matrix4.prototype.premultiply = function(m) {
                        return this.multiplyMatrices(m, this);
                    };
                    Matrix4.prototype.multiplyMatrices = function(a, b) {
                        var ae = a.elements;
                        var be = b.elements;
                        var te = this.elements;
                        var a11 = ae[0],
                            a12 = ae[4],
                            a13 = ae[8],
                            a14 = ae[12];
                        var a21 = ae[1],
                            a22 = ae[5],
                            a23 = ae[9],
                            a24 = ae[13];
                        var a31 = ae[2],
                            a32 = ae[6],
                            a33 = ae[10],
                            a34 = ae[14];
                        var a41 = ae[3],
                            a42 = ae[7],
                            a43 = ae[11],
                            a44 = ae[15];
                        var b11 = be[0],
                            b12 = be[4],
                            b13 = be[8],
                            b14 = be[12];
                        var b21 = be[1],
                            b22 = be[5],
                            b23 = be[9],
                            b24 = be[13];
                        var b31 = be[2],
                            b32 = be[6],
                            b33 = be[10],
                            b34 = be[14];
                        var b41 = be[3],
                            b42 = be[7],
                            b43 = be[11],
                            b44 = be[15];
                        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
                        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
                        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
                        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
                        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
                        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
                        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
                        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
                        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
                        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
                        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
                        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
                        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
                        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
                        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
                        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
                        return this;
                    };
                    Matrix4.prototype.multiplyScalar = function(s) {
                        var te = this.elements;
                        te[0] *= s;
                        te[4] *= s;
                        te[8] *= s;
                        te[12] *= s;
                        te[1] *= s;
                        te[5] *= s;
                        te[9] *= s;
                        te[13] *= s;
                        te[2] *= s;
                        te[6] *= s;
                        te[10] *= s;
                        te[14] *= s;
                        te[3] *= s;
                        te[7] *= s;
                        te[11] *= s;
                        te[15] *= s;
                        return this;
                    };
                    Matrix4.prototype.determinant = function() {
                        var te = this.elements;
                        var n11 = te[0],
                            n12 = te[4],
                            n13 = te[8],
                            n14 = te[12];
                        var n21 = te[1],
                            n22 = te[5],
                            n23 = te[9],
                            n24 = te[13];
                        var n31 = te[2],
                            n32 = te[6],
                            n33 = te[10],
                            n34 = te[14];
                        var n41 = te[3],
                            n42 = te[7],
                            n43 = te[11],
                            n44 = te[15];
                        //TODO: make this more efficient
                        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
                        return (n41 * (+n14 * n23 * n32 -
                                n13 * n24 * n32 -
                                n14 * n22 * n33 +
                                n12 * n24 * n33 +
                                n13 * n22 * n34 -
                                n12 * n23 * n34) +
                            n42 * (+n11 * n23 * n34 -
                                n11 * n24 * n33 +
                                n14 * n21 * n33 -
                                n13 * n21 * n34 +
                                n13 * n24 * n31 -
                                n14 * n23 * n31) +
                            n43 * (+n11 * n24 * n32 -
                                n11 * n22 * n34 -
                                n14 * n21 * n32 +
                                n12 * n21 * n34 +
                                n14 * n22 * n31 -
                                n12 * n24 * n31) +
                            n44 * (-n13 * n22 * n31 -
                                n11 * n23 * n32 +
                                n11 * n22 * n33 +
                                n13 * n21 * n32 -
                                n12 * n21 * n33 +
                                n12 * n23 * n31));
                    };
                    Matrix4.prototype.transpose = function() {
                        var te = this.elements;
                        var tmp;
                        tmp = te[1];
                        te[1] = te[4];
                        te[4] = tmp;
                        tmp = te[2];
                        te[2] = te[8];
                        te[8] = tmp;
                        tmp = te[6];
                        te[6] = te[9];
                        te[9] = tmp;
                        tmp = te[3];
                        te[3] = te[12];
                        te[12] = tmp;
                        tmp = te[7];
                        te[7] = te[13];
                        te[13] = tmp;
                        tmp = te[11];
                        te[11] = te[14];
                        te[14] = tmp;
                        return this;
                    };
                    Matrix4.prototype.setPosition = function(x, y, z) {
                        var te = this.elements;
                        if (x.isVector3) {
                            te[12] = x.x;
                            te[13] = x.y;
                            te[14] = x.z;
                        } else {
                            te[12] = x;
                            te[13] = y;
                            te[14] = z;
                        }
                        return this;
                    };
                    Matrix4.prototype.invert = function() {
                        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
                        var te = this.elements,
                            n11 = te[0],
                            n21 = te[1],
                            n31 = te[2],
                            n41 = te[3],
                            n12 = te[4],
                            n22 = te[5],
                            n32 = te[6],
                            n42 = te[7],
                            n13 = te[8],
                            n23 = te[9],
                            n33 = te[10],
                            n43 = te[11],
                            n14 = te[12],
                            n24 = te[13],
                            n34 = te[14],
                            n44 = te[15],
                            t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
                            t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
                            t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
                            t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
                        var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
                        if (det === 0)
                            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                        var detInv = 1 / det;
                        te[0] = t11 * detInv;
                        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
                        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
                        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
                        te[4] = t12 * detInv;
                        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
                        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
                        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
                        te[8] = t13 * detInv;
                        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
                        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
                        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
                        te[12] = t14 * detInv;
                        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
                        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
                        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
                        return this;
                    };
                    Matrix4.prototype.scale = function(v) {
                        var te = this.elements;
                        var x = v.x,
                            y = v.y,
                            z = v.z;
                        te[0] *= x;
                        te[4] *= y;
                        te[8] *= z;
                        te[1] *= x;
                        te[5] *= y;
                        te[9] *= z;
                        te[2] *= x;
                        te[6] *= y;
                        te[10] *= z;
                        te[3] *= x;
                        te[7] *= y;
                        te[11] *= z;
                        return this;
                    };
                    Matrix4.prototype.getMaxScaleOnAxis = function() {
                        var te = this.elements;
                        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
                        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
                        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
                        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
                    };
                    Matrix4.prototype.makeTranslation = function(x, y, z) {
                        this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
                        return this;
                    };
                    Matrix4.prototype.makeRotationX = function(theta) {
                        var c = Math.cos(theta),
                            s = Math.sin(theta);
                        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
                        return this;
                    };
                    Matrix4.prototype.makeRotationY = function(theta) {
                        var c = Math.cos(theta),
                            s = Math.sin(theta);
                        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
                        return this;
                    };
                    Matrix4.prototype.makeRotationZ = function(theta) {
                        var c = Math.cos(theta),
                            s = Math.sin(theta);
                        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                        return this;
                    };
                    Matrix4.prototype.makeRotationAxis = function(axis, angle) {
                        // Based on http://www.gamedev.net/reference/articles/article1199.asp
                        var c = Math.cos(angle);
                        var s = Math.sin(angle);
                        var t = 1 - c;
                        var x = axis.x,
                            y = axis.y,
                            z = axis.z;
                        var tx = t * x,
                            ty = t * y;
                        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
                        return this;
                    };
                    Matrix4.prototype.makeScale = function(x, y, z) {
                        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
                        return this;
                    };
                    Matrix4.prototype.makeShear = function(xy, xz, yx, yz, zx, zy) {
                        this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
                        return this;
                    };
                    Matrix4.prototype.compose = function(position, quaternion, scale) {
                        var te = this.elements;
                        var x = quaternion._x,
                            y = quaternion._y,
                            z = quaternion._z,
                            w = quaternion._w;
                        var x2 = x + x,
                            y2 = y + y,
                            z2 = z + z;
                        var xx = x * x2,
                            xy = x * y2,
                            xz = x * z2;
                        var yy = y * y2,
                            yz = y * z2,
                            zz = z * z2;
                        var wx = w * x2,
                            wy = w * y2,
                            wz = w * z2;
                        var sx = scale.x,
                            sy = scale.y,
                            sz = scale.z;
                        te[0] = (1 - (yy + zz)) * sx;
                        te[1] = (xy + wz) * sx;
                        te[2] = (xz - wy) * sx;
                        te[3] = 0;
                        te[4] = (xy - wz) * sy;
                        te[5] = (1 - (xx + zz)) * sy;
                        te[6] = (yz + wx) * sy;
                        te[7] = 0;
                        te[8] = (xz + wy) * sz;
                        te[9] = (yz - wx) * sz;
                        te[10] = (1 - (xx + yy)) * sz;
                        te[11] = 0;
                        te[12] = position.x;
                        te[13] = position.y;
                        te[14] = position.z;
                        te[15] = 1;
                        return this;
                    };
                    Matrix4.prototype.decompose = function(position, quaternion, scale) {
                        var te = this.elements;
                        var sx = _v1$5.set(te[0], te[1], te[2]).length();
                        var sy = _v1$5.set(te[4], te[5], te[6]).length();
                        var sz = _v1$5.set(te[8], te[9], te[10]).length();
                        // if determine is negative, we need to invert one scale
                        var det = this.determinant();
                        if (det < 0)
                            sx = -sx;
                        position.x = te[12];
                        position.y = te[13];
                        position.z = te[14];
                        // scale the rotation part
                        _m1$2.copy(this);
                        var invSX = 1 / sx;
                        var invSY = 1 / sy;
                        var invSZ = 1 / sz;
                        _m1$2.elements[0] *= invSX;
                        _m1$2.elements[1] *= invSX;
                        _m1$2.elements[2] *= invSX;
                        _m1$2.elements[4] *= invSY;
                        _m1$2.elements[5] *= invSY;
                        _m1$2.elements[6] *= invSY;
                        _m1$2.elements[8] *= invSZ;
                        _m1$2.elements[9] *= invSZ;
                        _m1$2.elements[10] *= invSZ;
                        quaternion.setFromRotationMatrix(_m1$2);
                        scale.x = sx;
                        scale.y = sy;
                        scale.z = sz;
                        return this;
                    };
                    Matrix4.prototype.makePerspective = function(left, right, top, bottom, near, far) {
                        if (far === undefined) {
                            console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
                        }
                        var te = this.elements;
                        var x = 2 * near / (right - left);
                        var y = 2 * near / (top - bottom);
                        var a = (right + left) / (right - left);
                        var b = (top + bottom) / (top - bottom);
                        var c = -(far + near) / (far - near);
                        var d = -2 * far * near / (far - near);
                        te[0] = x;
                        te[4] = 0;
                        te[8] = a;
                        te[12] = 0;
                        te[1] = 0;
                        te[5] = y;
                        te[9] = b;
                        te[13] = 0;
                        te[2] = 0;
                        te[6] = 0;
                        te[10] = c;
                        te[14] = d;
                        te[3] = 0;
                        te[7] = 0;
                        te[11] = -1;
                        te[15] = 0;
                        return this;
                    };
                    Matrix4.prototype.makeOrthographic = function(left, right, top, bottom, near, far) {
                        var te = this.elements;
                        var w = 1.0 / (right - left);
                        var h = 1.0 / (top - bottom);
                        var p = 1.0 / (far - near);
                        var x = (right + left) * w;
                        var y = (top + bottom) * h;
                        var z = (far + near) * p;
                        te[0] = 2 * w;
                        te[4] = 0;
                        te[8] = 0;
                        te[12] = -x;
                        te[1] = 0;
                        te[5] = 2 * h;
                        te[9] = 0;
                        te[13] = -y;
                        te[2] = 0;
                        te[6] = 0;
                        te[10] = -2 * p;
                        te[14] = -z;
                        te[3] = 0;
                        te[7] = 0;
                        te[11] = 0;
                        te[15] = 1;
                        return this;
                    };
                    Matrix4.prototype.equals = function(matrix) {
                        var te = this.elements;
                        var me = matrix.elements;
                        for (var i = 0; i < 16; i++) {
                            if (te[i] !== me[i])
                                return false;
                        }
                        return true;
                    };
                    Matrix4.prototype.fromArray = function(array, offset) {
                        if (offset === void 0) {
                            offset = 0;
                        }
                        for (var i = 0; i < 16; i++) {
                            this.elements[i] = array[i + offset];
                        }
                        return this;
                    };
                    Matrix4.prototype.toArray = function(array, offset) {
                        if (array === void 0) {
                            array = [];
                        }
                        if (offset === void 0) {
                            offset = 0;
                        }
                        var te = this.elements;
                        array[offset] = te[0];
                        array[offset + 1] = te[1];
                        array[offset + 2] = te[2];
                        array[offset + 3] = te[3];
                        array[offset + 4] = te[4];
                        array[offset + 5] = te[5];
                        array[offset + 6] = te[6];
                        array[offset + 7] = te[7];
                        array[offset + 8] = te[8];
                        array[offset + 9] = te[9];
                        array[offset + 10] = te[10];
                        array[offset + 11] = te[11];
                        array[offset + 12] = te[12];
                        array[offset + 13] = te[13];
                        array[offset + 14] = te[14];
                        array[offset + 15] = te[15];
                        return array;
                    };
                    return Matrix4;
                }());
                Matrix4.prototype.isMatrix4 = true;
                var _v1$5 = /*@__PURE__*/ new Vector3();
                var _m1$2 = /*@__PURE__*/ new Matrix4();
                var _zero = /*@__PURE__*/ new Vector3(0, 0, 0);
                var _one = /*@__PURE__*/ new Vector3(1, 1, 1);
                var _x = /*@__PURE__*/ new Vector3();
                var _y = /*@__PURE__*/ new Vector3();
                var _z = /*@__PURE__*/ new Vector3();
                var _matrix$1 = /*@__PURE__*/ new Matrix4();
                var _quaternion$3 = /*@__PURE__*/ new Quaternion();
                var Euler = /** @class */ (function() {
                    function Euler(x, y, z, order) {
                        if (x === void 0) {
                            x = 0;
                        }
                        if (y === void 0) {
                            y = 0;
                        }
                        if (z === void 0) {
                            z = 0;
                        }
                        if (order === void 0) {
                            order = Euler.DefaultOrder;
                        }
                        this._x = x;
                        this._y = y;
                        this._z = z;
                        this._order = order;
                    }
                    Object.defineProperty(Euler.prototype, "x", {
                        get: function() {
                            return this._x;
                        },
                        set: function(value) {
                            this._x = value;
                            this._onChangeCallback();
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(Euler.prototype, "y", {
                        get: function() {
                            return this._y;
                        },
                        set: function(value) {
                            this._y = value;
                            this._onChangeCallback();
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(Euler.prototype, "z", {
                        get: function() {
                            return this._z;
                        },
                        set: function(value) {
                            this._z = value;
                            this._onChangeCallback();
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(Euler.prototype, "order", {
                        get: function() {
                            return this._order;
                        },
                        set: function(value) {
                            this._order = value;
                            this._onChangeCallback();
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Euler.prototype.set = function(x, y, z, order) {
                        if (order === void 0) {
                            order = this._order;
                        }
                        this._x = x;
                        this._y = y;
                        this._z = z;
                        this._order = order;
                        this._onChangeCallback();
                        return this;
                    };
                    Euler.prototype.clone = function() {
                        return new this.constructor(this._x, this._y, this._z, this._order);
                    };
                    Euler.prototype.copy = function(euler) {
                        this._x = euler._x;
                        this._y = euler._y;
                        this._z = euler._z;
                        this._order = euler._order;
                        this._onChangeCallback();
                        return this;
                    };
                    Euler.prototype.setFromRotationMatrix = function(m, order, update) {
                        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
                        if (order === void 0) {
                            order = this._order;
                        }
                        if (update === void 0) {
                            update = true;
                        }
                        var te = m.elements;
                        var m11 = te[0],
                            m12 = te[4],
                            m13 = te[8];
                        var m21 = te[1],
                            m22 = te[5],
                            m23 = te[9];
                        var m31 = te[2],
                            m32 = te[6],
                            m33 = te[10];
                        switch (order) {
                            case 'XYZ':
                                this._y = Math.asin(clamp(m13, -1, 1));
                                if (Math.abs(m13) < 0.9999999) {
                                    this._x = Math.atan2(-m23, m33);
                                    this._z = Math.atan2(-m12, m11);
                                } else {
                                    this._x = Math.atan2(m32, m22);
                                    this._z = 0;
                                }
                                break;
                            case 'YXZ':
                                this._x = Math.asin(-clamp(m23, -1, 1));
                                if (Math.abs(m23) < 0.9999999) {
                                    this._y = Math.atan2(m13, m33);
                                    this._z = Math.atan2(m21, m22);
                                } else {
                                    this._y = Math.atan2(-m31, m11);
                                    this._z = 0;
                                }
                                break;
                            case 'ZXY':
                                this._x = Math.asin(clamp(m32, -1, 1));
                                if (Math.abs(m32) < 0.9999999) {
                                    this._y = Math.atan2(-m31, m33);
                                    this._z = Math.atan2(-m12, m22);
                                } else {
                                    this._y = 0;
                                    this._z = Math.atan2(m21, m11);
                                }
                                break;
                            case 'ZYX':
                                this._y = Math.asin(-clamp(m31, -1, 1));
                                if (Math.abs(m31) < 0.9999999) {
                                    this._x = Math.atan2(m32, m33);
                                    this._z = Math.atan2(m21, m11);
                                } else {
                                    this._x = 0;
                                    this._z = Math.atan2(-m12, m22);
                                }
                                break;
                            case 'YZX':
                                this._z = Math.asin(clamp(m21, -1, 1));
                                if (Math.abs(m21) < 0.9999999) {
                                    this._x = Math.atan2(-m23, m22);
                                    this._y = Math.atan2(-m31, m11);
                                } else {
                                    this._x = 0;
                                    this._y = Math.atan2(m13, m33);
                                }
                                break;
                            case 'XZY':
                                this._z = Math.asin(-clamp(m12, -1, 1));
                                if (Math.abs(m12) < 0.9999999) {
                                    this._x = Math.atan2(m32, m22);
                                    this._y = Math.atan2(m13, m11);
                                } else {
                                    this._x = Math.atan2(-m23, m33);
                                    this._y = 0;
                                }
                                break;
                            default:
                                console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
                        }
                        this._order = order;
                        if (update === true)
                            this._onChangeCallback();
                        return this;
                    };
                    Euler.prototype.setFromQuaternion = function(q, order, update) {
                        _matrix$1.makeRotationFromQuaternion(q);
                        return this.setFromRotationMatrix(_matrix$1, order, update);
                    };
                    Euler.prototype.setFromVector3 = function(v, order) {
                        if (order === void 0) {
                            order = this._order;
                        }
                        return this.set(v.x, v.y, v.z, order);
                    };
                    Euler.prototype.reorder = function(newOrder) {
                        // WARNING: this discards revolution information -bhouston
                        _quaternion$3.setFromEuler(this);
                        return this.setFromQuaternion(_quaternion$3, newOrder);
                    };
                    Euler.prototype.equals = function(euler) {
                        return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order);
                    };
                    Euler.prototype.fromArray = function(array) {
                        this._x = array[0];
                        this._y = array[1];
                        this._z = array[2];
                        if (array[3] !== undefined)
                            this._order = array[3];
                        this._onChangeCallback();
                        return this;
                    };
                    Euler.prototype.toArray = function(array, offset) {
                        if (array === void 0) {
                            array = [];
                        }
                        if (offset === void 0) {
                            offset = 0;
                        }
                        array[offset] = this._x;
                        array[offset + 1] = this._y;
                        array[offset + 2] = this._z;
                        array[offset + 3] = this._order;
                        return array;
                    };
                    Euler.prototype._onChange = function(callback) {
                        this._onChangeCallback = callback;
                        return this;
                    };
                    Euler.prototype._onChangeCallback = function() {};
                    return Euler;
                }());
                Euler.prototype.isEuler = true;
                Euler.DefaultOrder = 'XYZ';
                Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];
                var Layers = /** @class */ (function() {
                    function Layers() {
                        this.mask = 1 | 0;
                    }
                    Layers.prototype.set = function(channel) {
                        this.mask = (1 << channel | 0) >>> 0;
                    };
                    Layers.prototype.enable = function(channel) {
                        this.mask |= 1 << channel | 0;
                    };
                    Layers.prototype.enableAll = function() {
                        this.mask = 0xffffffff | 0;
                    };
                    Layers.prototype.toggle = function(channel) {
                        this.mask ^= 1 << channel | 0;
                    };
                    Layers.prototype.disable = function(channel) {
                        this.mask &= ~(1 << channel | 0);
                    };
                    Layers.prototype.disableAll = function() {
                        this.mask = 0;
                    };
                    Layers.prototype.test = function(layers) {
                        return (this.mask & layers.mask) !== 0;
                    };
                    Layers.prototype.isEnabled = function(channel) {
                        return (this.mask & (1 << channel | 0)) !== 0;
                    };
                    return Layers;
                }());
                var _object3DId = 0;
                var _v1$4 = /*@__PURE__*/ new Vector3();
                var _q1 = /*@__PURE__*/ new Quaternion();
                var _m1$1 = /*@__PURE__*/ new Matrix4();
                var _target = /*@__PURE__*/ new Vector3();
                var _position$3 = /*@__PURE__*/ new Vector3();
                var _scale$2 = /*@__PURE__*/ new Vector3();
                var _quaternion$2 = /*@__PURE__*/ new Quaternion();
                var _xAxis = /*@__PURE__*/ new Vector3(1, 0, 0);
                var _yAxis = /*@__PURE__*/ new Vector3(0, 1, 0);
                var _zAxis = /*@__PURE__*/ new Vector3(0, 0, 1);
                var _addedEvent = {
                    type: 'added'
                };
                var _removedEvent = {
                    type: 'removed'
                };
                var Object3D = /** @class */ (function(_super) {
                    __extends(Object3D, _super);

                    function Object3D() {
                        var _this_1 = _super.call(this) || this;
                        Object.defineProperty(_this_1, 'id', {
                            value: _object3DId++
                        });
                        _this_1.uuid = generateUUID();
                        _this_1.name = '';
                        _this_1.type = 'Object3D';
                        _this_1.parent = null;
                        _this_1.children = [];
                        _this_1.up = Object3D.DefaultUp.clone();
                        var position = new Vector3();
                        var rotation = new Euler();
                        var quaternion = new Quaternion();
                        var scale = new Vector3(1, 1, 1);

                        function onRotationChange() {
                            quaternion.setFromEuler(rotation, false);
                        }

                        function onQuaternionChange() {
                            rotation.setFromQuaternion(quaternion, undefined, false);
                        }
                        rotation._onChange(onRotationChange);
                        quaternion._onChange(onQuaternionChange);
                        Object.defineProperties(_this_1, {
                            position: {
                                configurable: true,
                                enumerable: true,
                                value: position
                            },
                            rotation: {
                                configurable: true,
                                enumerable: true,
                                value: rotation
                            },
                            quaternion: {
                                configurable: true,
                                enumerable: true,
                                value: quaternion
                            },
                            scale: {
                                configurable: true,
                                enumerable: true,
                                value: scale
                            },
                            modelViewMatrix: {
                                value: new Matrix4()
                            },
                            normalMatrix: {
                                value: new Matrix3()
                            }
                        });
                        _this_1.matrix = new Matrix4();
                        _this_1.matrixWorld = new Matrix4();
                        _this_1.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
                        _this_1.matrixWorldNeedsUpdate = false;
                        _this_1.layers = new Layers();
                        _this_1.visible = true;
                        _this_1.castShadow = false;
                        _this_1.receiveShadow = false;
                        _this_1.frustumCulled = true;
                        _this_1.renderOrder = 0;
                        _this_1.animations = [];
                        _this_1.userData = {};
                        return _this_1;
                    }
                    Object3D.prototype.onBeforeRender = function( /* renderer, scene, camera, geometry, material, group */ ) {};
                    Object3D.prototype.onAfterRender = function( /* renderer, scene, camera, geometry, material, group */ ) {};
                    Object3D.prototype.applyMatrix4 = function(matrix) {
                        if (this.matrixAutoUpdate)
                            this.updateMatrix();
                        this.matrix.premultiply(matrix);
                        this.matrix.decompose(this.position, this.quaternion, this.scale);
                    };
                    Object3D.prototype.applyQuaternion = function(q) {
                        this.quaternion.premultiply(q);
                        return this;
                    };
                    Object3D.prototype.setRotationFromAxisAngle = function(axis, angle) {
                        // assumes axis is normalized
                        this.quaternion.setFromAxisAngle(axis, angle);
                    };
                    Object3D.prototype.setRotationFromEuler = function(euler) {
                        this.quaternion.setFromEuler(euler, true);
                    };
                    Object3D.prototype.setRotationFromMatrix = function(m) {
                        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
                        this.quaternion.setFromRotationMatrix(m);
                    };
                    Object3D.prototype.setRotationFromQuaternion = function(q) {
                        // assumes q is normalized
                        this.quaternion.copy(q);
                    };
                    Object3D.prototype.rotateOnAxis = function(axis, angle) {
                        // rotate object on axis in object space
                        // axis is assumed to be normalized
                        _q1.setFromAxisAngle(axis, angle);
                        this.quaternion.multiply(_q1);
                        return this;
                    };
                    Object3D.prototype.rotateOnWorldAxis = function(axis, angle) {
                        // rotate object on axis in world space
                        // axis is assumed to be normalized
                        // method assumes no rotated parent
                        _q1.setFromAxisAngle(axis, angle);
                        this.quaternion.premultiply(_q1);
                        return this;
                    };
                    Object3D.prototype.rotateX = function(angle) {
                        return this.rotateOnAxis(_xAxis, angle);
                    };
                    Object3D.prototype.rotateY = function(angle) {
                        return this.rotateOnAxis(_yAxis, angle);
                    };
                    Object3D.prototype.rotateZ = function(angle) {
                        return this.rotateOnAxis(_zAxis, angle);
                    };
                    Object3D.prototype.translateOnAxis = function(axis, distance) {
                        // translate object by distance along axis in object space
                        // axis is assumed to be normalized
                        _v1$4.copy(axis).applyQuaternion(this.quaternion);
                        this.position.add(_v1$4.multiplyScalar(distance));
                        return this;
                    };
                    Object3D.prototype.translateX = function(distance) {
                        return this.translateOnAxis(_xAxis, distance);
                    };
                    Object3D.prototype.translateY = function(distance) {
                        return this.translateOnAxis(_yAxis, distance);
                    };
                    Object3D.prototype.translateZ = function(distance) {
                        return this.translateOnAxis(_zAxis, distance);
                    };
                    Object3D.prototype.localToWorld = function(vector) {
                        return vector.applyMatrix4(this.matrixWorld);
                    };
                    Object3D.prototype.worldToLocal = function(vector) {
                        return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
                    };
                    Object3D.prototype.lookAt = function(x, y, z) {
                        // This method does not support objects having non-uniformly-scaled parent(s)
                        if (x.isVector3) {
                            _target.copy(x);
                        } else {
                            _target.set(x, y, z);
                        }
                        var parent = this.parent;
                        this.updateWorldMatrix(true, false);
                        _position$3.setFromMatrixPosition(this.matrixWorld);
                        if (this.isCamera || this.isLight) {
                            _m1$1.lookAt(_position$3, _target, this.up);
                        } else {
                            _m1$1.lookAt(_target, _position$3, this.up);
                        }
                        this.quaternion.setFromRotationMatrix(_m1$1);
                        if (parent) {
                            _m1$1.extractRotation(parent.matrixWorld);
                            _q1.setFromRotationMatrix(_m1$1);
                            this.quaternion.premultiply(_q1.invert());
                        }
                    };
                    Object3D.prototype.add = function(object) {
                        if (arguments.length > 1) {
                            for (var i = 0; i < arguments.length; i++) {
                                this.add(arguments[i]);
                            }
                            return this;
                        }
                        if (object === this) {
                            console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
                            return this;
                        }
                        if (object && object.isObject3D) {
                            if (object.parent !== null) {
                                object.parent.remove(object);
                            }
                            object.parent = this;
                            this.children.push(object);
                            object.dispatchEvent(_addedEvent);
                        } else {
                            console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
                        }
                        return this;
                    };
                    Object3D.prototype.remove = function(object) {
                        if (arguments.length > 1) {
                            for (var i = 0; i < arguments.length; i++) {
                                this.remove(arguments[i]);
                            }
                            return this;
                        }
                        var index = this.children.indexOf(object);
                        if (index !== -1) {
                            object.parent = null;
                            this.children.splice(index, 1);
                            object.dispatchEvent(_removedEvent);
                        }
                        return this;
                    };
                    Object3D.prototype.removeFromParent = function() {
                        var parent = this.parent;
                        if (parent !== null) {
                            parent.remove(this);
                        }
                        return this;
                    };
                    Object3D.prototype.clear = function() {
                        for (var i = 0; i < this.children.length; i++) {
                            var object = this.children[i];
                            object.parent = null;
                            object.dispatchEvent(_removedEvent);
                        }
                        this.children.length = 0;
                        return this;
                    };
                    Object3D.prototype.attach = function(object) {
                        // adds object as a child of this, while maintaining the object's world transform
                        // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)
                        this.updateWorldMatrix(true, false);
                        _m1$1.copy(this.matrixWorld).invert();
                        if (object.parent !== null) {
                            object.parent.updateWorldMatrix(true, false);
                            _m1$1.multiply(object.parent.matrixWorld);
                        }
                        object.applyMatrix4(_m1$1);
                        this.add(object);
                        object.updateWorldMatrix(false, true);
                        return this;
                    };
                    Object3D.prototype.getObjectById = function(id) {
                        return this.getObjectByProperty('id', id);
                    };
                    Object3D.prototype.getObjectByName = function(name) {
                        return this.getObjectByProperty('name', name);
                    };
                    Object3D.prototype.getObjectByProperty = function(name, value) {
                        if (this[name] === value)
                            return this;
                        for (var i = 0, l = this.children.length; i < l; i++) {
                            var child = this.children[i];
                            var object = child.getObjectByProperty(name, value);
                            if (object !== undefined) {
                                return object;
                            }
                        }
                        return undefined;
                    };
                    Object3D.prototype.getWorldPosition = function(target) {
                        this.updateWorldMatrix(true, false);
                        return target.setFromMatrixPosition(this.matrixWorld);
                    };
                    Object3D.prototype.getWorldQuaternion = function(target) {
                        this.updateWorldMatrix(true, false);
                        this.matrixWorld.decompose(_position$3, target, _scale$2);
                        return target;
                    };
                    Object3D.prototype.getWorldScale = function(target) {
                        this.updateWorldMatrix(true, false);
                        this.matrixWorld.decompose(_position$3, _quaternion$2, target);
                        return target;
                    };
                    Object3D.prototype.getWorldDirection = function(target) {
                        this.updateWorldMatrix(true, false);
                        var e = this.matrixWorld.elements;
                        return target.set(e[8], e[9], e[10]).normalize();
                    };
                    Object3D.prototype.raycast = function( /* raycaster, intersects */ ) {};
                    Object3D.prototype.traverse = function(callback) {
                        callback(this);
                        var children = this.children;
                        for (var i = 0, l = children.length; i < l; i++) {
                            children[i].traverse(callback);
                        }
                    };
                    Object3D.prototype.traverseVisible = function(callback) {
                        if (this.visible === false)
                            return;
                        callback(this);
                        var children = this.children;
                        for (var i = 0, l = children.length; i < l; i++) {
                            children[i].traverseVisible(callback);
                        }
                    };
                    Object3D.prototype.traverseAncestors = function(callback) {
                        var parent = this.parent;
                        if (parent !== null) {
                            callback(parent);
                            parent.traverseAncestors(callback);
                        }
                    };
                    Object3D.prototype.updateMatrix = function() {
                        this.matrix.compose(this.position, this.quaternion, this.scale);
                        this.matrixWorldNeedsUpdate = true;
                    };
                    Object3D.prototype.updateMatrixWorld = function(force) {
                        if (this.matrixAutoUpdate)
                            this.updateMatrix();
                        if (this.matrixWorldNeedsUpdate || force) {
                            if (this.parent === null) {
                                this.matrixWorld.copy(this.matrix);
                            } else {
                                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                            }
                            this.matrixWorldNeedsUpdate = false;
                            force = true;
                        }
                        // update children
                        var children = this.children;
                        for (var i = 0, l = children.length; i < l; i++) {
                            children[i].updateMatrixWorld(force);
                        }
                    };
                    Object3D.prototype.updateWorldMatrix = function(updateParents, updateChildren) {
                        var parent = this.parent;
                        if (updateParents === true && parent !== null) {
                            parent.updateWorldMatrix(true, false);
                        }
                        if (this.matrixAutoUpdate)
                            this.updateMatrix();
                        if (this.parent === null) {
                            this.matrixWorld.copy(this.matrix);
                        } else {
                            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
                        }
                        // update children
                        if (updateChildren === true) {
                            var children = this.children;
                            for (var i = 0, l = children.length; i < l; i++) {
                                children[i].updateWorldMatrix(false, true);
                            }
                        }
                    };
                    Object3D.prototype.toJSON = function(meta) {
                        // meta is a string when called from JSON.stringify
                        var isRootObject = (meta === undefined || typeof meta === 'string');
                        var output = {};
                        // meta is a hash used to collect geometries, materials.
                        // not providing it implies that this is the root object
                        // being serialized.
                        if (isRootObject) {
                            // initialize meta obj
                            meta = {
                                geometries: {},
                                materials: {},
                                textures: {},
                                images: {},
                                shapes: {},
                                skeletons: {},
                                animations: {},
                                nodes: {}
                            };
                            output.metadata = {
                                version: 4.5,
                                type: 'Object',
                                generator: 'Object3D.toJSON'
                            };
                        }
                        // standard Object3D serialization
                        var object = {};
                        object.uuid = this.uuid;
                        object.type = this.type;
                        if (this.name !== '')
                            object.name = this.name;
                        if (this.castShadow === true)
                            object.castShadow = true;
                        if (this.receiveShadow === true)
                            object.receiveShadow = true;
                        if (this.visible === false)
                            object.visible = false;
                        if (this.frustumCulled === false)
                            object.frustumCulled = false;
                        if (this.renderOrder !== 0)
                            object.renderOrder = this.renderOrder;
                        if (JSON.stringify(this.userData) !== '{}')
                            object.userData = this.userData;
                        object.layers = this.layers.mask;
                        object.matrix = this.matrix.toArray();
                        if (this.matrixAutoUpdate === false)
                            object.matrixAutoUpdate = false;
                        // object specific properties
                        if (this.isInstancedMesh) {
                            object.type = 'InstancedMesh';
                            object.count = this.count;
                            object.instanceMatrix = this.instanceMatrix.toJSON();
                            if (this.instanceColor !== null)
                                object.instanceColor = this.instanceColor.toJSON();
                        }
                        //
                        function serialize(library, element) {
                            if (library[element.uuid] === undefined) {
                                library[element.uuid] = element.toJSON(meta);
                            }
                            return element.uuid;
                        }
                        if (this.isScene) {
                            if (this.background) {
                                if (this.background.isColor) {
                                    object.background = this.background.toJSON();
                                } else if (this.background.isTexture) {
                                    object.background = this.background.toJSON(meta).uuid;
                                }
                            }
                            if (this.environment && this.environment.isTexture) {
                                object.environment = this.environment.toJSON(meta).uuid;
                            }
                        } else if (this.isMesh || this.isLine || this.isPoints) {
                            object.geometry = serialize(meta.geometries, this.geometry);
                            var parameters = this.geometry.parameters;
                            if (parameters !== undefined && parameters.shapes !== undefined) {
                                var shapes = parameters.shapes;
                                if (Array.isArray(shapes)) {
                                    for (var i = 0, l = shapes.length; i < l; i++) {
                                        var shape = shapes[i];
                                        serialize(meta.shapes, shape);
                                    }
                                } else {
                                    serialize(meta.shapes, shapes);
                                }
                            }
                        }
                        if (this.isSkinnedMesh) {
                            object.bindMode = this.bindMode;
                            object.bindMatrix = this.bindMatrix.toArray();
                            if (this.skeleton !== undefined) {
                                serialize(meta.skeletons, this.skeleton);
                                object.skeleton = this.skeleton.uuid;
                            }
                        }
                        if (this.material !== undefined) {
                            if (Array.isArray(this.material)) {
                                var uuids = [];
                                for (var i = 0, l = this.material.length; i < l; i++) {
                                    uuids.push(serialize(meta.materials, this.material[i]));
                                }
                                object.material = uuids;
                            } else {
                                object.material = serialize(meta.materials, this.material);
                            }
                        }
                        //
                        if (this.children.length > 0) {
                            object.children = [];
                            for (var i = 0; i < this.children.length; i++) {
                                object.children.push(this.children[i].toJSON(meta).object);
                            }
                        }
                        //
                        if (this.animations.length > 0) {
                            object.animations = [];
                            for (var i = 0; i < this.animations.length; i++) {
                                var animation = this.animations[i];
                                object.animations.push(serialize(meta.animations, animation));
                            }
                        }
                        if (isRootObject) {
                            var geometries = extractFromCache(meta.geometries);
                            var materials = extractFromCache(meta.materials);
                            var textures = extractFromCache(meta.textures);
                            var images = extractFromCache(meta.images);
                            var shapes = extractFromCache(meta.shapes);
                            var skeletons = extractFromCache(meta.skeletons);
                            var animations = extractFromCache(meta.animations);
                            var nodes = extractFromCache(meta.nodes);
                            if (geometries.length > 0)
                                output.geometries = geometries;
                            if (materials.length > 0)
                                output.materials = materials;
                            if (textures.length > 0)
                                output.textures = textures;
                            if (images.length > 0)
                                output.images = images;
                            if (shapes.length > 0)
                                output.shapes = shapes;
                            if (skeletons.length > 0)
                                output.skeletons = skeletons;
                            if (animations.length > 0)
                                output.animations = animations;
                            if (nodes.length > 0)
                                output.nodes = nodes;
                        }
                        output.object = object;
                        return output;
                        // extract data from the cache hash
                        // remove metadata on each item
                        // and return as array
                        function extractFromCache(cache) {
                            var values = [];
                            for (var key in cache) {
                                var data = cache[key];
                                delete data.metadata;
                                values.push(data);
                            }
                            return values;
                        }
                    };
                    Object3D.prototype.clone = function(recursive) {
                        return new this.constructor().copy(this, recursive);
                    };
                    Object3D.prototype.copy = function(source, recursive) {
                        if (recursive === void 0) {
                            recursive = true;
                        }
                        this.name = source.name;
                        this.up.copy(source.up);
                        this.position.copy(source.position);
                        this.rotation.order = source.rotation.order;
                        this.quaternion.copy(source.quaternion);
                        this.scale.copy(source.scale);
                        this.matrix.copy(source.matrix);
                        this.matrixWorld.copy(source.matrixWorld);
                        this.matrixAutoUpdate = source.matrixAutoUpdate;
                        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
                        this.layers.mask = source.layers.mask;
                        this.visible = source.visible;
                        this.castShadow = source.castShadow;
                        this.receiveShadow = source.receiveShadow;
                        this.frustumCulled = source.frustumCulled;
                        this.renderOrder = source.renderOrder;
                        this.userData = JSON.parse(JSON.stringify(source.userData));
                        if (recursive === true) {
                            for (var i = 0; i < source.children.length; i++) {
                                var child = source.children[i];
                                this.add(child.clone());
                            }
                        }
                        return this;
                    };
                    return Object3D;
                }(EventDispatcher));
                Object3D.DefaultUp = new Vector3(0, 1, 0);
                Object3D.DefaultMatrixAutoUpdate = true;
                Object3D.prototype.isObject3D = true;
                var _v0$1 = /*@__PURE__*/ new Vector3();
                var _v1$3 = /*@__PURE__*/ new Vector3();
                var _v2$2 = /*@__PURE__*/ new Vector3();
                var _v3$1 = /*@__PURE__*/ new Vector3();
                var _vab = /*@__PURE__*/ new Vector3();
                var _vac = /*@__PURE__*/ new Vector3();
                var _vbc = /*@__PURE__*/ new Vector3();
                var _vap = /*@__PURE__*/ new Vector3();
                var _vbp = /*@__PURE__*/ new Vector3();
                var _vcp = /*@__PURE__*/ new Vector3();
                var Triangle = /** @class */ (function() {
                    function Triangle(a, b, c) {
                        if (a === void 0) {
                            a = new Vector3();
                        }
                        if (b === void 0) {
                            b = new Vector3();
                        }
                        if (c === void 0) {
                            c = new Vector3();
                        }
                        this.a = a;
                        this.b = b;
                        this.c = c;
                    }
                    Triangle.getNormal = function(a, b, c, target) {
                        target.subVectors(c, b);
                        _v0$1.subVectors(a, b);
                        target.cross(_v0$1);
                        var targetLengthSq = target.lengthSq();
                        if (targetLengthSq > 0) {
                            return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
                        }
                        return target.set(0, 0, 0);
                    };
                    // static/instance method to calculate barycentric coordinates
                    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
                    Triangle.getBarycoord = function(point, a, b, c, target) {
                        _v0$1.subVectors(c, a);
                        _v1$3.subVectors(b, a);
                        _v2$2.subVectors(point, a);
                        var dot00 = _v0$1.dot(_v0$1);
                        var dot01 = _v0$1.dot(_v1$3);
                        var dot02 = _v0$1.dot(_v2$2);
                        var dot11 = _v1$3.dot(_v1$3);
                        var dot12 = _v1$3.dot(_v2$2);
                        var denom = (dot00 * dot11 - dot01 * dot01);
                        // collinear or singular triangle
                        if (denom === 0) {
                            // arbitrary location outside of triangle?
                            // not sure if this is the best idea, maybe should be returning undefined
                            return target.set(-2, -1, -1);
                        }
                        var invDenom = 1 / denom;
                        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                        // barycentric coordinates must always sum to 1
                        return target.set(1 - u - v, v, u);
                    };
                    Triangle.containsPoint = function(point, a, b, c) {
                        this.getBarycoord(point, a, b, c, _v3$1);
                        return (_v3$1.x >= 0) && (_v3$1.y >= 0) && ((_v3$1.x + _v3$1.y) <= 1);
                    };
                    Triangle.getUV = function(point, p1, p2, p3, uv1, uv2, uv3, target) {
                        this.getBarycoord(point, p1, p2, p3, _v3$1);
                        target.set(0, 0);
                        target.addScaledVector(uv1, _v3$1.x);
                        target.addScaledVector(uv2, _v3$1.y);
                        target.addScaledVector(uv3, _v3$1.z);
                        return target;
                    };
                    Triangle.isFrontFacing = function(a, b, c, direction) {
                        _v0$1.subVectors(c, b);
                        _v1$3.subVectors(a, b);
                        // strictly front facing
                        return (_v0$1.cross(_v1$3).dot(direction) < 0) ? true : false;
                    };
                    Triangle.prototype.set = function(a, b, c) {
                        this.a.copy(a);
                        this.b.copy(b);
                        this.c.copy(c);
                        return this;
                    };
                    Triangle.prototype.setFromPointsAndIndices = function(points, i0, i1, i2) {
                        this.a.copy(points[i0]);
                        this.b.copy(points[i1]);
                        this.c.copy(points[i2]);
                        return this;
                    };
                    Triangle.prototype.setFromAttributeAndIndices = function(attribute, i0, i1, i2) {
                        this.a.fromBufferAttribute(attribute, i0);
                        this.b.fromBufferAttribute(attribute, i1);
                        this.c.fromBufferAttribute(attribute, i2);
                        return this;
                    };
                    Triangle.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    Triangle.prototype.copy = function(triangle) {
                        this.a.copy(triangle.a);
                        this.b.copy(triangle.b);
                        this.c.copy(triangle.c);
                        return this;
                    };
                    Triangle.prototype.getArea = function() {
                        _v0$1.subVectors(this.c, this.b);
                        _v1$3.subVectors(this.a, this.b);
                        return _v0$1.cross(_v1$3).length() * 0.5;
                    };
                    Triangle.prototype.getMidpoint = function(target) {
                        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
                    };
                    Triangle.prototype.getNormal = function(target) {
                        return Triangle.getNormal(this.a, this.b, this.c, target);
                    };
                    Triangle.prototype.getPlane = function(target) {
                        return target.setFromCoplanarPoints(this.a, this.b, this.c);
                    };
                    Triangle.prototype.getBarycoord = function(point, target) {
                        return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
                    };
                    Triangle.prototype.getUV = function(point, uv1, uv2, uv3, target) {
                        return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
                    };
                    Triangle.prototype.containsPoint = function(point) {
                        return Triangle.containsPoint(point, this.a, this.b, this.c);
                    };
                    Triangle.prototype.isFrontFacing = function(direction) {
                        return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
                    };
                    Triangle.prototype.intersectsBox = function(box) {
                        return box.intersectsTriangle(this);
                    };
                    Triangle.prototype.closestPointToPoint = function(p, target) {
                        var a = this.a,
                            b = this.b,
                            c = this.c;
                        var v, w;
                        // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
                        // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
                        // under the accompanying license; see chapter 5.1.5 for detailed explanation.
                        // basically, we're distinguishing which of the voronoi regions of the triangle
                        // the point lies in with the minimum amount of redundant computation.
                        _vab.subVectors(b, a);
                        _vac.subVectors(c, a);
                        _vap.subVectors(p, a);
                        var d1 = _vab.dot(_vap);
                        var d2 = _vac.dot(_vap);
                        if (d1 <= 0 && d2 <= 0) {
                            // vertex region of A; barycentric coords (1, 0, 0)
                            return target.copy(a);
                        }
                        _vbp.subVectors(p, b);
                        var d3 = _vab.dot(_vbp);
                        var d4 = _vac.dot(_vbp);
                        if (d3 >= 0 && d4 <= d3) {
                            // vertex region of B; barycentric coords (0, 1, 0)
                            return target.copy(b);
                        }
                        var vc = d1 * d4 - d3 * d2;
                        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                            v = d1 / (d1 - d3);
                            // edge region of AB; barycentric coords (1-v, v, 0)
                            return target.copy(a).addScaledVector(_vab, v);
                        }
                        _vcp.subVectors(p, c);
                        var d5 = _vab.dot(_vcp);
                        var d6 = _vac.dot(_vcp);
                        if (d6 >= 0 && d5 <= d6) {
                            // vertex region of C; barycentric coords (0, 0, 1)
                            return target.copy(c);
                        }
                        var vb = d5 * d2 - d1 * d6;
                        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                            w = d2 / (d2 - d6);
                            // edge region of AC; barycentric coords (1-w, 0, w)
                            return target.copy(a).addScaledVector(_vac, w);
                        }
                        var va = d3 * d6 - d5 * d4;
                        if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
                            _vbc.subVectors(c, b);
                            w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
                            // edge region of BC; barycentric coords (0, 1-w, w)
                            return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
                        }
                        // face region
                        var denom = 1 / (va + vb + vc);
                        // u = va * denom
                        v = vb * denom;
                        w = vc * denom;
                        return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
                    };
                    Triangle.prototype.equals = function(triangle) {
                        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
                    };
                    return Triangle;
                }());
                var materialId = 0;
                var Material = /** @class */ (function(_super) {
                    __extends(Material, _super);

                    function Material() {
                        var _this_1 = _super.call(this) || this;
                        Object.defineProperty(_this_1, 'id', {
                            value: materialId++
                        });
                        _this_1.uuid = generateUUID();
                        _this_1.name = '';
                        _this_1.type = 'Material';
                        _this_1.fog = true;
                        _this_1.blending = NormalBlending;
                        _this_1.side = FrontSide;
                        _this_1.vertexColors = false;
                        _this_1.opacity = 1;
                        _this_1.transparent = false;
                        _this_1.blendSrc = SrcAlphaFactor;
                        _this_1.blendDst = OneMinusSrcAlphaFactor;
                        _this_1.blendEquation = AddEquation;
                        _this_1.blendSrcAlpha = null;
                        _this_1.blendDstAlpha = null;
                        _this_1.blendEquationAlpha = null;
                        _this_1.depthFunc = LessEqualDepth;
                        _this_1.depthTest = true;
                        _this_1.depthWrite = true;
                        _this_1.stencilWriteMask = 0xff;
                        _this_1.stencilFunc = AlwaysStencilFunc;
                        _this_1.stencilRef = 0;
                        _this_1.stencilFuncMask = 0xff;
                        _this_1.stencilFail = KeepStencilOp;
                        _this_1.stencilZFail = KeepStencilOp;
                        _this_1.stencilZPass = KeepStencilOp;
                        _this_1.stencilWrite = false;
                        _this_1.clippingPlanes = null;
                        _this_1.clipIntersection = false;
                        _this_1.clipShadows = false;
                        _this_1.shadowSide = null;
                        _this_1.colorWrite = true;
                        _this_1.precision = null; // override the renderer's default precision for this material
                        _this_1.polygonOffset = false;
                        _this_1.polygonOffsetFactor = 0;
                        _this_1.polygonOffsetUnits = 0;
                        _this_1.dithering = false;
                        _this_1.alphaToCoverage = false;
                        _this_1.premultipliedAlpha = false;
                        _this_1.visible = true;
                        _this_1.toneMapped = true;
                        _this_1.userData = {};
                        _this_1.version = 0;
                        _this_1._alphaTest = 0;
                        return _this_1;
                    }
                    Object.defineProperty(Material.prototype, "alphaTest", {
                        get: function() {
                            return this._alphaTest;
                        },
                        set: function(value) {
                            if (this._alphaTest > 0 !== value > 0) {
                                this.version++;
                            }
                            this._alphaTest = value;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Material.prototype.onBuild = function( /* shaderobject, renderer */ ) {};
                    Material.prototype.onBeforeRender = function( /* renderer, scene, camera, geometry, object, group */ ) {};
                    Material.prototype.onBeforeCompile = function( /* shaderobject, renderer */ ) {};
                    Material.prototype.customProgramCacheKey = function() {
                        return this.onBeforeCompile.toString();
                    };
                    Material.prototype.setValues = function(values) {
                        if (values === undefined)
                            return;
                        for (var key in values) {
                            var newValue = values[key];
                            if (newValue === undefined) {
                                console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
                                continue;
                            }
                            // for backward compatibility if shading is set in the constructor
                            if (key === 'shading') {
                                console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                                this.flatShading = (newValue === FlatShading) ? true : false;
                                continue;
                            }
                            var currentValue = this[key];
                            if (currentValue === undefined) {
                                console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
                                continue;
                            }
                            if (currentValue && currentValue.isColor) {
                                currentValue.set(newValue);
                            } else if ((currentValue && currentValue.isVector3) && (newValue && newValue.isVector3)) {
                                currentValue.copy(newValue);
                            } else {
                                this[key] = newValue;
                            }
                        }
                    };
                    Material.prototype.toJSON = function(meta) {
                        var isRootObject = (meta === undefined || typeof meta === 'string');
                        if (isRootObject) {
                            meta = {
                                textures: {},
                                images: {}
                            };
                        }
                        var data = {
                            metadata: {
                                version: 4.5,
                                type: 'Material',
                                generator: 'Material.toJSON'
                            }
                        };
                        // standard Material serialization
                        data.uuid = this.uuid;
                        data.type = this.type;
                        if (this.name !== '')
                            data.name = this.name;
                        if (this.color && this.color.isColor)
                            data.color = this.color.getHex();
                        if (this.roughness !== undefined)
                            data.roughness = this.roughness;
                        if (this.metalness !== undefined)
                            data.metalness = this.metalness;
                        if (this.sheen !== undefined)
                            data.sheen = this.sheen;
                        if (this.sheenColor && this.sheenColor.isColor)
                            data.sheenColor = this.sheenColor.getHex();
                        if (this.sheenRoughness !== undefined)
                            data.sheenRoughness = this.sheenRoughness;
                        if (this.emissive && this.emissive.isColor)
                            data.emissive = this.emissive.getHex();
                        if (this.emissiveIntensity && this.emissiveIntensity !== 1)
                            data.emissiveIntensity = this.emissiveIntensity;
                        if (this.specular && this.specular.isColor)
                            data.specular = this.specular.getHex();
                        if (this.specularIntensity !== undefined)
                            data.specularIntensity = this.specularIntensity;
                        if (this.specularColor && this.specularColor.isColor)
                            data.specularColor = this.specularColor.getHex();
                        if (this.shininess !== undefined)
                            data.shininess = this.shininess;
                        if (this.clearcoat !== undefined)
                            data.clearcoat = this.clearcoat;
                        if (this.clearcoatRoughness !== undefined)
                            data.clearcoatRoughness = this.clearcoatRoughness;
                        if (this.clearcoatMap && this.clearcoatMap.isTexture) {
                            data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
                        }
                        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
                            data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
                        }
                        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
                            data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
                            data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
                        }
                        if (this.map && this.map.isTexture)
                            data.map = this.map.toJSON(meta).uuid;
                        if (this.matcap && this.matcap.isTexture)
                            data.matcap = this.matcap.toJSON(meta).uuid;
                        if (this.alphaMap && this.alphaMap.isTexture)
                            data.alphaMap = this.alphaMap.toJSON(meta).uuid;
                        if (this.lightMap && this.lightMap.isTexture) {
                            data.lightMap = this.lightMap.toJSON(meta).uuid;
                            data.lightMapIntensity = this.lightMapIntensity;
                        }
                        if (this.aoMap && this.aoMap.isTexture) {
                            data.aoMap = this.aoMap.toJSON(meta).uuid;
                            data.aoMapIntensity = this.aoMapIntensity;
                        }
                        if (this.bumpMap && this.bumpMap.isTexture) {
                            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                            data.bumpScale = this.bumpScale;
                        }
                        if (this.normalMap && this.normalMap.isTexture) {
                            data.normalMap = this.normalMap.toJSON(meta).uuid;
                            data.normalMapType = this.normalMapType;
                            data.normalScale = this.normalScale.toArray();
                        }
                        if (this.displacementMap && this.displacementMap.isTexture) {
                            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                            data.displacementScale = this.displacementScale;
                            data.displacementBias = this.displacementBias;
                        }
                        if (this.roughnessMap && this.roughnessMap.isTexture)
                            data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
                        if (this.metalnessMap && this.metalnessMap.isTexture)
                            data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
                        if (this.emissiveMap && this.emissiveMap.isTexture)
                            data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
                        if (this.specularMap && this.specularMap.isTexture)
                            data.specularMap = this.specularMap.toJSON(meta).uuid;
                        if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
                            data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
                        if (this.specularColorMap && this.specularColorMap.isTexture)
                            data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
                        if (this.envMap && this.envMap.isTexture) {
                            data.envMap = this.envMap.toJSON(meta).uuid;
                            if (this.combine !== undefined)
                                data.combine = this.combine;
                        }
                        if (this.envMapIntensity !== undefined)
                            data.envMapIntensity = this.envMapIntensity;
                        if (this.reflectivity !== undefined)
                            data.reflectivity = this.reflectivity;
                        if (this.refractionRatio !== undefined)
                            data.refractionRatio = this.refractionRatio;
                        if (this.gradientMap && this.gradientMap.isTexture) {
                            data.gradientMap = this.gradientMap.toJSON(meta).uuid;
                        }
                        if (this.transmission !== undefined)
                            data.transmission = this.transmission;
                        if (this.transmissionMap && this.transmissionMap.isTexture)
                            data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
                        if (this.thickness !== undefined)
                            data.thickness = this.thickness;
                        if (this.thicknessMap && this.thicknessMap.isTexture)
                            data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
                        if (this.attenuationDistance !== undefined)
                            data.attenuationDistance = this.attenuationDistance;
                        if (this.attenuationColor !== undefined)
                            data.attenuationColor = this.attenuationColor.getHex();
                        if (this.size !== undefined)
                            data.size = this.size;
                        if (this.shadowSide !== null)
                            data.shadowSide = this.shadowSide;
                        if (this.sizeAttenuation !== undefined)
                            data.sizeAttenuation = this.sizeAttenuation;
                        if (this.blending !== NormalBlending)
                            data.blending = this.blending;
                        if (this.side !== FrontSide)
                            data.side = this.side;
                        if (this.vertexColors)
                            data.vertexColors = true;
                        if (this.opacity < 1)
                            data.opacity = this.opacity;
                        if (this.transparent === true)
                            data.transparent = this.transparent;
                        data.depthFunc = this.depthFunc;
                        data.depthTest = this.depthTest;
                        data.depthWrite = this.depthWrite;
                        data.colorWrite = this.colorWrite;
                        data.stencilWrite = this.stencilWrite;
                        data.stencilWriteMask = this.stencilWriteMask;
                        data.stencilFunc = this.stencilFunc;
                        data.stencilRef = this.stencilRef;
                        data.stencilFuncMask = this.stencilFuncMask;
                        data.stencilFail = this.stencilFail;
                        data.stencilZFail = this.stencilZFail;
                        data.stencilZPass = this.stencilZPass;
                        // rotation (SpriteMaterial)
                        if (this.rotation !== undefined && this.rotation !== 0)
                            data.rotation = this.rotation;
                        if (this.polygonOffset === true)
                            data.polygonOffset = true;
                        if (this.polygonOffsetFactor !== 0)
                            data.polygonOffsetFactor = this.polygonOffsetFactor;
                        if (this.polygonOffsetUnits !== 0)
                            data.polygonOffsetUnits = this.polygonOffsetUnits;
                        if (this.linewidth !== undefined && this.linewidth !== 1)
                            data.linewidth = this.linewidth;
                        if (this.dashSize !== undefined)
                            data.dashSize = this.dashSize;
                        if (this.gapSize !== undefined)
                            data.gapSize = this.gapSize;
                        if (this.scale !== undefined)
                            data.scale = this.scale;
                        if (this.dithering === true)
                            data.dithering = true;
                        if (this.alphaTest > 0)
                            data.alphaTest = this.alphaTest;
                        if (this.alphaToCoverage === true)
                            data.alphaToCoverage = this.alphaToCoverage;
                        if (this.premultipliedAlpha === true)
                            data.premultipliedAlpha = this.premultipliedAlpha;
                        if (this.wireframe === true)
                            data.wireframe = this.wireframe;
                        if (this.wireframeLinewidth > 1)
                            data.wireframeLinewidth = this.wireframeLinewidth;
                        if (this.wireframeLinecap !== 'round')
                            data.wireframeLinecap = this.wireframeLinecap;
                        if (this.wireframeLinejoin !== 'round')
                            data.wireframeLinejoin = this.wireframeLinejoin;
                        if (this.flatShading === true)
                            data.flatShading = this.flatShading;
                        if (this.visible === false)
                            data.visible = false;
                        if (this.toneMapped === false)
                            data.toneMapped = false;
                        if (JSON.stringify(this.userData) !== '{}')
                            data.userData = this.userData;
                        // TODO: Copied from Object3D.toJSON
                        function extractFromCache(cache) {
                            var values = [];
                            for (var key in cache) {
                                var data_1 = cache[key];
                                delete data_1.metadata;
                                values.push(data_1);
                            }
                            return values;
                        }
                        if (isRootObject) {
                            var textures = extractFromCache(meta.textures);
                            var images = extractFromCache(meta.images);
                            if (textures.length > 0)
                                data.textures = textures;
                            if (images.length > 0)
                                data.images = images;
                        }
                        return data;
                    };
                    Material.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    Material.prototype.copy = function(source) {
                        this.name = source.name;
                        this.fog = source.fog;
                        this.blending = source.blending;
                        this.side = source.side;
                        this.vertexColors = source.vertexColors;
                        this.opacity = source.opacity;
                        this.transparent = source.transparent;
                        this.blendSrc = source.blendSrc;
                        this.blendDst = source.blendDst;
                        this.blendEquation = source.blendEquation;
                        this.blendSrcAlpha = source.blendSrcAlpha;
                        this.blendDstAlpha = source.blendDstAlpha;
                        this.blendEquationAlpha = source.blendEquationAlpha;
                        this.depthFunc = source.depthFunc;
                        this.depthTest = source.depthTest;
                        this.depthWrite = source.depthWrite;
                        this.stencilWriteMask = source.stencilWriteMask;
                        this.stencilFunc = source.stencilFunc;
                        this.stencilRef = source.stencilRef;
                        this.stencilFuncMask = source.stencilFuncMask;
                        this.stencilFail = source.stencilFail;
                        this.stencilZFail = source.stencilZFail;
                        this.stencilZPass = source.stencilZPass;
                        this.stencilWrite = source.stencilWrite;
                        var srcPlanes = source.clippingPlanes;
                        var dstPlanes = null;
                        if (srcPlanes !== null) {
                            var n = srcPlanes.length;
                            dstPlanes = new Array(n);
                            for (var i = 0; i !== n; ++i) {
                                dstPlanes[i] = srcPlanes[i].clone();
                            }
                        }
                        this.clippingPlanes = dstPlanes;
                        this.clipIntersection = source.clipIntersection;
                        this.clipShadows = source.clipShadows;
                        this.shadowSide = source.shadowSide;
                        this.colorWrite = source.colorWrite;
                        this.precision = source.precision;
                        this.polygonOffset = source.polygonOffset;
                        this.polygonOffsetFactor = source.polygonOffsetFactor;
                        this.polygonOffsetUnits = source.polygonOffsetUnits;
                        this.dithering = source.dithering;
                        this.alphaTest = source.alphaTest;
                        this.alphaToCoverage = source.alphaToCoverage;
                        this.premultipliedAlpha = source.premultipliedAlpha;
                        this.visible = source.visible;
                        this.toneMapped = source.toneMapped;
                        this.userData = JSON.parse(JSON.stringify(source.userData));
                        return this;
                    };
                    Material.prototype.dispose = function() {
                        this.dispatchEvent({
                            type: 'dispose'
                        });
                    };
                    Object.defineProperty(Material.prototype, "needsUpdate", {
                        set: function(value) {
                            if (value === true)
                                this.version++;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    return Material;
                }(EventDispatcher));
                Material.prototype.isMaterial = true;
                Material.fromType = function( /*type*/ ) {
                    // TODO: Behavior added in Materials.js
                    return null;
                };
                var MeshBasicMaterial = /** @class */ (function(_super) {
                    __extends(MeshBasicMaterial, _super);

                    function MeshBasicMaterial(parameters) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'MeshBasicMaterial';
                        _this_1.color = new Color(0xffffff); // emissive
                        _this_1.map = null;
                        _this_1.lightMap = null;
                        _this_1.lightMapIntensity = 1.0;
                        _this_1.aoMap = null;
                        _this_1.aoMapIntensity = 1.0;
                        _this_1.specularMap = null;
                        _this_1.alphaMap = null;
                        _this_1.envMap = null;
                        _this_1.combine = MultiplyOperation;
                        _this_1.reflectivity = 1;
                        _this_1.refractionRatio = 0.98;
                        _this_1.wireframe = false;
                        _this_1.wireframeLinewidth = 1;
                        _this_1.wireframeLinecap = 'round';
                        _this_1.wireframeLinejoin = 'round';
                        _this_1.setValues(parameters);
                        return _this_1;
                    }
                    MeshBasicMaterial.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.color.copy(source.color);
                        this.map = source.map;
                        this.lightMap = source.lightMap;
                        this.lightMapIntensity = source.lightMapIntensity;
                        this.aoMap = source.aoMap;
                        this.aoMapIntensity = source.aoMapIntensity;
                        this.specularMap = source.specularMap;
                        this.alphaMap = source.alphaMap;
                        this.envMap = source.envMap;
                        this.combine = source.combine;
                        this.reflectivity = source.reflectivity;
                        this.refractionRatio = source.refractionRatio;
                        this.wireframe = source.wireframe;
                        this.wireframeLinewidth = source.wireframeLinewidth;
                        this.wireframeLinecap = source.wireframeLinecap;
                        this.wireframeLinejoin = source.wireframeLinejoin;
                        return this;
                    };
                    return MeshBasicMaterial;
                }(Material));
                MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
                var _vector$9 = /*@__PURE__*/ new Vector3();
                var _vector2$1 = /*@__PURE__*/ new Vector2();
                var BufferAttribute = /** @class */ (function() {
                    function BufferAttribute(array, itemSize, normalized) {
                        if (Array.isArray(array)) {
                            throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
                        }
                        this.name = '';
                        this.array = array;
                        this.itemSize = itemSize;
                        this.count = array !== undefined ? array.length / itemSize : 0;
                        this.normalized = normalized === true;
                        this.usage = StaticDrawUsage;
                        this.updateRange = {
                            offset: 0,
                            count: -1
                        };
                        this.version = 0;
                    }
                    BufferAttribute.prototype.onUploadCallback = function() {};
                    Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
                        set: function(value) {
                            if (value === true)
                                this.version++;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    BufferAttribute.prototype.setUsage = function(value) {
                        this.usage = value;
                        return this;
                    };
                    BufferAttribute.prototype.copy = function(source) {
                        this.name = source.name;
                        this.array = new source.array.constructor(source.array);
                        this.itemSize = source.itemSize;
                        this.count = source.count;
                        this.normalized = source.normalized;
                        this.usage = source.usage;
                        return this;
                    };
                    BufferAttribute.prototype.copyAt = function(index1, attribute, index2) {
                        index1 *= this.itemSize;
                        index2 *= attribute.itemSize;
                        for (var i = 0, l = this.itemSize; i < l; i++) {
                            this.array[index1 + i] = attribute.array[index2 + i];
                        }
                        return this;
                    };
                    BufferAttribute.prototype.copyArray = function(array) {
                        this.array.set(array);
                        return this;
                    };
                    BufferAttribute.prototype.copyColorsArray = function(colors) {
                        var array = this.array;
                        var offset = 0;
                        for (var i = 0, l = colors.length; i < l; i++) {
                            var color = colors[i];
                            if (color === undefined) {
                                console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
                                color = new Color();
                            }
                            array[offset++] = color.r;
                            array[offset++] = color.g;
                            array[offset++] = color.b;
                        }
                        return this;
                    };
                    BufferAttribute.prototype.copyVector2sArray = function(vectors) {
                        var array = this.array;
                        var offset = 0;
                        for (var i = 0, l = vectors.length; i < l; i++) {
                            var vector = vectors[i];
                            if (vector === undefined) {
                                console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
                                vector = new Vector2();
                            }
                            array[offset++] = vector.x;
                            array[offset++] = vector.y;
                        }
                        return this;
                    };
                    BufferAttribute.prototype.copyVector3sArray = function(vectors) {
                        var array = this.array;
                        var offset = 0;
                        for (var i = 0, l = vectors.length; i < l; i++) {
                            var vector = vectors[i];
                            if (vector === undefined) {
                                console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
                                vector = new Vector3();
                            }
                            array[offset++] = vector.x;
                            array[offset++] = vector.y;
                            array[offset++] = vector.z;
                        }
                        return this;
                    };
                    BufferAttribute.prototype.copyVector4sArray = function(vectors) {
                        var array = this.array;
                        var offset = 0;
                        for (var i = 0, l = vectors.length; i < l; i++) {
                            var vector = vectors[i];
                            if (vector === undefined) {
                                console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
                                vector = new Vector4();
                            }
                            array[offset++] = vector.x;
                            array[offset++] = vector.y;
                            array[offset++] = vector.z;
                            array[offset++] = vector.w;
                        }
                        return this;
                    };
                    BufferAttribute.prototype.applyMatrix3 = function(m) {
                        if (this.itemSize === 2) {
                            for (var i = 0, l = this.count; i < l; i++) {
                                _vector2$1.fromBufferAttribute(this, i);
                                _vector2$1.applyMatrix3(m);
                                this.setXY(i, _vector2$1.x, _vector2$1.y);
                            }
                        } else if (this.itemSize === 3) {
                            for (var i = 0, l = this.count; i < l; i++) {
                                _vector$9.fromBufferAttribute(this, i);
                                _vector$9.applyMatrix3(m);
                                this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
                            }
                        }
                        return this;
                    };
                    BufferAttribute.prototype.applyMatrix4 = function(m) {
                        for (var i = 0, l = this.count; i < l; i++) {
                            _vector$9.fromBufferAttribute(this, i);
                            _vector$9.applyMatrix4(m);
                            this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
                        }
                        return this;
                    };
                    BufferAttribute.prototype.applyNormalMatrix = function(m) {
                        for (var i = 0, l = this.count; i < l; i++) {
                            _vector$9.fromBufferAttribute(this, i);
                            _vector$9.applyNormalMatrix(m);
                            this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
                        }
                        return this;
                    };
                    BufferAttribute.prototype.transformDirection = function(m) {
                        for (var i = 0, l = this.count; i < l; i++) {
                            _vector$9.fromBufferAttribute(this, i);
                            _vector$9.transformDirection(m);
                            this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
                        }
                        return this;
                    };
                    BufferAttribute.prototype.set = function(value, offset) {
                        if (offset === void 0) {
                            offset = 0;
                        }
                        this.array.set(value, offset);
                        return this;
                    };
                    BufferAttribute.prototype.getX = function(index) {
                        return this.array[index * this.itemSize];
                    };
                    BufferAttribute.prototype.setX = function(index, x) {
                        this.array[index * this.itemSize] = x;
                        return this;
                    };
                    BufferAttribute.prototype.getY = function(index) {
                        return this.array[index * this.itemSize + 1];
                    };
                    BufferAttribute.prototype.setY = function(index, y) {
                        this.array[index * this.itemSize + 1] = y;
                        return this;
                    };
                    BufferAttribute.prototype.getZ = function(index) {
                        return this.array[index * this.itemSize + 2];
                    };
                    BufferAttribute.prototype.setZ = function(index, z) {
                        this.array[index * this.itemSize + 2] = z;
                        return this;
                    };
                    BufferAttribute.prototype.getW = function(index) {
                        return this.array[index * this.itemSize + 3];
                    };
                    BufferAttribute.prototype.setW = function(index, w) {
                        this.array[index * this.itemSize + 3] = w;
                        return this;
                    };
                    BufferAttribute.prototype.setXY = function(index, x, y) {
                        index *= this.itemSize;
                        this.array[index + 0] = x;
                        this.array[index + 1] = y;
                        return this;
                    };
                    BufferAttribute.prototype.setXYZ = function(index, x, y, z) {
                        index *= this.itemSize;
                        this.array[index + 0] = x;
                        this.array[index + 1] = y;
                        this.array[index + 2] = z;
                        return this;
                    };
                    BufferAttribute.prototype.setXYZW = function(index, x, y, z, w) {
                        index *= this.itemSize;
                        this.array[index + 0] = x;
                        this.array[index + 1] = y;
                        this.array[index + 2] = z;
                        this.array[index + 3] = w;
                        return this;
                    };
                    BufferAttribute.prototype.onUpload = function(callback) {
                        this.onUploadCallback = callback;
                        return this;
                    };
                    BufferAttribute.prototype.clone = function() {
                        return new this.constructor(this.array, this.itemSize).copy(this);
                    };
                    BufferAttribute.prototype.toJSON = function() {
                        var data = {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: Array.prototype.slice.call(this.array),
                            normalized: this.normalized
                        };
                        if (this.name !== '')
                            data.name = this.name;
                        if (this.usage !== StaticDrawUsage)
                            data.usage = this.usage;
                        if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
                            data.updateRange = this.updateRange;
                        return data;
                    };
                    return BufferAttribute;
                }());
                BufferAttribute.prototype.isBufferAttribute = true;
                //
                var Int8BufferAttribute = /** @class */ (function(_super) {
                    __extends(Int8BufferAttribute, _super);

                    function Int8BufferAttribute(array, itemSize, normalized) {
                        return _super.call(this, new Int8Array(array), itemSize, normalized) || this;
                    }
                    return Int8BufferAttribute;
                }(BufferAttribute));
                var Uint8BufferAttribute = /** @class */ (function(_super) {
                    __extends(Uint8BufferAttribute, _super);

                    function Uint8BufferAttribute(array, itemSize, normalized) {
                        return _super.call(this, new Uint8Array(array), itemSize, normalized) || this;
                    }
                    return Uint8BufferAttribute;
                }(BufferAttribute));
                var Uint8ClampedBufferAttribute = /** @class */ (function(_super) {
                    __extends(Uint8ClampedBufferAttribute, _super);

                    function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
                        return _super.call(this, new Uint8ClampedArray(array), itemSize, normalized) || this;
                    }
                    return Uint8ClampedBufferAttribute;
                }(BufferAttribute));
                var Int16BufferAttribute = /** @class */ (function(_super) {
                    __extends(Int16BufferAttribute, _super);

                    function Int16BufferAttribute(array, itemSize, normalized) {
                        return _super.call(this, new Int16Array(array), itemSize, normalized) || this;
                    }
                    return Int16BufferAttribute;
                }(BufferAttribute));
                var Uint16BufferAttribute = /** @class */ (function(_super) {
                    __extends(Uint16BufferAttribute, _super);

                    function Uint16BufferAttribute(array, itemSize, normalized) {
                        return _super.call(this, new Uint16Array(array), itemSize, normalized) || this;
                    }
                    return Uint16BufferAttribute;
                }(BufferAttribute));
                var Int32BufferAttribute = /** @class */ (function(_super) {
                    __extends(Int32BufferAttribute, _super);

                    function Int32BufferAttribute(array, itemSize, normalized) {
                        return _super.call(this, new Int32Array(array), itemSize, normalized) || this;
                    }
                    return Int32BufferAttribute;
                }(BufferAttribute));
                var Uint32BufferAttribute = /** @class */ (function(_super) {
                    __extends(Uint32BufferAttribute, _super);

                    function Uint32BufferAttribute(array, itemSize, normalized) {
                        return _super.call(this, new Uint32Array(array), itemSize, normalized) || this;
                    }
                    return Uint32BufferAttribute;
                }(BufferAttribute));
                var Float16BufferAttribute = /** @class */ (function(_super) {
                    __extends(Float16BufferAttribute, _super);

                    function Float16BufferAttribute(array, itemSize, normalized) {
                        return _super.call(this, new Uint16Array(array), itemSize, normalized) || this;
                    }
                    return Float16BufferAttribute;
                }(BufferAttribute));
                Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
                var Float32BufferAttribute = /** @class */ (function(_super) {
                    __extends(Float32BufferAttribute, _super);

                    function Float32BufferAttribute(array, itemSize, normalized) {
                        return _super.call(this, new Float32Array(array), itemSize, normalized) || this;
                    }
                    return Float32BufferAttribute;
                }(BufferAttribute));
                var Float64BufferAttribute = /** @class */ (function(_super) {
                    __extends(Float64BufferAttribute, _super);

                    function Float64BufferAttribute(array, itemSize, normalized) {
                        return _super.call(this, new Float64Array(array), itemSize, normalized) || this;
                    }
                    return Float64BufferAttribute;
                }(BufferAttribute));
                var _id$1 = 0;
                var _m1 = /*@__PURE__*/ new Matrix4();
                var _obj = /*@__PURE__*/ new Object3D();
                var _offset = /*@__PURE__*/ new Vector3();
                var _box$1 = /*@__PURE__*/ new Box3();
                var _boxMorphTargets = /*@__PURE__*/ new Box3();
                var _vector$8 = /*@__PURE__*/ new Vector3();
                var BufferGeometry = /** @class */ (function(_super) {
                    __extends(BufferGeometry, _super);

                    function BufferGeometry() {
                        var _this_1 = _super.call(this) || this;
                        Object.defineProperty(_this_1, 'id', {
                            value: _id$1++
                        });
                        _this_1.uuid = generateUUID();
                        _this_1.name = '';
                        _this_1.type = 'BufferGeometry';
                        _this_1.index = null;
                        _this_1.attributes = {};
                        _this_1.morphAttributes = {};
                        _this_1.morphTargetsRelative = false;
                        _this_1.groups = [];
                        _this_1.boundingBox = null;
                        _this_1.boundingSphere = null;
                        _this_1.drawRange = {
                            start: 0,
                            count: Infinity
                        };
                        _this_1.userData = {};
                        return _this_1;
                    }
                    BufferGeometry.prototype.getIndex = function() {
                        return this.index;
                    };
                    BufferGeometry.prototype.setIndex = function(index) {
                        if (Array.isArray(index)) {
                            this.index = new(arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
                        } else {
                            this.index = index;
                        }
                        return this;
                    };
                    BufferGeometry.prototype.getAttribute = function(name) {
                        return this.attributes[name];
                    };
                    BufferGeometry.prototype.setAttribute = function(name, attribute) {
                        this.attributes[name] = attribute;
                        return this;
                    };
                    BufferGeometry.prototype.deleteAttribute = function(name) {
                        delete this.attributes[name];
                        return this;
                    };
                    BufferGeometry.prototype.hasAttribute = function(name) {
                        return this.attributes[name] !== undefined;
                    };
                    BufferGeometry.prototype.addGroup = function(start, count, materialIndex) {
                        if (materialIndex === void 0) {
                            materialIndex = 0;
                        }
                        this.groups.push({
                            start: start,
                            count: count,
                            materialIndex: materialIndex
                        });
                    };
                    BufferGeometry.prototype.clearGroups = function() {
                        this.groups = [];
                    };
                    BufferGeometry.prototype.setDrawRange = function(start, count) {
                        this.drawRange.start = start;
                        this.drawRange.count = count;
                    };
                    BufferGeometry.prototype.applyMatrix4 = function(matrix) {
                        var position = this.attributes.position;
                        if (position !== undefined) {
                            position.applyMatrix4(matrix);
                            position.needsUpdate = true;
                        }
                        var normal = this.attributes.normal;
                        if (normal !== undefined) {
                            var normalMatrix = new Matrix3().getNormalMatrix(matrix);
                            normal.applyNormalMatrix(normalMatrix);
                            normal.needsUpdate = true;
                        }
                        var tangent = this.attributes.tangent;
                        if (tangent !== undefined) {
                            tangent.transformDirection(matrix);
                            tangent.needsUpdate = true;
                        }
                        if (this.boundingBox !== null) {
                            this.computeBoundingBox();
                        }
                        if (this.boundingSphere !== null) {
                            this.computeBoundingSphere();
                        }
                        return this;
                    };
                    BufferGeometry.prototype.applyQuaternion = function(q) {
                        _m1.makeRotationFromQuaternion(q);
                        this.applyMatrix4(_m1);
                        return this;
                    };
                    BufferGeometry.prototype.rotateX = function(angle) {
                        // rotate geometry around world x-axis
                        _m1.makeRotationX(angle);
                        this.applyMatrix4(_m1);
                        return this;
                    };
                    BufferGeometry.prototype.rotateY = function(angle) {
                        // rotate geometry around world y-axis
                        _m1.makeRotationY(angle);
                        this.applyMatrix4(_m1);
                        return this;
                    };
                    BufferGeometry.prototype.rotateZ = function(angle) {
                        // rotate geometry around world z-axis
                        _m1.makeRotationZ(angle);
                        this.applyMatrix4(_m1);
                        return this;
                    };
                    BufferGeometry.prototype.translate = function(x, y, z) {
                        // translate geometry
                        _m1.makeTranslation(x, y, z);
                        this.applyMatrix4(_m1);
                        return this;
                    };
                    BufferGeometry.prototype.scale = function(x, y, z) {
                        // scale geometry
                        _m1.makeScale(x, y, z);
                        this.applyMatrix4(_m1);
                        return this;
                    };
                    BufferGeometry.prototype.lookAt = function(vector) {
                        _obj.lookAt(vector);
                        _obj.updateMatrix();
                        this.applyMatrix4(_obj.matrix);
                        return this;
                    };
                    BufferGeometry.prototype.center = function() {
                        this.computeBoundingBox();
                        this.boundingBox.getCenter(_offset).negate();
                        this.translate(_offset.x, _offset.y, _offset.z);
                        return this;
                    };
                    BufferGeometry.prototype.setFromPoints = function(points) {
                        var position = [];
                        for (var i = 0, l = points.length; i < l; i++) {
                            var point = points[i];
                            position.push(point.x, point.y, point.z || 0);
                        }
                        this.setAttribute('position', new Float32BufferAttribute(position, 3));
                        return this;
                    };
                    BufferGeometry.prototype.computeBoundingBox = function() {
                        if (this.boundingBox === null) {
                            this.boundingBox = new Box3();
                        }
                        var position = this.attributes.position;
                        var morphAttributesPosition = this.morphAttributes.position;
                        if (position && position.isGLBufferAttribute) {
                            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
                            this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
                            return;
                        }
                        if (position !== undefined) {
                            this.boundingBox.setFromBufferAttribute(position);
                            // process morph attributes if present
                            if (morphAttributesPosition) {
                                for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
                                    var morphAttribute = morphAttributesPosition[i];
                                    _box$1.setFromBufferAttribute(morphAttribute);
                                    if (this.morphTargetsRelative) {
                                        _vector$8.addVectors(this.boundingBox.min, _box$1.min);
                                        this.boundingBox.expandByPoint(_vector$8);
                                        _vector$8.addVectors(this.boundingBox.max, _box$1.max);
                                        this.boundingBox.expandByPoint(_vector$8);
                                    } else {
                                        this.boundingBox.expandByPoint(_box$1.min);
                                        this.boundingBox.expandByPoint(_box$1.max);
                                    }
                                }
                            }
                        } else {
                            this.boundingBox.makeEmpty();
                        }
                        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
                            console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
                        }
                    };
                    BufferGeometry.prototype.computeBoundingSphere = function() {
                        if (this.boundingSphere === null) {
                            this.boundingSphere = new Sphere();
                        }
                        var position = this.attributes.position;
                        var morphAttributesPosition = this.morphAttributes.position;
                        if (position && position.isGLBufferAttribute) {
                            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
                            this.boundingSphere.set(new Vector3(), Infinity);
                            return;
                        }
                        if (position) {
                            // first, find the center of the bounding sphere
                            var center = this.boundingSphere.center;
                            _box$1.setFromBufferAttribute(position);
                            // process morph attributes if present
                            if (morphAttributesPosition) {
                                for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
                                    var morphAttribute = morphAttributesPosition[i];
                                    _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                                    if (this.morphTargetsRelative) {
                                        _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
                                        _box$1.expandByPoint(_vector$8);
                                        _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
                                        _box$1.expandByPoint(_vector$8);
                                    } else {
                                        _box$1.expandByPoint(_boxMorphTargets.min);
                                        _box$1.expandByPoint(_boxMorphTargets.max);
                                    }
                                }
                            }
                            _box$1.getCenter(center);
                            // second, try to find a boundingSphere with a radius smaller than the
                            // boundingSphere of the boundingBox: sqrt(3) smaller in the best case
                            var maxRadiusSq = 0;
                            for (var i = 0, il = position.count; i < il; i++) {
                                _vector$8.fromBufferAttribute(position, i);
                                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
                            }
                            // process morph attributes if present
                            if (morphAttributesPosition) {
                                for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
                                    var morphAttribute = morphAttributesPosition[i];
                                    var morphTargetsRelative = this.morphTargetsRelative;
                                    for (var j = 0, jl = morphAttribute.count; j < jl; j++) {
                                        _vector$8.fromBufferAttribute(morphAttribute, j);
                                        if (morphTargetsRelative) {
                                            _offset.fromBufferAttribute(position, j);
                                            _vector$8.add(_offset);
                                        }
                                        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
                                    }
                                }
                            }
                            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
                            if (isNaN(this.boundingSphere.radius)) {
                                console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
                            }
                        }
                    };
                    BufferGeometry.prototype.computeTangents = function() {
                        var index = this.index;
                        var attributes = this.attributes;
                        // based on http://www.terathon.com/code/tangent.html
                        // (per vertex tangents)
                        if (index === null ||
                            attributes.position === undefined ||
                            attributes.normal === undefined ||
                            attributes.uv === undefined) {
                            console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
                            return;
                        }
                        var indices = index.array;
                        var positions = attributes.position.array;
                        var normals = attributes.normal.array;
                        var uvs = attributes.uv.array;
                        var nVertices = positions.length / 3;
                        if (this.hasAttribute('tangent') === false) {
                            this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
                        }
                        var tangents = this.getAttribute('tangent').array;
                        var tan1 = [],
                            tan2 = [];
                        for (var i = 0; i < nVertices; i++) {
                            tan1[i] = new Vector3();
                            tan2[i] = new Vector3();
                        }
                        var vA = new Vector3(),
                            vB = new Vector3(),
                            vC = new Vector3(),
                            uvA = new Vector2(),
                            uvB = new Vector2(),
                            uvC = new Vector2(),
                            sdir = new Vector3(),
                            tdir = new Vector3();

                        function handleTriangle(a, b, c) {
                            vA.fromArray(positions, a * 3);
                            vB.fromArray(positions, b * 3);
                            vC.fromArray(positions, c * 3);
                            uvA.fromArray(uvs, a * 2);
                            uvB.fromArray(uvs, b * 2);
                            uvC.fromArray(uvs, c * 2);
                            vB.sub(vA);
                            vC.sub(vA);
                            uvB.sub(uvA);
                            uvC.sub(uvA);
                            var r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);
                            // silently ignore degenerate uv triangles having coincident or colinear vertices
                            if (!isFinite(r))
                                return;
                            sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
                            tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
                            tan1[a].add(sdir);
                            tan1[b].add(sdir);
                            tan1[c].add(sdir);
                            tan2[a].add(tdir);
                            tan2[b].add(tdir);
                            tan2[c].add(tdir);
                        }
                        var groups = this.groups;
                        if (groups.length === 0) {
                            groups = [{
                                start: 0,
                                count: indices.length
                            }];
                        }
                        for (var i = 0, il = groups.length; i < il; ++i) {
                            var group = groups[i];
                            var start = group.start;
                            var count = group.count;
                            for (var j = start, jl = start + count; j < jl; j += 3) {
                                handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
                            }
                        }
                        var tmp = new Vector3(),
                            tmp2 = new Vector3();
                        var n = new Vector3(),
                            n2 = new Vector3();

                        function handleVertex(v) {
                            n.fromArray(normals, v * 3);
                            n2.copy(n);
                            var t = tan1[v];
                            // Gram-Schmidt orthogonalize
                            tmp.copy(t);
                            tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
                            // Calculate handedness
                            tmp2.crossVectors(n2, t);
                            var test = tmp2.dot(tan2[v]);
                            var w = (test < 0.0) ? -1.0 : 1.0;
                            tangents[v * 4] = tmp.x;
                            tangents[v * 4 + 1] = tmp.y;
                            tangents[v * 4 + 2] = tmp.z;
                            tangents[v * 4 + 3] = w;
                        }
                        for (var i = 0, il = groups.length; i < il; ++i) {
                            var group = groups[i];
                            var start = group.start;
                            var count = group.count;
                            for (var j = start, jl = start + count; j < jl; j += 3) {
                                handleVertex(indices[j + 0]);
                                handleVertex(indices[j + 1]);
                                handleVertex(indices[j + 2]);
                            }
                        }
                    };
                    BufferGeometry.prototype.computeVertexNormals = function() {
                        var index = this.index;
                        var positionAttribute = this.getAttribute('position');
                        if (positionAttribute !== undefined) {
                            var normalAttribute = this.getAttribute('normal');
                            if (normalAttribute === undefined) {
                                normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
                                this.setAttribute('normal', normalAttribute);
                            } else {
                                // reset existing normals to zero
                                for (var i = 0, il = normalAttribute.count; i < il; i++) {
                                    normalAttribute.setXYZ(i, 0, 0, 0);
                                }
                            }
                            var pA = new Vector3(),
                                pB = new Vector3(),
                                pC = new Vector3();
                            var nA = new Vector3(),
                                nB = new Vector3(),
                                nC = new Vector3();
                            var cb = new Vector3(),
                                ab = new Vector3();
                            // indexed elements
                            if (index) {
                                for (var i = 0, il = index.count; i < il; i += 3) {
                                    var vA = index.getX(i + 0);
                                    var vB = index.getX(i + 1);
                                    var vC = index.getX(i + 2);
                                    pA.fromBufferAttribute(positionAttribute, vA);
                                    pB.fromBufferAttribute(positionAttribute, vB);
                                    pC.fromBufferAttribute(positionAttribute, vC);
                                    cb.subVectors(pC, pB);
                                    ab.subVectors(pA, pB);
                                    cb.cross(ab);
                                    nA.fromBufferAttribute(normalAttribute, vA);
                                    nB.fromBufferAttribute(normalAttribute, vB);
                                    nC.fromBufferAttribute(normalAttribute, vC);
                                    nA.add(cb);
                                    nB.add(cb);
                                    nC.add(cb);
                                    normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                                    normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                                    normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
                                }
                            } else {
                                // non-indexed elements (unconnected triangle soup)
                                for (var i = 0, il = positionAttribute.count; i < il; i += 3) {
                                    pA.fromBufferAttribute(positionAttribute, i + 0);
                                    pB.fromBufferAttribute(positionAttribute, i + 1);
                                    pC.fromBufferAttribute(positionAttribute, i + 2);
                                    cb.subVectors(pC, pB);
                                    ab.subVectors(pA, pB);
                                    cb.cross(ab);
                                    normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
                                    normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
                                    normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
                                }
                            }
                            this.normalizeNormals();
                            normalAttribute.needsUpdate = true;
                        }
                    };
                    BufferGeometry.prototype.merge = function(geometry, offset) {
                        if (!(geometry && geometry.isBufferGeometry)) {
                            console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
                            return;
                        }
                        if (offset === undefined) {
                            offset = 0;
                            console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' +
                                'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
                        }
                        var attributes = this.attributes;
                        for (var key in attributes) {
                            if (geometry.attributes[key] === undefined)
                                continue;
                            var attribute1 = attributes[key];
                            var attributeArray1 = attribute1.array;
                            var attribute2 = geometry.attributes[key];
                            var attributeArray2 = attribute2.array;
                            var attributeOffset = attribute2.itemSize * offset;
                            var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
                            for (var i = 0, j = attributeOffset; i < length; i++, j++) {
                                attributeArray1[j] = attributeArray2[i];
                            }
                        }
                        return this;
                    };
                    BufferGeometry.prototype.normalizeNormals = function() {
                        var normals = this.attributes.normal;
                        for (var i = 0, il = normals.count; i < il; i++) {
                            _vector$8.fromBufferAttribute(normals, i);
                            _vector$8.normalize();
                            normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
                        }
                    };
                    BufferGeometry.prototype.toNonIndexed = function() {
                        function convertBufferAttribute(attribute, indices) {
                            var array = attribute.array;
                            var itemSize = attribute.itemSize;
                            var normalized = attribute.normalized;
                            var array2 = new array.constructor(indices.length * itemSize);
                            var index = 0,
                                index2 = 0;
                            for (var i = 0, l = indices.length; i < l; i++) {
                                if (attribute.isInterleavedBufferAttribute) {
                                    index = indices[i] * attribute.data.stride + attribute.offset;
                                } else {
                                    index = indices[i] * itemSize;
                                }
                                for (var j = 0; j < itemSize; j++) {
                                    array2[index2++] = array[index++];
                                }
                            }
                            return new BufferAttribute(array2, itemSize, normalized);
                        }
                        //
                        if (this.index === null) {
                            console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
                            return this;
                        }
                        var geometry2 = new BufferGeometry();
                        var indices = this.index.array;
                        var attributes = this.attributes;
                        // attributes
                        for (var name in attributes) {
                            var attribute = attributes[name];
                            var newAttribute = convertBufferAttribute(attribute, indices);
                            geometry2.setAttribute(name, newAttribute);
                        }
                        // morph attributes
                        var morphAttributes = this.morphAttributes;
                        for (var name in morphAttributes) {
                            var morphArray = [];
                            var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes
                            for (var i = 0, il = morphAttribute.length; i < il; i++) {
                                var attribute = morphAttribute[i];
                                var newAttribute = convertBufferAttribute(attribute, indices);
                                morphArray.push(newAttribute);
                            }
                            geometry2.morphAttributes[name] = morphArray;
                        }
                        geometry2.morphTargetsRelative = this.morphTargetsRelative;
                        // groups
                        var groups = this.groups;
                        for (var i = 0, l = groups.length; i < l; i++) {
                            var group = groups[i];
                            geometry2.addGroup(group.start, group.count, group.materialIndex);
                        }
                        return geometry2;
                    };
                    BufferGeometry.prototype.toJSON = function() {
                        var data = {
                            metadata: {
                                version: 4.5,
                                type: 'BufferGeometry',
                                generator: 'BufferGeometry.toJSON'
                            }
                        };
                        // standard BufferGeometry serialization
                        data.uuid = this.uuid;
                        data.type = this.type;
                        if (this.name !== '')
                            data.name = this.name;
                        if (Object.keys(this.userData).length > 0)
                            data.userData = this.userData;
                        if (this.parameters !== undefined) {
                            var parameters = this.parameters;
                            for (var key in parameters) {
                                if (parameters[key] !== undefined)
                                    data[key] = parameters[key];
                            }
                            return data;
                        }
                        // for simplicity the code assumes attributes are not shared across geometries, see #15811
                        data.data = {
                            attributes: {}
                        };
                        var index = this.index;
                        if (index !== null) {
                            data.data.index = {
                                type: index.array.constructor.name,
                                array: Array.prototype.slice.call(index.array)
                            };
                        }
                        var attributes = this.attributes;
                        for (var key in attributes) {
                            var attribute = attributes[key];
                            data.data.attributes[key] = attribute.toJSON(data.data);
                        }
                        var morphAttributes = {};
                        var hasMorphAttributes = false;
                        for (var key in this.morphAttributes) {
                            var attributeArray = this.morphAttributes[key];
                            var array = [];
                            for (var i = 0, il = attributeArray.length; i < il; i++) {
                                var attribute = attributeArray[i];
                                array.push(attribute.toJSON(data.data));
                            }
                            if (array.length > 0) {
                                morphAttributes[key] = array;
                                hasMorphAttributes = true;
                            }
                        }
                        if (hasMorphAttributes) {
                            data.data.morphAttributes = morphAttributes;
                            data.data.morphTargetsRelative = this.morphTargetsRelative;
                        }
                        var groups = this.groups;
                        if (groups.length > 0) {
                            data.data.groups = JSON.parse(JSON.stringify(groups));
                        }
                        var boundingSphere = this.boundingSphere;
                        if (boundingSphere !== null) {
                            data.data.boundingSphere = {
                                center: boundingSphere.center.toArray(),
                                radius: boundingSphere.radius
                            };
                        }
                        return data;
                    };
                    BufferGeometry.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    BufferGeometry.prototype.copy = function(source) {
                        // reset
                        this.index = null;
                        this.attributes = {};
                        this.morphAttributes = {};
                        this.groups = [];
                        this.boundingBox = null;
                        this.boundingSphere = null;
                        // used for storing cloned, shared data
                        var data = {};
                        // name
                        this.name = source.name;
                        // index
                        var index = source.index;
                        if (index !== null) {
                            this.setIndex(index.clone(data));
                        }
                        // attributes
                        var attributes = source.attributes;
                        for (var name in attributes) {
                            var attribute = attributes[name];
                            this.setAttribute(name, attribute.clone(data));
                        }
                        // morph attributes
                        var morphAttributes = source.morphAttributes;
                        for (var name in morphAttributes) {
                            var array = [];
                            var morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes
                            for (var i = 0, l = morphAttribute.length; i < l; i++) {
                                array.push(morphAttribute[i].clone(data));
                            }
                            this.morphAttributes[name] = array;
                        }
                        this.morphTargetsRelative = source.morphTargetsRelative;
                        // groups
                        var groups = source.groups;
                        for (var i = 0, l = groups.length; i < l; i++) {
                            var group = groups[i];
                            this.addGroup(group.start, group.count, group.materialIndex);
                        }
                        // bounding box
                        var boundingBox = source.boundingBox;
                        if (boundingBox !== null) {
                            this.boundingBox = boundingBox.clone();
                        }
                        // bounding sphere
                        var boundingSphere = source.boundingSphere;
                        if (boundingSphere !== null) {
                            this.boundingSphere = boundingSphere.clone();
                        }
                        // draw range
                        this.drawRange.start = source.drawRange.start;
                        this.drawRange.count = source.drawRange.count;
                        // user data
                        this.userData = source.userData;
                        // geometry generator parameters
                        if (source.parameters !== undefined)
                            this.parameters = Object.assign({}, source.parameters);
                        return this;
                    };
                    BufferGeometry.prototype.dispose = function() {
                        this.dispatchEvent({
                            type: 'dispose'
                        });
                    };
                    return BufferGeometry;
                }(EventDispatcher));
                BufferGeometry.prototype.isBufferGeometry = true;
                var _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
                var _ray$2 = /*@__PURE__*/ new Ray();
                var _sphere$3 = /*@__PURE__*/ new Sphere();
                var _vA$1 = /*@__PURE__*/ new Vector3();
                var _vB$1 = /*@__PURE__*/ new Vector3();
                var _vC$1 = /*@__PURE__*/ new Vector3();
                var _tempA = /*@__PURE__*/ new Vector3();
                var _tempB = /*@__PURE__*/ new Vector3();
                var _tempC = /*@__PURE__*/ new Vector3();
                var _morphA = /*@__PURE__*/ new Vector3();
                var _morphB = /*@__PURE__*/ new Vector3();
                var _morphC = /*@__PURE__*/ new Vector3();
                var _uvA$1 = /*@__PURE__*/ new Vector2();
                var _uvB$1 = /*@__PURE__*/ new Vector2();
                var _uvC$1 = /*@__PURE__*/ new Vector2();
                var _intersectionPoint = /*@__PURE__*/ new Vector3();
                var _intersectionPointWorld = /*@__PURE__*/ new Vector3();
                var Mesh = /** @class */ (function(_super) {
                    __extends(Mesh, _super);

                    function Mesh(geometry, material) {
                        if (geometry === void 0) {
                            geometry = new BufferGeometry();
                        }
                        if (material === void 0) {
                            material = new MeshBasicMaterial();
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'Mesh';
                        _this_1.geometry = geometry;
                        _this_1.material = material;
                        _this_1.updateMorphTargets();
                        return _this_1;
                    }
                    Mesh.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        if (source.morphTargetInfluences !== undefined) {
                            this.morphTargetInfluences = source.morphTargetInfluences.slice();
                        }
                        if (source.morphTargetDictionary !== undefined) {
                            this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
                        }
                        this.material = source.material;
                        this.geometry = source.geometry;
                        return this;
                    };
                    Mesh.prototype.updateMorphTargets = function() {
                        var geometry = this.geometry;
                        if (geometry.isBufferGeometry) {
                            var morphAttributes = geometry.morphAttributes;
                            var keys = Object.keys(morphAttributes);
                            if (keys.length > 0) {
                                var morphAttribute = morphAttributes[keys[0]];
                                if (morphAttribute !== undefined) {
                                    this.morphTargetInfluences = [];
                                    this.morphTargetDictionary = {};
                                    for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
                                        var name = morphAttribute[m].name || String(m);
                                        this.morphTargetInfluences.push(0);
                                        this.morphTargetDictionary[name] = m;
                                    }
                                }
                            }
                        } else {
                            var morphTargets = geometry.morphTargets;
                            if (morphTargets !== undefined && morphTargets.length > 0) {
                                console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
                            }
                        }
                    };
                    Mesh.prototype.raycast = function(raycaster, intersects) {
                        var geometry = this.geometry;
                        var material = this.material;
                        var matrixWorld = this.matrixWorld;
                        if (material === undefined)
                            return;
                        // Checking boundingSphere distance to ray
                        if (geometry.boundingSphere === null)
                            geometry.computeBoundingSphere();
                        _sphere$3.copy(geometry.boundingSphere);
                        _sphere$3.applyMatrix4(matrixWorld);
                        if (raycaster.ray.intersectsSphere(_sphere$3) === false)
                            return;
                        //
                        _inverseMatrix$2.copy(matrixWorld).invert();
                        _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
                        // Check boundingBox before continuing
                        if (geometry.boundingBox !== null) {
                            if (_ray$2.intersectsBox(geometry.boundingBox) === false)
                                return;
                        }
                        var intersection;
                        if (geometry.isBufferGeometry) {
                            var index = geometry.index;
                            var position = geometry.attributes.position;
                            var morphPosition = geometry.morphAttributes.position;
                            var morphTargetsRelative = geometry.morphTargetsRelative;
                            var uv = geometry.attributes.uv;
                            var uv2 = geometry.attributes.uv2;
                            var groups = geometry.groups;
                            var drawRange = geometry.drawRange;
                            if (index !== null) {
                                // indexed buffer geometry
                                if (Array.isArray(material)) {
                                    for (var i = 0, il = groups.length; i < il; i++) {
                                        var group = groups[i];
                                        var groupMaterial = material[group.materialIndex];
                                        var start = Math.max(group.start, drawRange.start);
                                        var end = Math.min(index.count, Math.min((group.start + group.count), (drawRange.start + drawRange.count)));
                                        for (var j = start, jl = end; j < jl; j += 3) {
                                            var a = index.getX(j);
                                            var b = index.getX(j + 1);
                                            var c = index.getX(j + 2);
                                            intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                                            if (intersection) {
                                                intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                                                intersection.face.materialIndex = group.materialIndex;
                                                intersects.push(intersection);
                                            }
                                        }
                                    }
                                } else {
                                    var start = Math.max(0, drawRange.start);
                                    var end = Math.min(index.count, (drawRange.start + drawRange.count));
                                    for (var i = start, il = end; i < il; i += 3) {
                                        var a = index.getX(i);
                                        var b = index.getX(i + 1);
                                        var c = index.getX(i + 2);
                                        intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                                        if (intersection) {
                                            intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics
                                            intersects.push(intersection);
                                        }
                                    }
                                }
                            } else if (position !== undefined) {
                                // non-indexed buffer geometry
                                if (Array.isArray(material)) {
                                    for (var i = 0, il = groups.length; i < il; i++) {
                                        var group = groups[i];
                                        var groupMaterial = material[group.materialIndex];
                                        var start = Math.max(group.start, drawRange.start);
                                        var end = Math.min(position.count, Math.min((group.start + group.count), (drawRange.start + drawRange.count)));
                                        for (var j = start, jl = end; j < jl; j += 3) {
                                            var a = j;
                                            var b = j + 1;
                                            var c = j + 2;
                                            intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                                            if (intersection) {
                                                intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
                                                intersection.face.materialIndex = group.materialIndex;
                                                intersects.push(intersection);
                                            }
                                        }
                                    }
                                } else {
                                    var start = Math.max(0, drawRange.start);
                                    var end = Math.min(position.count, (drawRange.start + drawRange.count));
                                    for (var i = start, il = end; i < il; i += 3) {
                                        var a = i;
                                        var b = i + 1;
                                        var c = i + 2;
                                        intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
                                        if (intersection) {
                                            intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics
                                            intersects.push(intersection);
                                        }
                                    }
                                }
                            }
                        } else if (geometry.isGeometry) {
                            console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
                        }
                    };
                    return Mesh;
                }(Object3D));
                Mesh.prototype.isMesh = true;

                function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
                    var intersect;
                    if (material.side === BackSide) {
                        intersect = ray.intersectTriangle(pC, pB, pA, true, point);
                    } else {
                        intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
                    }
                    if (intersect === null)
                        return null;
                    _intersectionPointWorld.copy(point);
                    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
                    var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
                    if (distance < raycaster.near || distance > raycaster.far)
                        return null;
                    return {
                        distance: distance,
                        point: _intersectionPointWorld.clone(),
                        object: object
                    };
                }

                function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
                    _vA$1.fromBufferAttribute(position, a);
                    _vB$1.fromBufferAttribute(position, b);
                    _vC$1.fromBufferAttribute(position, c);
                    var morphInfluences = object.morphTargetInfluences;
                    if (morphPosition && morphInfluences) {
                        _morphA.set(0, 0, 0);
                        _morphB.set(0, 0, 0);
                        _morphC.set(0, 0, 0);
                        for (var i = 0, il = morphPosition.length; i < il; i++) {
                            var influence = morphInfluences[i];
                            var morphAttribute = morphPosition[i];
                            if (influence === 0)
                                continue;
                            _tempA.fromBufferAttribute(morphAttribute, a);
                            _tempB.fromBufferAttribute(morphAttribute, b);
                            _tempC.fromBufferAttribute(morphAttribute, c);
                            if (morphTargetsRelative) {
                                _morphA.addScaledVector(_tempA, influence);
                                _morphB.addScaledVector(_tempB, influence);
                                _morphC.addScaledVector(_tempC, influence);
                            } else {
                                _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
                                _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
                                _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
                            }
                        }
                        _vA$1.add(_morphA);
                        _vB$1.add(_morphB);
                        _vC$1.add(_morphC);
                    }
                    if (object.isSkinnedMesh) {
                        object.boneTransform(a, _vA$1);
                        object.boneTransform(b, _vB$1);
                        object.boneTransform(c, _vC$1);
                    }
                    var intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
                    if (intersection) {
                        if (uv) {
                            _uvA$1.fromBufferAttribute(uv, a);
                            _uvB$1.fromBufferAttribute(uv, b);
                            _uvC$1.fromBufferAttribute(uv, c);
                            intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
                        }
                        if (uv2) {
                            _uvA$1.fromBufferAttribute(uv2, a);
                            _uvB$1.fromBufferAttribute(uv2, b);
                            _uvC$1.fromBufferAttribute(uv2, c);
                            intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
                        }
                        var face = {
                            a: a,
                            b: b,
                            c: c,
                            normal: new Vector3(),
                            materialIndex: 0
                        };
                        Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
                        intersection.face = face;
                    }
                    return intersection;
                }
                var BoxGeometry = /** @class */ (function(_super) {
                    __extends(BoxGeometry, _super);

                    function BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments) {
                        if (width === void 0) {
                            width = 1;
                        }
                        if (height === void 0) {
                            height = 1;
                        }
                        if (depth === void 0) {
                            depth = 1;
                        }
                        if (widthSegments === void 0) {
                            widthSegments = 1;
                        }
                        if (heightSegments === void 0) {
                            heightSegments = 1;
                        }
                        if (depthSegments === void 0) {
                            depthSegments = 1;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'BoxGeometry';
                        _this_1.parameters = {
                            width: width,
                            height: height,
                            depth: depth,
                            widthSegments: widthSegments,
                            heightSegments: heightSegments,
                            depthSegments: depthSegments
                        };
                        var scope = _this_1;
                        // segments
                        widthSegments = Math.floor(widthSegments);
                        heightSegments = Math.floor(heightSegments);
                        depthSegments = Math.floor(depthSegments);
                        // buffers
                        var indices = [];
                        var vertices = [];
                        var normals = [];
                        var uvs = [];
                        // helper variables
                        var numberOfVertices = 0;
                        var groupStart = 0;
                        // build each side of the box geometry
                        buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
                        buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
                        buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
                        buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
                        buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
                        buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
                        // build geometry
                        _this_1.setIndex(indices);
                        _this_1.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        _this_1.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        _this_1.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

                        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
                            var segmentWidth = width / gridX;
                            var segmentHeight = height / gridY;
                            var widthHalf = width / 2;
                            var heightHalf = height / 2;
                            var depthHalf = depth / 2;
                            var gridX1 = gridX + 1;
                            var gridY1 = gridY + 1;
                            var vertexCounter = 0;
                            var groupCount = 0;
                            var vector = new Vector3();
                            // generate vertices, normals and uvs
                            for (var iy = 0; iy < gridY1; iy++) {
                                var y = iy * segmentHeight - heightHalf;
                                for (var ix = 0; ix < gridX1; ix++) {
                                    var x = ix * segmentWidth - widthHalf;
                                    // set values to correct vector component
                                    vector[u] = x * udir;
                                    vector[v] = y * vdir;
                                    vector[w] = depthHalf;
                                    // now apply vector to vertex buffer
                                    vertices.push(vector.x, vector.y, vector.z);
                                    // set values to correct vector component
                                    vector[u] = 0;
                                    vector[v] = 0;
                                    vector[w] = depth > 0 ? 1 : -1;
                                    // now apply vector to normal buffer
                                    normals.push(vector.x, vector.y, vector.z);
                                    // uvs
                                    uvs.push(ix / gridX);
                                    uvs.push(1 - (iy / gridY));
                                    // counters
                                    vertexCounter += 1;
                                }
                            }
                            // indices
                            // 1. you need three indices to draw a single face
                            // 2. a single segment consists of two faces
                            // 3. so we need to generate six (2*3) indices per segment
                            for (var iy = 0; iy < gridY; iy++) {
                                for (var ix = 0; ix < gridX; ix++) {
                                    var a = numberOfVertices + ix + gridX1 * iy;
                                    var b = numberOfVertices + ix + gridX1 * (iy + 1);
                                    var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                                    var d = numberOfVertices + (ix + 1) + gridX1 * iy;
                                    // faces
                                    indices.push(a, b, d);
                                    indices.push(b, c, d);
                                    // increase counter
                                    groupCount += 6;
                                }
                            }
                            // add a group to the geometry. this will ensure multi material support
                            scope.addGroup(groupStart, groupCount, materialIndex);
                            // calculate new start value for groups
                            groupStart += groupCount;
                            // update total number of vertices
                            numberOfVertices += vertexCounter;
                        }
                        return _this_1;
                    }
                    BoxGeometry.fromJSON = function(data) {
                        return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
                    };
                    return BoxGeometry;
                }(BufferGeometry));
                /**
                 * Uniform Utilities
                 */
                function cloneUniforms(src) {
                    var dst = {};
                    for (var u in src) {
                        dst[u] = {};
                        for (var p in src[u]) {
                            var property = src[u][p];
                            if (property && (property.isColor ||
                                    property.isMatrix3 || property.isMatrix4 ||
                                    property.isVector2 || property.isVector3 || property.isVector4 ||
                                    property.isTexture || property.isQuaternion)) {
                                dst[u][p] = property.clone();
                            } else if (Array.isArray(property)) {
                                dst[u][p] = property.slice();
                            } else {
                                dst[u][p] = property;
                            }
                        }
                    }
                    return dst;
                }

                function mergeUniforms(uniforms) {
                    var merged = {};
                    for (var u = 0; u < uniforms.length; u++) {
                        var tmp_1 = cloneUniforms(uniforms[u]);
                        for (var p in tmp_1) {
                            merged[p] = tmp_1[p];
                        }
                    }
                    return merged;
                }
                // Legacy
                var UniformsUtils = {
                    clone: cloneUniforms,
                    merge: mergeUniforms
                };
                var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
                var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
                var ShaderMaterial = /** @class */ (function(_super) {
                    __extends(ShaderMaterial, _super);

                    function ShaderMaterial(parameters) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'ShaderMaterial';
                        _this_1.defines = {};
                        _this_1.uniforms = {};
                        _this_1.vertexShader = default_vertex;
                        _this_1.fragmentShader = default_fragment;
                        _this_1.linewidth = 1;
                        _this_1.wireframe = false;
                        _this_1.wireframeLinewidth = 1;
                        _this_1.fog = false; // set to use scene fog
                        _this_1.lights = false; // set to use scene lights
                        _this_1.clipping = false; // set to use user-defined clipping planes
                        _this_1.extensions = {
                            derivatives: false,
                            fragDepth: false,
                            drawBuffers: false,
                            shaderTextureLOD: false // set to use shader texture LOD
                        };
                        // When rendered geometry doesn't include these attributes but the material does,
                        // use these default values in WebGL. This avoids errors when buffer data is missing.
                        _this_1.defaultAttributeValues = {
                            'color': [1, 1, 1],
                            'uv': [0, 0],
                            'uv2': [0, 0]
                        };
                        _this_1.index0AttributeName = undefined;
                        _this_1.uniformsNeedUpdate = false;
                        _this_1.glslVersion = null;
                        if (parameters !== undefined) {
                            if (parameters.attributes !== undefined) {
                                console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
                            }
                            _this_1.setValues(parameters);
                        }
                        return _this_1;
                    }
                    ShaderMaterial.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.fragmentShader = source.fragmentShader;
                        this.vertexShader = source.vertexShader;
                        this.uniforms = cloneUniforms(source.uniforms);
                        this.defines = Object.assign({}, source.defines);
                        this.wireframe = source.wireframe;
                        this.wireframeLinewidth = source.wireframeLinewidth;
                        this.lights = source.lights;
                        this.clipping = source.clipping;
                        this.extensions = Object.assign({}, source.extensions);
                        this.glslVersion = source.glslVersion;
                        return this;
                    };
                    ShaderMaterial.prototype.toJSON = function(meta) {
                        var data = _super.prototype.toJSON.call(this, meta);
                        data.glslVersion = this.glslVersion;
                        data.uniforms = {};
                        for (var name in this.uniforms) {
                            var uniform = this.uniforms[name];
                            var value = uniform.value;
                            if (value && value.isTexture) {
                                data.uniforms[name] = {
                                    type: 't',
                                    value: value.toJSON(meta).uuid
                                };
                            } else if (value && value.isColor) {
                                data.uniforms[name] = {
                                    type: 'c',
                                    value: value.getHex()
                                };
                            } else if (value && value.isVector2) {
                                data.uniforms[name] = {
                                    type: 'v2',
                                    value: value.toArray()
                                };
                            } else if (value && value.isVector3) {
                                data.uniforms[name] = {
                                    type: 'v3',
                                    value: value.toArray()
                                };
                            } else if (value && value.isVector4) {
                                data.uniforms[name] = {
                                    type: 'v4',
                                    value: value.toArray()
                                };
                            } else if (value && value.isMatrix3) {
                                data.uniforms[name] = {
                                    type: 'm3',
                                    value: value.toArray()
                                };
                            } else if (value && value.isMatrix4) {
                                data.uniforms[name] = {
                                    type: 'm4',
                                    value: value.toArray()
                                };
                            } else {
                                data.uniforms[name] = {
                                    value: value
                                };
                                // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
                            }
                        }
                        if (Object.keys(this.defines).length > 0)
                            data.defines = this.defines;
                        data.vertexShader = this.vertexShader;
                        data.fragmentShader = this.fragmentShader;
                        var extensions = {};
                        for (var key in this.extensions) {
                            if (this.extensions[key] === true)
                                extensions[key] = true;
                        }
                        if (Object.keys(extensions).length > 0)
                            data.extensions = extensions;
                        return data;
                    };
                    return ShaderMaterial;
                }(Material));
                ShaderMaterial.prototype.isShaderMaterial = true;
                var Camera = /** @class */ (function(_super) {
                    __extends(Camera, _super);

                    function Camera() {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'Camera';
                        _this_1.matrixWorldInverse = new Matrix4();
                        _this_1.projectionMatrix = new Matrix4();
                        _this_1.projectionMatrixInverse = new Matrix4();
                        return _this_1;
                    }
                    Camera.prototype.copy = function(source, recursive) {
                        _super.prototype.copy.call(this, source, recursive);
                        this.matrixWorldInverse.copy(source.matrixWorldInverse);
                        this.projectionMatrix.copy(source.projectionMatrix);
                        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
                        return this;
                    };
                    Camera.prototype.getWorldDirection = function(target) {
                        this.updateWorldMatrix(true, false);
                        var e = this.matrixWorld.elements;
                        return target.set(-e[8], -e[9], -e[10]).normalize();
                    };
                    Camera.prototype.updateMatrixWorld = function(force) {
                        _super.prototype.updateMatrixWorld.call(this, force);
                        this.matrixWorldInverse.copy(this.matrixWorld).invert();
                    };
                    Camera.prototype.updateWorldMatrix = function(updateParents, updateChildren) {
                        _super.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
                        this.matrixWorldInverse.copy(this.matrixWorld).invert();
                    };
                    Camera.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    return Camera;
                }(Object3D));
                Camera.prototype.isCamera = true;
                var PerspectiveCamera = /** @class */ (function(_super) {
                    __extends(PerspectiveCamera, _super);

                    function PerspectiveCamera(fov, aspect, near, far) {
                        if (fov === void 0) {
                            fov = 50;
                        }
                        if (aspect === void 0) {
                            aspect = 1;
                        }
                        if (near === void 0) {
                            near = 0.1;
                        }
                        if (far === void 0) {
                            far = 2000;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'PerspectiveCamera';
                        _this_1.fov = fov;
                        _this_1.zoom = 1;
                        _this_1.near = near;
                        _this_1.far = far;
                        _this_1.focus = 10;
                        _this_1.aspect = aspect;
                        _this_1.view = null;
                        _this_1.filmGauge = 35; // width of the film (default in millimeters)
                        _this_1.filmOffset = 0; // horizontal film offset (same unit as gauge)
                        _this_1.updateProjectionMatrix();
                        return _this_1;
                    }
                    PerspectiveCamera.prototype.copy = function(source, recursive) {
                        _super.prototype.copy.call(this, source, recursive);
                        this.fov = source.fov;
                        this.zoom = source.zoom;
                        this.near = source.near;
                        this.far = source.far;
                        this.focus = source.focus;
                        this.aspect = source.aspect;
                        this.view = source.view === null ? null : Object.assign({}, source.view);
                        this.filmGauge = source.filmGauge;
                        this.filmOffset = source.filmOffset;
                        return this;
                    };
                    /**
                     * Sets the FOV by focal length in respect to the current .filmGauge.
                     *
                     * The default film gauge is 35, so that the focal length can be specified for
                     * a 35mm (full frame) camera.
                     *
                     * Values for focal length and film gauge must have the same unit.
                     */
                    PerspectiveCamera.prototype.setFocalLength = function(focalLength) {
                        /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
                        var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
                        this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
                        this.updateProjectionMatrix();
                    };
                    /**
                     * Calculates the focal length from the current .fov and .filmGauge.
                     */
                    PerspectiveCamera.prototype.getFocalLength = function() {
                        var vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
                        return 0.5 * this.getFilmHeight() / vExtentSlope;
                    };
                    PerspectiveCamera.prototype.getEffectiveFOV = function() {
                        return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
                    };
                    PerspectiveCamera.prototype.getFilmWidth = function() {
                        // film not completely covered in portrait format (aspect < 1)
                        return this.filmGauge * Math.min(this.aspect, 1);
                    };
                    PerspectiveCamera.prototype.getFilmHeight = function() {
                        // film not completely covered in landscape format (aspect > 1)
                        return this.filmGauge / Math.max(this.aspect, 1);
                    };
                    /**
                     * Sets an offset in a larger frustum. This is useful for multi-window or
                     * multi-monitor/multi-machine setups.
                     *
                     * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
                     * the monitors are in grid like this
                     *
                     *   +---+---+---+
                     *   | A | B | C |
                     *   +---+---+---+
                     *   | D | E | F |
                     *   +---+---+---+
                     *
                     * then for each monitor you would call it like this
                     *
                     *   const w = 1920;
                     *   const h = 1080;
                     *   const fullWidth = w * 3;
                     *   const fullHeight = h * 2;
                     *
                     *   --A--
                     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
                     *   --B--
                     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
                     *   --C--
                     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
                     *   --D--
                     *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
                     *   --E--
                     *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
                     *   --F--
                     *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
                     *
                     *   Note there is no reason monitors have to be the same size or in a grid.
                     */
                    PerspectiveCamera.prototype.setViewOffset = function(fullWidth, fullHeight, x, y, width, height) {
                        this.aspect = fullWidth / fullHeight;
                        if (this.view === null) {
                            this.view = {
                                enabled: true,
                                fullWidth: 1,
                                fullHeight: 1,
                                offsetX: 0,
                                offsetY: 0,
                                width: 1,
                                height: 1
                            };
                        }
                        this.view.enabled = true;
                        this.view.fullWidth = fullWidth;
                        this.view.fullHeight = fullHeight;
                        this.view.offsetX = x;
                        this.view.offsetY = y;
                        this.view.width = width;
                        this.view.height = height;
                        this.updateProjectionMatrix();
                    };
                    PerspectiveCamera.prototype.clearViewOffset = function() {
                        if (this.view !== null) {
                            this.view.enabled = false;
                        }
                        this.updateProjectionMatrix();
                    };
                    PerspectiveCamera.prototype.updateProjectionMatrix = function() {
                        var near = this.near;
                        var top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
                        var height = 2 * top;
                        var width = this.aspect * height;
                        var left = -0.5 * width;
                        var view = this.view;
                        if (this.view !== null && this.view.enabled) {
                            var fullWidth = view.fullWidth,
                                fullHeight = view.fullHeight;
                            left += view.offsetX * width / fullWidth;
                            top -= view.offsetY * height / fullHeight;
                            width *= view.width / fullWidth;
                            height *= view.height / fullHeight;
                        }
                        var skew = this.filmOffset;
                        if (skew !== 0)
                            left += near * skew / this.getFilmWidth();
                        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
                    };
                    PerspectiveCamera.prototype.toJSON = function(meta) {
                        var data = _super.prototype.toJSON.call(this, meta);
                        data.object.fov = this.fov;
                        data.object.zoom = this.zoom;
                        data.object.near = this.near;
                        data.object.far = this.far;
                        data.object.focus = this.focus;
                        data.object.aspect = this.aspect;
                        if (this.view !== null)
                            data.object.view = Object.assign({}, this.view);
                        data.object.filmGauge = this.filmGauge;
                        data.object.filmOffset = this.filmOffset;
                        return data;
                    };
                    return PerspectiveCamera;
                }(Camera));
                PerspectiveCamera.prototype.isPerspectiveCamera = true;
                var fov = 90,
                    aspect = 1;
                var CubeCamera = /** @class */ (function(_super) {
                    __extends(CubeCamera, _super);

                    function CubeCamera(near, far, renderTarget) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'CubeCamera';
                        if (renderTarget.isWebGLCubeRenderTarget !== true) {
                            console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
                            return _this_1;
                        }
                        _this_1.renderTarget = renderTarget;
                        var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
                        cameraPX.layers = _this_1.layers;
                        cameraPX.up.set(0, -1, 0);
                        cameraPX.lookAt(new Vector3(1, 0, 0));
                        _this_1.add(cameraPX);
                        var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
                        cameraNX.layers = _this_1.layers;
                        cameraNX.up.set(0, -1, 0);
                        cameraNX.lookAt(new Vector3(-1, 0, 0));
                        _this_1.add(cameraNX);
                        var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
                        cameraPY.layers = _this_1.layers;
                        cameraPY.up.set(0, 0, 1);
                        cameraPY.lookAt(new Vector3(0, 1, 0));
                        _this_1.add(cameraPY);
                        var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
                        cameraNY.layers = _this_1.layers;
                        cameraNY.up.set(0, 0, -1);
                        cameraNY.lookAt(new Vector3(0, -1, 0));
                        _this_1.add(cameraNY);
                        var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
                        cameraPZ.layers = _this_1.layers;
                        cameraPZ.up.set(0, -1, 0);
                        cameraPZ.lookAt(new Vector3(0, 0, 1));
                        _this_1.add(cameraPZ);
                        var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
                        cameraNZ.layers = _this_1.layers;
                        cameraNZ.up.set(0, -1, 0);
                        cameraNZ.lookAt(new Vector3(0, 0, -1));
                        _this_1.add(cameraNZ);
                        return _this_1;
                    }
                    CubeCamera.prototype.update = function(renderer, scene) {
                        if (this.parent === null)
                            this.updateMatrixWorld();
                        var renderTarget = this.renderTarget;
                        var _a = __read(this.children, 6),
                            cameraPX = _a[0],
                            cameraNX = _a[1],
                            cameraPY = _a[2],
                            cameraNY = _a[3],
                            cameraPZ = _a[4],
                            cameraNZ = _a[5];
                        var currentRenderTarget = renderer.getRenderTarget();
                        var currentOutputEncoding = renderer.outputEncoding;
                        var currentToneMapping = renderer.toneMapping;
                        var currentXrEnabled = renderer.xr.enabled;
                        renderer.outputEncoding = LinearEncoding;
                        renderer.toneMapping = NoToneMapping;
                        renderer.xr.enabled = false;
                        var generateMipmaps = renderTarget.texture.generateMipmaps;
                        renderTarget.texture.generateMipmaps = false;
                        renderer.setRenderTarget(renderTarget, 0);
                        renderer.render(scene, cameraPX);
                        renderer.setRenderTarget(renderTarget, 1);
                        renderer.render(scene, cameraNX);
                        renderer.setRenderTarget(renderTarget, 2);
                        renderer.render(scene, cameraPY);
                        renderer.setRenderTarget(renderTarget, 3);
                        renderer.render(scene, cameraNY);
                        renderer.setRenderTarget(renderTarget, 4);
                        renderer.render(scene, cameraPZ);
                        renderTarget.texture.generateMipmaps = generateMipmaps;
                        renderer.setRenderTarget(renderTarget, 5);
                        renderer.render(scene, cameraNZ);
                        renderer.setRenderTarget(currentRenderTarget);
                        renderer.outputEncoding = currentOutputEncoding;
                        renderer.toneMapping = currentToneMapping;
                        renderer.xr.enabled = currentXrEnabled;
                        renderTarget.texture.needsPMREMUpdate = true;
                    };
                    return CubeCamera;
                }(Object3D));
                var CubeTexture = /** @class */ (function(_super) {
                    __extends(CubeTexture, _super);

                    function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
                        var _this_1 = this;
                        images = images !== undefined ? images : [];
                        mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
                        _this_1 = _super.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) || this;
                        _this_1.flipY = false;
                        return _this_1;
                    }
                    Object.defineProperty(CubeTexture.prototype, "images", {
                        get: function() {
                            return this.image;
                        },
                        set: function(value) {
                            this.image = value;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    return CubeTexture;
                }(Texture));
                CubeTexture.prototype.isCubeTexture = true;
                var WebGLCubeRenderTarget = /** @class */ (function(_super) {
                    __extends(WebGLCubeRenderTarget, _super);

                    function WebGLCubeRenderTarget(size, options) {
                        if (options === void 0) {
                            options = {};
                        }
                        var _this_1 = _super.call(this, size, size, options) || this;
                        var image = {
                            width: size,
                            height: size,
                            depth: 1
                        };
                        var images = [image, image, image, image, image, image];
                        _this_1.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
                        // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
                        // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
                        // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
                        // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
                        // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
                        // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).
                        _this_1.texture.isRenderTargetTexture = true;
                        _this_1.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
                        _this_1.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
                        return _this_1;
                    }
                    WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function(renderer, texture) {
                        this.texture.type = texture.type;
                        this.texture.encoding = texture.encoding;
                        this.texture.generateMipmaps = texture.generateMipmaps;
                        this.texture.minFilter = texture.minFilter;
                        this.texture.magFilter = texture.magFilter;
                        var shader = {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                },
                            },
                            vertexShader: /* glsl */ "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                            fragmentShader: /* glsl */ "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
                        };
                        var geometry = new BoxGeometry(5, 5, 5);
                        var material = new ShaderMaterial({
                            name: 'CubemapFromEquirect',
                            uniforms: cloneUniforms(shader.uniforms),
                            vertexShader: shader.vertexShader,
                            fragmentShader: shader.fragmentShader,
                            side: BackSide,
                            blending: NoBlending
                        });
                        material.uniforms.tEquirect.value = texture;
                        var mesh = new Mesh(geometry, material);
                        var currentMinFilter = texture.minFilter;
                        // Avoid blurred poles
                        if (texture.minFilter === LinearMipmapLinearFilter)
                            texture.minFilter = LinearFilter;
                        var camera = new CubeCamera(1, 10, this);
                        camera.update(renderer, mesh);
                        texture.minFilter = currentMinFilter;
                        mesh.geometry.dispose();
                        mesh.material.dispose();
                        return this;
                    };
                    WebGLCubeRenderTarget.prototype.clear = function(renderer, color, depth, stencil) {
                        var currentRenderTarget = renderer.getRenderTarget();
                        for (var i = 0; i < 6; i++) {
                            renderer.setRenderTarget(this, i);
                            renderer.clear(color, depth, stencil);
                        }
                        renderer.setRenderTarget(currentRenderTarget);
                    };
                    return WebGLCubeRenderTarget;
                }(WebGLRenderTarget));
                WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
                var _vector1 = /*@__PURE__*/ new Vector3();
                var _vector2 = /*@__PURE__*/ new Vector3();
                var _normalMatrix = /*@__PURE__*/ new Matrix3();
                var Plane = /** @class */ (function() {
                    function Plane(normal, constant) {
                        // normal is assumed to be normalized
                        if (normal === void 0) {
                            normal = new Vector3(1, 0, 0);
                        }
                        if (constant === void 0) {
                            constant = 0;
                        }
                        this.normal = normal;
                        this.constant = constant;
                    }
                    Plane.prototype.set = function(normal, constant) {
                        this.normal.copy(normal);
                        this.constant = constant;
                        return this;
                    };
                    Plane.prototype.setComponents = function(x, y, z, w) {
                        this.normal.set(x, y, z);
                        this.constant = w;
                        return this;
                    };
                    Plane.prototype.setFromNormalAndCoplanarPoint = function(normal, point) {
                        this.normal.copy(normal);
                        this.constant = -point.dot(this.normal);
                        return this;
                    };
                    Plane.prototype.setFromCoplanarPoints = function(a, b, c) {
                        var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
                        // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
                        this.setFromNormalAndCoplanarPoint(normal, a);
                        return this;
                    };
                    Plane.prototype.copy = function(plane) {
                        this.normal.copy(plane.normal);
                        this.constant = plane.constant;
                        return this;
                    };
                    Plane.prototype.normalize = function() {
                        // Note: will lead to a divide by zero if the plane is invalid.
                        var inverseNormalLength = 1.0 / this.normal.length();
                        this.normal.multiplyScalar(inverseNormalLength);
                        this.constant *= inverseNormalLength;
                        return this;
                    };
                    Plane.prototype.negate = function() {
                        this.constant *= -1;
                        this.normal.negate();
                        return this;
                    };
                    Plane.prototype.distanceToPoint = function(point) {
                        return this.normal.dot(point) + this.constant;
                    };
                    Plane.prototype.distanceToSphere = function(sphere) {
                        return this.distanceToPoint(sphere.center) - sphere.radius;
                    };
                    Plane.prototype.projectPoint = function(point, target) {
                        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
                    };
                    Plane.prototype.intersectLine = function(line, target) {
                        var direction = line.delta(_vector1);
                        var denominator = this.normal.dot(direction);
                        if (denominator === 0) {
                            // line is coplanar, return origin
                            if (this.distanceToPoint(line.start) === 0) {
                                return target.copy(line.start);
                            }
                            // Unsure if this is the correct method to handle this case.
                            return null;
                        }
                        var t = -(line.start.dot(this.normal) + this.constant) / denominator;
                        if (t < 0 || t > 1) {
                            return null;
                        }
                        return target.copy(direction).multiplyScalar(t).add(line.start);
                    };
                    Plane.prototype.intersectsLine = function(line) {
                        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
                        var startSign = this.distanceToPoint(line.start);
                        var endSign = this.distanceToPoint(line.end);
                        return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
                    };
                    Plane.prototype.intersectsBox = function(box) {
                        return box.intersectsPlane(this);
                    };
                    Plane.prototype.intersectsSphere = function(sphere) {
                        return sphere.intersectsPlane(this);
                    };
                    Plane.prototype.coplanarPoint = function(target) {
                        return target.copy(this.normal).multiplyScalar(-this.constant);
                    };
                    Plane.prototype.applyMatrix4 = function(matrix, optionalNormalMatrix) {
                        var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
                        var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
                        var normal = this.normal.applyMatrix3(normalMatrix).normalize();
                        this.constant = -referencePoint.dot(normal);
                        return this;
                    };
                    Plane.prototype.translate = function(offset) {
                        this.constant -= offset.dot(this.normal);
                        return this;
                    };
                    Plane.prototype.equals = function(plane) {
                        return plane.normal.equals(this.normal) && (plane.constant === this.constant);
                    };
                    Plane.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    return Plane;
                }());
                Plane.prototype.isPlane = true;
                var _sphere$2 = /*@__PURE__*/ new Sphere();
                var _vector$7 = /*@__PURE__*/ new Vector3();
                var Frustum = /** @class */ (function() {
                    function Frustum(p0, p1, p2, p3, p4, p5) {
                        if (p0 === void 0) {
                            p0 = new Plane();
                        }
                        if (p1 === void 0) {
                            p1 = new Plane();
                        }
                        if (p2 === void 0) {
                            p2 = new Plane();
                        }
                        if (p3 === void 0) {
                            p3 = new Plane();
                        }
                        if (p4 === void 0) {
                            p4 = new Plane();
                        }
                        if (p5 === void 0) {
                            p5 = new Plane();
                        }
                        this.planes = [p0, p1, p2, p3, p4, p5];
                    }
                    Frustum.prototype.set = function(p0, p1, p2, p3, p4, p5) {
                        var planes = this.planes;
                        planes[0].copy(p0);
                        planes[1].copy(p1);
                        planes[2].copy(p2);
                        planes[3].copy(p3);
                        planes[4].copy(p4);
                        planes[5].copy(p5);
                        return this;
                    };
                    Frustum.prototype.copy = function(frustum) {
                        var planes = this.planes;
                        for (var i = 0; i < 6; i++) {
                            planes[i].copy(frustum.planes[i]);
                        }
                        return this;
                    };
                    Frustum.prototype.setFromProjectionMatrix = function(m) {
                        var planes = this.planes;
                        var me = m.elements;
                        var me0 = me[0],
                            me1 = me[1],
                            me2 = me[2],
                            me3 = me[3];
                        var me4 = me[4],
                            me5 = me[5],
                            me6 = me[6],
                            me7 = me[7];
                        var me8 = me[8],
                            me9 = me[9],
                            me10 = me[10],
                            me11 = me[11];
                        var me12 = me[12],
                            me13 = me[13],
                            me14 = me[14],
                            me15 = me[15];
                        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
                        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
                        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
                        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
                        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
                        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
                        return this;
                    };
                    Frustum.prototype.intersectsObject = function(object) {
                        var geometry = object.geometry;
                        if (geometry.boundingSphere === null)
                            geometry.computeBoundingSphere();
                        _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
                        return this.intersectsSphere(_sphere$2);
                    };
                    Frustum.prototype.intersectsSprite = function(sprite) {
                        _sphere$2.center.set(0, 0, 0);
                        _sphere$2.radius = 0.7071067811865476;
                        _sphere$2.applyMatrix4(sprite.matrixWorld);
                        return this.intersectsSphere(_sphere$2);
                    };
                    Frustum.prototype.intersectsSphere = function(sphere) {
                        var planes = this.planes;
                        var center = sphere.center;
                        var negRadius = -sphere.radius;
                        for (var i = 0; i < 6; i++) {
                            var distance = planes[i].distanceToPoint(center);
                            if (distance < negRadius) {
                                return false;
                            }
                        }
                        return true;
                    };
                    Frustum.prototype.intersectsBox = function(box) {
                        var planes = this.planes;
                        for (var i = 0; i < 6; i++) {
                            var plane = planes[i];
                            // corner at max distance
                            _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                            _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                            _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                            if (plane.distanceToPoint(_vector$7) < 0) {
                                return false;
                            }
                        }
                        return true;
                    };
                    Frustum.prototype.containsPoint = function(point) {
                        var planes = this.planes;
                        for (var i = 0; i < 6; i++) {
                            if (planes[i].distanceToPoint(point) < 0) {
                                return false;
                            }
                        }
                        return true;
                    };
                    Frustum.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    return Frustum;
                }());

                function WebGLAnimation() {
                    var context = null;
                    var isAnimating = false;
                    var animationLoop = null;
                    var requestId = null;

                    function onAnimationFrame(time, frame) {
                        animationLoop(time, frame);
                        requestId = context.requestAnimationFrame(onAnimationFrame);
                    }
                    return {
                        start: function() {
                            if (isAnimating === true)
                                return;
                            if (animationLoop === null)
                                return;
                            requestId = context.requestAnimationFrame(onAnimationFrame);
                            isAnimating = true;
                        },
                        stop: function() {
                            context.cancelAnimationFrame(requestId);
                            isAnimating = false;
                        },
                        setAnimationLoop: function(callback) {
                            animationLoop = callback;
                        },
                        setContext: function(value) {
                            context = value;
                        }
                    };
                }

                function WebGLAttributes(gl, capabilities) {
                    var isWebGL2 = capabilities.isWebGL2;
                    var buffers = new WeakMap();

                    function createBuffer(attribute, bufferType) {
                        var array = attribute.array;
                        var usage = attribute.usage;
                        var buffer = gl.createBuffer();
                        gl.bindBuffer(bufferType, buffer);
                        gl.bufferData(bufferType, array, usage);
                        attribute.onUploadCallback();
                        var type;
                        if (array instanceof Float32Array) {
                            type = 5126;
                        } else if (array instanceof Uint16Array) {
                            if (attribute.isFloat16BufferAttribute) {
                                if (isWebGL2) {
                                    type = 5131;
                                } else {
                                    throw new Error('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
                                }
                            } else {
                                type = 5123;
                            }
                        } else if (array instanceof Int16Array) {
                            type = 5122;
                        } else if (array instanceof Uint32Array) {
                            type = 5125;
                        } else if (array instanceof Int32Array) {
                            type = 5124;
                        } else if (array instanceof Int8Array) {
                            type = 5120;
                        } else if (array instanceof Uint8Array) {
                            type = 5121;
                        } else if (array instanceof Uint8ClampedArray) {
                            type = 5121;
                        } else {
                            throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + array);
                        }
                        return {
                            buffer: buffer,
                            type: type,
                            bytesPerElement: array.BYTES_PER_ELEMENT,
                            version: attribute.version
                        };
                    }

                    function updateBuffer(buffer, attribute, bufferType) {
                        var array = attribute.array;
                        var updateRange = attribute.updateRange;
                        gl.bindBuffer(bufferType, buffer);
                        if (updateRange.count === -1) {
                            // Not using update ranges
                            gl.bufferSubData(bufferType, 0, array);
                        } else {
                            if (isWebGL2) {
                                gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
                            } else {
                                gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
                            }
                            updateRange.count = -1; // reset range
                        }
                    }
                    //
                    function get(attribute) {
                        if (attribute.isInterleavedBufferAttribute)
                            attribute = attribute.data;
                        return buffers.get(attribute);
                    }

                    function remove(attribute) {
                        if (attribute.isInterleavedBufferAttribute)
                            attribute = attribute.data;
                        var data = buffers.get(attribute);
                        if (data) {
                            gl.deleteBuffer(data.buffer);
                            buffers.delete(attribute);
                        }
                    }

                    function update(attribute, bufferType) {
                        if (attribute.isGLBufferAttribute) {
                            var cached = buffers.get(attribute);
                            if (!cached || cached.version < attribute.version) {
                                buffers.set(attribute, {
                                    buffer: attribute.buffer,
                                    type: attribute.type,
                                    bytesPerElement: attribute.elementSize,
                                    version: attribute.version
                                });
                            }
                            return;
                        }
                        if (attribute.isInterleavedBufferAttribute)
                            attribute = attribute.data;
                        var data = buffers.get(attribute);
                        if (data === undefined) {
                            buffers.set(attribute, createBuffer(attribute, bufferType));
                        } else if (data.version < attribute.version) {
                            updateBuffer(data.buffer, attribute, bufferType);
                            data.version = attribute.version;
                        }
                    }
                    return {
                        get: get,
                        remove: remove,
                        update: update
                    };
                }
                var PlaneGeometry = /** @class */ (function(_super) {
                    __extends(PlaneGeometry, _super);

                    function PlaneGeometry(width, height, widthSegments, heightSegments) {
                        if (width === void 0) {
                            width = 1;
                        }
                        if (height === void 0) {
                            height = 1;
                        }
                        if (widthSegments === void 0) {
                            widthSegments = 1;
                        }
                        if (heightSegments === void 0) {
                            heightSegments = 1;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'PlaneGeometry';
                        _this_1.parameters = {
                            width: width,
                            height: height,
                            widthSegments: widthSegments,
                            heightSegments: heightSegments
                        };
                        var width_half = width / 2;
                        var height_half = height / 2;
                        var gridX = Math.floor(widthSegments);
                        var gridY = Math.floor(heightSegments);
                        var gridX1 = gridX + 1;
                        var gridY1 = gridY + 1;
                        var segment_width = width / gridX;
                        var segment_height = height / gridY;
                        //
                        var indices = [];
                        var vertices = [];
                        var normals = [];
                        var uvs = [];
                        for (var iy = 0; iy < gridY1; iy++) {
                            var y = iy * segment_height - height_half;
                            for (var ix = 0; ix < gridX1; ix++) {
                                var x = ix * segment_width - width_half;
                                vertices.push(x, -y, 0);
                                normals.push(0, 0, 1);
                                uvs.push(ix / gridX);
                                uvs.push(1 - (iy / gridY));
                            }
                        }
                        for (var iy = 0; iy < gridY; iy++) {
                            for (var ix = 0; ix < gridX; ix++) {
                                var a = ix + gridX1 * iy;
                                var b = ix + gridX1 * (iy + 1);
                                var c = (ix + 1) + gridX1 * (iy + 1);
                                var d = (ix + 1) + gridX1 * iy;
                                indices.push(a, b, d);
                                indices.push(b, c, d);
                            }
                        }
                        _this_1.setIndex(indices);
                        _this_1.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        _this_1.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        _this_1.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
                        return _this_1;
                    }
                    PlaneGeometry.fromJSON = function(data) {
                        return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
                    };
                    return PlaneGeometry;
                }(BufferGeometry));
                var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
                var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
                var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";
                var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";
                var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";
                var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
                var begin_vertex = "vec3 transformed = vec3( position );";
                var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
                var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";
                var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
                var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
                var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
                var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
                var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
                var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";
                var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";
                var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";
                var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";
                var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";
                var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";
                var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
                var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
                var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
                var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
                var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
                var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
                var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
                var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
                var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
                var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
                var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
                var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
                var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";
                var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";
                var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
                var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
                var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";
                var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
                var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
                var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";
                var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";
                var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";
                var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
                var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";
                var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
                var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
                var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";
                var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
                var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
                var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";
                var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
                var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
                var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
                var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
                var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
                var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";
                var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
                var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
                var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
                var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
                var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
                var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";
                var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";
                var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";
                var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";
                var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
                var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
                var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
                var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
                var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";
                var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";
                var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
                var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";
                var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
                var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
                var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
                var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
                var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
                var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
                var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
                var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
                var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
                var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
                var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
                var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";
                var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
                var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
                var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
                var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
                var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
                var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
                var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
                var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
                var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
                var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
                var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";
                var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
                var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
                var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
                var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
                var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
                var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
                var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
                var vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
                var fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
                var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
                var fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
                var vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
                var fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
                var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
                var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
                var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
                var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
                var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
                var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
                var vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
                var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
                var vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
                var fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
                var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
                var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
                var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
                var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";
                var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
                var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
                var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";
                var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
                var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
                var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
                var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
                var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
                var vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
                var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
                var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
                var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
                var ShaderChunk = {
                    alphamap_fragment: alphamap_fragment,
                    alphamap_pars_fragment: alphamap_pars_fragment,
                    alphatest_fragment: alphatest_fragment,
                    alphatest_pars_fragment: alphatest_pars_fragment,
                    aomap_fragment: aomap_fragment,
                    aomap_pars_fragment: aomap_pars_fragment,
                    begin_vertex: begin_vertex,
                    beginnormal_vertex: beginnormal_vertex,
                    bsdfs: bsdfs,
                    bumpmap_pars_fragment: bumpmap_pars_fragment,
                    clipping_planes_fragment: clipping_planes_fragment,
                    clipping_planes_pars_fragment: clipping_planes_pars_fragment,
                    clipping_planes_pars_vertex: clipping_planes_pars_vertex,
                    clipping_planes_vertex: clipping_planes_vertex,
                    color_fragment: color_fragment,
                    color_pars_fragment: color_pars_fragment,
                    color_pars_vertex: color_pars_vertex,
                    color_vertex: color_vertex,
                    common: common,
                    cube_uv_reflection_fragment: cube_uv_reflection_fragment,
                    defaultnormal_vertex: defaultnormal_vertex,
                    displacementmap_pars_vertex: displacementmap_pars_vertex,
                    displacementmap_vertex: displacementmap_vertex,
                    emissivemap_fragment: emissivemap_fragment,
                    emissivemap_pars_fragment: emissivemap_pars_fragment,
                    encodings_fragment: encodings_fragment,
                    encodings_pars_fragment: encodings_pars_fragment,
                    envmap_fragment: envmap_fragment,
                    envmap_common_pars_fragment: envmap_common_pars_fragment,
                    envmap_pars_fragment: envmap_pars_fragment,
                    envmap_pars_vertex: envmap_pars_vertex,
                    envmap_physical_pars_fragment: envmap_physical_pars_fragment,
                    envmap_vertex: envmap_vertex,
                    fog_vertex: fog_vertex,
                    fog_pars_vertex: fog_pars_vertex,
                    fog_fragment: fog_fragment,
                    fog_pars_fragment: fog_pars_fragment,
                    gradientmap_pars_fragment: gradientmap_pars_fragment,
                    lightmap_fragment: lightmap_fragment,
                    lightmap_pars_fragment: lightmap_pars_fragment,
                    lights_lambert_vertex: lights_lambert_vertex,
                    lights_pars_begin: lights_pars_begin,
                    lights_toon_fragment: lights_toon_fragment,
                    lights_toon_pars_fragment: lights_toon_pars_fragment,
                    lights_phong_fragment: lights_phong_fragment,
                    lights_phong_pars_fragment: lights_phong_pars_fragment,
                    lights_physical_fragment: lights_physical_fragment,
                    lights_physical_pars_fragment: lights_physical_pars_fragment,
                    lights_fragment_begin: lights_fragment_begin,
                    lights_fragment_maps: lights_fragment_maps,
                    lights_fragment_end: lights_fragment_end,
                    logdepthbuf_fragment: logdepthbuf_fragment,
                    logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
                    logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
                    logdepthbuf_vertex: logdepthbuf_vertex,
                    map_fragment: map_fragment,
                    map_pars_fragment: map_pars_fragment,
                    map_particle_fragment: map_particle_fragment,
                    map_particle_pars_fragment: map_particle_pars_fragment,
                    metalnessmap_fragment: metalnessmap_fragment,
                    metalnessmap_pars_fragment: metalnessmap_pars_fragment,
                    morphcolor_vertex: morphcolor_vertex,
                    morphnormal_vertex: morphnormal_vertex,
                    morphtarget_pars_vertex: morphtarget_pars_vertex,
                    morphtarget_vertex: morphtarget_vertex,
                    normal_fragment_begin: normal_fragment_begin,
                    normal_fragment_maps: normal_fragment_maps,
                    normal_pars_fragment: normal_pars_fragment,
                    normal_pars_vertex: normal_pars_vertex,
                    normal_vertex: normal_vertex,
                    normalmap_pars_fragment: normalmap_pars_fragment,
                    clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
                    clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
                    clearcoat_pars_fragment: clearcoat_pars_fragment,
                    output_fragment: output_fragment,
                    packing: packing,
                    premultiplied_alpha_fragment: premultiplied_alpha_fragment,
                    project_vertex: project_vertex,
                    dithering_fragment: dithering_fragment,
                    dithering_pars_fragment: dithering_pars_fragment,
                    roughnessmap_fragment: roughnessmap_fragment,
                    roughnessmap_pars_fragment: roughnessmap_pars_fragment,
                    shadowmap_pars_fragment: shadowmap_pars_fragment,
                    shadowmap_pars_vertex: shadowmap_pars_vertex,
                    shadowmap_vertex: shadowmap_vertex,
                    shadowmask_pars_fragment: shadowmask_pars_fragment,
                    skinbase_vertex: skinbase_vertex,
                    skinning_pars_vertex: skinning_pars_vertex,
                    skinning_vertex: skinning_vertex,
                    skinnormal_vertex: skinnormal_vertex,
                    specularmap_fragment: specularmap_fragment,
                    specularmap_pars_fragment: specularmap_pars_fragment,
                    tonemapping_fragment: tonemapping_fragment,
                    tonemapping_pars_fragment: tonemapping_pars_fragment,
                    transmission_fragment: transmission_fragment,
                    transmission_pars_fragment: transmission_pars_fragment,
                    uv_pars_fragment: uv_pars_fragment,
                    uv_pars_vertex: uv_pars_vertex,
                    uv_vertex: uv_vertex,
                    uv2_pars_fragment: uv2_pars_fragment,
                    uv2_pars_vertex: uv2_pars_vertex,
                    uv2_vertex: uv2_vertex,
                    worldpos_vertex: worldpos_vertex,
                    background_vert: vertex$g,
                    background_frag: fragment$g,
                    cube_vert: vertex$f,
                    cube_frag: fragment$f,
                    depth_vert: vertex$e,
                    depth_frag: fragment$e,
                    distanceRGBA_vert: vertex$d,
                    distanceRGBA_frag: fragment$d,
                    equirect_vert: vertex$c,
                    equirect_frag: fragment$c,
                    linedashed_vert: vertex$b,
                    linedashed_frag: fragment$b,
                    meshbasic_vert: vertex$a,
                    meshbasic_frag: fragment$a,
                    meshlambert_vert: vertex$9,
                    meshlambert_frag: fragment$9,
                    meshmatcap_vert: vertex$8,
                    meshmatcap_frag: fragment$8,
                    meshnormal_vert: vertex$7,
                    meshnormal_frag: fragment$7,
                    meshphong_vert: vertex$6,
                    meshphong_frag: fragment$6,
                    meshphysical_vert: vertex$5,
                    meshphysical_frag: fragment$5,
                    meshtoon_vert: vertex$4,
                    meshtoon_frag: fragment$4,
                    points_vert: vertex$3,
                    points_frag: fragment$3,
                    shadow_vert: vertex$2,
                    shadow_frag: fragment$2,
                    sprite_vert: vertex$1,
                    sprite_frag: fragment$1
                };
                /**
                 * Uniforms library for shared webgl shaders
                 */
                var UniformsLib = {
                    common: {
                        diffuse: {
                            value: new Color(0xffffff)
                        },
                        opacity: {
                            value: 1.0
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Matrix3()
                        },
                        uv2Transform: {
                            value: new Matrix3()
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        },
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1.0
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: 0.98
                        } // basic, lambert, phong
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new Vector2(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 0.00025
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2000
                        },
                        fogColor: {
                            value: new Color(0xffffff)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new Color(0xffffff)
                        },
                        opacity: {
                            value: 1.0
                        },
                        size: {
                            value: 1.0
                        },
                        scale: {
                            value: 1.0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new Matrix3()
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new Color(0xffffff)
                        },
                        opacity: {
                            value: 1.0
                        },
                        center: {
                            value: new Vector2(0.5, 0.5)
                        },
                        rotation: {
                            value: 0.0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new Matrix3()
                        }
                    }
                };
                var ShaderLib = {
                    basic: {
                        uniforms: mergeUniforms([
                            UniformsLib.common,
                            UniformsLib.specularmap,
                            UniformsLib.envmap,
                            UniformsLib.aomap,
                            UniformsLib.lightmap,
                            UniformsLib.fog
                        ]),
                        vertexShader: ShaderChunk.meshbasic_vert,
                        fragmentShader: ShaderChunk.meshbasic_frag
                    },
                    lambert: {
                        uniforms: mergeUniforms([
                            UniformsLib.common,
                            UniformsLib.specularmap,
                            UniformsLib.envmap,
                            UniformsLib.aomap,
                            UniformsLib.lightmap,
                            UniformsLib.emissivemap,
                            UniformsLib.fog,
                            UniformsLib.lights,
                            {
                                emissive: {
                                    value: new Color(0x000000)
                                }
                            }
                        ]),
                        vertexShader: ShaderChunk.meshlambert_vert,
                        fragmentShader: ShaderChunk.meshlambert_frag
                    },
                    phong: {
                        uniforms: mergeUniforms([
                            UniformsLib.common,
                            UniformsLib.specularmap,
                            UniformsLib.envmap,
                            UniformsLib.aomap,
                            UniformsLib.lightmap,
                            UniformsLib.emissivemap,
                            UniformsLib.bumpmap,
                            UniformsLib.normalmap,
                            UniformsLib.displacementmap,
                            UniformsLib.fog,
                            UniformsLib.lights,
                            {
                                emissive: {
                                    value: new Color(0x000000)
                                },
                                specular: {
                                    value: new Color(0x111111)
                                },
                                shininess: {
                                    value: 30
                                }
                            }
                        ]),
                        vertexShader: ShaderChunk.meshphong_vert,
                        fragmentShader: ShaderChunk.meshphong_frag
                    },
                    standard: {
                        uniforms: mergeUniforms([
                            UniformsLib.common,
                            UniformsLib.envmap,
                            UniformsLib.aomap,
                            UniformsLib.lightmap,
                            UniformsLib.emissivemap,
                            UniformsLib.bumpmap,
                            UniformsLib.normalmap,
                            UniformsLib.displacementmap,
                            UniformsLib.roughnessmap,
                            UniformsLib.metalnessmap,
                            UniformsLib.fog,
                            UniformsLib.lights,
                            {
                                emissive: {
                                    value: new Color(0x000000)
                                },
                                roughness: {
                                    value: 1.0
                                },
                                metalness: {
                                    value: 0.0
                                },
                                envMapIntensity: {
                                    value: 1
                                } // temporary
                            }
                        ]),
                        vertexShader: ShaderChunk.meshphysical_vert,
                        fragmentShader: ShaderChunk.meshphysical_frag
                    },
                    toon: {
                        uniforms: mergeUniforms([
                            UniformsLib.common,
                            UniformsLib.aomap,
                            UniformsLib.lightmap,
                            UniformsLib.emissivemap,
                            UniformsLib.bumpmap,
                            UniformsLib.normalmap,
                            UniformsLib.displacementmap,
                            UniformsLib.gradientmap,
                            UniformsLib.fog,
                            UniformsLib.lights,
                            {
                                emissive: {
                                    value: new Color(0x000000)
                                }
                            }
                        ]),
                        vertexShader: ShaderChunk.meshtoon_vert,
                        fragmentShader: ShaderChunk.meshtoon_frag
                    },
                    matcap: {
                        uniforms: mergeUniforms([
                            UniformsLib.common,
                            UniformsLib.bumpmap,
                            UniformsLib.normalmap,
                            UniformsLib.displacementmap,
                            UniformsLib.fog,
                            {
                                matcap: {
                                    value: null
                                }
                            }
                        ]),
                        vertexShader: ShaderChunk.meshmatcap_vert,
                        fragmentShader: ShaderChunk.meshmatcap_frag
                    },
                    points: {
                        uniforms: mergeUniforms([
                            UniformsLib.points,
                            UniformsLib.fog
                        ]),
                        vertexShader: ShaderChunk.points_vert,
                        fragmentShader: ShaderChunk.points_frag
                    },
                    dashed: {
                        uniforms: mergeUniforms([
                            UniformsLib.common,
                            UniformsLib.fog,
                            {
                                scale: {
                                    value: 1
                                },
                                dashSize: {
                                    value: 1
                                },
                                totalSize: {
                                    value: 2
                                }
                            }
                        ]),
                        vertexShader: ShaderChunk.linedashed_vert,
                        fragmentShader: ShaderChunk.linedashed_frag
                    },
                    depth: {
                        uniforms: mergeUniforms([
                            UniformsLib.common,
                            UniformsLib.displacementmap
                        ]),
                        vertexShader: ShaderChunk.depth_vert,
                        fragmentShader: ShaderChunk.depth_frag
                    },
                    normal: {
                        uniforms: mergeUniforms([
                            UniformsLib.common,
                            UniformsLib.bumpmap,
                            UniformsLib.normalmap,
                            UniformsLib.displacementmap,
                            {
                                opacity: {
                                    value: 1.0
                                }
                            }
                        ]),
                        vertexShader: ShaderChunk.meshnormal_vert,
                        fragmentShader: ShaderChunk.meshnormal_frag
                    },
                    sprite: {
                        uniforms: mergeUniforms([
                            UniformsLib.sprite,
                            UniformsLib.fog
                        ]),
                        vertexShader: ShaderChunk.sprite_vert,
                        fragmentShader: ShaderChunk.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new Matrix3()
                            },
                            t2D: {
                                value: null
                            },
                        },
                        vertexShader: ShaderChunk.background_vert,
                        fragmentShader: ShaderChunk.background_frag
                    },
                    /* -------------------------------------------------------------------------
                    //	Cube map shader
                     ------------------------------------------------------------------------- */
                    cube: {
                        uniforms: mergeUniforms([
                            UniformsLib.envmap,
                            {
                                opacity: {
                                    value: 1.0
                                }
                            }
                        ]),
                        vertexShader: ShaderChunk.cube_vert,
                        fragmentShader: ShaderChunk.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            },
                        },
                        vertexShader: ShaderChunk.equirect_vert,
                        fragmentShader: ShaderChunk.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: mergeUniforms([
                            UniformsLib.common,
                            UniformsLib.displacementmap,
                            {
                                referencePosition: {
                                    value: new Vector3()
                                },
                                nearDistance: {
                                    value: 1
                                },
                                farDistance: {
                                    value: 1000
                                }
                            }
                        ]),
                        vertexShader: ShaderChunk.distanceRGBA_vert,
                        fragmentShader: ShaderChunk.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: mergeUniforms([
                            UniformsLib.lights,
                            UniformsLib.fog,
                            {
                                color: {
                                    value: new Color(0x00000)
                                },
                                opacity: {
                                    value: 1.0
                                }
                            },
                        ]),
                        vertexShader: ShaderChunk.shadow_vert,
                        fragmentShader: ShaderChunk.shadow_frag
                    }
                };
                ShaderLib.physical = {
                    uniforms: mergeUniforms([
                        ShaderLib.standard.uniforms,
                        {
                            clearcoat: {
                                value: 0
                            },
                            clearcoatMap: {
                                value: null
                            },
                            clearcoatRoughness: {
                                value: 0
                            },
                            clearcoatRoughnessMap: {
                                value: null
                            },
                            clearcoatNormalScale: {
                                value: new Vector2(1, 1)
                            },
                            clearcoatNormalMap: {
                                value: null
                            },
                            sheen: {
                                value: 0
                            },
                            sheenColor: {
                                value: new Color(0x000000)
                            },
                            sheenColorMap: {
                                value: null
                            },
                            sheenRoughness: {
                                value: 1
                            },
                            sheenRoughnessMap: {
                                value: null
                            },
                            transmission: {
                                value: 0
                            },
                            transmissionMap: {
                                value: null
                            },
                            transmissionSamplerSize: {
                                value: new Vector2()
                            },
                            transmissionSamplerMap: {
                                value: null
                            },
                            thickness: {
                                value: 0
                            },
                            thicknessMap: {
                                value: null
                            },
                            attenuationDistance: {
                                value: 0
                            },
                            attenuationColor: {
                                value: new Color(0x000000)
                            },
                            specularIntensity: {
                                value: 1
                            },
                            specularIntensityMap: {
                                value: null
                            },
                            specularColor: {
                                value: new Color(1, 1, 1)
                            },
                            specularColorMap: {
                                value: null
                            },
                        }
                    ]),
                    vertexShader: ShaderChunk.meshphysical_vert,
                    fragmentShader: ShaderChunk.meshphysical_frag
                };

                function WebGLBackground(renderer, cubemaps, state, objects, alpha, premultipliedAlpha) {
                    var clearColor = new Color(0x000000);
                    var clearAlpha = alpha === true ? 0 : 1;
                    var planeMesh;
                    var boxMesh;
                    var currentBackground = null;
                    var currentBackgroundVersion = 0;
                    var currentTonemapping = null;

                    function render(renderList, scene) {
                        var forceClear = false;
                        var background = scene.isScene === true ? scene.background : null;
                        if (background && background.isTexture) {
                            background = cubemaps.get(background);
                        }
                        // Ignore background in AR
                        // TODO: Reconsider this.
                        var xr = renderer.xr;
                        var session = xr.getSession && xr.getSession();
                        if (session && session.environmentBlendMode === 'additive') {
                            background = null;
                        }
                        if (background === null) {
                            setClear(clearColor, clearAlpha);
                        } else if (background && background.isColor) {
                            setClear(background, 1);
                            forceClear = true;
                        }
                        if (renderer.autoClear || forceClear) {
                            renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
                        }
                        if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
                            if (boxMesh === undefined) {
                                boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
                                    name: 'BackgroundCubeMaterial',
                                    uniforms: cloneUniforms(ShaderLib.cube.uniforms),
                                    vertexShader: ShaderLib.cube.vertexShader,
                                    fragmentShader: ShaderLib.cube.fragmentShader,
                                    side: BackSide,
                                    depthTest: false,
                                    depthWrite: false,
                                    fog: false
                                }));
                                boxMesh.geometry.deleteAttribute('normal');
                                boxMesh.geometry.deleteAttribute('uv');
                                boxMesh.onBeforeRender = function(renderer, scene, camera) {
                                    this.matrixWorld.copyPosition(camera.matrixWorld);
                                };
                                // enable code injection for non-built-in material
                                Object.defineProperty(boxMesh.material, 'envMap', {
                                    get: function() {
                                        return this.uniforms.envMap.value;
                                    }
                                });
                                objects.update(boxMesh);
                            }
                            boxMesh.material.uniforms.envMap.value = background;
                            boxMesh.material.uniforms.flipEnvMap.value = (background.isCubeTexture && background.isRenderTargetTexture === false) ? -1 : 1;
                            if (currentBackground !== background ||
                                currentBackgroundVersion !== background.version ||
                                currentTonemapping !== renderer.toneMapping) {
                                boxMesh.material.needsUpdate = true;
                                currentBackground = background;
                                currentBackgroundVersion = background.version;
                                currentTonemapping = renderer.toneMapping;
                            }
                            // push to the pre-sorted opaque render list
                            renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
                        } else if (background && background.isTexture) {
                            if (planeMesh === undefined) {
                                planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
                                    name: 'BackgroundMaterial',
                                    uniforms: cloneUniforms(ShaderLib.background.uniforms),
                                    vertexShader: ShaderLib.background.vertexShader,
                                    fragmentShader: ShaderLib.background.fragmentShader,
                                    side: FrontSide,
                                    depthTest: false,
                                    depthWrite: false,
                                    fog: false
                                }));
                                planeMesh.geometry.deleteAttribute('normal');
                                // enable code injection for non-built-in material
                                Object.defineProperty(planeMesh.material, 'map', {
                                    get: function() {
                                        return this.uniforms.t2D.value;
                                    }
                                });
                                objects.update(planeMesh);
                            }
                            planeMesh.material.uniforms.t2D.value = background;
                            if (background.matrixAutoUpdate === true) {
                                background.updateMatrix();
                            }
                            planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
                            if (currentBackground !== background ||
                                currentBackgroundVersion !== background.version ||
                                currentTonemapping !== renderer.toneMapping) {
                                planeMesh.material.needsUpdate = true;
                                currentBackground = background;
                                currentBackgroundVersion = background.version;
                                currentTonemapping = renderer.toneMapping;
                            }
                            // push to the pre-sorted opaque render list
                            renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
                        }
                    }

                    function setClear(color, alpha) {
                        state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
                    }
                    return {
                        getClearColor: function() {
                            return clearColor;
                        },
                        setClearColor: function(color, alpha) {
                            if (alpha === void 0) {
                                alpha = 1;
                            }
                            clearColor.set(color);
                            clearAlpha = alpha;
                            setClear(clearColor, clearAlpha);
                        },
                        getClearAlpha: function() {
                            return clearAlpha;
                        },
                        setClearAlpha: function(alpha) {
                            clearAlpha = alpha;
                            setClear(clearColor, clearAlpha);
                        },
                        render: render
                    };
                }

                function WebGLBindingStates(gl, extensions, attributes, capabilities) {
                    var maxVertexAttributes = gl.getParameter(34921);
                    var extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
                    var vaoAvailable = capabilities.isWebGL2 || extension !== null;
                    var bindingStates = {};
                    var defaultState = createBindingState(null);
                    var currentState = defaultState;
                    var forceUpdate = false;

                    function setup(object, material, program, geometry, index) {
                        var updateBuffers = false;
                        if (vaoAvailable) {
                            var state = getBindingState(geometry, program, material);
                            if (currentState !== state) {
                                currentState = state;
                                bindVertexArrayObject(currentState.object);
                            }
                            updateBuffers = needsUpdate(geometry, index);
                            if (updateBuffers)
                                saveCache(geometry, index);
                        } else {
                            var wireframe = (material.wireframe === true);
                            if (currentState.geometry !== geometry.id ||
                                currentState.program !== program.id ||
                                currentState.wireframe !== wireframe) {
                                currentState.geometry = geometry.id;
                                currentState.program = program.id;
                                currentState.wireframe = wireframe;
                                updateBuffers = true;
                            }
                        }
                        if (object.isInstancedMesh === true) {
                            updateBuffers = true;
                        }
                        if (index !== null) {
                            attributes.update(index, 34963);
                        }
                        if (updateBuffers || forceUpdate) {
                            forceUpdate = false;
                            setupVertexAttributes(object, material, program, geometry);
                            if (index !== null) {
                                gl.bindBuffer(34963, attributes.get(index).buffer);
                            }
                        }
                    }

                    function createVertexArrayObject() {
                        if (capabilities.isWebGL2)
                            return gl.createVertexArray();
                        return extension.createVertexArrayOES();
                    }

                    function bindVertexArrayObject(vao) {
                        if (capabilities.isWebGL2)
                            return gl.bindVertexArray(vao);
                        return extension.bindVertexArrayOES(vao);
                    }

                    function deleteVertexArrayObject(vao) {
                        if (capabilities.isWebGL2)
                            return gl.deleteVertexArray(vao);
                        return extension.deleteVertexArrayOES(vao);
                    }

                    function getBindingState(geometry, program, material) {
                        var wireframe = (material.wireframe === true);
                        var programMap = bindingStates[geometry.id];
                        if (programMap === undefined) {
                            programMap = {};
                            bindingStates[geometry.id] = programMap;
                        }
                        var stateMap = programMap[program.id];
                        if (stateMap === undefined) {
                            stateMap = {};
                            programMap[program.id] = stateMap;
                        }
                        var state = stateMap[wireframe];
                        if (state === undefined) {
                            state = createBindingState(createVertexArrayObject());
                            stateMap[wireframe] = state;
                        }
                        return state;
                    }

                    function createBindingState(vao) {
                        var newAttributes = [];
                        var enabledAttributes = [];
                        var attributeDivisors = [];
                        for (var i = 0; i < maxVertexAttributes; i++) {
                            newAttributes[i] = 0;
                            enabledAttributes[i] = 0;
                            attributeDivisors[i] = 0;
                        }
                        return {
                            // for backward compatibility on non-VAO support browser
                            geometry: null,
                            program: null,
                            wireframe: false,
                            newAttributes: newAttributes,
                            enabledAttributes: enabledAttributes,
                            attributeDivisors: attributeDivisors,
                            object: vao,
                            attributes: {},
                            index: null
                        };
                    }

                    function needsUpdate(geometry, index) {
                        var cachedAttributes = currentState.attributes;
                        var geometryAttributes = geometry.attributes;
                        var attributesNum = 0;
                        for (var key in geometryAttributes) {
                            var cachedAttribute = cachedAttributes[key];
                            var geometryAttribute = geometryAttributes[key];
                            if (cachedAttribute === undefined)
                                return true;
                            if (cachedAttribute.attribute !== geometryAttribute)
                                return true;
                            if (cachedAttribute.data !== geometryAttribute.data)
                                return true;
                            attributesNum++;
                        }
                        if (currentState.attributesNum !== attributesNum)
                            return true;
                        if (currentState.index !== index)
                            return true;
                        return false;
                    }

                    function saveCache(geometry, index) {
                        var cache = {};
                        var attributes = geometry.attributes;
                        var attributesNum = 0;
                        for (var key in attributes) {
                            var attribute = attributes[key];
                            var data = {};
                            data.attribute = attribute;
                            if (attribute.data) {
                                data.data = attribute.data;
                            }
                            cache[key] = data;
                            attributesNum++;
                        }
                        currentState.attributes = cache;
                        currentState.attributesNum = attributesNum;
                        currentState.index = index;
                    }

                    function initAttributes() {
                        var newAttributes = currentState.newAttributes;
                        for (var i = 0, il = newAttributes.length; i < il; i++) {
                            newAttributes[i] = 0;
                        }
                    }

                    function enableAttribute(attribute) {
                        enableAttributeAndDivisor(attribute, 0);
                    }

                    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
                        var newAttributes = currentState.newAttributes;
                        var enabledAttributes = currentState.enabledAttributes;
                        var attributeDivisors = currentState.attributeDivisors;
                        newAttributes[attribute] = 1;
                        if (enabledAttributes[attribute] === 0) {
                            gl.enableVertexAttribArray(attribute);
                            enabledAttributes[attribute] = 1;
                        }
                        if (attributeDivisors[attribute] !== meshPerAttribute) {
                            var extension_1 = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
                            extension_1[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
                            attributeDivisors[attribute] = meshPerAttribute;
                        }
                    }

                    function disableUnusedAttributes() {
                        var newAttributes = currentState.newAttributes;
                        var enabledAttributes = currentState.enabledAttributes;
                        for (var i = 0, il = enabledAttributes.length; i < il; i++) {
                            if (enabledAttributes[i] !== newAttributes[i]) {
                                gl.disableVertexAttribArray(i);
                                enabledAttributes[i] = 0;
                            }
                        }
                    }

                    function vertexAttribPointer(index, size, type, normalized, stride, offset) {
                        if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
                            gl.vertexAttribIPointer(index, size, type, stride, offset);
                        } else {
                            gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
                        }
                    }

                    function setupVertexAttributes(object, material, program, geometry) {
                        if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
                            if (extensions.get('ANGLE_instanced_arrays') === null)
                                return;
                        }
                        initAttributes();
                        var geometryAttributes = geometry.attributes;
                        var programAttributes = program.getAttributes();
                        var materialDefaultAttributeValues = material.defaultAttributeValues;
                        for (var name in programAttributes) {
                            var programAttribute = programAttributes[name];
                            if (programAttribute.location >= 0) {
                                var geometryAttribute = geometryAttributes[name];
                                if (geometryAttribute === undefined) {
                                    if (name === 'instanceMatrix' && object.instanceMatrix)
                                        geometryAttribute = object.instanceMatrix;
                                    if (name === 'instanceColor' && object.instanceColor)
                                        geometryAttribute = object.instanceColor;
                                }
                                if (geometryAttribute !== undefined) {
                                    var normalized = geometryAttribute.normalized;
                                    var size = geometryAttribute.itemSize;
                                    var attribute = attributes.get(geometryAttribute);
                                    // TODO Attribute may not be available on context restore
                                    if (attribute === undefined)
                                        continue;
                                    var buffer = attribute.buffer;
                                    var type = attribute.type;
                                    var bytesPerElement = attribute.bytesPerElement;
                                    if (geometryAttribute.isInterleavedBufferAttribute) {
                                        var data = geometryAttribute.data;
                                        var stride = data.stride;
                                        var offset = geometryAttribute.offset;
                                        if (data.isInstancedInterleavedBuffer) {
                                            for (var i = 0; i < programAttribute.locationSize; i++) {
                                                enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
                                            }
                                            if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
                                                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                                            }
                                        } else {
                                            for (var i = 0; i < programAttribute.locationSize; i++) {
                                                enableAttribute(programAttribute.location + i);
                                            }
                                        }
                                        gl.bindBuffer(34962, buffer);
                                        for (var i = 0; i < programAttribute.locationSize; i++) {
                                            vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + (size / programAttribute.locationSize) * i) * bytesPerElement);
                                        }
                                    } else {
                                        if (geometryAttribute.isInstancedBufferAttribute) {
                                            for (var i = 0; i < programAttribute.locationSize; i++) {
                                                enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
                                            }
                                            if (object.isInstancedMesh !== true && geometry._maxInstanceCount === undefined) {
                                                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                                            }
                                        } else {
                                            for (var i = 0; i < programAttribute.locationSize; i++) {
                                                enableAttribute(programAttribute.location + i);
                                            }
                                        }
                                        gl.bindBuffer(34962, buffer);
                                        for (var i = 0; i < programAttribute.locationSize; i++) {
                                            vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, (size / programAttribute.locationSize) * i * bytesPerElement);
                                        }
                                    }
                                } else if (materialDefaultAttributeValues !== undefined) {
                                    var value = materialDefaultAttributeValues[name];
                                    if (value !== undefined) {
                                        switch (value.length) {
                                            case 2:
                                                gl.vertexAttrib2fv(programAttribute.location, value);
                                                break;
                                            case 3:
                                                gl.vertexAttrib3fv(programAttribute.location, value);
                                                break;
                                            case 4:
                                                gl.vertexAttrib4fv(programAttribute.location, value);
                                                break;
                                            default:
                                                gl.vertexAttrib1fv(programAttribute.location, value);
                                        }
                                    }
                                }
                            }
                        }
                        disableUnusedAttributes();
                    }

                    function dispose() {
                        reset();
                        for (var geometryId in bindingStates) {
                            var programMap = bindingStates[geometryId];
                            for (var programId in programMap) {
                                var stateMap = programMap[programId];
                                for (var wireframe in stateMap) {
                                    deleteVertexArrayObject(stateMap[wireframe].object);
                                    delete stateMap[wireframe];
                                }
                                delete programMap[programId];
                            }
                            delete bindingStates[geometryId];
                        }
                    }

                    function releaseStatesOfGeometry(geometry) {
                        if (bindingStates[geometry.id] === undefined)
                            return;
                        var programMap = bindingStates[geometry.id];
                        for (var programId in programMap) {
                            var stateMap = programMap[programId];
                            for (var wireframe in stateMap) {
                                deleteVertexArrayObject(stateMap[wireframe].object);
                                delete stateMap[wireframe];
                            }
                            delete programMap[programId];
                        }
                        delete bindingStates[geometry.id];
                    }

                    function releaseStatesOfProgram(program) {
                        for (var geometryId in bindingStates) {
                            var programMap = bindingStates[geometryId];
                            if (programMap[program.id] === undefined)
                                continue;
                            var stateMap = programMap[program.id];
                            for (var wireframe in stateMap) {
                                deleteVertexArrayObject(stateMap[wireframe].object);
                                delete stateMap[wireframe];
                            }
                            delete programMap[program.id];
                        }
                    }

                    function reset() {
                        resetDefaultState();
                        forceUpdate = true;
                        if (currentState === defaultState)
                            return;
                        currentState = defaultState;
                        bindVertexArrayObject(currentState.object);
                    }
                    // for backward-compatibility
                    function resetDefaultState() {
                        defaultState.geometry = null;
                        defaultState.program = null;
                        defaultState.wireframe = false;
                    }
                    return {
                        setup: setup,
                        reset: reset,
                        resetDefaultState: resetDefaultState,
                        dispose: dispose,
                        releaseStatesOfGeometry: releaseStatesOfGeometry,
                        releaseStatesOfProgram: releaseStatesOfProgram,
                        initAttributes: initAttributes,
                        enableAttribute: enableAttribute,
                        disableUnusedAttributes: disableUnusedAttributes
                    };
                }

                function WebGLBufferRenderer(gl, extensions, info, capabilities) {
                    var isWebGL2 = capabilities.isWebGL2;
                    var mode;

                    function setMode(value) {
                        mode = value;
                    }

                    function render(start, count) {
                        gl.drawArrays(mode, start, count);
                        info.update(count, mode, 1);
                    }

                    function renderInstances(start, count, primcount) {
                        if (primcount === 0)
                            return;
                        var extension, methodName;
                        if (isWebGL2) {
                            extension = gl;
                            methodName = 'drawArraysInstanced';
                        } else {
                            extension = extensions.get('ANGLE_instanced_arrays');
                            methodName = 'drawArraysInstancedANGLE';
                            if (extension === null) {
                                console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                                return;
                            }
                        }
                        extension[methodName](mode, start, count, primcount);
                        info.update(count, mode, primcount);
                    }
                    //
                    this.setMode = setMode;
                    this.render = render;
                    this.renderInstances = renderInstances;
                }

                function WebGLCapabilities(gl, extensions, parameters) {
                    var maxAnisotropy;

                    function getMaxAnisotropy() {
                        if (maxAnisotropy !== undefined)
                            return maxAnisotropy;
                        if (extensions.has('EXT_texture_filter_anisotropic') === true) {
                            var extension = extensions.get('EXT_texture_filter_anisotropic');
                            maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                        } else {
                            maxAnisotropy = 0;
                        }
                        return maxAnisotropy;
                    }

                    function getMaxPrecision(precision) {
                        if (precision === 'highp') {
                            if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
                                gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
                                return 'highp';
                            }
                            precision = 'mediump';
                        }
                        if (precision === 'mediump') {
                            if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
                                gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
                                return 'mediump';
                            }
                        }
                        return 'lowp';
                    }
                    var isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) ||
                        (typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext);
                    var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
                    var maxPrecision = getMaxPrecision(precision);
                    if (maxPrecision !== precision) {
                        console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
                        precision = maxPrecision;
                    }
                    var drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');
                    var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
                    var maxTextures = gl.getParameter(34930);
                    var maxVertexTextures = gl.getParameter(35660);
                    var maxTextureSize = gl.getParameter(3379);
                    var maxCubemapSize = gl.getParameter(34076);
                    var maxAttributes = gl.getParameter(34921);
                    var maxVertexUniforms = gl.getParameter(36347);
                    var maxVaryings = gl.getParameter(36348);
                    var maxFragmentUniforms = gl.getParameter(36349);
                    var vertexTextures = maxVertexTextures > 0;
                    var floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');
                    var floatVertexTextures = vertexTextures && floatFragmentTextures;
                    var maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
                    return {
                        isWebGL2: isWebGL2,
                        drawBuffers: drawBuffers,
                        getMaxAnisotropy: getMaxAnisotropy,
                        getMaxPrecision: getMaxPrecision,
                        precision: precision,
                        logarithmicDepthBuffer: logarithmicDepthBuffer,
                        maxTextures: maxTextures,
                        maxVertexTextures: maxVertexTextures,
                        maxTextureSize: maxTextureSize,
                        maxCubemapSize: maxCubemapSize,
                        maxAttributes: maxAttributes,
                        maxVertexUniforms: maxVertexUniforms,
                        maxVaryings: maxVaryings,
                        maxFragmentUniforms: maxFragmentUniforms,
                        vertexTextures: vertexTextures,
                        floatFragmentTextures: floatFragmentTextures,
                        floatVertexTextures: floatVertexTextures,
                        maxSamples: maxSamples
                    };
                }

                function WebGLClipping(properties) {
                    var scope = this;
                    var globalState = null,
                        numGlobalPlanes = 0,
                        localClippingEnabled = false,
                        renderingShadows = false;
                    var plane = new Plane(),
                        viewNormalMatrix = new Matrix3(),
                        uniform = {
                            value: null,
                            needsUpdate: false
                        };
                    this.uniform = uniform;
                    this.numPlanes = 0;
                    this.numIntersection = 0;
                    this.init = function(planes, enableLocalClipping, camera) {
                        var enabled = planes.length !== 0 ||
                            enableLocalClipping ||
                            // enable state of previous frame - the clipping code has to
                            // run another frame in order to reset the state:
                            numGlobalPlanes !== 0 ||
                            localClippingEnabled;
                        localClippingEnabled = enableLocalClipping;
                        globalState = projectPlanes(planes, camera, 0);
                        numGlobalPlanes = planes.length;
                        return enabled;
                    };
                    this.beginShadows = function() {
                        renderingShadows = true;
                        projectPlanes(null);
                    };
                    this.endShadows = function() {
                        renderingShadows = false;
                        resetGlobalState();
                    };
                    this.setState = function(material, camera, useCache) {
                        var planes = material.clippingPlanes,
                            clipIntersection = material.clipIntersection,
                            clipShadows = material.clipShadows;
                        var materialProperties = properties.get(material);
                        if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
                            // there's no local clipping
                            if (renderingShadows) {
                                // there's no global clipping
                                projectPlanes(null);
                            } else {
                                resetGlobalState();
                            }
                        } else {
                            var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
                                lGlobal = nGlobal * 4;
                            var dstArray = materialProperties.clippingState || null;
                            uniform.value = dstArray; // ensure unique state
                            dstArray = projectPlanes(planes, camera, lGlobal, useCache);
                            for (var i = 0; i !== lGlobal; ++i) {
                                dstArray[i] = globalState[i];
                            }
                            materialProperties.clippingState = dstArray;
                            this.numIntersection = clipIntersection ? this.numPlanes : 0;
                            this.numPlanes += nGlobal;
                        }
                    };

                    function resetGlobalState() {
                        if (uniform.value !== globalState) {
                            uniform.value = globalState;
                            uniform.needsUpdate = numGlobalPlanes > 0;
                        }
                        scope.numPlanes = numGlobalPlanes;
                        scope.numIntersection = 0;
                    }

                    function projectPlanes(planes, camera, dstOffset, skipTransform) {
                        var nPlanes = planes !== null ? planes.length : 0;
                        var dstArray = null;
                        if (nPlanes !== 0) {
                            dstArray = uniform.value;
                            if (skipTransform !== true || dstArray === null) {
                                var flatSize = dstOffset + nPlanes * 4,
                                    viewMatrix = camera.matrixWorldInverse;
                                viewNormalMatrix.getNormalMatrix(viewMatrix);
                                if (dstArray === null || dstArray.length < flatSize) {
                                    dstArray = new Float32Array(flatSize);
                                }
                                for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
                                    plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
                                    plane.normal.toArray(dstArray, i4);
                                    dstArray[i4 + 3] = plane.constant;
                                }
                            }
                            uniform.value = dstArray;
                            uniform.needsUpdate = true;
                        }
                        scope.numPlanes = nPlanes;
                        scope.numIntersection = 0;
                        return dstArray;
                    }
                }

                function WebGLCubeMaps(renderer) {
                    var cubemaps = new WeakMap();

                    function mapTextureMapping(texture, mapping) {
                        if (mapping === EquirectangularReflectionMapping) {
                            texture.mapping = CubeReflectionMapping;
                        } else if (mapping === EquirectangularRefractionMapping) {
                            texture.mapping = CubeRefractionMapping;
                        }
                        return texture;
                    }

                    function get(texture) {
                        if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
                            var mapping = texture.mapping;
                            if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
                                if (cubemaps.has(texture)) {
                                    var cubemap = cubemaps.get(texture).texture;
                                    return mapTextureMapping(cubemap, texture.mapping);
                                } else {
                                    var image = texture.image;
                                    if (image && image.height > 0) {
                                        var renderTarget = new WebGLCubeRenderTarget(image.height / 2);
                                        renderTarget.fromEquirectangularTexture(renderer, texture);
                                        cubemaps.set(texture, renderTarget);
                                        texture.addEventListener('dispose', onTextureDispose);
                                        return mapTextureMapping(renderTarget.texture, texture.mapping);
                                    } else {
                                        // image not yet ready. try the conversion next frame
                                        return null;
                                    }
                                }
                            }
                        }
                        return texture;
                    }

                    function onTextureDispose(event) {
                        var texture = event.target;
                        texture.removeEventListener('dispose', onTextureDispose);
                        var cubemap = cubemaps.get(texture);
                        if (cubemap !== undefined) {
                            cubemaps.delete(texture);
                            cubemap.dispose();
                        }
                    }

                    function dispose() {
                        cubemaps = new WeakMap();
                    }
                    return {
                        get: get,
                        dispose: dispose
                    };
                }
                var OrthographicCamera = /** @class */ (function(_super) {
                    __extends(OrthographicCamera, _super);

                    function OrthographicCamera(left, right, top, bottom, near, far) {
                        if (left === void 0) {
                            left = -1;
                        }
                        if (right === void 0) {
                            right = 1;
                        }
                        if (top === void 0) {
                            top = 1;
                        }
                        if (bottom === void 0) {
                            bottom = -1;
                        }
                        if (near === void 0) {
                            near = 0.1;
                        }
                        if (far === void 0) {
                            far = 2000;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'OrthographicCamera';
                        _this_1.zoom = 1;
                        _this_1.view = null;
                        _this_1.left = left;
                        _this_1.right = right;
                        _this_1.top = top;
                        _this_1.bottom = bottom;
                        _this_1.near = near;
                        _this_1.far = far;
                        _this_1.updateProjectionMatrix();
                        return _this_1;
                    }
                    OrthographicCamera.prototype.copy = function(source, recursive) {
                        _super.prototype.copy.call(this, source, recursive);
                        this.left = source.left;
                        this.right = source.right;
                        this.top = source.top;
                        this.bottom = source.bottom;
                        this.near = source.near;
                        this.far = source.far;
                        this.zoom = source.zoom;
                        this.view = source.view === null ? null : Object.assign({}, source.view);
                        return this;
                    };
                    OrthographicCamera.prototype.setViewOffset = function(fullWidth, fullHeight, x, y, width, height) {
                        if (this.view === null) {
                            this.view = {
                                enabled: true,
                                fullWidth: 1,
                                fullHeight: 1,
                                offsetX: 0,
                                offsetY: 0,
                                width: 1,
                                height: 1
                            };
                        }
                        this.view.enabled = true;
                        this.view.fullWidth = fullWidth;
                        this.view.fullHeight = fullHeight;
                        this.view.offsetX = x;
                        this.view.offsetY = y;
                        this.view.width = width;
                        this.view.height = height;
                        this.updateProjectionMatrix();
                    };
                    OrthographicCamera.prototype.clearViewOffset = function() {
                        if (this.view !== null) {
                            this.view.enabled = false;
                        }
                        this.updateProjectionMatrix();
                    };
                    OrthographicCamera.prototype.updateProjectionMatrix = function() {
                        var dx = (this.right - this.left) / (2 * this.zoom);
                        var dy = (this.top - this.bottom) / (2 * this.zoom);
                        var cx = (this.right + this.left) / 2;
                        var cy = (this.top + this.bottom) / 2;
                        var left = cx - dx;
                        var right = cx + dx;
                        var top = cy + dy;
                        var bottom = cy - dy;
                        if (this.view !== null && this.view.enabled) {
                            var scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
                            var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                            left += scaleW * this.view.offsetX;
                            right = left + scaleW * this.view.width;
                            top -= scaleH * this.view.offsetY;
                            bottom = top - scaleH * this.view.height;
                        }
                        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
                    };
                    OrthographicCamera.prototype.toJSON = function(meta) {
                        var data = _super.prototype.toJSON.call(this, meta);
                        data.object.zoom = this.zoom;
                        data.object.left = this.left;
                        data.object.right = this.right;
                        data.object.top = this.top;
                        data.object.bottom = this.bottom;
                        data.object.near = this.near;
                        data.object.far = this.far;
                        if (this.view !== null)
                            data.object.view = Object.assign({}, this.view);
                        return data;
                    };
                    return OrthographicCamera;
                }(Camera));
                OrthographicCamera.prototype.isOrthographicCamera = true;
                var LOD_MIN = 4;
                // The standard deviations (radians) associated with the extra mips. These are
                // chosen to approximate a Trowbridge-Reitz distribution function times the
                // geometric shadowing function. These sigma values squared must match the
                // variance #defines in cube_uv_reflection_fragment.glsl.js.
                var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
                // The maximum length of the blur for loop. Smaller sigmas will use fewer
                // samples and exit early, but not recompile the shader.
                var MAX_SAMPLES = 20;
                var _flatCamera = /*@__PURE__*/ new OrthographicCamera();
                var _clearColor = /*@__PURE__*/ new Color();
                var _oldTarget = null;
                // Golden Ratio
                var PHI = (1 + Math.sqrt(5)) / 2;
                var INV_PHI = 1 / PHI;
                // Vertices of a dodecahedron (except the opposites, which represent the
                // same axis), used as axis directions evenly spread on a sphere.
                var _axisDirections = [
                    /*@__PURE__*/
                    new Vector3(1, 1, 1),
                    /*@__PURE__*/
                    new Vector3(-1, 1, 1),
                    /*@__PURE__*/
                    new Vector3(1, 1, -1),
                    /*@__PURE__*/
                    new Vector3(-1, 1, -1),
                    /*@__PURE__*/
                    new Vector3(0, PHI, INV_PHI),
                    /*@__PURE__*/
                    new Vector3(0, PHI, -INV_PHI),
                    /*@__PURE__*/
                    new Vector3(INV_PHI, 0, PHI),
                    /*@__PURE__*/
                    new Vector3(-INV_PHI, 0, PHI),
                    /*@__PURE__*/
                    new Vector3(PHI, INV_PHI, 0),
                    /*@__PURE__*/
                    new Vector3(-PHI, INV_PHI, 0)
                ];
                /**
                 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
                 * (PMREM) from a cubeMap environment texture. This allows different levels of
                 * blur to be quickly accessed based on material roughness. It is packed into a
                 * special CubeUV format that allows us to perform custom interpolation so that
                 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
                 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
                 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
                 * higher roughness levels. In this way we maintain resolution to smoothly
                 * interpolate diffuse lighting while limiting sampling computation.
                 *
                 * Paper: Fast, Accurate Image-Based Lighting
                 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
                 */
                var PMREMGenerator = /** @class */ (function() {
                    function PMREMGenerator(renderer) {
                        this._renderer = renderer;
                        this._pingPongRenderTarget = null;
                        this._lodMax = 0;
                        this._cubeSize = 0;
                        this._lodPlanes = [];
                        this._sizeLods = [];
                        this._sigmas = [];
                        this._blurMaterial = null;
                        this._cubemapMaterial = null;
                        this._equirectMaterial = null;
                        this._compileMaterial(this._blurMaterial);
                    }
                    /**
                     * Generates a PMREM from a supplied Scene, which can be faster than using an
                     * image if networking bandwidth is low. Optional sigma specifies a blur radius
                     * in radians to be applied to the scene before PMREM generation. Optional near
                     * and far planes ensure the scene is rendered in its entirety (the cubeCamera
                     * is placed at the origin).
                     */
                    PMREMGenerator.prototype.fromScene = function(scene, sigma, near, far) {
                        if (sigma === void 0) {
                            sigma = 0;
                        }
                        if (near === void 0) {
                            near = 0.1;
                        }
                        if (far === void 0) {
                            far = 100;
                        }
                        _oldTarget = this._renderer.getRenderTarget();
                        this._setSize(256);
                        var cubeUVRenderTarget = this._allocateTargets();
                        cubeUVRenderTarget.depthBuffer = true;
                        this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
                        if (sigma > 0) {
                            this._blur(cubeUVRenderTarget, 0, 0, sigma);
                        }
                        this._applyPMREM(cubeUVRenderTarget);
                        this._cleanup(cubeUVRenderTarget);
                        return cubeUVRenderTarget;
                    };
                    /**
                     * Generates a PMREM from an equirectangular texture, which can be either LDR
                     * or HDR. The ideal input image size is 1k (1024 x 512),
                     * as this matches best with the 256 x 256 cubemap output.
                     */
                    PMREMGenerator.prototype.fromEquirectangular = function(equirectangular, renderTarget) {
                        if (renderTarget === void 0) {
                            renderTarget = null;
                        }
                        return this._fromTexture(equirectangular, renderTarget);
                    };
                    /**
                     * Generates a PMREM from an cubemap texture, which can be either LDR
                     * or HDR. The ideal input cube size is 256 x 256,
                     * as this matches best with the 256 x 256 cubemap output.
                     */
                    PMREMGenerator.prototype.fromCubemap = function(cubemap, renderTarget) {
                        if (renderTarget === void 0) {
                            renderTarget = null;
                        }
                        return this._fromTexture(cubemap, renderTarget);
                    };
                    /**
                     * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
                     * your texture's network fetch for increased concurrency.
                     */
                    PMREMGenerator.prototype.compileCubemapShader = function() {
                        if (this._cubemapMaterial === null) {
                            this._cubemapMaterial = _getCubemapMaterial();
                            this._compileMaterial(this._cubemapMaterial);
                        }
                    };
                    /**
                     * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
                     * your texture's network fetch for increased concurrency.
                     */
                    PMREMGenerator.prototype.compileEquirectangularShader = function() {
                        if (this._equirectMaterial === null) {
                            this._equirectMaterial = _getEquirectMaterial();
                            this._compileMaterial(this._equirectMaterial);
                        }
                    };
                    /**
                     * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
                     * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
                     * one of them will cause any others to also become unusable.
                     */
                    PMREMGenerator.prototype.dispose = function() {
                        this._dispose();
                        if (this._cubemapMaterial !== null)
                            this._cubemapMaterial.dispose();
                        if (this._equirectMaterial !== null)
                            this._equirectMaterial.dispose();
                    };
                    // private interface
                    PMREMGenerator.prototype._setSize = function(cubeSize) {
                        this._lodMax = Math.floor(Math.log2(cubeSize));
                        this._cubeSize = Math.pow(2, this._lodMax);
                    };
                    PMREMGenerator.prototype._dispose = function() {
                        if (this._blurMaterial !== null)
                            this._blurMaterial.dispose();
                        if (this._pingPongRenderTarget !== null)
                            this._pingPongRenderTarget.dispose();
                        for (var i = 0; i < this._lodPlanes.length; i++) {
                            this._lodPlanes[i].dispose();
                        }
                    };
                    PMREMGenerator.prototype._cleanup = function(outputTarget) {
                        this._renderer.setRenderTarget(_oldTarget);
                        outputTarget.scissorTest = false;
                        _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
                    };
                    PMREMGenerator.prototype._fromTexture = function(texture, renderTarget) {
                        if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
                            this._setSize(texture.image.length === 0 ? 16 : (texture.image[0].width || texture.image[0].image.width));
                        } else { // Equirectangular
                            this._setSize(texture.image.width / 4);
                        }
                        _oldTarget = this._renderer.getRenderTarget();
                        var cubeUVRenderTarget = renderTarget || this._allocateTargets();
                        this._textureToCubeUV(texture, cubeUVRenderTarget);
                        this._applyPMREM(cubeUVRenderTarget);
                        this._cleanup(cubeUVRenderTarget);
                        return cubeUVRenderTarget;
                    };
                    PMREMGenerator.prototype._allocateTargets = function() {
                        var _a;
                        var width = 3 * Math.max(this._cubeSize, 16 * 7);
                        var height = 4 * this._cubeSize - 32;
                        var params = {
                            magFilter: LinearFilter,
                            minFilter: LinearFilter,
                            generateMipmaps: false,
                            type: HalfFloatType,
                            format: RGBAFormat,
                            encoding: LinearEncoding,
                            depthBuffer: false
                        };
                        var cubeUVRenderTarget = _createRenderTarget(width, height, params);
                        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width) {
                            if (this._pingPongRenderTarget !== null) {
                                this._dispose();
                            }
                            this._pingPongRenderTarget = _createRenderTarget(width, height, params);
                            var _lodMax = this._lodMax;
                            (_a = _createPlanes(_lodMax), this._sizeLods = _a.sizeLods, this._lodPlanes = _a.lodPlanes, this._sigmas = _a.sigmas);
                            this._blurMaterial = _getBlurShader(_lodMax, width, height);
                        }
                        return cubeUVRenderTarget;
                    };
                    PMREMGenerator.prototype._compileMaterial = function(material) {
                        var tmpMesh = new Mesh(this._lodPlanes[0], material);
                        this._renderer.compile(tmpMesh, _flatCamera);
                    };
                    PMREMGenerator.prototype._sceneToCubeUV = function(scene, near, far, cubeUVRenderTarget) {
                        var fov = 90;
                        var aspect = 1;
                        var cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
                        var upSign = [1, -1, 1, 1, 1, 1];
                        var forwardSign = [1, 1, 1, -1, -1, -1];
                        var renderer = this._renderer;
                        var originalAutoClear = renderer.autoClear;
                        var toneMapping = renderer.toneMapping;
                        renderer.getClearColor(_clearColor);
                        renderer.toneMapping = NoToneMapping;
                        renderer.autoClear = false;
                        var backgroundMaterial = new MeshBasicMaterial({
                            name: 'PMREM.Background',
                            side: BackSide,
                            depthWrite: false,
                            depthTest: false,
                        });
                        var backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
                        var useSolidColor = false;
                        var background = scene.background;
                        if (background) {
                            if (background.isColor) {
                                backgroundMaterial.color.copy(background);
                                scene.background = null;
                                useSolidColor = true;
                            }
                        } else {
                            backgroundMaterial.color.copy(_clearColor);
                            useSolidColor = true;
                        }
                        for (var i = 0; i < 6; i++) {
                            var col = i % 3;
                            if (col === 0) {
                                cubeCamera.up.set(0, upSign[i], 0);
                                cubeCamera.lookAt(forwardSign[i], 0, 0);
                            } else if (col === 1) {
                                cubeCamera.up.set(0, 0, upSign[i]);
                                cubeCamera.lookAt(0, forwardSign[i], 0);
                            } else {
                                cubeCamera.up.set(0, upSign[i], 0);
                                cubeCamera.lookAt(0, 0, forwardSign[i]);
                            }
                            var size = this._cubeSize;
                            _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
                            renderer.setRenderTarget(cubeUVRenderTarget);
                            if (useSolidColor) {
                                renderer.render(backgroundBox, cubeCamera);
                            }
                            renderer.render(scene, cubeCamera);
                        }
                        backgroundBox.geometry.dispose();
                        backgroundBox.material.dispose();
                        renderer.toneMapping = toneMapping;
                        renderer.autoClear = originalAutoClear;
                        scene.background = background;
                    };
                    PMREMGenerator.prototype._textureToCubeUV = function(texture, cubeUVRenderTarget) {
                        var renderer = this._renderer;
                        var isCubeTexture = (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping);
                        if (isCubeTexture) {
                            if (this._cubemapMaterial === null) {
                                this._cubemapMaterial = _getCubemapMaterial();
                            }
                            this._cubemapMaterial.uniforms.flipEnvMap.value = (texture.isRenderTargetTexture === false) ? -1 : 1;
                        } else {
                            if (this._equirectMaterial === null) {
                                this._equirectMaterial = _getEquirectMaterial();
                            }
                        }
                        var material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
                        var mesh = new Mesh(this._lodPlanes[0], material);
                        var uniforms = material.uniforms;
                        uniforms['envMap'].value = texture;
                        var size = this._cubeSize;
                        _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
                        renderer.setRenderTarget(cubeUVRenderTarget);
                        renderer.render(mesh, _flatCamera);
                    };
                    PMREMGenerator.prototype._applyPMREM = function(cubeUVRenderTarget) {
                        var renderer = this._renderer;
                        var autoClear = renderer.autoClear;
                        renderer.autoClear = false;
                        for (var i = 1; i < this._lodPlanes.length; i++) {
                            var sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
                            var poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
                            this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
                        }
                        renderer.autoClear = autoClear;
                    };
                    /**
                     * This is a two-pass Gaussian blur for a cubemap. Normally this is done
                     * vertically and horizontally, but this breaks down on a cube. Here we apply
                     * the blur latitudinally (around the poles), and then longitudinally (towards
                     * the poles) to approximate the orthogonally-separable blur. It is least
                     * accurate at the poles, but still does a decent job.
                     */
                    PMREMGenerator.prototype._blur = function(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
                        var pingPongRenderTarget = this._pingPongRenderTarget;
                        this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
                        this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
                    };
                    PMREMGenerator.prototype._halfBlur = function(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
                        var renderer = this._renderer;
                        var blurMaterial = this._blurMaterial;
                        if (direction !== 'latitudinal' && direction !== 'longitudinal') {
                            console.error('blur direction must be either latitudinal or longitudinal!');
                        }
                        // Number of standard deviations at which to cut off the discrete approximation.
                        var STANDARD_DEVIATIONS = 3;
                        var blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
                        var blurUniforms = blurMaterial.uniforms;
                        var pixels = this._sizeLods[lodIn] - 1;
                        var radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
                        var sigmaPixels = sigmaRadians / radiansPerPixel;
                        var samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
                        if (samples > MAX_SAMPLES) {
                            console.warn("sigmaRadians, ".concat(sigmaRadians, ", is too large and will clip, as it requested ").concat(samples, " samples when the maximum is set to ").concat(MAX_SAMPLES));
                        }
                        var weights = [];
                        var sum = 0;
                        for (var i = 0; i < MAX_SAMPLES; ++i) {
                            var x_1 = i / sigmaPixels;
                            var weight = Math.exp(-x_1 * x_1 / 2);
                            weights.push(weight);
                            if (i === 0) {
                                sum += weight;
                            } else if (i < samples) {
                                sum += 2 * weight;
                            }
                        }
                        for (var i = 0; i < weights.length; i++) {
                            weights[i] = weights[i] / sum;
                        }
                        blurUniforms['envMap'].value = targetIn.texture;
                        blurUniforms['samples'].value = samples;
                        blurUniforms['weights'].value = weights;
                        blurUniforms['latitudinal'].value = direction === 'latitudinal';
                        if (poleAxis) {
                            blurUniforms['poleAxis'].value = poleAxis;
                        }
                        var _lodMax = this._lodMax;
                        blurUniforms['dTheta'].value = radiansPerPixel;
                        blurUniforms['mipInt'].value = _lodMax - lodIn;
                        var outputSize = this._sizeLods[lodOut];
                        var x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
                        var y = 4 * (this._cubeSize - outputSize);
                        _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
                        renderer.setRenderTarget(targetOut);
                        renderer.render(blurMesh, _flatCamera);
                    };
                    return PMREMGenerator;
                }());

                function _createPlanes(lodMax) {
                    var lodPlanes = [];
                    var sizeLods = [];
                    var sigmas = [];
                    var lod = lodMax;
                    var totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
                    for (var i = 0; i < totalLods; i++) {
                        var sizeLod = Math.pow(2, lod);
                        sizeLods.push(sizeLod);
                        var sigma = 1.0 / sizeLod;
                        if (i > lodMax - LOD_MIN) {
                            sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
                        } else if (i === 0) {
                            sigma = 0;
                        }
                        sigmas.push(sigma);
                        var texelSize = 1.0 / (sizeLod - 1);
                        var min = -texelSize / 2;
                        var max = 1 + texelSize / 2;
                        var uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
                        var cubeFaces = 6;
                        var vertices = 6;
                        var positionSize = 3;
                        var uvSize = 2;
                        var faceIndexSize = 1;
                        var position = new Float32Array(positionSize * vertices * cubeFaces);
                        var uv = new Float32Array(uvSize * vertices * cubeFaces);
                        var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
                        for (var face = 0; face < cubeFaces; face++) {
                            var x = (face % 3) * 2 / 3 - 1;
                            var y = face > 2 ? 0 : -1;
                            var coordinates = [
                                x, y, 0,
                                x + 2 / 3, y, 0,
                                x + 2 / 3, y + 1, 0,
                                x, y, 0,
                                x + 2 / 3, y + 1, 0,
                                x, y + 1, 0
                            ];
                            position.set(coordinates, positionSize * vertices * face);
                            uv.set(uv1, uvSize * vertices * face);
                            var fill = [face, face, face, face, face, face];
                            faceIndex.set(fill, faceIndexSize * vertices * face);
                        }
                        var planes = new BufferGeometry();
                        planes.setAttribute('position', new BufferAttribute(position, positionSize));
                        planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
                        planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
                        lodPlanes.push(planes);
                        if (lod > LOD_MIN) {
                            lod--;
                        }
                    }
                    return {
                        lodPlanes: lodPlanes,
                        sizeLods: sizeLods,
                        sigmas: sigmas
                    };
                }

                function _createRenderTarget(width, height, params) {
                    var cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
                    cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
                    cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
                    cubeUVRenderTarget.scissorTest = true;
                    return cubeUVRenderTarget;
                }

                function _setViewport(target, x, y, width, height) {
                    target.viewport.set(x, y, width, height);
                    target.scissor.set(x, y, width, height);
                }

                function _getBlurShader(lodMax, width, height) {
                    var weights = new Float32Array(MAX_SAMPLES);
                    var poleAxis = new Vector3(0, 1, 0);
                    var shaderMaterial = new ShaderMaterial({
                        name: 'SphericalGaussianBlur',
                        defines: {
                            'n': MAX_SAMPLES,
                            'CUBEUV_TEXEL_WIDTH': 1.0 / width,
                            'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
                            'CUBEUV_MAX_MIP': "".concat(lodMax, ".0"),
                        },
                        uniforms: {
                            'envMap': {
                                value: null
                            },
                            'samples': {
                                value: 1
                            },
                            'weights': {
                                value: weights
                            },
                            'latitudinal': {
                                value: false
                            },
                            'dTheta': {
                                value: 0
                            },
                            'mipInt': {
                                value: 0
                            },
                            'poleAxis': {
                                value: poleAxis
                            }
                        },
                        vertexShader: _getCommonVertexShader(),
                        fragmentShader: /* glsl */ "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                        blending: NoBlending,
                        depthTest: false,
                        depthWrite: false
                    });
                    return shaderMaterial;
                }

                function _getEquirectMaterial() {
                    return new ShaderMaterial({
                        name: 'EquirectangularToCubeUV',
                        uniforms: {
                            'envMap': {
                                value: null
                            }
                        },
                        vertexShader: _getCommonVertexShader(),
                        fragmentShader: /* glsl */ "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                        blending: NoBlending,
                        depthTest: false,
                        depthWrite: false
                    });
                }

                function _getCubemapMaterial() {
                    return new ShaderMaterial({
                        name: 'CubemapToCubeUV',
                        uniforms: {
                            'envMap': {
                                value: null
                            },
                            'flipEnvMap': {
                                value: -1
                            }
                        },
                        vertexShader: _getCommonVertexShader(),
                        fragmentShader: /* glsl */ "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                        blending: NoBlending,
                        depthTest: false,
                        depthWrite: false
                    });
                }

                function _getCommonVertexShader() {
                    return /* glsl */ "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
                }

                function WebGLCubeUVMaps(renderer) {
                    var cubeUVmaps = new WeakMap();
                    var pmremGenerator = null;

                    function get(texture) {
                        if (texture && texture.isTexture) {
                            var mapping = texture.mapping;
                            var isEquirectMap = (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping);
                            var isCubeMap = (mapping === CubeReflectionMapping || mapping === CubeRefractionMapping);
                            // equirect/cube map to cubeUV conversion
                            if (isEquirectMap || isCubeMap) {
                                if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
                                    texture.needsPMREMUpdate = false;
                                    var renderTarget = cubeUVmaps.get(texture);
                                    if (pmremGenerator === null)
                                        pmremGenerator = new PMREMGenerator(renderer);
                                    renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
                                    cubeUVmaps.set(texture, renderTarget);
                                    return renderTarget.texture;
                                } else {
                                    if (cubeUVmaps.has(texture)) {
                                        return cubeUVmaps.get(texture).texture;
                                    } else {
                                        var image = texture.image;
                                        if ((isEquirectMap && image && image.height > 0) || (isCubeMap && image && isCubeTextureComplete(image))) {
                                            if (pmremGenerator === null)
                                                pmremGenerator = new PMREMGenerator(renderer);
                                            var renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
                                            cubeUVmaps.set(texture, renderTarget);
                                            texture.addEventListener('dispose', onTextureDispose);
                                            return renderTarget.texture;
                                        } else {
                                            // image not yet ready. try the conversion next frame
                                            return null;
                                        }
                                    }
                                }
                            }
                        }
                        return texture;
                    }

                    function isCubeTextureComplete(image) {
                        var count = 0;
                        var length = 6;
                        for (var i = 0; i < length; i++) {
                            if (image[i] !== undefined)
                                count++;
                        }
                        return count === length;
                    }

                    function onTextureDispose(event) {
                        var texture = event.target;
                        texture.removeEventListener('dispose', onTextureDispose);
                        var cubemapUV = cubeUVmaps.get(texture);
                        if (cubemapUV !== undefined) {
                            cubeUVmaps.delete(texture);
                            cubemapUV.dispose();
                        }
                    }

                    function dispose() {
                        cubeUVmaps = new WeakMap();
                        if (pmremGenerator !== null) {
                            pmremGenerator.dispose();
                            pmremGenerator = null;
                        }
                    }
                    return {
                        get: get,
                        dispose: dispose
                    };
                }

                function WebGLExtensions(gl) {
                    var extensions = {};

                    function getExtension(name) {
                        if (extensions[name] !== undefined) {
                            return extensions[name];
                        }
                        var extension;
                        switch (name) {
                            case 'WEBGL_depth_texture':
                                extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                                break;
                            case 'EXT_texture_filter_anisotropic':
                                extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                                break;
                            case 'WEBGL_compressed_texture_s3tc':
                                extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                                break;
                            case 'WEBGL_compressed_texture_pvrtc':
                                extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                                break;
                            default:
                                extension = gl.getExtension(name);
                        }
                        extensions[name] = extension;
                        return extension;
                    }
                    return {
                        has: function(name) {
                            return getExtension(name) !== null;
                        },
                        init: function(capabilities) {
                            if (capabilities.isWebGL2) {
                                getExtension('EXT_color_buffer_float');
                            } else {
                                getExtension('WEBGL_depth_texture');
                                getExtension('OES_texture_float');
                                getExtension('OES_texture_half_float');
                                getExtension('OES_texture_half_float_linear');
                                getExtension('OES_standard_derivatives');
                                getExtension('OES_element_index_uint');
                                getExtension('OES_vertex_array_object');
                                getExtension('ANGLE_instanced_arrays');
                            }
                            getExtension('OES_texture_float_linear');
                            getExtension('EXT_color_buffer_half_float');
                            getExtension('WEBGL_multisampled_render_to_texture');
                        },
                        get: function(name) {
                            var extension = getExtension(name);
                            if (extension === null) {
                                console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
                            }
                            return extension;
                        }
                    };
                }

                function WebGLGeometries(gl, attributes, info, bindingStates) {
                    var geometries = {};
                    var wireframeAttributes = new WeakMap();

                    function onGeometryDispose(event) {
                        var geometry = event.target;
                        if (geometry.index !== null) {
                            attributes.remove(geometry.index);
                        }
                        for (var name in geometry.attributes) {
                            attributes.remove(geometry.attributes[name]);
                        }
                        geometry.removeEventListener('dispose', onGeometryDispose);
                        delete geometries[geometry.id];
                        var attribute = wireframeAttributes.get(geometry);
                        if (attribute) {
                            attributes.remove(attribute);
                            wireframeAttributes.delete(geometry);
                        }
                        bindingStates.releaseStatesOfGeometry(geometry);
                        if (geometry.isInstancedBufferGeometry === true) {
                            delete geometry._maxInstanceCount;
                        }
                        //
                        info.memory.geometries--;
                    }

                    function get(object, geometry) {
                        if (geometries[geometry.id] === true)
                            return geometry;
                        geometry.addEventListener('dispose', onGeometryDispose);
                        geometries[geometry.id] = true;
                        info.memory.geometries++;
                        return geometry;
                    }

                    function update(geometry) {
                        var geometryAttributes = geometry.attributes;
                        // Updating index buffer in VAO now. See WebGLBindingStates.
                        for (var name in geometryAttributes) {
                            attributes.update(geometryAttributes[name], 34962);
                        }
                        // morph targets
                        var morphAttributes = geometry.morphAttributes;
                        for (var name in morphAttributes) {
                            var array = morphAttributes[name];
                            for (var i = 0, l = array.length; i < l; i++) {
                                attributes.update(array[i], 34962);
                            }
                        }
                    }

                    function updateWireframeAttribute(geometry) {
                        var indices = [];
                        var geometryIndex = geometry.index;
                        var geometryPosition = geometry.attributes.position;
                        var version = 0;
                        if (geometryIndex !== null) {
                            var array = geometryIndex.array;
                            version = geometryIndex.version;
                            for (var i = 0, l = array.length; i < l; i += 3) {
                                var a = array[i + 0];
                                var b = array[i + 1];
                                var c = array[i + 2];
                                indices.push(a, b, b, c, c, a);
                            }
                        } else {
                            var array = geometryPosition.array;
                            version = geometryPosition.version;
                            for (var i = 0, l = (array.length / 3) - 1; i < l; i += 3) {
                                var a = i + 0;
                                var b = i + 1;
                                var c = i + 2;
                                indices.push(a, b, b, c, c, a);
                            }
                        }
                        var attribute = new(arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
                        attribute.version = version;
                        // Updating index buffer in VAO now. See WebGLBindingStates
                        //
                        var previousAttribute = wireframeAttributes.get(geometry);
                        if (previousAttribute)
                            attributes.remove(previousAttribute);
                        //
                        wireframeAttributes.set(geometry, attribute);
                    }

                    function getWireframeAttribute(geometry) {
                        var currentAttribute = wireframeAttributes.get(geometry);
                        if (currentAttribute) {
                            var geometryIndex = geometry.index;
                            if (geometryIndex !== null) {
                                // if the attribute is obsolete, create a new one
                                if (currentAttribute.version < geometryIndex.version) {
                                    updateWireframeAttribute(geometry);
                                }
                            }
                        } else {
                            updateWireframeAttribute(geometry);
                        }
                        return wireframeAttributes.get(geometry);
                    }
                    return {
                        get: get,
                        update: update,
                        getWireframeAttribute: getWireframeAttribute
                    };
                }

                function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
                    var isWebGL2 = capabilities.isWebGL2;
                    var mode;

                    function setMode(value) {
                        mode = value;
                    }
                    var type, bytesPerElement;

                    function setIndex(value) {
                        type = value.type;
                        bytesPerElement = value.bytesPerElement;
                    }

                    function render(start, count) {
                        gl.drawElements(mode, count, type, start * bytesPerElement);
                        info.update(count, mode, 1);
                    }

                    function renderInstances(start, count, primcount) {
                        if (primcount === 0)
                            return;
                        var extension, methodName;
                        if (isWebGL2) {
                            extension = gl;
                            methodName = 'drawElementsInstanced';
                        } else {
                            extension = extensions.get('ANGLE_instanced_arrays');
                            methodName = 'drawElementsInstancedANGLE';
                            if (extension === null) {
                                console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
                                return;
                            }
                        }
                        extension[methodName](mode, count, type, start * bytesPerElement, primcount);
                        info.update(count, mode, primcount);
                    }
                    //
                    this.setMode = setMode;
                    this.setIndex = setIndex;
                    this.render = render;
                    this.renderInstances = renderInstances;
                }

                function WebGLInfo(gl) {
                    var memory = {
                        geometries: 0,
                        textures: 0
                    };
                    var render = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0
                    };

                    function update(count, mode, instanceCount) {
                        render.calls++;
                        switch (mode) {
                            case 4:
                                render.triangles += instanceCount * (count / 3);
                                break;
                            case 1:
                                render.lines += instanceCount * (count / 2);
                                break;
                            case 3:
                                render.lines += instanceCount * (count - 1);
                                break;
                            case 2:
                                render.lines += instanceCount * count;
                                break;
                            case 0:
                                render.points += instanceCount * count;
                                break;
                            default:
                                console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
                                break;
                        }
                    }

                    function reset() {
                        render.frame++;
                        render.calls = 0;
                        render.triangles = 0;
                        render.points = 0;
                        render.lines = 0;
                    }
                    return {
                        memory: memory,
                        render: render,
                        programs: null,
                        autoReset: true,
                        reset: reset,
                        update: update
                    };
                }

                function numericalSort(a, b) {
                    return a[0] - b[0];
                }

                function absNumericalSort(a, b) {
                    return Math.abs(b[1]) - Math.abs(a[1]);
                }

                function denormalize(morph, attribute) {
                    var denominator = 1;
                    var array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
                    if (array instanceof Int8Array)
                        denominator = 127;
                    else if (array instanceof Int16Array)
                        denominator = 32767;
                    else if (array instanceof Int32Array)
                        denominator = 2147483647;
                    else
                        console.error('THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', array);
                    morph.divideScalar(denominator);
                }

                function WebGLMorphtargets(gl, capabilities, textures) {
                    var influencesList = {};
                    var morphInfluences = new Float32Array(8);
                    var morphTextures = new WeakMap();
                    var morph = new Vector4();
                    var workInfluences = [];
                    for (var i = 0; i < 8; i++) {
                        workInfluences[i] = [i, 0];
                    }

                    function update(object, geometry, material, program) {
                        var objectInfluences = object.morphTargetInfluences;
                        if (capabilities.isWebGL2 === true) {
                            // instead of using attributes, the WebGL 2 code path encodes morph targets
                            // into an array of data textures. Each layer represents a single morph target.
                            var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
                            var morphTargetsCount = (morphAttribute !== undefined) ? morphAttribute.length : 0;
                            var entry = morphTextures.get(geometry);
                            if (entry === undefined || entry.count !== morphTargetsCount) {
                                if (entry !== undefined)
                                    entry.texture.dispose();
                                var hasMorphPosition = geometry.morphAttributes.position !== undefined;
                                var hasMorphNormals = geometry.morphAttributes.normal !== undefined;
                                var hasMorphColors = geometry.morphAttributes.color !== undefined;
                                var morphTargets = geometry.morphAttributes.position || [];
                                var morphNormals = geometry.morphAttributes.normal || [];
                                var morphColors = geometry.morphAttributes.color || [];
                                var vertexDataCount = 0;
                                if (hasMorphPosition === true)
                                    vertexDataCount = 1;
                                if (hasMorphNormals === true)
                                    vertexDataCount = 2;
                                if (hasMorphColors === true)
                                    vertexDataCount = 3;
                                var width = geometry.attributes.position.count * vertexDataCount;
                                var height = 1;
                                if (width > capabilities.maxTextureSize) {
                                    height = Math.ceil(width / capabilities.maxTextureSize);
                                    width = capabilities.maxTextureSize;
                                }
                                var buffer = new Float32Array(width * height * 4 * morphTargetsCount);
                                var texture_1 = new DataArrayTexture(buffer, width, height, morphTargetsCount);
                                texture_1.type = FloatType;
                                texture_1.needsUpdate = true;
                                // fill buffer
                                var vertexDataStride = vertexDataCount * 4;
                                for (var i = 0; i < morphTargetsCount; i++) {
                                    var morphTarget = morphTargets[i];
                                    var morphNormal = morphNormals[i];
                                    var morphColor = morphColors[i];
                                    var offset = width * height * 4 * i;
                                    for (var j = 0; j < morphTarget.count; j++) {
                                        var stride = j * vertexDataStride;
                                        if (hasMorphPosition === true) {
                                            morph.fromBufferAttribute(morphTarget, j);
                                            if (morphTarget.normalized === true)
                                                denormalize(morph, morphTarget);
                                            buffer[offset + stride + 0] = morph.x;
                                            buffer[offset + stride + 1] = morph.y;
                                            buffer[offset + stride + 2] = morph.z;
                                            buffer[offset + stride + 3] = 0;
                                        }
                                        if (hasMorphNormals === true) {
                                            morph.fromBufferAttribute(morphNormal, j);
                                            if (morphNormal.normalized === true)
                                                denormalize(morph, morphNormal);
                                            buffer[offset + stride + 4] = morph.x;
                                            buffer[offset + stride + 5] = morph.y;
                                            buffer[offset + stride + 6] = morph.z;
                                            buffer[offset + stride + 7] = 0;
                                        }
                                        if (hasMorphColors === true) {
                                            morph.fromBufferAttribute(morphColor, j);
                                            if (morphColor.normalized === true)
                                                denormalize(morph, morphColor);
                                            buffer[offset + stride + 8] = morph.x;
                                            buffer[offset + stride + 9] = morph.y;
                                            buffer[offset + stride + 10] = morph.z;
                                            buffer[offset + stride + 11] = (morphColor.itemSize === 4) ? morph.w : 1;
                                        }
                                    }
                                }
                                entry = {
                                    count: morphTargetsCount,
                                    texture: texture_1,
                                    size: new Vector2(width, height)
                                };
                                morphTextures.set(geometry, entry);

                                function disposeTexture() {
                                    texture_1.dispose();
                                    morphTextures.delete(geometry);
                                    geometry.removeEventListener('dispose', disposeTexture);
                                }
                                geometry.addEventListener('dispose', disposeTexture);
                            }
                            //
                            var morphInfluencesSum = 0;
                            for (var i = 0; i < objectInfluences.length; i++) {
                                morphInfluencesSum += objectInfluences[i];
                            }
                            var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
                            program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
                            program.getUniforms().setValue(gl, 'morphTargetInfluences', objectInfluences);
                            program.getUniforms().setValue(gl, 'morphTargetsTexture', entry.texture, textures);
                            program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);
                        } else {
                            // When object doesn't have morph target influences defined, we treat it as a 0-length array
                            // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
                            var length = objectInfluences === undefined ? 0 : objectInfluences.length;
                            var influences = influencesList[geometry.id];
                            if (influences === undefined || influences.length !== length) {
                                // initialise list
                                influences = [];
                                for (var i = 0; i < length; i++) {
                                    influences[i] = [i, 0];
                                }
                                influencesList[geometry.id] = influences;
                            }
                            // Collect influences
                            for (var i = 0; i < length; i++) {
                                var influence = influences[i];
                                influence[0] = i;
                                influence[1] = objectInfluences[i];
                            }
                            influences.sort(absNumericalSort);
                            for (var i = 0; i < 8; i++) {
                                if (i < length && influences[i][1]) {
                                    workInfluences[i][0] = influences[i][0];
                                    workInfluences[i][1] = influences[i][1];
                                } else {
                                    workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
                                    workInfluences[i][1] = 0;
                                }
                            }
                            workInfluences.sort(numericalSort);
                            var morphTargets = geometry.morphAttributes.position;
                            var morphNormals = geometry.morphAttributes.normal;
                            var morphInfluencesSum = 0;
                            for (var i = 0; i < 8; i++) {
                                var influence = workInfluences[i];
                                var index = influence[0];
                                var value = influence[1];
                                if (index !== Number.MAX_SAFE_INTEGER && value) {
                                    if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {
                                        geometry.setAttribute('morphTarget' + i, morphTargets[index]);
                                    }
                                    if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {
                                        geometry.setAttribute('morphNormal' + i, morphNormals[index]);
                                    }
                                    morphInfluences[i] = value;
                                    morphInfluencesSum += value;
                                } else {
                                    if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {
                                        geometry.deleteAttribute('morphTarget' + i);
                                    }
                                    if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {
                                        geometry.deleteAttribute('morphNormal' + i);
                                    }
                                    morphInfluences[i] = 0;
                                }
                            }
                            // GLSL shader uses formula baseinfluence * base + sum(target * influence)
                            // This allows us to switch between absolute morphs and relative morphs without changing shader code
                            // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
                            var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
                            program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
                            program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
                        }
                    }
                    return {
                        update: update
                    };
                }

                function WebGLObjects(gl, geometries, attributes, info) {
                    var updateMap = new WeakMap();

                    function update(object) {
                        var frame = info.render.frame;
                        var geometry = object.geometry;
                        var buffergeometry = geometries.get(object, geometry);
                        // Update once per frame
                        if (updateMap.get(buffergeometry) !== frame) {
                            geometries.update(buffergeometry);
                            updateMap.set(buffergeometry, frame);
                        }
                        if (object.isInstancedMesh) {
                            if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {
                                object.addEventListener('dispose', onInstancedMeshDispose);
                            }
                            attributes.update(object.instanceMatrix, 34962);
                            if (object.instanceColor !== null) {
                                attributes.update(object.instanceColor, 34962);
                            }
                        }
                        return buffergeometry;
                    }

                    function dispose() {
                        updateMap = new WeakMap();
                    }

                    function onInstancedMeshDispose(event) {
                        var instancedMesh = event.target;
                        instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
                        attributes.remove(instancedMesh.instanceMatrix);
                        if (instancedMesh.instanceColor !== null)
                            attributes.remove(instancedMesh.instanceColor);
                    }
                    return {
                        update: update,
                        dispose: dispose
                    };
                }
                /**
                 * Uniforms of a program.
                 * Those form a tree structure with a special top-level container for the root,
                 * which you get by calling 'new WebGLUniforms( gl, program )'.
                 *
                 *
                 * Properties of inner nodes including the top-level container:
                 *
                 * .seq - array of nested uniforms
                 * .map - nested uniforms by name
                 *
                 *
                 * Methods of all nodes except the top-level container:
                 *
                 * .setValue( gl, value, [textures] )
                 *
                 * 		uploads a uniform value(s)
                 *  	the 'textures' parameter is needed for sampler uniforms
                 *
                 *
                 * Static methods of the top-level container (textures factorizations):
                 *
                 * .upload( gl, seq, values, textures )
                 *
                 * 		sets uniforms in 'seq' to 'values[id].value'
                 *
                 * .seqWithValue( seq, values ) : filteredSeq
                 *
                 * 		filters 'seq' entries with corresponding entry in values
                 *
                 *
                 * Methods of the top-level container (textures factorizations):
                 *
                 * .setValue( gl, name, value, textures )
                 *
                 * 		sets uniform with  name 'name' to 'value'
                 *
                 * .setOptional( gl, obj, prop )
                 *
                 * 		like .set for an optional property of the object
                 *
                 */
                var emptyTexture = new Texture();
                var emptyArrayTexture = new DataArrayTexture();
                var empty3dTexture = new Data3DTexture();
                var emptyCubeTexture = new CubeTexture();
                // --- Utilities ---
                // Array Caches (provide typed arrays for temporary by size)
                var arrayCacheF32 = [];
                var arrayCacheI32 = [];
                // Float32Array caches used for uploading Matrix uniforms
                var mat4array = new Float32Array(16);
                var mat3array = new Float32Array(9);
                var mat2array = new Float32Array(4);
                // Flattening for arrays of vectors and matrices
                function flatten(array, nBlocks, blockSize) {
                    var firstElem = array[0];
                    if (firstElem <= 0 || firstElem > 0)
                        return array;
                    // unoptimized: ! isNaN( firstElem )
                    // see http://jacksondunstan.com/articles/983
                    var n = nBlocks * blockSize;
                    var r = arrayCacheF32[n];
                    if (r === undefined) {
                        r = new Float32Array(n);
                        arrayCacheF32[n] = r;
                    }
                    if (nBlocks !== 0) {
                        firstElem.toArray(r, 0);
                        for (var i = 1, offset = 0; i !== nBlocks; ++i) {
                            offset += blockSize;
                            array[i].toArray(r, offset);
                        }
                    }
                    return r;
                }

                function arraysEqual(a, b) {
                    if (a.length !== b.length)
                        return false;
                    for (var i = 0, l = a.length; i < l; i++) {
                        if (a[i] !== b[i])
                            return false;
                    }
                    return true;
                }

                function copyArray(a, b) {
                    for (var i = 0, l = b.length; i < l; i++) {
                        a[i] = b[i];
                    }
                }
                // Texture unit allocation
                function allocTexUnits(textures, n) {
                    var r = arrayCacheI32[n];
                    if (r === undefined) {
                        r = new Int32Array(n);
                        arrayCacheI32[n] = r;
                    }
                    for (var i = 0; i !== n; ++i) {
                        r[i] = textures.allocateTextureUnit();
                    }
                    return r;
                }
                // --- Setters ---
                // Note: Defining these methods externally, because they come in a bunch
                // and this way their names minify.
                // Single scalar
                function setValueV1f(gl, v) {
                    var cache = this.cache;
                    if (cache[0] === v)
                        return;
                    gl.uniform1f(this.addr, v);
                    cache[0] = v;
                }
                // Single float vector (from flat array or THREE.VectorN)
                function setValueV2f(gl, v) {
                    var cache = this.cache;
                    if (v.x !== undefined) {
                        if (cache[0] !== v.x || cache[1] !== v.y) {
                            gl.uniform2f(this.addr, v.x, v.y);
                            cache[0] = v.x;
                            cache[1] = v.y;
                        }
                    } else {
                        if (arraysEqual(cache, v))
                            return;
                        gl.uniform2fv(this.addr, v);
                        copyArray(cache, v);
                    }
                }

                function setValueV3f(gl, v) {
                    var cache = this.cache;
                    if (v.x !== undefined) {
                        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
                            gl.uniform3f(this.addr, v.x, v.y, v.z);
                            cache[0] = v.x;
                            cache[1] = v.y;
                            cache[2] = v.z;
                        }
                    } else if (v.r !== undefined) {
                        if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
                            gl.uniform3f(this.addr, v.r, v.g, v.b);
                            cache[0] = v.r;
                            cache[1] = v.g;
                            cache[2] = v.b;
                        }
                    } else {
                        if (arraysEqual(cache, v))
                            return;
                        gl.uniform3fv(this.addr, v);
                        copyArray(cache, v);
                    }
                }

                function setValueV4f(gl, v) {
                    var cache = this.cache;
                    if (v.x !== undefined) {
                        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
                            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
                            cache[0] = v.x;
                            cache[1] = v.y;
                            cache[2] = v.z;
                            cache[3] = v.w;
                        }
                    } else {
                        if (arraysEqual(cache, v))
                            return;
                        gl.uniform4fv(this.addr, v);
                        copyArray(cache, v);
                    }
                }
                // Single matrix (from flat array or THREE.MatrixN)
                function setValueM2(gl, v) {
                    var cache = this.cache;
                    var elements = v.elements;
                    if (elements === undefined) {
                        if (arraysEqual(cache, v))
                            return;
                        gl.uniformMatrix2fv(this.addr, false, v);
                        copyArray(cache, v);
                    } else {
                        if (arraysEqual(cache, elements))
                            return;
                        mat2array.set(elements);
                        gl.uniformMatrix2fv(this.addr, false, mat2array);
                        copyArray(cache, elements);
                    }
                }

                function setValueM3(gl, v) {
                    var cache = this.cache;
                    var elements = v.elements;
                    if (elements === undefined) {
                        if (arraysEqual(cache, v))
                            return;
                        gl.uniformMatrix3fv(this.addr, false, v);
                        copyArray(cache, v);
                    } else {
                        if (arraysEqual(cache, elements))
                            return;
                        mat3array.set(elements);
                        gl.uniformMatrix3fv(this.addr, false, mat3array);
                        copyArray(cache, elements);
                    }
                }

                function setValueM4(gl, v) {
                    var cache = this.cache;
                    var elements = v.elements;
                    if (elements === undefined) {
                        if (arraysEqual(cache, v))
                            return;
                        gl.uniformMatrix4fv(this.addr, false, v);
                        copyArray(cache, v);
                    } else {
                        if (arraysEqual(cache, elements))
                            return;
                        mat4array.set(elements);
                        gl.uniformMatrix4fv(this.addr, false, mat4array);
                        copyArray(cache, elements);
                    }
                }
                // Single integer / boolean
                function setValueV1i(gl, v) {
                    var cache = this.cache;
                    if (cache[0] === v)
                        return;
                    gl.uniform1i(this.addr, v);
                    cache[0] = v;
                }
                // Single integer / boolean vector (from flat array)
                function setValueV2i(gl, v) {
                    var cache = this.cache;
                    if (arraysEqual(cache, v))
                        return;
                    gl.uniform2iv(this.addr, v);
                    copyArray(cache, v);
                }

                function setValueV3i(gl, v) {
                    var cache = this.cache;
                    if (arraysEqual(cache, v))
                        return;
                    gl.uniform3iv(this.addr, v);
                    copyArray(cache, v);
                }

                function setValueV4i(gl, v) {
                    var cache = this.cache;
                    if (arraysEqual(cache, v))
                        return;
                    gl.uniform4iv(this.addr, v);
                    copyArray(cache, v);
                }
                // Single unsigned integer
                function setValueV1ui(gl, v) {
                    var cache = this.cache;
                    if (cache[0] === v)
                        return;
                    gl.uniform1ui(this.addr, v);
                    cache[0] = v;
                }
                // Single unsigned integer vector (from flat array)
                function setValueV2ui(gl, v) {
                    var cache = this.cache;
                    if (arraysEqual(cache, v))
                        return;
                    gl.uniform2uiv(this.addr, v);
                    copyArray(cache, v);
                }

                function setValueV3ui(gl, v) {
                    var cache = this.cache;
                    if (arraysEqual(cache, v))
                        return;
                    gl.uniform3uiv(this.addr, v);
                    copyArray(cache, v);
                }

                function setValueV4ui(gl, v) {
                    var cache = this.cache;
                    if (arraysEqual(cache, v))
                        return;
                    gl.uniform4uiv(this.addr, v);
                    copyArray(cache, v);
                }
                // Single texture (2D / Cube)
                function setValueT1(gl, v, textures) {
                    var cache = this.cache;
                    var unit = textures.allocateTextureUnit();
                    if (cache[0] !== unit) {
                        gl.uniform1i(this.addr, unit);
                        cache[0] = unit;
                    }
                    textures.setTexture2D(v || emptyTexture, unit);
                }

                function setValueT3D1(gl, v, textures) {
                    var cache = this.cache;
                    var unit = textures.allocateTextureUnit();
                    if (cache[0] !== unit) {
                        gl.uniform1i(this.addr, unit);
                        cache[0] = unit;
                    }
                    textures.setTexture3D(v || empty3dTexture, unit);
                }

                function setValueT6(gl, v, textures) {
                    var cache = this.cache;
                    var unit = textures.allocateTextureUnit();
                    if (cache[0] !== unit) {
                        gl.uniform1i(this.addr, unit);
                        cache[0] = unit;
                    }
                    textures.setTextureCube(v || emptyCubeTexture, unit);
                }

                function setValueT2DArray1(gl, v, textures) {
                    var cache = this.cache;
                    var unit = textures.allocateTextureUnit();
                    if (cache[0] !== unit) {
                        gl.uniform1i(this.addr, unit);
                        cache[0] = unit;
                    }
                    textures.setTexture2DArray(v || emptyArrayTexture, unit);
                }
                // Helper to pick the right setter for the singular case
                function getSingularSetter(type) {
                    switch (type) {
                        case 0x1406:
                            return setValueV1f; // FLOAT
                        case 0x8b50:
                            return setValueV2f; // _VEC2
                        case 0x8b51:
                            return setValueV3f; // _VEC3
                        case 0x8b52:
                            return setValueV4f; // _VEC4
                        case 0x8b5a:
                            return setValueM2; // _MAT2
                        case 0x8b5b:
                            return setValueM3; // _MAT3
                        case 0x8b5c:
                            return setValueM4; // _MAT4
                        case 0x1404:
                        case 0x8b56:
                            return setValueV1i; // INT, BOOL
                        case 0x8b53:
                        case 0x8b57:
                            return setValueV2i; // _VEC2
                        case 0x8b54:
                        case 0x8b58:
                            return setValueV3i; // _VEC3
                        case 0x8b55:
                        case 0x8b59:
                            return setValueV4i; // _VEC4
                        case 0x1405:
                            return setValueV1ui; // UINT
                        case 0x8dc6:
                            return setValueV2ui; // _VEC2
                        case 0x8dc7:
                            return setValueV3ui; // _VEC3
                        case 0x8dc8:
                            return setValueV4ui; // _VEC4
                        case 0x8b5e: // SAMPLER_2D
                        case 0x8d66: // SAMPLER_EXTERNAL_OES
                        case 0x8dca: // INT_SAMPLER_2D
                        case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
                        case 0x8b62: // SAMPLER_2D_SHADOW
                            return setValueT1;
                        case 0x8b5f: // SAMPLER_3D
                        case 0x8dcb: // INT_SAMPLER_3D
                        case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
                            return setValueT3D1;
                        case 0x8b60: // SAMPLER_CUBE
                        case 0x8dcc: // INT_SAMPLER_CUBE
                        case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
                        case 0x8dc5: // SAMPLER_CUBE_SHADOW
                            return setValueT6;
                        case 0x8dc1: // SAMPLER_2D_ARRAY
                        case 0x8dcf: // INT_SAMPLER_2D_ARRAY
                        case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
                        case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
                            return setValueT2DArray1;
                    }
                }
                // Array of scalars
                function setValueV1fArray(gl, v) {
                    gl.uniform1fv(this.addr, v);
                }
                // Array of vectors (from flat array or array of THREE.VectorN)
                function setValueV2fArray(gl, v) {
                    var data = flatten(v, this.size, 2);
                    gl.uniform2fv(this.addr, data);
                }

                function setValueV3fArray(gl, v) {
                    var data = flatten(v, this.size, 3);
                    gl.uniform3fv(this.addr, data);
                }

                function setValueV4fArray(gl, v) {
                    var data = flatten(v, this.size, 4);
                    gl.uniform4fv(this.addr, data);
                }
                // Array of matrices (from flat array or array of THREE.MatrixN)
                function setValueM2Array(gl, v) {
                    var data = flatten(v, this.size, 4);
                    gl.uniformMatrix2fv(this.addr, false, data);
                }

                function setValueM3Array(gl, v) {
                    var data = flatten(v, this.size, 9);
                    gl.uniformMatrix3fv(this.addr, false, data);
                }

                function setValueM4Array(gl, v) {
                    var data = flatten(v, this.size, 16);
                    gl.uniformMatrix4fv(this.addr, false, data);
                }
                // Array of integer / boolean
                function setValueV1iArray(gl, v) {
                    gl.uniform1iv(this.addr, v);
                }
                // Array of integer / boolean vectors (from flat array)
                function setValueV2iArray(gl, v) {
                    gl.uniform2iv(this.addr, v);
                }

                function setValueV3iArray(gl, v) {
                    gl.uniform3iv(this.addr, v);
                }

                function setValueV4iArray(gl, v) {
                    gl.uniform4iv(this.addr, v);
                }
                // Array of unsigned integer
                function setValueV1uiArray(gl, v) {
                    gl.uniform1uiv(this.addr, v);
                }
                // Array of unsigned integer vectors (from flat array)
                function setValueV2uiArray(gl, v) {
                    gl.uniform2uiv(this.addr, v);
                }

                function setValueV3uiArray(gl, v) {
                    gl.uniform3uiv(this.addr, v);
                }

                function setValueV4uiArray(gl, v) {
                    gl.uniform4uiv(this.addr, v);
                }
                // Array of textures (2D / 3D / Cube / 2DArray)
                function setValueT1Array(gl, v, textures) {
                    var n = v.length;
                    var units = allocTexUnits(textures, n);
                    gl.uniform1iv(this.addr, units);
                    for (var i = 0; i !== n; ++i) {
                        textures.setTexture2D(v[i] || emptyTexture, units[i]);
                    }
                }

                function setValueT3DArray(gl, v, textures) {
                    var n = v.length;
                    var units = allocTexUnits(textures, n);
                    gl.uniform1iv(this.addr, units);
                    for (var i = 0; i !== n; ++i) {
                        textures.setTexture3D(v[i] || empty3dTexture, units[i]);
                    }
                }

                function setValueT6Array(gl, v, textures) {
                    var n = v.length;
                    var units = allocTexUnits(textures, n);
                    gl.uniform1iv(this.addr, units);
                    for (var i = 0; i !== n; ++i) {
                        textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
                    }
                }

                function setValueT2DArrayArray(gl, v, textures) {
                    var n = v.length;
                    var units = allocTexUnits(textures, n);
                    gl.uniform1iv(this.addr, units);
                    for (var i = 0; i !== n; ++i) {
                        textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
                    }
                }
                // Helper to pick the right setter for a pure (bottom-level) array
                function getPureArraySetter(type) {
                    switch (type) {
                        case 0x1406:
                            return setValueV1fArray; // FLOAT
                        case 0x8b50:
                            return setValueV2fArray; // _VEC2
                        case 0x8b51:
                            return setValueV3fArray; // _VEC3
                        case 0x8b52:
                            return setValueV4fArray; // _VEC4
                        case 0x8b5a:
                            return setValueM2Array; // _MAT2
                        case 0x8b5b:
                            return setValueM3Array; // _MAT3
                        case 0x8b5c:
                            return setValueM4Array; // _MAT4
                        case 0x1404:
                        case 0x8b56:
                            return setValueV1iArray; // INT, BOOL
                        case 0x8b53:
                        case 0x8b57:
                            return setValueV2iArray; // _VEC2
                        case 0x8b54:
                        case 0x8b58:
                            return setValueV3iArray; // _VEC3
                        case 0x8b55:
                        case 0x8b59:
                            return setValueV4iArray; // _VEC4
                        case 0x1405:
                            return setValueV1uiArray; // UINT
                        case 0x8dc6:
                            return setValueV2uiArray; // _VEC2
                        case 0x8dc7:
                            return setValueV3uiArray; // _VEC3
                        case 0x8dc8:
                            return setValueV4uiArray; // _VEC4
                        case 0x8b5e: // SAMPLER_2D
                        case 0x8d66: // SAMPLER_EXTERNAL_OES
                        case 0x8dca: // INT_SAMPLER_2D
                        case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
                        case 0x8b62: // SAMPLER_2D_SHADOW
                            return setValueT1Array;
                        case 0x8b5f: // SAMPLER_3D
                        case 0x8dcb: // INT_SAMPLER_3D
                        case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
                            return setValueT3DArray;
                        case 0x8b60: // SAMPLER_CUBE
                        case 0x8dcc: // INT_SAMPLER_CUBE
                        case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
                        case 0x8dc5: // SAMPLER_CUBE_SHADOW
                            return setValueT6Array;
                        case 0x8dc1: // SAMPLER_2D_ARRAY
                        case 0x8dcf: // INT_SAMPLER_2D_ARRAY
                        case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
                        case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
                            return setValueT2DArrayArray;
                    }
                }
                // --- Uniform Classes ---
                function SingleUniform(id, activeInfo, addr) {
                    this.id = id;
                    this.addr = addr;
                    this.cache = [];
                    this.setValue = getSingularSetter(activeInfo.type);
                    // this.path = activeInfo.name; // DEBUG
                }

                function PureArrayUniform(id, activeInfo, addr) {
                    this.id = id;
                    this.addr = addr;
                    this.cache = [];
                    this.size = activeInfo.size;
                    this.setValue = getPureArraySetter(activeInfo.type);
                    // this.path = activeInfo.name; // DEBUG
                }
                PureArrayUniform.prototype.updateCache = function(data) {
                    var cache = this.cache;
                    if (data instanceof Float32Array && cache.length !== data.length) {
                        this.cache = new Float32Array(data.length);
                    }
                    copyArray(cache, data);
                };

                function StructuredUniform(id) {
                    this.id = id;
                    this.seq = [];
                    this.map = {};
                }
                StructuredUniform.prototype.setValue = function(gl, value, textures) {
                    var seq = this.seq;
                    for (var i = 0, n = seq.length; i !== n; ++i) {
                        var u = seq[i];
                        u.setValue(gl, value[u.id], textures);
                    }
                };
                // --- Top-level ---
                // Parser - builds up the property tree from the path strings
                var RePathPart = /(\w+)(\])?(\[|\.)?/g;
                // extracts
                // 	- the identifier (member name or array index)
                //  - followed by an optional right bracket (found when array index)
                //  - followed by an optional left bracket or dot (type of subscript)
                //
                // Note: These portions can be read in a non-overlapping fashion and
                // allow straightforward parsing of the hierarchy that WebGL encodes
                // in the uniform names.
                function addUniform(container, uniformObject) {
                    container.seq.push(uniformObject);
                    container.map[uniformObject.id] = uniformObject;
                }

                function parseUniform(activeInfo, addr, container) {
                    var path = activeInfo.name,
                        pathLength = path.length;
                    // reset RegExp object, because of the early exit of a previous run
                    RePathPart.lastIndex = 0;
                    while (true) {
                        var match = RePathPart.exec(path),
                            matchEnd = RePathPart.lastIndex;
                        var id = match[1];
                        var idIsIndex = match[2] === ']',
                            subscript = match[3];
                        if (idIsIndex)
                            id = id | 0; // convert to integer
                        if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
                            // bare name or "pure" bottom-level array "[0]" suffix
                            addUniform(container, subscript === undefined ?
                                new SingleUniform(id, activeInfo, addr) :
                                new PureArrayUniform(id, activeInfo, addr));
                            break;
                        } else {
                            // step into inner node / create it in case it doesn't exist
                            var map = container.map;
                            var next = map[id];
                            if (next === undefined) {
                                next = new StructuredUniform(id);
                                addUniform(container, next);
                            }
                            container = next;
                        }
                    }
                }
                // Root Container
                function WebGLUniforms(gl, program) {
                    this.seq = [];
                    this.map = {};
                    var n = gl.getProgramParameter(program, 35718);
                    for (var i = 0; i < n; ++i) {
                        var info = gl.getActiveUniform(program, i),
                            addr = gl.getUniformLocation(program, info.name);
                        parseUniform(info, addr, this);
                    }
                }
                WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
                    var u = this.map[name];
                    if (u !== undefined)
                        u.setValue(gl, value, textures);
                };
                WebGLUniforms.prototype.setOptional = function(gl, object, name) {
                    var v = object[name];
                    if (v !== undefined)
                        this.setValue(gl, name, v);
                };
                // Static interface
                WebGLUniforms.upload = function(gl, seq, values, textures) {
                    for (var i = 0, n = seq.length; i !== n; ++i) {
                        var u = seq[i],
                            v = values[u.id];
                        if (v.needsUpdate !== false) {
                            // note: always updating when .needsUpdate is undefined
                            u.setValue(gl, v.value, textures);
                        }
                    }
                };
                WebGLUniforms.seqWithValue = function(seq, values) {
                    var r = [];
                    for (var i = 0, n = seq.length; i !== n; ++i) {
                        var u = seq[i];
                        if (u.id in values)
                            r.push(u);
                    }
                    return r;
                };

                function WebGLShader(gl, type, string) {
                    var shader = gl.createShader(type);
                    gl.shaderSource(shader, string);
                    gl.compileShader(shader);
                    return shader;
                }
                var programIdCount = 0;

                function handleSource(string, errorLine) {
                    var lines = string.split('\n');
                    var lines2 = [];
                    var from = Math.max(errorLine - 6, 0);
                    var to = Math.min(errorLine + 6, lines.length);
                    for (var i = from; i < to; i++) {
                        lines2.push((i + 1) + ': ' + lines[i]);
                    }
                    return lines2.join('\n');
                }

                function getEncodingComponents(encoding) {
                    switch (encoding) {
                        case LinearEncoding:
                            return ['Linear', '( value )'];
                        case sRGBEncoding:
                            return ['sRGB', '( value )'];
                        default:
                            console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
                            return ['Linear', '( value )'];
                    }
                }

                function getShaderErrors(gl, shader, type) {
                    var status = gl.getShaderParameter(shader, 35713);
                    var errors = gl.getShaderInfoLog(shader).trim();
                    if (status && errors === '')
                        return '';
                    var errorLine = parseInt(/ERROR: 0:(\d+)/.exec(errors)[1]);
                    // --enable-privileged-webgl-extension
                    // console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
                    return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource(gl.getShaderSource(shader), errorLine);
                }

                function getTexelEncodingFunction(functionName, encoding) {
                    var components = getEncodingComponents(encoding);
                    return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
                }

                function getToneMappingFunction(functionName, toneMapping) {
                    var toneMappingName;
                    switch (toneMapping) {
                        case LinearToneMapping:
                            toneMappingName = 'Linear';
                            break;
                        case ReinhardToneMapping:
                            toneMappingName = 'Reinhard';
                            break;
                        case CineonToneMapping:
                            toneMappingName = 'OptimizedCineon';
                            break;
                        case ACESFilmicToneMapping:
                            toneMappingName = 'ACESFilmic';
                            break;
                        case CustomToneMapping:
                            toneMappingName = 'Custom';
                            break;
                        default:
                            console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
                            toneMappingName = 'Linear';
                    }
                    return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
                }

                function generateExtensions(parameters) {
                    var chunks = [
                        (parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical') ? '#extension GL_OES_standard_derivatives : enable' : '',
                        (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
                        (parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers) ? '#extension GL_EXT_draw_buffers : require' : '',
                        (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
                    ];
                    return chunks.filter(filterEmptyLine).join('\n');
                }

                function generateDefines(defines) {
                    var chunks = [];
                    for (var name in defines) {
                        var value = defines[name];
                        if (value === false)
                            continue;
                        chunks.push('#define ' + name + ' ' + value);
                    }
                    return chunks.join('\n');
                }

                function fetchAttributeLocations(gl, program) {
                    var attributes = {};
                    var n = gl.getProgramParameter(program, 35721);
                    for (var i = 0; i < n; i++) {
                        var info = gl.getActiveAttrib(program, i);
                        var name = info.name;
                        var locationSize = 1;
                        if (info.type === 35674)
                            locationSize = 2;
                        if (info.type === 35675)
                            locationSize = 3;
                        if (info.type === 35676)
                            locationSize = 4;
                        // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
                        attributes[name] = {
                            type: info.type,
                            location: gl.getAttribLocation(program, name),
                            locationSize: locationSize
                        };
                    }
                    return attributes;
                }

                function filterEmptyLine(string) {
                    return string !== '';
                }

                function replaceLightNums(string, parameters) {
                    return string
                        .replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)
                        .replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)
                        .replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights)
                        .replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)
                        .replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights)
                        .replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows)
                        .replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows)
                        .replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
                }

                function replaceClippingPlaneNums(string, parameters) {
                    return string
                        .replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes)
                        .replace(/UNION_CLIPPING_PLANES/g, (parameters.numClippingPlanes - parameters.numClipIntersection));
                }
                // Resolve Includes
                var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

                function resolveIncludes(string) {
                    return string.replace(includePattern, includeReplacer);
                }

                function includeReplacer(match, include) {
                    var string = ShaderChunk[include];
                    if (string === undefined) {
                        throw new Error('Can not resolve #include <' + include + '>');
                    }
                    return resolveIncludes(string);
                }
                // Unroll Loops
                var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
                var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

                function unrollLoops(string) {
                    return string
                        .replace(unrollLoopPattern, loopReplacer)
                        .replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
                }

                function deprecatedLoopReplacer(match, start, end, snippet) {
                    console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
                    return loopReplacer(match, start, end, snippet);
                }

                function loopReplacer(match, start, end, snippet) {
                    var string = '';
                    for (var i = parseInt(start); i < parseInt(end); i++) {
                        string += snippet
                            .replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]')
                            .replace(/UNROLLED_LOOP_INDEX/g, i);
                    }
                    return string;
                }
                //
                function generatePrecision(parameters) {
                    var precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';
                    if (parameters.precision === 'highp') {
                        precisionstring += '\n#define HIGH_PRECISION';
                    } else if (parameters.precision === 'mediump') {
                        precisionstring += '\n#define MEDIUM_PRECISION';
                    } else if (parameters.precision === 'lowp') {
                        precisionstring += '\n#define LOW_PRECISION';
                    }
                    return precisionstring;
                }

                function generateShadowMapTypeDefine(parameters) {
                    var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
                    if (parameters.shadowMapType === PCFShadowMap) {
                        shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
                    } else if (parameters.shadowMapType === PCFSoftShadowMap) {
                        shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
                    } else if (parameters.shadowMapType === VSMShadowMap) {
                        shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
                    }
                    return shadowMapTypeDefine;
                }

                function generateEnvMapTypeDefine(parameters) {
                    var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                    if (parameters.envMap) {
                        switch (parameters.envMapMode) {
                            case CubeReflectionMapping:
                            case CubeRefractionMapping:
                                envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                                break;
                            case CubeUVReflectionMapping:
                                envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
                                break;
                        }
                    }
                    return envMapTypeDefine;
                }

                function generateEnvMapModeDefine(parameters) {
                    var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
                    if (parameters.envMap) {
                        switch (parameters.envMapMode) {
                            case CubeRefractionMapping:
                                envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                                break;
                        }
                    }
                    return envMapModeDefine;
                }

                function generateEnvMapBlendingDefine(parameters) {
                    var envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
                    if (parameters.envMap) {
                        switch (parameters.combine) {
                            case MultiplyOperation:
                                envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                                break;
                            case MixOperation:
                                envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                                break;
                            case AddOperation:
                                envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                                break;
                        }
                    }
                    return envMapBlendingDefine;
                }

                function generateCubeUVSize(parameters) {
                    var imageHeight = parameters.envMapCubeUVHeight;
                    if (imageHeight === null)
                        return null;
                    var maxMip = Math.log2(imageHeight / 32 + 1) + 3;
                    var texelHeight = 1.0 / imageHeight;
                    var texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
                    return {
                        texelWidth: texelWidth,
                        texelHeight: texelHeight,
                        maxMip: maxMip
                    };
                }

                function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
                    // TODO Send this event to Three.js DevTools
                    // console.log( 'WebGLProgram', cacheKey );
                    var gl = renderer.getContext();
                    var defines = parameters.defines;
                    var vertexShader = parameters.vertexShader;
                    var fragmentShader = parameters.fragmentShader;
                    var shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
                    var envMapTypeDefine = generateEnvMapTypeDefine(parameters);
                    var envMapModeDefine = generateEnvMapModeDefine(parameters);
                    var envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
                    var envMapCubeUVSize = generateCubeUVSize(parameters);
                    var customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
                    var customDefines = generateDefines(defines);
                    var program = gl.createProgram();
                    var prefixVertex, prefixFragment;
                    var versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';
                    if (parameters.isRawShaderMaterial) {
                        prefixVertex = [
                            customDefines
                        ].filter(filterEmptyLine).join('\n');
                        if (prefixVertex.length > 0) {
                            prefixVertex += '\n';
                        }
                        prefixFragment = [
                            customExtensions,
                            customDefines
                        ].filter(filterEmptyLine).join('\n');
                        if (prefixFragment.length > 0) {
                            prefixFragment += '\n';
                        }
                    } else {
                        prefixVertex = [
                            generatePrecision(parameters),
                            '#define SHADER_NAME ' + parameters.shaderName,
                            customDefines,
                            parameters.instancing ? '#define USE_INSTANCING' : '',
                            parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
                            parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
                            '#define MAX_BONES ' + parameters.maxBones,
                            (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
                            (parameters.useFog && parameters.fogExp2) ? '#define FOG_EXP2' : '',
                            parameters.map ? '#define USE_MAP' : '',
                            parameters.envMap ? '#define USE_ENVMAP' : '',
                            parameters.envMap ? '#define ' + envMapModeDefine : '',
                            parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                            parameters.aoMap ? '#define USE_AOMAP' : '',
                            parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                            parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                            parameters.normalMap ? '#define USE_NORMALMAP' : '',
                            (parameters.normalMap && parameters.objectSpaceNormalMap) ? '#define OBJECTSPACE_NORMALMAP' : '',
                            (parameters.normalMap && parameters.tangentSpaceNormalMap) ? '#define TANGENTSPACE_NORMALMAP' : '',
                            parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
                            parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
                            parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
                            parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
                            parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                            parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
                            parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
                            parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                            parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
                            parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                            parameters.transmission ? '#define USE_TRANSMISSION' : '',
                            parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
                            parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',
                            parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
                            parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',
                            parameters.vertexTangents ? '#define USE_TANGENT' : '',
                            parameters.vertexColors ? '#define USE_COLOR' : '',
                            parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
                            parameters.vertexUvs ? '#define USE_UV' : '',
                            parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
                            parameters.flatShading ? '#define FLAT_SHADED' : '',
                            parameters.skinning ? '#define USE_SKINNING' : '',
                            parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
                            parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
                            parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
                            (parameters.morphColors && parameters.isWebGL2) ? '#define USE_MORPHCOLORS' : '',
                            (parameters.morphTargetsCount > 0 && parameters.isWebGL2) ? '#define MORPHTARGETS_TEXTURE' : '',
                            (parameters.morphTargetsCount > 0 && parameters.isWebGL2) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '',
                            (parameters.morphTargetsCount > 0 && parameters.isWebGL2) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '',
                            parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                            parameters.flipSided ? '#define FLIP_SIDED' : '',
                            parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                            parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                            parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
                            parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                            (parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth) ? '#define USE_LOGDEPTHBUF_EXT' : '',
                            'uniform mat4 modelMatrix;',
                            'uniform mat4 modelViewMatrix;',
                            'uniform mat4 projectionMatrix;',
                            'uniform mat4 viewMatrix;',
                            'uniform mat3 normalMatrix;',
                            'uniform vec3 cameraPosition;',
                            'uniform bool isOrthographic;',
                            '#ifdef USE_INSTANCING',
                            '	attribute mat4 instanceMatrix;',
                            '#endif',
                            '#ifdef USE_INSTANCING_COLOR',
                            '	attribute vec3 instanceColor;',
                            '#endif',
                            'attribute vec3 position;',
                            'attribute vec3 normal;',
                            'attribute vec2 uv;',
                            '#ifdef USE_TANGENT',
                            '	attribute vec4 tangent;',
                            '#endif',
                            '#if defined( USE_COLOR_ALPHA )',
                            '	attribute vec4 color;',
                            '#elif defined( USE_COLOR )',
                            '	attribute vec3 color;',
                            '#endif',
                            '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',
                            '	attribute vec3 morphTarget0;',
                            '	attribute vec3 morphTarget1;',
                            '	attribute vec3 morphTarget2;',
                            '	attribute vec3 morphTarget3;',
                            '	#ifdef USE_MORPHNORMALS',
                            '		attribute vec3 morphNormal0;',
                            '		attribute vec3 morphNormal1;',
                            '		attribute vec3 morphNormal2;',
                            '		attribute vec3 morphNormal3;',
                            '	#else',
                            '		attribute vec3 morphTarget4;',
                            '		attribute vec3 morphTarget5;',
                            '		attribute vec3 morphTarget6;',
                            '		attribute vec3 morphTarget7;',
                            '	#endif',
                            '#endif',
                            '#ifdef USE_SKINNING',
                            '	attribute vec4 skinIndex;',
                            '	attribute vec4 skinWeight;',
                            '#endif',
                            '\n'
                        ].filter(filterEmptyLine).join('\n');
                        prefixFragment = [
                            customExtensions,
                            generatePrecision(parameters),
                            '#define SHADER_NAME ' + parameters.shaderName,
                            customDefines,
                            (parameters.useFog && parameters.fog) ? '#define USE_FOG' : '',
                            (parameters.useFog && parameters.fogExp2) ? '#define FOG_EXP2' : '',
                            parameters.map ? '#define USE_MAP' : '',
                            parameters.matcap ? '#define USE_MATCAP' : '',
                            parameters.envMap ? '#define USE_ENVMAP' : '',
                            parameters.envMap ? '#define ' + envMapTypeDefine : '',
                            parameters.envMap ? '#define ' + envMapModeDefine : '',
                            parameters.envMap ? '#define ' + envMapBlendingDefine : '',
                            envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '',
                            envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '',
                            envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '',
                            parameters.lightMap ? '#define USE_LIGHTMAP' : '',
                            parameters.aoMap ? '#define USE_AOMAP' : '',
                            parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
                            parameters.bumpMap ? '#define USE_BUMPMAP' : '',
                            parameters.normalMap ? '#define USE_NORMALMAP' : '',
                            (parameters.normalMap && parameters.objectSpaceNormalMap) ? '#define OBJECTSPACE_NORMALMAP' : '',
                            (parameters.normalMap && parameters.tangentSpaceNormalMap) ? '#define TANGENTSPACE_NORMALMAP' : '',
                            parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
                            parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
                            parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
                            parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
                            parameters.specularMap ? '#define USE_SPECULARMAP' : '',
                            parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
                            parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
                            parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
                            parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
                            parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
                            parameters.alphaTest ? '#define USE_ALPHATEST' : '',
                            parameters.sheen ? '#define USE_SHEEN' : '',
                            parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
                            parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',
                            parameters.transmission ? '#define USE_TRANSMISSION' : '',
                            parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
                            parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',
                            parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
                            parameters.vertexTangents ? '#define USE_TANGENT' : '',
                            parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
                            parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
                            parameters.vertexUvs ? '#define USE_UV' : '',
                            parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
                            parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
                            parameters.flatShading ? '#define FLAT_SHADED' : '',
                            parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
                            parameters.flipSided ? '#define FLIP_SIDED' : '',
                            parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
                            parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
                            parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
                            parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
                            parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
                            (parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth) ? '#define USE_LOGDEPTHBUF_EXT' : '',
                            'uniform mat4 viewMatrix;',
                            'uniform vec3 cameraPosition;',
                            'uniform bool isOrthographic;',
                            (parameters.toneMapping !== NoToneMapping) ? '#define TONE_MAPPING' : '',
                            (parameters.toneMapping !== NoToneMapping) ? ShaderChunk['tonemapping_pars_fragment'] : '',
                            (parameters.toneMapping !== NoToneMapping) ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '',
                            parameters.dithering ? '#define DITHERING' : '',
                            parameters.opaque ? '#define OPAQUE' : '',
                            ShaderChunk['encodings_pars_fragment'],
                            getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding),
                            parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',
                            '\n'
                        ].filter(filterEmptyLine).join('\n');
                    }
                    vertexShader = resolveIncludes(vertexShader);
                    vertexShader = replaceLightNums(vertexShader, parameters);
                    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
                    fragmentShader = resolveIncludes(fragmentShader);
                    fragmentShader = replaceLightNums(fragmentShader, parameters);
                    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
                    vertexShader = unrollLoops(vertexShader);
                    fragmentShader = unrollLoops(fragmentShader);
                    if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
                        // GLSL 3.0 conversion for built-in materials and ShaderMaterial
                        versionString = '#version 300 es\n';
                        prefixVertex = [
                            'precision mediump sampler2DArray;',
                            '#define attribute in',
                            '#define varying out',
                            '#define texture2D texture'
                        ].join('\n') + '\n' + prefixVertex;
                        prefixFragment = [
                            '#define varying in',
                            (parameters.glslVersion === GLSL3) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;',
                            (parameters.glslVersion === GLSL3) ? '' : '#define gl_FragColor pc_fragColor',
                            '#define gl_FragDepthEXT gl_FragDepth',
                            '#define texture2D texture',
                            '#define textureCube texture',
                            '#define texture2DProj textureProj',
                            '#define texture2DLodEXT textureLod',
                            '#define texture2DProjLodEXT textureProjLod',
                            '#define textureCubeLodEXT textureLod',
                            '#define texture2DGradEXT textureGrad',
                            '#define texture2DProjGradEXT textureProjGrad',
                            '#define textureCubeGradEXT textureGrad'
                        ].join('\n') + '\n' + prefixFragment;
                    }
                    var vertexGlsl = versionString + prefixVertex + vertexShader;
                    var fragmentGlsl = versionString + prefixFragment + fragmentShader;
                    // console.log( '*VERTEX*', vertexGlsl );
                    // console.log( '*FRAGMENT*', fragmentGlsl );
                    var glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
                    var glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
                    gl.attachShader(program, glVertexShader);
                    gl.attachShader(program, glFragmentShader);
                    // Force a particular attribute to index 0.
                    if (parameters.index0AttributeName !== undefined) {
                        gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
                    } else if (parameters.morphTargets === true) {
                        // programs with morphTargets displace position out of attribute 0
                        gl.bindAttribLocation(program, 0, 'position');
                    }
                    gl.linkProgram(program);
                    // check for link errors
                    if (renderer.debug.checkShaderErrors) {
                        var programLog = gl.getProgramInfoLog(program).trim();
                        var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
                        var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
                        var runnable = true;
                        var haveDiagnostics = true;
                        if (gl.getProgramParameter(program, 35714) === false) {
                            runnable = false;
                            var vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
                            var fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
                            console.error('THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' +
                                'VALIDATE_STATUS ' + gl.getProgramParameter(program, 35715) + '\n\n' +
                                'Program Info Log: ' + programLog + '\n' +
                                vertexErrors + '\n' +
                                fragmentErrors);
                        } else if (programLog !== '') {
                            console.warn('THREE.WebGLProgram: Program Info Log:', programLog);
                        } else if (vertexLog === '' || fragmentLog === '') {
                            haveDiagnostics = false;
                        }
                        if (haveDiagnostics) {
                            this.diagnostics = {
                                runnable: runnable,
                                programLog: programLog,
                                vertexShader: {
                                    log: vertexLog,
                                    prefix: prefixVertex
                                },
                                fragmentShader: {
                                    log: fragmentLog,
                                    prefix: prefixFragment
                                }
                            };
                        }
                    }
                    // Clean up
                    // Crashes in iOS9 and iOS10. #18402
                    // gl.detachShader( program, glVertexShader );
                    // gl.detachShader( program, glFragmentShader );
                    gl.deleteShader(glVertexShader);
                    gl.deleteShader(glFragmentShader);
                    // set up caching for uniform locations
                    var cachedUniforms;
                    this.getUniforms = function() {
                        if (cachedUniforms === undefined) {
                            cachedUniforms = new WebGLUniforms(gl, program);
                        }
                        return cachedUniforms;
                    };
                    // set up caching for attribute locations
                    var cachedAttributes;
                    this.getAttributes = function() {
                        if (cachedAttributes === undefined) {
                            cachedAttributes = fetchAttributeLocations(gl, program);
                        }
                        return cachedAttributes;
                    };
                    // free resource
                    this.destroy = function() {
                        bindingStates.releaseStatesOfProgram(this);
                        gl.deleteProgram(program);
                        this.program = undefined;
                    };
                    //
                    this.name = parameters.shaderName;
                    this.id = programIdCount++;
                    this.cacheKey = cacheKey;
                    this.usedTimes = 1;
                    this.program = program;
                    this.vertexShader = glVertexShader;
                    this.fragmentShader = glFragmentShader;
                    return this;
                }
                var _id = 0;
                var WebGLShaderCache = /** @class */ (function() {
                    function WebGLShaderCache() {
                        this.shaderCache = new Map();
                        this.materialCache = new Map();
                    }
                    WebGLShaderCache.prototype.update = function(material) {
                        var vertexShader = material.vertexShader;
                        var fragmentShader = material.fragmentShader;
                        var vertexShaderStage = this._getShaderStage(vertexShader);
                        var fragmentShaderStage = this._getShaderStage(fragmentShader);
                        var materialShaders = this._getShaderCacheForMaterial(material);
                        if (materialShaders.has(vertexShaderStage) === false) {
                            materialShaders.add(vertexShaderStage);
                            vertexShaderStage.usedTimes++;
                        }
                        if (materialShaders.has(fragmentShaderStage) === false) {
                            materialShaders.add(fragmentShaderStage);
                            fragmentShaderStage.usedTimes++;
                        }
                        return this;
                    };
                    WebGLShaderCache.prototype.remove = function(material) {
                        var e_1, _a;
                        var materialShaders = this.materialCache.get(material);
                        try {
                            for (var materialShaders_1 = __values(materialShaders), materialShaders_1_1 = materialShaders_1.next(); !materialShaders_1_1.done; materialShaders_1_1 = materialShaders_1.next()) {
                                var shaderStage = materialShaders_1_1.value;
                                shaderStage.usedTimes--;
                                if (shaderStage.usedTimes === 0)
                                    this.shaderCache.delete(shaderStage.code);
                            }
                        } catch (e_1_1) {
                            e_1 = {
                                error: e_1_1
                            };
                        } finally {
                            try {
                                if (materialShaders_1_1 && !materialShaders_1_1.done && (_a = materialShaders_1.return)) _a.call(materialShaders_1);
                            } finally {
                                if (e_1) throw e_1.error;
                            }
                        }
                        this.materialCache.delete(material);
                        return this;
                    };
                    WebGLShaderCache.prototype.getVertexShaderID = function(material) {
                        return this._getShaderStage(material.vertexShader).id;
                    };
                    WebGLShaderCache.prototype.getFragmentShaderID = function(material) {
                        return this._getShaderStage(material.fragmentShader).id;
                    };
                    WebGLShaderCache.prototype.dispose = function() {
                        this.shaderCache.clear();
                        this.materialCache.clear();
                    };
                    WebGLShaderCache.prototype._getShaderCacheForMaterial = function(material) {
                        var cache = this.materialCache;
                        if (cache.has(material) === false) {
                            cache.set(material, new Set());
                        }
                        return cache.get(material);
                    };
                    WebGLShaderCache.prototype._getShaderStage = function(code) {
                        var cache = this.shaderCache;
                        if (cache.has(code) === false) {
                            var stage = new WebGLShaderStage(code);
                            cache.set(code, stage);
                        }
                        return cache.get(code);
                    };
                    return WebGLShaderCache;
                }());
                var WebGLShaderStage = /** @class */ (function() {
                    function WebGLShaderStage(code) {
                        this.id = _id++;
                        this.code = code;
                        this.usedTimes = 0;
                    }
                    return WebGLShaderStage;
                }());

                function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
                    var _programLayers = new Layers();
                    var _customShaders = new WebGLShaderCache();
                    var programs = [];
                    var isWebGL2 = capabilities.isWebGL2;
                    var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
                    var floatVertexTextures = capabilities.floatVertexTextures;
                    var maxVertexUniforms = capabilities.maxVertexUniforms;
                    var vertexTextures = capabilities.vertexTextures;
                    var precision = capabilities.precision;
                    var shaderIDs = {
                        MeshDepthMaterial: 'depth',
                        MeshDistanceMaterial: 'distanceRGBA',
                        MeshNormalMaterial: 'normal',
                        MeshBasicMaterial: 'basic',
                        MeshLambertMaterial: 'lambert',
                        MeshPhongMaterial: 'phong',
                        MeshToonMaterial: 'toon',
                        MeshStandardMaterial: 'physical',
                        MeshPhysicalMaterial: 'physical',
                        MeshMatcapMaterial: 'matcap',
                        LineBasicMaterial: 'basic',
                        LineDashedMaterial: 'dashed',
                        PointsMaterial: 'points',
                        ShadowMaterial: 'shadow',
                        SpriteMaterial: 'sprite'
                    };

                    function getMaxBones(object) {
                        var skeleton = object.skeleton;
                        var bones = skeleton.bones;
                        if (floatVertexTextures) {
                            return 1024;
                        } else {
                            // default for when object is not specified
                            // ( for example when prebuilding shader to be used with multiple objects )
                            //
                            //  - leave some extra space for other uniforms
                            //  - limit here is ANGLE's 254 max uniform vectors
                            //    (up to 54 should be safe)
                            var nVertexUniforms = maxVertexUniforms;
                            var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
                            var maxBones = Math.min(nVertexMatrices, bones.length);
                            if (maxBones < bones.length) {
                                console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
                                return 0;
                            }
                            return maxBones;
                        }
                    }

                    function getParameters(material, lights, shadows, scene, object) {
                        var fog = scene.fog;
                        var geometry = object.geometry;
                        var environment = material.isMeshStandardMaterial ? scene.environment : null;
                        var envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
                        var envMapCubeUVHeight = (!!envMap) && (envMap.mapping === CubeUVReflectionMapping) ? envMap.image.height : null;
                        var shaderID = shaderIDs[material.type];
                        // heuristics to create shader parameters according to lights in the scene
                        // (not to blow over maxLights budget)
                        var maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
                        if (material.precision !== null) {
                            precision = capabilities.getMaxPrecision(material.precision);
                            if (precision !== material.precision) {
                                console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
                            }
                        }
                        //
                        var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
                        var morphTargetsCount = (morphAttribute !== undefined) ? morphAttribute.length : 0;
                        var morphTextureStride = 0;
                        if (geometry.morphAttributes.position !== undefined)
                            morphTextureStride = 1;
                        if (geometry.morphAttributes.normal !== undefined)
                            morphTextureStride = 2;
                        if (geometry.morphAttributes.color !== undefined)
                            morphTextureStride = 3;
                        //
                        var vertexShader, fragmentShader;
                        var customVertexShaderID, customFragmentShaderID;
                        if (shaderID) {
                            var shader = ShaderLib[shaderID];
                            vertexShader = shader.vertexShader;
                            fragmentShader = shader.fragmentShader;
                        } else {
                            vertexShader = material.vertexShader;
                            fragmentShader = material.fragmentShader;
                            _customShaders.update(material);
                            customVertexShaderID = _customShaders.getVertexShaderID(material);
                            customFragmentShaderID = _customShaders.getFragmentShaderID(material);
                        }
                        var currentRenderTarget = renderer.getRenderTarget();
                        var useAlphaTest = material.alphaTest > 0;
                        var useClearcoat = material.clearcoat > 0;
                        var parameters = {
                            isWebGL2: isWebGL2,
                            shaderID: shaderID,
                            shaderName: material.type,
                            vertexShader: vertexShader,
                            fragmentShader: fragmentShader,
                            defines: material.defines,
                            customVertexShaderID: customVertexShaderID,
                            customFragmentShaderID: customFragmentShaderID,
                            isRawShaderMaterial: material.isRawShaderMaterial === true,
                            glslVersion: material.glslVersion,
                            precision: precision,
                            instancing: object.isInstancedMesh === true,
                            instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
                            supportsVertexTextures: vertexTextures,
                            outputEncoding: (currentRenderTarget === null) ? renderer.outputEncoding : (currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding),
                            map: !!material.map,
                            matcap: !!material.matcap,
                            envMap: !!envMap,
                            envMapMode: envMap && envMap.mapping,
                            envMapCubeUVHeight: envMapCubeUVHeight,
                            lightMap: !!material.lightMap,
                            aoMap: !!material.aoMap,
                            emissiveMap: !!material.emissiveMap,
                            bumpMap: !!material.bumpMap,
                            normalMap: !!material.normalMap,
                            objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
                            tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
                            decodeVideoTexture: !!material.map && (material.map.isVideoTexture === true) && (material.map.encoding === sRGBEncoding),
                            clearcoat: useClearcoat,
                            clearcoatMap: useClearcoat && !!material.clearcoatMap,
                            clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
                            clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
                            displacementMap: !!material.displacementMap,
                            roughnessMap: !!material.roughnessMap,
                            metalnessMap: !!material.metalnessMap,
                            specularMap: !!material.specularMap,
                            specularIntensityMap: !!material.specularIntensityMap,
                            specularColorMap: !!material.specularColorMap,
                            opaque: material.transparent === false && material.blending === NormalBlending,
                            alphaMap: !!material.alphaMap,
                            alphaTest: useAlphaTest,
                            gradientMap: !!material.gradientMap,
                            sheen: material.sheen > 0,
                            sheenColorMap: !!material.sheenColorMap,
                            sheenRoughnessMap: !!material.sheenRoughnessMap,
                            transmission: material.transmission > 0,
                            transmissionMap: !!material.transmissionMap,
                            thicknessMap: !!material.thicknessMap,
                            combine: material.combine,
                            vertexTangents: (!!material.normalMap && !!geometry.attributes.tangent),
                            vertexColors: material.vertexColors,
                            vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
                            vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
                            uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
                            fog: !!fog,
                            useFog: material.fog,
                            fogExp2: (fog && fog.isFogExp2),
                            flatShading: !!material.flatShading,
                            sizeAttenuation: material.sizeAttenuation,
                            logarithmicDepthBuffer: logarithmicDepthBuffer,
                            skinning: object.isSkinnedMesh === true && maxBones > 0,
                            maxBones: maxBones,
                            useVertexTexture: floatVertexTextures,
                            morphTargets: geometry.morphAttributes.position !== undefined,
                            morphNormals: geometry.morphAttributes.normal !== undefined,
                            morphColors: geometry.morphAttributes.color !== undefined,
                            morphTargetsCount: morphTargetsCount,
                            morphTextureStride: morphTextureStride,
                            numDirLights: lights.directional.length,
                            numPointLights: lights.point.length,
                            numSpotLights: lights.spot.length,
                            numRectAreaLights: lights.rectArea.length,
                            numHemiLights: lights.hemi.length,
                            numDirLightShadows: lights.directionalShadowMap.length,
                            numPointLightShadows: lights.pointShadowMap.length,
                            numSpotLightShadows: lights.spotShadowMap.length,
                            numClippingPlanes: clipping.numPlanes,
                            numClipIntersection: clipping.numIntersection,
                            dithering: material.dithering,
                            shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
                            shadowMapType: renderer.shadowMap.type,
                            toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
                            physicallyCorrectLights: renderer.physicallyCorrectLights,
                            premultipliedAlpha: material.premultipliedAlpha,
                            doubleSided: material.side === DoubleSide,
                            flipSided: material.side === BackSide,
                            depthPacking: (material.depthPacking !== undefined) ? material.depthPacking : false,
                            index0AttributeName: material.index0AttributeName,
                            extensionDerivatives: material.extensions && material.extensions.derivatives,
                            extensionFragDepth: material.extensions && material.extensions.fragDepth,
                            extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
                            extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
                            rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
                            rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
                            rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
                            customProgramCacheKey: material.customProgramCacheKey()
                        };
                        return parameters;
                    }

                    function getProgramCacheKey(parameters) {
                        var array = [];
                        if (parameters.shaderID) {
                            array.push(parameters.shaderID);
                        } else {
                            array.push(parameters.customVertexShaderID);
                            array.push(parameters.customFragmentShaderID);
                        }
                        if (parameters.defines !== undefined) {
                            for (var name in parameters.defines) {
                                array.push(name);
                                array.push(parameters.defines[name]);
                            }
                        }
                        if (parameters.isRawShaderMaterial === false) {
                            getProgramCacheKeyParameters(array, parameters);
                            getProgramCacheKeyBooleans(array, parameters);
                            array.push(renderer.outputEncoding);
                        }
                        array.push(parameters.customProgramCacheKey);
                        return array.join();
                    }

                    function getProgramCacheKeyParameters(array, parameters) {
                        array.push(parameters.precision);
                        array.push(parameters.outputEncoding);
                        array.push(parameters.envMapMode);
                        array.push(parameters.envMapCubeUVHeight);
                        array.push(parameters.combine);
                        array.push(parameters.vertexUvs);
                        array.push(parameters.fogExp2);
                        array.push(parameters.sizeAttenuation);
                        array.push(parameters.maxBones);
                        array.push(parameters.morphTargetsCount);
                        array.push(parameters.morphAttributeCount);
                        array.push(parameters.numDirLights);
                        array.push(parameters.numPointLights);
                        array.push(parameters.numSpotLights);
                        array.push(parameters.numHemiLights);
                        array.push(parameters.numRectAreaLights);
                        array.push(parameters.numDirLightShadows);
                        array.push(parameters.numPointLightShadows);
                        array.push(parameters.numSpotLightShadows);
                        array.push(parameters.shadowMapType);
                        array.push(parameters.toneMapping);
                        array.push(parameters.numClippingPlanes);
                        array.push(parameters.numClipIntersection);
                    }

                    function getProgramCacheKeyBooleans(array, parameters) {
                        _programLayers.disableAll();
                        if (parameters.isWebGL2)
                            _programLayers.enable(0);
                        if (parameters.supportsVertexTextures)
                            _programLayers.enable(1);
                        if (parameters.instancing)
                            _programLayers.enable(2);
                        if (parameters.instancingColor)
                            _programLayers.enable(3);
                        if (parameters.map)
                            _programLayers.enable(4);
                        if (parameters.matcap)
                            _programLayers.enable(5);
                        if (parameters.envMap)
                            _programLayers.enable(6);
                        if (parameters.lightMap)
                            _programLayers.enable(7);
                        if (parameters.aoMap)
                            _programLayers.enable(8);
                        if (parameters.emissiveMap)
                            _programLayers.enable(9);
                        if (parameters.bumpMap)
                            _programLayers.enable(10);
                        if (parameters.normalMap)
                            _programLayers.enable(11);
                        if (parameters.objectSpaceNormalMap)
                            _programLayers.enable(12);
                        if (parameters.tangentSpaceNormalMap)
                            _programLayers.enable(13);
                        if (parameters.clearcoat)
                            _programLayers.enable(14);
                        if (parameters.clearcoatMap)
                            _programLayers.enable(15);
                        if (parameters.clearcoatRoughnessMap)
                            _programLayers.enable(16);
                        if (parameters.clearcoatNormalMap)
                            _programLayers.enable(17);
                        if (parameters.displacementMap)
                            _programLayers.enable(18);
                        if (parameters.specularMap)
                            _programLayers.enable(19);
                        if (parameters.roughnessMap)
                            _programLayers.enable(20);
                        if (parameters.metalnessMap)
                            _programLayers.enable(21);
                        if (parameters.gradientMap)
                            _programLayers.enable(22);
                        if (parameters.alphaMap)
                            _programLayers.enable(23);
                        if (parameters.alphaTest)
                            _programLayers.enable(24);
                        if (parameters.vertexColors)
                            _programLayers.enable(25);
                        if (parameters.vertexAlphas)
                            _programLayers.enable(26);
                        if (parameters.vertexUvs)
                            _programLayers.enable(27);
                        if (parameters.vertexTangents)
                            _programLayers.enable(28);
                        if (parameters.uvsVertexOnly)
                            _programLayers.enable(29);
                        if (parameters.fog)
                            _programLayers.enable(30);
                        array.push(_programLayers.mask);
                        _programLayers.disableAll();
                        if (parameters.useFog)
                            _programLayers.enable(0);
                        if (parameters.flatShading)
                            _programLayers.enable(1);
                        if (parameters.logarithmicDepthBuffer)
                            _programLayers.enable(2);
                        if (parameters.skinning)
                            _programLayers.enable(3);
                        if (parameters.useVertexTexture)
                            _programLayers.enable(4);
                        if (parameters.morphTargets)
                            _programLayers.enable(5);
                        if (parameters.morphNormals)
                            _programLayers.enable(6);
                        if (parameters.morphColors)
                            _programLayers.enable(7);
                        if (parameters.premultipliedAlpha)
                            _programLayers.enable(8);
                        if (parameters.shadowMapEnabled)
                            _programLayers.enable(9);
                        if (parameters.physicallyCorrectLights)
                            _programLayers.enable(10);
                        if (parameters.doubleSided)
                            _programLayers.enable(11);
                        if (parameters.flipSided)
                            _programLayers.enable(12);
                        if (parameters.depthPacking)
                            _programLayers.enable(13);
                        if (parameters.dithering)
                            _programLayers.enable(14);
                        if (parameters.specularIntensityMap)
                            _programLayers.enable(15);
                        if (parameters.specularColorMap)
                            _programLayers.enable(16);
                        if (parameters.transmission)
                            _programLayers.enable(17);
                        if (parameters.transmissionMap)
                            _programLayers.enable(18);
                        if (parameters.thicknessMap)
                            _programLayers.enable(19);
                        if (parameters.sheen)
                            _programLayers.enable(20);
                        if (parameters.sheenColorMap)
                            _programLayers.enable(21);
                        if (parameters.sheenRoughnessMap)
                            _programLayers.enable(22);
                        if (parameters.decodeVideoTexture)
                            _programLayers.enable(23);
                        if (parameters.opaque)
                            _programLayers.enable(24);
                        array.push(_programLayers.mask);
                    }

                    function getUniforms(material) {
                        var shaderID = shaderIDs[material.type];
                        var uniforms;
                        if (shaderID) {
                            var shader = ShaderLib[shaderID];
                            uniforms = UniformsUtils.clone(shader.uniforms);
                        } else {
                            uniforms = material.uniforms;
                        }
                        return uniforms;
                    }

                    function acquireProgram(parameters, cacheKey) {
                        var program;
                        // Check if code has been already compiled
                        for (var p = 0, pl = programs.length; p < pl; p++) {
                            var preexistingProgram = programs[p];
                            if (preexistingProgram.cacheKey === cacheKey) {
                                program = preexistingProgram;
                                ++program.usedTimes;
                                break;
                            }
                        }
                        if (program === undefined) {
                            program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
                            programs.push(program);
                        }
                        return program;
                    }

                    function releaseProgram(program) {
                        if (--program.usedTimes === 0) {
                            // Remove from unordered set
                            var i = programs.indexOf(program);
                            programs[i] = programs[programs.length - 1];
                            programs.pop();
                            // Free WebGL resources
                            program.destroy();
                        }
                    }

                    function releaseShaderCache(material) {
                        _customShaders.remove(material);
                    }

                    function dispose() {
                        _customShaders.dispose();
                    }
                    return {
                        getParameters: getParameters,
                        getProgramCacheKey: getProgramCacheKey,
                        getUniforms: getUniforms,
                        acquireProgram: acquireProgram,
                        releaseProgram: releaseProgram,
                        releaseShaderCache: releaseShaderCache,
                        // Exposed for resource monitoring & error feedback via renderer.info:
                        programs: programs,
                        dispose: dispose
                    };
                }

                function WebGLProperties() {
                    var properties = new WeakMap();

                    function get(object) {
                        var map = properties.get(object);
                        if (map === undefined) {
                            map = {};
                            properties.set(object, map);
                        }
                        return map;
                    }

                    function remove(object) {
                        properties.delete(object);
                    }

                    function update(object, key, value) {
                        properties.get(object)[key] = value;
                    }

                    function dispose() {
                        properties = new WeakMap();
                    }
                    return {
                        get: get,
                        remove: remove,
                        update: update,
                        dispose: dispose
                    };
                }

                function painterSortStable(a, b) {
                    if (a.groupOrder !== b.groupOrder) {
                        return a.groupOrder - b.groupOrder;
                    } else if (a.renderOrder !== b.renderOrder) {
                        return a.renderOrder - b.renderOrder;
                    } else if (a.material.id !== b.material.id) {
                        return a.material.id - b.material.id;
                    } else if (a.z !== b.z) {
                        return a.z - b.z;
                    } else {
                        return a.id - b.id;
                    }
                }

                function reversePainterSortStable(a, b) {
                    if (a.groupOrder !== b.groupOrder) {
                        return a.groupOrder - b.groupOrder;
                    } else if (a.renderOrder !== b.renderOrder) {
                        return a.renderOrder - b.renderOrder;
                    } else if (a.z !== b.z) {
                        return b.z - a.z;
                    } else {
                        return a.id - b.id;
                    }
                }

                function WebGLRenderList() {
                    var renderItems = [];
                    var renderItemsIndex = 0;
                    var opaque = [];
                    var transmissive = [];
                    var transparent = [];

                    function init() {
                        renderItemsIndex = 0;
                        opaque.length = 0;
                        transmissive.length = 0;
                        transparent.length = 0;
                    }

                    function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
                        var renderItem = renderItems[renderItemsIndex];
                        if (renderItem === undefined) {
                            renderItem = {
                                id: object.id,
                                object: object,
                                geometry: geometry,
                                material: material,
                                groupOrder: groupOrder,
                                renderOrder: object.renderOrder,
                                z: z,
                                group: group
                            };
                            renderItems[renderItemsIndex] = renderItem;
                        } else {
                            renderItem.id = object.id;
                            renderItem.object = object;
                            renderItem.geometry = geometry;
                            renderItem.material = material;
                            renderItem.groupOrder = groupOrder;
                            renderItem.renderOrder = object.renderOrder;
                            renderItem.z = z;
                            renderItem.group = group;
                        }
                        renderItemsIndex++;
                        return renderItem;
                    }

                    function push(object, geometry, material, groupOrder, z, group) {
                        var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
                        if (material.transmission > 0.0) {
                            transmissive.push(renderItem);
                        } else if (material.transparent === true) {
                            transparent.push(renderItem);
                        } else {
                            opaque.push(renderItem);
                        }
                    }

                    function unshift(object, geometry, material, groupOrder, z, group) {
                        var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
                        if (material.transmission > 0.0) {
                            transmissive.unshift(renderItem);
                        } else if (material.transparent === true) {
                            transparent.unshift(renderItem);
                        } else {
                            opaque.unshift(renderItem);
                        }
                    }

                    function sort(customOpaqueSort, customTransparentSort) {
                        if (opaque.length > 1)
                            opaque.sort(customOpaqueSort || painterSortStable);
                        if (transmissive.length > 1)
                            transmissive.sort(customTransparentSort || reversePainterSortStable);
                        if (transparent.length > 1)
                            transparent.sort(customTransparentSort || reversePainterSortStable);
                    }

                    function finish() {
                        // Clear references from inactive renderItems in the list
                        for (var i = renderItemsIndex, il = renderItems.length; i < il; i++) {
                            var renderItem = renderItems[i];
                            if (renderItem.id === null)
                                break;
                            renderItem.id = null;
                            renderItem.object = null;
                            renderItem.geometry = null;
                            renderItem.material = null;
                            renderItem.group = null;
                        }
                    }
                    return {
                        opaque: opaque,
                        transmissive: transmissive,
                        transparent: transparent,
                        init: init,
                        push: push,
                        unshift: unshift,
                        finish: finish,
                        sort: sort
                    };
                }

                function WebGLRenderLists() {
                    var lists = new WeakMap();

                    function get(scene, renderCallDepth) {
                        var list;
                        if (lists.has(scene) === false) {
                            list = new WebGLRenderList();
                            lists.set(scene, [list]);
                        } else {
                            if (renderCallDepth >= lists.get(scene).length) {
                                list = new WebGLRenderList();
                                lists.get(scene).push(list);
                            } else {
                                list = lists.get(scene)[renderCallDepth];
                            }
                        }
                        return list;
                    }

                    function dispose() {
                        lists = new WeakMap();
                    }
                    return {
                        get: get,
                        dispose: dispose
                    };
                }

                function UniformsCache() {
                    var lights = {};
                    return {
                        get: function(light) {
                            if (lights[light.id] !== undefined) {
                                return lights[light.id];
                            }
                            var uniforms;
                            switch (light.type) {
                                case 'DirectionalLight':
                                    uniforms = {
                                        direction: new Vector3(),
                                        color: new Color()
                                    };
                                    break;
                                case 'SpotLight':
                                    uniforms = {
                                        position: new Vector3(),
                                        direction: new Vector3(),
                                        color: new Color(),
                                        distance: 0,
                                        coneCos: 0,
                                        penumbraCos: 0,
                                        decay: 0
                                    };
                                    break;
                                case 'PointLight':
                                    uniforms = {
                                        position: new Vector3(),
                                        color: new Color(),
                                        distance: 0,
                                        decay: 0
                                    };
                                    break;
                                case 'HemisphereLight':
                                    uniforms = {
                                        direction: new Vector3(),
                                        skyColor: new Color(),
                                        groundColor: new Color()
                                    };
                                    break;
                                case 'RectAreaLight':
                                    uniforms = {
                                        color: new Color(),
                                        position: new Vector3(),
                                        halfWidth: new Vector3(),
                                        halfHeight: new Vector3()
                                    };
                                    break;
                            }
                            lights[light.id] = uniforms;
                            return uniforms;
                        }
                    };
                }

                function ShadowUniformsCache() {
                    var lights = {};
                    return {
                        get: function(light) {
                            if (lights[light.id] !== undefined) {
                                return lights[light.id];
                            }
                            var uniforms;
                            switch (light.type) {
                                case 'DirectionalLight':
                                    uniforms = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Vector2()
                                    };
                                    break;
                                case 'SpotLight':
                                    uniforms = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Vector2()
                                    };
                                    break;
                                case 'PointLight':
                                    uniforms = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Vector2(),
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1000
                                    };
                                    break;
                                    // TODO (abelnation): set RectAreaLight shadow uniforms
                            }
                            lights[light.id] = uniforms;
                            return uniforms;
                        }
                    };
                }
                var nextVersion = 0;

                function shadowCastingLightsFirst(lightA, lightB) {
                    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
                }

                function WebGLLights(extensions, capabilities) {
                    var cache = new UniformsCache();
                    var shadowCache = ShadowUniformsCache();
                    var state = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    };
                    for (var i = 0; i < 9; i++)
                        state.probe.push(new Vector3());
                    var vector3 = new Vector3();
                    var matrix4 = new Matrix4();
                    var matrix42 = new Matrix4();

                    function setup(lights, physicallyCorrectLights) {
                        var r = 0,
                            g = 0,
                            b = 0;
                        for (var i = 0; i < 9; i++)
                            state.probe[i].set(0, 0, 0);
                        var directionalLength = 0;
                        var pointLength = 0;
                        var spotLength = 0;
                        var rectAreaLength = 0;
                        var hemiLength = 0;
                        var numDirectionalShadows = 0;
                        var numPointShadows = 0;
                        var numSpotShadows = 0;
                        lights.sort(shadowCastingLightsFirst);
                        // artist-friendly light intensity scaling factor
                        var scaleFactor = (physicallyCorrectLights !== true) ? Math.PI : 1;
                        for (var i = 0, l = lights.length; i < l; i++) {
                            var light = lights[i];
                            var color = light.color;
                            var intensity = light.intensity;
                            var distance = light.distance;
                            var shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null;
                            if (light.isAmbientLight) {
                                r += color.r * intensity * scaleFactor;
                                g += color.g * intensity * scaleFactor;
                                b += color.b * intensity * scaleFactor;
                            } else if (light.isLightProbe) {
                                for (var j = 0; j < 9; j++) {
                                    state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
                                }
                            } else if (light.isDirectionalLight) {
                                var uniforms = cache.get(light);
                                uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
                                if (light.castShadow) {
                                    var shadow = light.shadow;
                                    var shadowUniforms = shadowCache.get(light);
                                    shadowUniforms.shadowBias = shadow.bias;
                                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                                    shadowUniforms.shadowRadius = shadow.radius;
                                    shadowUniforms.shadowMapSize = shadow.mapSize;
                                    state.directionalShadow[directionalLength] = shadowUniforms;
                                    state.directionalShadowMap[directionalLength] = shadowMap;
                                    state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                                    numDirectionalShadows++;
                                }
                                state.directional[directionalLength] = uniforms;
                                directionalLength++;
                            } else if (light.isSpotLight) {
                                var uniforms = cache.get(light);
                                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                                uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
                                uniforms.distance = distance;
                                uniforms.coneCos = Math.cos(light.angle);
                                uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                                uniforms.decay = light.decay;
                                if (light.castShadow) {
                                    var shadow = light.shadow;
                                    var shadowUniforms = shadowCache.get(light);
                                    shadowUniforms.shadowBias = shadow.bias;
                                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                                    shadowUniforms.shadowRadius = shadow.radius;
                                    shadowUniforms.shadowMapSize = shadow.mapSize;
                                    state.spotShadow[spotLength] = shadowUniforms;
                                    state.spotShadowMap[spotLength] = shadowMap;
                                    state.spotShadowMatrix[spotLength] = light.shadow.matrix;
                                    numSpotShadows++;
                                }
                                state.spot[spotLength] = uniforms;
                                spotLength++;
                            } else if (light.isRectAreaLight) {
                                var uniforms = cache.get(light);
                                // (a) intensity is the total visible light emitted
                                //uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
                                // (b) intensity is the brightness of the light
                                uniforms.color.copy(color).multiplyScalar(intensity);
                                uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                                uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
                                state.rectArea[rectAreaLength] = uniforms;
                                rectAreaLength++;
                            } else if (light.isPointLight) {
                                var uniforms = cache.get(light);
                                uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
                                uniforms.distance = light.distance;
                                uniforms.decay = light.decay;
                                if (light.castShadow) {
                                    var shadow = light.shadow;
                                    var shadowUniforms = shadowCache.get(light);
                                    shadowUniforms.shadowBias = shadow.bias;
                                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                                    shadowUniforms.shadowRadius = shadow.radius;
                                    shadowUniforms.shadowMapSize = shadow.mapSize;
                                    shadowUniforms.shadowCameraNear = shadow.camera.near;
                                    shadowUniforms.shadowCameraFar = shadow.camera.far;
                                    state.pointShadow[pointLength] = shadowUniforms;
                                    state.pointShadowMap[pointLength] = shadowMap;
                                    state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                                    numPointShadows++;
                                }
                                state.point[pointLength] = uniforms;
                                pointLength++;
                            } else if (light.isHemisphereLight) {
                                var uniforms = cache.get(light);
                                uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
                                uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
                                state.hemi[hemiLength] = uniforms;
                                hemiLength++;
                            }
                        }
                        if (rectAreaLength > 0) {
                            if (capabilities.isWebGL2) {
                                // WebGL 2
                                state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
                                state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
                            } else {
                                // WebGL 1
                                if (extensions.has('OES_texture_float_linear') === true) {
                                    state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
                                    state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
                                } else if (extensions.has('OES_texture_half_float_linear') === true) {
                                    state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
                                    state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
                                } else {
                                    console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
                                }
                            }
                        }
                        state.ambient[0] = r;
                        state.ambient[1] = g;
                        state.ambient[2] = b;
                        var hash = state.hash;
                        if (hash.directionalLength !== directionalLength ||
                            hash.pointLength !== pointLength ||
                            hash.spotLength !== spotLength ||
                            hash.rectAreaLength !== rectAreaLength ||
                            hash.hemiLength !== hemiLength ||
                            hash.numDirectionalShadows !== numDirectionalShadows ||
                            hash.numPointShadows !== numPointShadows ||
                            hash.numSpotShadows !== numSpotShadows) {
                            state.directional.length = directionalLength;
                            state.spot.length = spotLength;
                            state.rectArea.length = rectAreaLength;
                            state.point.length = pointLength;
                            state.hemi.length = hemiLength;
                            state.directionalShadow.length = numDirectionalShadows;
                            state.directionalShadowMap.length = numDirectionalShadows;
                            state.pointShadow.length = numPointShadows;
                            state.pointShadowMap.length = numPointShadows;
                            state.spotShadow.length = numSpotShadows;
                            state.spotShadowMap.length = numSpotShadows;
                            state.directionalShadowMatrix.length = numDirectionalShadows;
                            state.pointShadowMatrix.length = numPointShadows;
                            state.spotShadowMatrix.length = numSpotShadows;
                            hash.directionalLength = directionalLength;
                            hash.pointLength = pointLength;
                            hash.spotLength = spotLength;
                            hash.rectAreaLength = rectAreaLength;
                            hash.hemiLength = hemiLength;
                            hash.numDirectionalShadows = numDirectionalShadows;
                            hash.numPointShadows = numPointShadows;
                            hash.numSpotShadows = numSpotShadows;
                            state.version = nextVersion++;
                        }
                    }

                    function setupView(lights, camera) {
                        var directionalLength = 0;
                        var pointLength = 0;
                        var spotLength = 0;
                        var rectAreaLength = 0;
                        var hemiLength = 0;
                        var viewMatrix = camera.matrixWorldInverse;
                        for (var i = 0, l = lights.length; i < l; i++) {
                            var light = lights[i];
                            if (light.isDirectionalLight) {
                                var uniforms = state.directional[directionalLength];
                                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                                vector3.setFromMatrixPosition(light.target.matrixWorld);
                                uniforms.direction.sub(vector3);
                                uniforms.direction.transformDirection(viewMatrix);
                                directionalLength++;
                            } else if (light.isSpotLight) {
                                var uniforms = state.spot[spotLength];
                                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                                uniforms.position.applyMatrix4(viewMatrix);
                                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                                vector3.setFromMatrixPosition(light.target.matrixWorld);
                                uniforms.direction.sub(vector3);
                                uniforms.direction.transformDirection(viewMatrix);
                                spotLength++;
                            } else if (light.isRectAreaLight) {
                                var uniforms = state.rectArea[rectAreaLength];
                                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                                uniforms.position.applyMatrix4(viewMatrix);
                                // extract local rotation of light to derive width/height half vectors
                                matrix42.identity();
                                matrix4.copy(light.matrixWorld);
                                matrix4.premultiply(viewMatrix);
                                matrix42.extractRotation(matrix4);
                                uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                                uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
                                uniforms.halfWidth.applyMatrix4(matrix42);
                                uniforms.halfHeight.applyMatrix4(matrix42);
                                rectAreaLength++;
                            } else if (light.isPointLight) {
                                var uniforms = state.point[pointLength];
                                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                                uniforms.position.applyMatrix4(viewMatrix);
                                pointLength++;
                            } else if (light.isHemisphereLight) {
                                var uniforms = state.hemi[hemiLength];
                                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                                uniforms.direction.transformDirection(viewMatrix);
                                uniforms.direction.normalize();
                                hemiLength++;
                            }
                        }
                    }
                    return {
                        setup: setup,
                        setupView: setupView,
                        state: state
                    };
                }

                function WebGLRenderState(extensions, capabilities) {
                    var lights = new WebGLLights(extensions, capabilities);
                    var lightsArray = [];
                    var shadowsArray = [];

                    function init() {
                        lightsArray.length = 0;
                        shadowsArray.length = 0;
                    }

                    function pushLight(light) {
                        lightsArray.push(light);
                    }

                    function pushShadow(shadowLight) {
                        shadowsArray.push(shadowLight);
                    }

                    function setupLights(physicallyCorrectLights) {
                        lights.setup(lightsArray, physicallyCorrectLights);
                    }

                    function setupLightsView(camera) {
                        lights.setupView(lightsArray, camera);
                    }
                    var state = {
                        lightsArray: lightsArray,
                        shadowsArray: shadowsArray,
                        lights: lights
                    };
                    return {
                        init: init,
                        state: state,
                        setupLights: setupLights,
                        setupLightsView: setupLightsView,
                        pushLight: pushLight,
                        pushShadow: pushShadow
                    };
                }

                function WebGLRenderStates(extensions, capabilities) {
                    var renderStates = new WeakMap();

                    function get(scene, renderCallDepth) {
                        if (renderCallDepth === void 0) {
                            renderCallDepth = 0;
                        }
                        var renderState;
                        if (renderStates.has(scene) === false) {
                            renderState = new WebGLRenderState(extensions, capabilities);
                            renderStates.set(scene, [renderState]);
                        } else {
                            if (renderCallDepth >= renderStates.get(scene).length) {
                                renderState = new WebGLRenderState(extensions, capabilities);
                                renderStates.get(scene).push(renderState);
                            } else {
                                renderState = renderStates.get(scene)[renderCallDepth];
                            }
                        }
                        return renderState;
                    }

                    function dispose() {
                        renderStates = new WeakMap();
                    }
                    return {
                        get: get,
                        dispose: dispose
                    };
                }
                var MeshDepthMaterial = /** @class */ (function(_super) {
                    __extends(MeshDepthMaterial, _super);

                    function MeshDepthMaterial(parameters) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'MeshDepthMaterial';
                        _this_1.depthPacking = BasicDepthPacking;
                        _this_1.map = null;
                        _this_1.alphaMap = null;
                        _this_1.displacementMap = null;
                        _this_1.displacementScale = 1;
                        _this_1.displacementBias = 0;
                        _this_1.wireframe = false;
                        _this_1.wireframeLinewidth = 1;
                        _this_1.fog = false;
                        _this_1.setValues(parameters);
                        return _this_1;
                    }
                    MeshDepthMaterial.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.depthPacking = source.depthPacking;
                        this.map = source.map;
                        this.alphaMap = source.alphaMap;
                        this.displacementMap = source.displacementMap;
                        this.displacementScale = source.displacementScale;
                        this.displacementBias = source.displacementBias;
                        this.wireframe = source.wireframe;
                        this.wireframeLinewidth = source.wireframeLinewidth;
                        return this;
                    };
                    return MeshDepthMaterial;
                }(Material));
                MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
                var MeshDistanceMaterial = /** @class */ (function(_super) {
                    __extends(MeshDistanceMaterial, _super);

                    function MeshDistanceMaterial(parameters) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'MeshDistanceMaterial';
                        _this_1.referencePosition = new Vector3();
                        _this_1.nearDistance = 1;
                        _this_1.farDistance = 1000;
                        _this_1.map = null;
                        _this_1.alphaMap = null;
                        _this_1.displacementMap = null;
                        _this_1.displacementScale = 1;
                        _this_1.displacementBias = 0;
                        _this_1.fog = false;
                        _this_1.setValues(parameters);
                        return _this_1;
                    }
                    MeshDistanceMaterial.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.referencePosition.copy(source.referencePosition);
                        this.nearDistance = source.nearDistance;
                        this.farDistance = source.farDistance;
                        this.map = source.map;
                        this.alphaMap = source.alphaMap;
                        this.displacementMap = source.displacementMap;
                        this.displacementScale = source.displacementScale;
                        this.displacementBias = source.displacementBias;
                        return this;
                    };
                    return MeshDistanceMaterial;
                }(Material));
                MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
                var vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
                var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

                function WebGLShadowMap(_renderer, _objects, _capabilities) {
                    var _frustum = new Frustum();
                    var _shadowMapSize = new Vector2(),
                        _viewportSize = new Vector2(),
                        _viewport = new Vector4(),
                        _depthMaterial = new MeshDepthMaterial({
                            depthPacking: RGBADepthPacking
                        }),
                        _distanceMaterial = new MeshDistanceMaterial(),
                        _materialCache = {},
                        _maxTextureSize = _capabilities.maxTextureSize;
                    var shadowSide = {
                        0: BackSide,
                        1: FrontSide,
                        2: DoubleSide
                    };
                    var shadowMaterialVertical = new ShaderMaterial({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new Vector2()
                            },
                            radius: {
                                value: 4.0
                            }
                        },
                        vertexShader: vertex,
                        fragmentShader: fragment
                    });
                    var shadowMaterialHorizontal = shadowMaterialVertical.clone();
                    shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
                    var fullScreenTri = new BufferGeometry();
                    fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
                    var fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
                    var scope = this;
                    this.enabled = false;
                    this.autoUpdate = true;
                    this.needsUpdate = false;
                    this.type = PCFShadowMap;
                    this.render = function(lights, scene, camera) {
                        if (scope.enabled === false)
                            return;
                        if (scope.autoUpdate === false && scope.needsUpdate === false)
                            return;
                        if (lights.length === 0)
                            return;
                        var currentRenderTarget = _renderer.getRenderTarget();
                        var activeCubeFace = _renderer.getActiveCubeFace();
                        var activeMipmapLevel = _renderer.getActiveMipmapLevel();
                        var _state = _renderer.state;
                        // Set GL state for depth map.
                        _state.setBlending(NoBlending);
                        _state.buffers.color.setClear(1, 1, 1, 1);
                        _state.buffers.depth.setTest(true);
                        _state.setScissorTest(false);
                        // render depth map
                        for (var i = 0, il = lights.length; i < il; i++) {
                            var light = lights[i];
                            var shadow = light.shadow;
                            if (shadow === undefined) {
                                console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                                continue;
                            }
                            if (shadow.autoUpdate === false && shadow.needsUpdate === false)
                                continue;
                            _shadowMapSize.copy(shadow.mapSize);
                            var shadowFrameExtents = shadow.getFrameExtents();
                            _shadowMapSize.multiply(shadowFrameExtents);
                            _viewportSize.copy(shadow.mapSize);
                            if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
                                if (_shadowMapSize.x > _maxTextureSize) {
                                    _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
                                    _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                                    shadow.mapSize.x = _viewportSize.x;
                                }
                                if (_shadowMapSize.y > _maxTextureSize) {
                                    _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
                                    _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                                    shadow.mapSize.y = _viewportSize.y;
                                }
                            }
                            if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
                                shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
                                shadow.map.texture.name = light.name + '.shadowMap';
                                shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
                                shadow.camera.updateProjectionMatrix();
                            }
                            if (shadow.map === null) {
                                var pars = {
                                    minFilter: NearestFilter,
                                    magFilter: NearestFilter,
                                    format: RGBAFormat
                                };
                                shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                                shadow.map.texture.name = light.name + '.shadowMap';
                                shadow.camera.updateProjectionMatrix();
                            }
                            _renderer.setRenderTarget(shadow.map);
                            _renderer.clear();
                            var viewportCount = shadow.getViewportCount();
                            for (var vp = 0; vp < viewportCount; vp++) {
                                var viewport = shadow.getViewport(vp);
                                _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
                                _state.viewport(_viewport);
                                shadow.updateMatrices(light, vp);
                                _frustum = shadow.getFrustum();
                                renderObject(scene, camera, shadow.camera, light, this.type);
                            }
                            // do blur pass for VSM
                            if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
                                VSMPass(shadow, camera);
                            }
                            shadow.needsUpdate = false;
                        }
                        scope.needsUpdate = false;
                        _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
                    };

                    function VSMPass(shadow, camera) {
                        var geometry = _objects.update(fullScreenMesh);
                        if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
                            shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
                            shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
                            shadowMaterialVertical.needsUpdate = true;
                            shadowMaterialHorizontal.needsUpdate = true;
                        }
                        // vertical pass
                        shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
                        shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
                        shadowMaterialVertical.uniforms.radius.value = shadow.radius;
                        _renderer.setRenderTarget(shadow.mapPass);
                        _renderer.clear();
                        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
                        // horizontal pass
                        shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
                        shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
                        shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
                        _renderer.setRenderTarget(shadow.map);
                        _renderer.clear();
                        _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
                    }

                    function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
                        var result = null;
                        var customMaterial = (light.isPointLight === true) ? object.customDistanceMaterial : object.customDepthMaterial;
                        if (customMaterial !== undefined) {
                            result = customMaterial;
                        } else {
                            result = (light.isPointLight === true) ? _distanceMaterial : _depthMaterial;
                        }
                        if ((_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) ||
                            (material.displacementMap && material.displacementScale !== 0) ||
                            (material.alphaMap && material.alphaTest > 0)) {
                            // in this case we need a unique material instance reflecting the
                            // appropriate state
                            var keyA = result.uuid,
                                keyB = material.uuid;
                            var materialsForVariant = _materialCache[keyA];
                            if (materialsForVariant === undefined) {
                                materialsForVariant = {};
                                _materialCache[keyA] = materialsForVariant;
                            }
                            var cachedMaterial = materialsForVariant[keyB];
                            if (cachedMaterial === undefined) {
                                cachedMaterial = result.clone();
                                materialsForVariant[keyB] = cachedMaterial;
                            }
                            result = cachedMaterial;
                        }
                        result.visible = material.visible;
                        result.wireframe = material.wireframe;
                        if (type === VSMShadowMap) {
                            result.side = (material.shadowSide !== null) ? material.shadowSide : material.side;
                        } else {
                            result.side = (material.shadowSide !== null) ? material.shadowSide : shadowSide[material.side];
                        }
                        result.alphaMap = material.alphaMap;
                        result.alphaTest = material.alphaTest;
                        result.clipShadows = material.clipShadows;
                        result.clippingPlanes = material.clippingPlanes;
                        result.clipIntersection = material.clipIntersection;
                        result.displacementMap = material.displacementMap;
                        result.displacementScale = material.displacementScale;
                        result.displacementBias = material.displacementBias;
                        result.wireframeLinewidth = material.wireframeLinewidth;
                        result.linewidth = material.linewidth;
                        if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
                            result.referencePosition.setFromMatrixPosition(light.matrixWorld);
                            result.nearDistance = shadowCameraNear;
                            result.farDistance = shadowCameraFar;
                        }
                        return result;
                    }

                    function renderObject(object, camera, shadowCamera, light, type) {
                        if (object.visible === false)
                            return;
                        var visible = object.layers.test(camera.layers);
                        if (visible && (object.isMesh || object.isLine || object.isPoints)) {
                            if ((object.castShadow || (object.receiveShadow && type === VSMShadowMap)) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                                object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                                var geometry = _objects.update(object);
                                var material = object.material;
                                if (Array.isArray(material)) {
                                    var groups = geometry.groups;
                                    for (var k = 0, kl = groups.length; k < kl; k++) {
                                        var group = groups[k];
                                        var groupMaterial = material[group.materialIndex];
                                        if (groupMaterial && groupMaterial.visible) {
                                            var depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
                                            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                                        }
                                    }
                                } else if (material.visible) {
                                    var depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);
                                    _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                                }
                            }
                        }
                        var children = object.children;
                        for (var i = 0, l = children.length; i < l; i++) {
                            renderObject(children[i], camera, shadowCamera, light, type);
                        }
                    }
                }

                function WebGLState(gl, extensions, capabilities) {
                    var _a, _b;
                    var isWebGL2 = capabilities.isWebGL2;

                    function ColorBuffer() {
                        var locked = false;
                        var color = new Vector4();
                        var currentColorMask = null;
                        var currentColorClear = new Vector4(0, 0, 0, 0);
                        return {
                            setMask: function(colorMask) {
                                if (currentColorMask !== colorMask && !locked) {
                                    gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                                    currentColorMask = colorMask;
                                }
                            },
                            setLocked: function(lock) {
                                locked = lock;
                            },
                            setClear: function(r, g, b, a, premultipliedAlpha) {
                                if (premultipliedAlpha === true) {
                                    r *= a;
                                    g *= a;
                                    b *= a;
                                }
                                color.set(r, g, b, a);
                                if (currentColorClear.equals(color) === false) {
                                    gl.clearColor(r, g, b, a);
                                    currentColorClear.copy(color);
                                }
                            },
                            reset: function() {
                                locked = false;
                                currentColorMask = null;
                                currentColorClear.set(-1, 0, 0, 0); // set to invalid state
                            }
                        };
                    }

                    function DepthBuffer() {
                        var locked = false;
                        var currentDepthMask = null;
                        var currentDepthFunc = null;
                        var currentDepthClear = null;
                        return {
                            setTest: function(depthTest) {
                                if (depthTest) {
                                    enable(2929);
                                } else {
                                    disable(2929);
                                }
                            },
                            setMask: function(depthMask) {
                                if (currentDepthMask !== depthMask && !locked) {
                                    gl.depthMask(depthMask);
                                    currentDepthMask = depthMask;
                                }
                            },
                            setFunc: function(depthFunc) {
                                if (currentDepthFunc !== depthFunc) {
                                    if (depthFunc) {
                                        switch (depthFunc) {
                                            case NeverDepth:
                                                gl.depthFunc(512);
                                                break;
                                            case AlwaysDepth:
                                                gl.depthFunc(519);
                                                break;
                                            case LessDepth:
                                                gl.depthFunc(513);
                                                break;
                                            case LessEqualDepth:
                                                gl.depthFunc(515);
                                                break;
                                            case EqualDepth:
                                                gl.depthFunc(514);
                                                break;
                                            case GreaterEqualDepth:
                                                gl.depthFunc(518);
                                                break;
                                            case GreaterDepth:
                                                gl.depthFunc(516);
                                                break;
                                            case NotEqualDepth:
                                                gl.depthFunc(517);
                                                break;
                                            default:
                                                gl.depthFunc(515);
                                        }
                                    } else {
                                        gl.depthFunc(515);
                                    }
                                    currentDepthFunc = depthFunc;
                                }
                            },
                            setLocked: function(lock) {
                                locked = lock;
                            },
                            setClear: function(depth) {
                                if (currentDepthClear !== depth) {
                                    gl.clearDepth(depth);
                                    currentDepthClear = depth;
                                }
                            },
                            reset: function() {
                                locked = false;
                                currentDepthMask = null;
                                currentDepthFunc = null;
                                currentDepthClear = null;
                            }
                        };
                    }

                    function StencilBuffer() {
                        var locked = false;
                        var currentStencilMask = null;
                        var currentStencilFunc = null;
                        var currentStencilRef = null;
                        var currentStencilFuncMask = null;
                        var currentStencilFail = null;
                        var currentStencilZFail = null;
                        var currentStencilZPass = null;
                        var currentStencilClear = null;
                        return {
                            setTest: function(stencilTest) {
                                if (!locked) {
                                    if (stencilTest) {
                                        enable(2960);
                                    } else {
                                        disable(2960);
                                    }
                                }
                            },
                            setMask: function(stencilMask) {
                                if (currentStencilMask !== stencilMask && !locked) {
                                    gl.stencilMask(stencilMask);
                                    currentStencilMask = stencilMask;
                                }
                            },
                            setFunc: function(stencilFunc, stencilRef, stencilMask) {
                                if (currentStencilFunc !== stencilFunc ||
                                    currentStencilRef !== stencilRef ||
                                    currentStencilFuncMask !== stencilMask) {
                                    gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                                    currentStencilFunc = stencilFunc;
                                    currentStencilRef = stencilRef;
                                    currentStencilFuncMask = stencilMask;
                                }
                            },
                            setOp: function(stencilFail, stencilZFail, stencilZPass) {
                                if (currentStencilFail !== stencilFail ||
                                    currentStencilZFail !== stencilZFail ||
                                    currentStencilZPass !== stencilZPass) {
                                    gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                                    currentStencilFail = stencilFail;
                                    currentStencilZFail = stencilZFail;
                                    currentStencilZPass = stencilZPass;
                                }
                            },
                            setLocked: function(lock) {
                                locked = lock;
                            },
                            setClear: function(stencil) {
                                if (currentStencilClear !== stencil) {
                                    gl.clearStencil(stencil);
                                    currentStencilClear = stencil;
                                }
                            },
                            reset: function() {
                                locked = false;
                                currentStencilMask = null;
                                currentStencilFunc = null;
                                currentStencilRef = null;
                                currentStencilFuncMask = null;
                                currentStencilFail = null;
                                currentStencilZFail = null;
                                currentStencilZPass = null;
                                currentStencilClear = null;
                            }
                        };
                    }
                    //
                    var colorBuffer = new ColorBuffer();
                    var depthBuffer = new DepthBuffer();
                    var stencilBuffer = new StencilBuffer();
                    var enabledCapabilities = {};
                    var currentBoundFramebuffers = {};
                    var currentDrawbuffers = new WeakMap();
                    var defaultDrawbuffers = [];
                    var currentProgram = null;
                    var currentBlendingEnabled = false;
                    var currentBlending = null;
                    var currentBlendEquation = null;
                    var currentBlendSrc = null;
                    var currentBlendDst = null;
                    var currentBlendEquationAlpha = null;
                    var currentBlendSrcAlpha = null;
                    var currentBlendDstAlpha = null;
                    var currentPremultipledAlpha = false;
                    var currentFlipSided = null;
                    var currentCullFace = null;
                    var currentLineWidth = null;
                    var currentPolygonOffsetFactor = null;
                    var currentPolygonOffsetUnits = null;
                    var maxTextures = gl.getParameter(35661);
                    var lineWidthAvailable = false;
                    var version = 0;
                    var glVersion = gl.getParameter(7938);
                    if (glVersion.indexOf('WebGL') !== -1) {
                        version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
                        lineWidthAvailable = (version >= 1.0);
                    } else if (glVersion.indexOf('OpenGL ES') !== -1) {
                        version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
                        lineWidthAvailable = (version >= 2.0);
                    }
                    var currentTextureSlot = null;
                    var currentBoundTextures = {};
                    var scissorParam = gl.getParameter(3088);
                    var viewportParam = gl.getParameter(2978);
                    var currentScissor = new Vector4().fromArray(scissorParam);
                    var currentViewport = new Vector4().fromArray(viewportParam);

                    function createTexture(type, target, count) {
                        var data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
                        var texture = gl.createTexture();
                        gl.bindTexture(type, texture);
                        gl.texParameteri(type, 10241, 9728);
                        gl.texParameteri(type, 10240, 9728);
                        for (var i = 0; i < count; i++) {
                            gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
                        }
                        return texture;
                    }
                    var emptyTextures = {};
                    emptyTextures[3553] = createTexture(3553, 3553, 1);
                    emptyTextures[34067] = createTexture(34067, 34069, 6);
                    // init
                    colorBuffer.setClear(0, 0, 0, 1);
                    depthBuffer.setClear(1);
                    stencilBuffer.setClear(0);
                    enable(2929);
                    depthBuffer.setFunc(LessEqualDepth);
                    setFlipSided(false);
                    setCullFace(CullFaceBack);
                    enable(2884);
                    setBlending(NoBlending);
                    //
                    function enable(id) {
                        if (enabledCapabilities[id] !== true) {
                            gl.enable(id);
                            enabledCapabilities[id] = true;
                        }
                    }

                    function disable(id) {
                        if (enabledCapabilities[id] !== false) {
                            gl.disable(id);
                            enabledCapabilities[id] = false;
                        }
                    }

                    function bindFramebuffer(target, framebuffer) {
                        if (currentBoundFramebuffers[target] !== framebuffer) {
                            gl.bindFramebuffer(target, framebuffer);
                            currentBoundFramebuffers[target] = framebuffer;
                            if (isWebGL2) {
                                // 36009 is equivalent to 36160
                                if (target === 36009) {
                                    currentBoundFramebuffers[36160] = framebuffer;
                                }
                                if (target === 36160) {
                                    currentBoundFramebuffers[36009] = framebuffer;
                                }
                            }
                            return true;
                        }
                        return false;
                    }

                    function drawBuffers(renderTarget, framebuffer) {
                        var drawBuffers = defaultDrawbuffers;
                        var needsUpdate = false;
                        if (renderTarget) {
                            drawBuffers = currentDrawbuffers.get(framebuffer);
                            if (drawBuffers === undefined) {
                                drawBuffers = [];
                                currentDrawbuffers.set(framebuffer, drawBuffers);
                            }
                            if (renderTarget.isWebGLMultipleRenderTargets) {
                                var textures = renderTarget.texture;
                                if (drawBuffers.length !== textures.length || drawBuffers[0] !== 36064) {
                                    for (var i = 0, il = textures.length; i < il; i++) {
                                        drawBuffers[i] = 36064 + i;
                                    }
                                    drawBuffers.length = textures.length;
                                    needsUpdate = true;
                                }
                            } else {
                                if (drawBuffers[0] !== 36064) {
                                    drawBuffers[0] = 36064;
                                    needsUpdate = true;
                                }
                            }
                        } else {
                            if (drawBuffers[0] !== 1029) {
                                drawBuffers[0] = 1029;
                                needsUpdate = true;
                            }
                        }
                        if (needsUpdate) {
                            if (capabilities.isWebGL2) {
                                gl.drawBuffers(drawBuffers);
                            } else {
                                extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(drawBuffers);
                            }
                        }
                    }

                    function useProgram(program) {
                        if (currentProgram !== program) {
                            gl.useProgram(program);
                            currentProgram = program;
                            return true;
                        }
                        return false;
                    }
                    var equationToGL = (_a = {},
                        _a[AddEquation] = 32774,
                        _a[SubtractEquation] = 32778,
                        _a[ReverseSubtractEquation] = 32779,
                        _a);
                    if (isWebGL2) {
                        equationToGL[MinEquation] = 32775;
                        equationToGL[MaxEquation] = 32776;
                    } else {
                        var extension = extensions.get('EXT_blend_minmax');
                        if (extension !== null) {
                            equationToGL[MinEquation] = extension.MIN_EXT;
                            equationToGL[MaxEquation] = extension.MAX_EXT;
                        }
                    }
                    var factorToGL = (_b = {},
                        _b[ZeroFactor] = 0,
                        _b[OneFactor] = 1,
                        _b[SrcColorFactor] = 768,
                        _b[SrcAlphaFactor] = 770,
                        _b[SrcAlphaSaturateFactor] = 776,
                        _b[DstColorFactor] = 774,
                        _b[DstAlphaFactor] = 772,
                        _b[OneMinusSrcColorFactor] = 769,
                        _b[OneMinusSrcAlphaFactor] = 771,
                        _b[OneMinusDstColorFactor] = 775,
                        _b[OneMinusDstAlphaFactor] = 773,
                        _b);

                    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
                        if (blending === NoBlending) {
                            if (currentBlendingEnabled === true) {
                                disable(3042);
                                currentBlendingEnabled = false;
                            }
                            return;
                        }
                        if (currentBlendingEnabled === false) {
                            enable(3042);
                            currentBlendingEnabled = true;
                        }
                        if (blending !== CustomBlending) {
                            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                                if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
                                    gl.blendEquation(32774);
                                    currentBlendEquation = AddEquation;
                                    currentBlendEquationAlpha = AddEquation;
                                }
                                if (premultipliedAlpha) {
                                    switch (blending) {
                                        case NormalBlending:
                                            gl.blendFuncSeparate(1, 771, 1, 771);
                                            break;
                                        case AdditiveBlending:
                                            gl.blendFunc(1, 1);
                                            break;
                                        case SubtractiveBlending:
                                            gl.blendFuncSeparate(0, 769, 0, 1);
                                            break;
                                        case MultiplyBlending:
                                            gl.blendFuncSeparate(0, 768, 0, 770);
                                            break;
                                        default:
                                            console.error('THREE.WebGLState: Invalid blending: ', blending);
                                            break;
                                    }
                                } else {
                                    switch (blending) {
                                        case NormalBlending:
                                            gl.blendFuncSeparate(770, 771, 1, 771);
                                            break;
                                        case AdditiveBlending:
                                            gl.blendFunc(770, 1);
                                            break;
                                        case SubtractiveBlending:
                                            gl.blendFuncSeparate(0, 769, 0, 1);
                                            break;
                                        case MultiplyBlending:
                                            gl.blendFunc(0, 768);
                                            break;
                                        default:
                                            console.error('THREE.WebGLState: Invalid blending: ', blending);
                                            break;
                                    }
                                }
                                currentBlendSrc = null;
                                currentBlendDst = null;
                                currentBlendSrcAlpha = null;
                                currentBlendDstAlpha = null;
                                currentBlending = blending;
                                currentPremultipledAlpha = premultipliedAlpha;
                            }
                            return;
                        }
                        // custom blending
                        blendEquationAlpha = blendEquationAlpha || blendEquation;
                        blendSrcAlpha = blendSrcAlpha || blendSrc;
                        blendDstAlpha = blendDstAlpha || blendDst;
                        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
                            gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
                            currentBlendEquation = blendEquation;
                            currentBlendEquationAlpha = blendEquationAlpha;
                        }
                        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
                            gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
                            currentBlendSrc = blendSrc;
                            currentBlendDst = blendDst;
                            currentBlendSrcAlpha = blendSrcAlpha;
                            currentBlendDstAlpha = blendDstAlpha;
                        }
                        currentBlending = blending;
                        currentPremultipledAlpha = null;
                    }

                    function setMaterial(material, frontFaceCW) {
                        material.side === DoubleSide ?
                            disable(2884) :
                            enable(2884);
                        var flipSided = (material.side === BackSide);
                        if (frontFaceCW)
                            flipSided = !flipSided;
                        setFlipSided(flipSided);
                        (material.blending === NormalBlending && material.transparent === false) ?
                        setBlending(NoBlending): setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
                        depthBuffer.setFunc(material.depthFunc);
                        depthBuffer.setTest(material.depthTest);
                        depthBuffer.setMask(material.depthWrite);
                        colorBuffer.setMask(material.colorWrite);
                        var stencilWrite = material.stencilWrite;
                        stencilBuffer.setTest(stencilWrite);
                        if (stencilWrite) {
                            stencilBuffer.setMask(material.stencilWriteMask);
                            stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
                            stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
                        }
                        setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
                        material.alphaToCoverage === true ?
                            enable(32926) :
                            disable(32926);
                    }
                    //
                    function setFlipSided(flipSided) {
                        if (currentFlipSided !== flipSided) {
                            if (flipSided) {
                                gl.frontFace(2304);
                            } else {
                                gl.frontFace(2305);
                            }
                            currentFlipSided = flipSided;
                        }
                    }

                    function setCullFace(cullFace) {
                        if (cullFace !== CullFaceNone) {
                            enable(2884);
                            if (cullFace !== currentCullFace) {
                                if (cullFace === CullFaceBack) {
                                    gl.cullFace(1029);
                                } else if (cullFace === CullFaceFront) {
                                    gl.cullFace(1028);
                                } else {
                                    gl.cullFace(1032);
                                }
                            }
                        } else {
                            disable(2884);
                        }
                        currentCullFace = cullFace;
                    }

                    function setLineWidth(width) {
                        if (width !== currentLineWidth) {
                            if (lineWidthAvailable)
                                gl.lineWidth(width);
                            currentLineWidth = width;
                        }
                    }

                    function setPolygonOffset(polygonOffset, factor, units) {
                        if (polygonOffset) {
                            enable(32823);
                            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                                gl.polygonOffset(factor, units);
                                currentPolygonOffsetFactor = factor;
                                currentPolygonOffsetUnits = units;
                            }
                        } else {
                            disable(32823);
                        }
                    }

                    function setScissorTest(scissorTest) {
                        if (scissorTest) {
                            enable(3089);
                        } else {
                            disable(3089);
                        }
                    }
                    // texture
                    function activeTexture(webglSlot) {
                        if (webglSlot === undefined)
                            webglSlot = 33984 + maxTextures - 1;
                        if (currentTextureSlot !== webglSlot) {
                            gl.activeTexture(webglSlot);
                            currentTextureSlot = webglSlot;
                        }
                    }

                    function bindTexture(webglType, webglTexture) {
                        if (currentTextureSlot === null) {
                            activeTexture();
                        }
                        var boundTexture = currentBoundTextures[currentTextureSlot];
                        if (boundTexture === undefined) {
                            boundTexture = {
                                type: undefined,
                                texture: undefined
                            };
                            currentBoundTextures[currentTextureSlot] = boundTexture;
                        }
                        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
                            gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
                            boundTexture.type = webglType;
                            boundTexture.texture = webglTexture;
                        }
                    }

                    function unbindTexture() {
                        var boundTexture = currentBoundTextures[currentTextureSlot];
                        if (boundTexture !== undefined && boundTexture.type !== undefined) {
                            gl.bindTexture(boundTexture.type, null);
                            boundTexture.type = undefined;
                            boundTexture.texture = undefined;
                        }
                    }

                    function compressedTexImage2D() {
                        try {
                            gl.compressedTexImage2D.apply(gl, arguments);
                        } catch (error) {
                            console.error('THREE.WebGLState:', error);
                        }
                    }

                    function texSubImage2D() {
                        try {
                            gl.texSubImage2D.apply(gl, arguments);
                        } catch (error) {
                            console.error('THREE.WebGLState:', error);
                        }
                    }

                    function texSubImage3D() {
                        try {
                            gl.texSubImage3D.apply(gl, arguments);
                        } catch (error) {
                            console.error('THREE.WebGLState:', error);
                        }
                    }

                    function compressedTexSubImage2D() {
                        try {
                            gl.compressedTexSubImage2D.apply(gl, arguments);
                        } catch (error) {
                            console.error('THREE.WebGLState:', error);
                        }
                    }

                    function texStorage2D() {
                        try {
                            gl.texStorage2D.apply(gl, arguments);
                        } catch (error) {
                            console.error('THREE.WebGLState:', error);
                        }
                    }

                    function texStorage3D() {
                        try {
                            gl.texStorage3D.apply(gl, arguments);
                        } catch (error) {
                            console.error('THREE.WebGLState:', error);
                        }
                    }

                    function texImage2D() {
                        try {
                            gl.texImage2D.apply(gl, arguments);
                        } catch (error) {
                            console.error('THREE.WebGLState:', error);
                        }
                    }

                    function texImage3D() {
                        try {
                            gl.texImage3D.apply(gl, arguments);
                        } catch (error) {
                            console.error('THREE.WebGLState:', error);
                        }
                    }
                    //
                    function scissor(scissor) {
                        if (currentScissor.equals(scissor) === false) {
                            gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
                            currentScissor.copy(scissor);
                        }
                    }

                    function viewport(viewport) {
                        if (currentViewport.equals(viewport) === false) {
                            gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
                            currentViewport.copy(viewport);
                        }
                    }
                    //
                    function reset() {
                        // reset state
                        gl.disable(3042);
                        gl.disable(2884);
                        gl.disable(2929);
                        gl.disable(32823);
                        gl.disable(3089);
                        gl.disable(2960);
                        gl.disable(32926);
                        gl.blendEquation(32774);
                        gl.blendFunc(1, 0);
                        gl.blendFuncSeparate(1, 0, 1, 0);
                        gl.colorMask(true, true, true, true);
                        gl.clearColor(0, 0, 0, 0);
                        gl.depthMask(true);
                        gl.depthFunc(513);
                        gl.clearDepth(1);
                        gl.stencilMask(0xffffffff);
                        gl.stencilFunc(519, 0, 0xffffffff);
                        gl.stencilOp(7680, 7680, 7680);
                        gl.clearStencil(0);
                        gl.cullFace(1029);
                        gl.frontFace(2305);
                        gl.polygonOffset(0, 0);
                        gl.activeTexture(33984);
                        gl.bindFramebuffer(36160, null);
                        if (isWebGL2 === true) {
                            gl.bindFramebuffer(36009, null);
                            gl.bindFramebuffer(36008, null);
                        }
                        gl.useProgram(null);
                        gl.lineWidth(1);
                        gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
                        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                        // reset internals
                        enabledCapabilities = {};
                        currentTextureSlot = null;
                        currentBoundTextures = {};
                        currentBoundFramebuffers = {};
                        currentDrawbuffers = new WeakMap();
                        defaultDrawbuffers = [];
                        currentProgram = null;
                        currentBlendingEnabled = false;
                        currentBlending = null;
                        currentBlendEquation = null;
                        currentBlendSrc = null;
                        currentBlendDst = null;
                        currentBlendEquationAlpha = null;
                        currentBlendSrcAlpha = null;
                        currentBlendDstAlpha = null;
                        currentPremultipledAlpha = false;
                        currentFlipSided = null;
                        currentCullFace = null;
                        currentLineWidth = null;
                        currentPolygonOffsetFactor = null;
                        currentPolygonOffsetUnits = null;
                        currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
                        currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
                        colorBuffer.reset();
                        depthBuffer.reset();
                        stencilBuffer.reset();
                    }
                    return {
                        buffers: {
                            color: colorBuffer,
                            depth: depthBuffer,
                            stencil: stencilBuffer
                        },
                        enable: enable,
                        disable: disable,
                        bindFramebuffer: bindFramebuffer,
                        drawBuffers: drawBuffers,
                        useProgram: useProgram,
                        setBlending: setBlending,
                        setMaterial: setMaterial,
                        setFlipSided: setFlipSided,
                        setCullFace: setCullFace,
                        setLineWidth: setLineWidth,
                        setPolygonOffset: setPolygonOffset,
                        setScissorTest: setScissorTest,
                        activeTexture: activeTexture,
                        bindTexture: bindTexture,
                        unbindTexture: unbindTexture,
                        compressedTexImage2D: compressedTexImage2D,
                        texImage2D: texImage2D,
                        texImage3D: texImage3D,
                        texStorage2D: texStorage2D,
                        texStorage3D: texStorage3D,
                        texSubImage2D: texSubImage2D,
                        texSubImage3D: texSubImage3D,
                        compressedTexSubImage2D: compressedTexSubImage2D,
                        scissor: scissor,
                        viewport: viewport,
                        reset: reset
                    };
                }

                function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
                    var _a, _b;
                    var isWebGL2 = capabilities.isWebGL2;
                    var maxTextures = capabilities.maxTextures;
                    var maxCubemapSize = capabilities.maxCubemapSize;
                    var maxTextureSize = capabilities.maxTextureSize;
                    var maxSamples = capabilities.maxSamples;
                    var multisampledRTTExt = extensions.has('WEBGL_multisampled_render_to_texture') ? extensions.get('WEBGL_multisampled_render_to_texture') : null;
                    var supportsInvalidateFramebuffer = /OculusBrowser/g.test(navigator.userAgent);
                    var _videoTextures = new WeakMap();
                    var _canvas;
                    var _sources = new WeakMap(); // maps WebglTexture objects to instances of Source
                    // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
                    // also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
                    // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
                    var useOffscreenCanvas = false;
                    try {
                        useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
                            // eslint-disable-next-line compat/compat
                            &&
                            (new OffscreenCanvas(1, 1).getContext('2d')) !== null;
                    } catch (err) {
                        // Ignore any errors
                    }

                    function createCanvas(width, height) {
                        // Use OffscreenCanvas when available. Specially needed in web workers
                        return useOffscreenCanvas ?
                            // eslint-disable-next-line compat/compat
                            new OffscreenCanvas(width, height) : createElementNS('canvas');
                    }

                    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
                        var scale = 1;
                        // handle case if texture exceeds max size
                        if (image.width > maxSize || image.height > maxSize) {
                            scale = maxSize / Math.max(image.width, image.height);
                        }
                        // only perform resize if necessary
                        if (scale < 1 || needsPowerOfTwo === true) {
                            // only perform resize for certain image types
                            if ((typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) ||
                                (typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) ||
                                (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)) {
                                var floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
                                var width = floor(scale * image.width);
                                var height = floor(scale * image.height);
                                if (_canvas === undefined)
                                    _canvas = createCanvas(width, height);
                                // cube textures can't reuse the same canvas
                                var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
                                canvas.width = width;
                                canvas.height = height;
                                var context = canvas.getContext('2d');
                                context.drawImage(image, 0, 0, width, height);
                                console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
                                return canvas;
                            } else {
                                if ('data' in image) {
                                    console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
                                }
                                return image;
                            }
                        }
                        return image;
                    }

                    function isPowerOfTwo$1(image) {
                        return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
                    }

                    function textureNeedsPowerOfTwo(texture) {
                        if (isWebGL2)
                            return false;
                        return (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) ||
                            (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter);
                    }

                    function textureNeedsGenerateMipmaps(texture, supportsMips) {
                        return texture.generateMipmaps && supportsMips &&
                            texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
                    }

                    function generateMipmap(target) {
                        _gl.generateMipmap(target);
                    }

                    function getInternalFormat(internalFormatName, glFormat, glType, encoding, isVideoTexture) {
                        if (isVideoTexture === void 0) {
                            isVideoTexture = false;
                        }
                        if (isWebGL2 === false)
                            return glFormat;
                        if (internalFormatName !== null) {
                            if (_gl[internalFormatName] !== undefined)
                                return _gl[internalFormatName];
                            console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
                        }
                        var internalFormat = glFormat;
                        if (glFormat === 6403) {
                            if (glType === 5126)
                                internalFormat = 33326;
                            if (glType === 5131)
                                internalFormat = 33325;
                            if (glType === 5121)
                                internalFormat = 33321;
                        }
                        if (glFormat === 33319) {
                            if (glType === 5126)
                                internalFormat = 33328;
                            if (glType === 5131)
                                internalFormat = 33327;
                            if (glType === 5121)
                                internalFormat = 33323;
                        }
                        if (glFormat === 6408) {
                            if (glType === 5126)
                                internalFormat = 34836;
                            if (glType === 5131)
                                internalFormat = 34842;
                            if (glType === 5121)
                                internalFormat = (encoding === sRGBEncoding && isVideoTexture === false) ? 35907 : 32856;
                            if (glType === 32819)
                                internalFormat = 32854;
                            if (glType === 32820)
                                internalFormat = 32855;
                        }
                        if (internalFormat === 33325 || internalFormat === 33326 ||
                            internalFormat === 33327 || internalFormat === 33328 ||
                            internalFormat === 34842 || internalFormat === 34836) {
                            extensions.get('EXT_color_buffer_float');
                        }
                        return internalFormat;
                    }

                    function getMipLevels(texture, image, supportsMips) {
                        if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || (texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter)) {
                            return Math.log2(Math.max(image.width, image.height)) + 1;
                        } else if (texture.mipmaps !== undefined && texture.mipmaps.length > 0) {
                            // user-defined mipmaps
                            return texture.mipmaps.length;
                        } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
                            return image.mipmaps.length;
                        } else {
                            // texture without mipmaps (only base level)
                            return 1;
                        }
                    }
                    // Fallback filters for non-power-of-2 textures
                    function filterFallback(f) {
                        if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
                            return 9728;
                        }
                        return 9729;
                    }
                    //
                    function onTextureDispose(event) {
                        var texture = event.target;
                        texture.removeEventListener('dispose', onTextureDispose);
                        deallocateTexture(texture);
                        if (texture.isVideoTexture) {
                            _videoTextures.delete(texture);
                        }
                    }

                    function onRenderTargetDispose(event) {
                        var renderTarget = event.target;
                        renderTarget.removeEventListener('dispose', onRenderTargetDispose);
                        deallocateRenderTarget(renderTarget);
                    }
                    //
                    function deallocateTexture(texture) {
                        var textureProperties = properties.get(texture);
                        if (textureProperties.__webglInit === undefined)
                            return;
                        // check if it's necessary to remove the WebGLTexture object
                        var source = texture.source;
                        var webglTextures = _sources.get(source);
                        if (webglTextures) {
                            var webglTexture = webglTextures[textureProperties.__cacheKey];
                            webglTexture.usedTimes--;
                            // the WebGLTexture object is not used anymore, remove it
                            if (webglTexture.usedTimes === 0) {
                                deleteTexture(texture);
                            }
                            // remove the weak map entry if no WebGLTexture uses the source anymore
                            if (Object.keys(webglTextures).length === 0) {
                                _sources.delete(source);
                            }
                        }
                        properties.remove(texture);
                    }

                    function deleteTexture(texture) {
                        var textureProperties = properties.get(texture);
                        _gl.deleteTexture(textureProperties.__webglTexture);
                        var source = texture.source;
                        var webglTextures = _sources.get(source);
                        delete webglTextures[textureProperties.__cacheKey];
                        info.memory.textures--;
                    }

                    function deallocateRenderTarget(renderTarget) {
                        var texture = renderTarget.texture;
                        var renderTargetProperties = properties.get(renderTarget);
                        var textureProperties = properties.get(texture);
                        if (textureProperties.__webglTexture !== undefined) {
                            _gl.deleteTexture(textureProperties.__webglTexture);
                            info.memory.textures--;
                        }
                        if (renderTarget.depthTexture) {
                            renderTarget.depthTexture.dispose();
                        }
                        if (renderTarget.isWebGLCubeRenderTarget) {
                            for (var i = 0; i < 6; i++) {
                                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
                                if (renderTargetProperties.__webglDepthbuffer)
                                    _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
                            }
                        } else {
                            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
                            if (renderTargetProperties.__webglDepthbuffer)
                                _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
                            if (renderTargetProperties.__webglMultisampledFramebuffer)
                                _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
                            if (renderTargetProperties.__webglColorRenderbuffer)
                                _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
                            if (renderTargetProperties.__webglDepthRenderbuffer)
                                _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
                        }
                        if (renderTarget.isWebGLMultipleRenderTargets) {
                            for (var i = 0, il = texture.length; i < il; i++) {
                                var attachmentProperties = properties.get(texture[i]);
                                if (attachmentProperties.__webglTexture) {
                                    _gl.deleteTexture(attachmentProperties.__webglTexture);
                                    info.memory.textures--;
                                }
                                properties.remove(texture[i]);
                            }
                        }
                        properties.remove(texture);
                        properties.remove(renderTarget);
                    }
                    //
                    var textureUnits = 0;

                    function resetTextureUnits() {
                        textureUnits = 0;
                    }

                    function allocateTextureUnit() {
                        var textureUnit = textureUnits;
                        if (textureUnit >= maxTextures) {
                            console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
                        }
                        textureUnits += 1;
                        return textureUnit;
                    }

                    function getTextureCacheKey(texture) {
                        var array = [];
                        array.push(texture.wrapS);
                        array.push(texture.wrapT);
                        array.push(texture.magFilter);
                        array.push(texture.minFilter);
                        array.push(texture.anisotropy);
                        array.push(texture.internalFormat);
                        array.push(texture.format);
                        array.push(texture.type);
                        array.push(texture.generateMipmaps);
                        array.push(texture.premultiplyAlpha);
                        array.push(texture.flipY);
                        array.push(texture.unpackAlignment);
                        array.push(texture.encoding);
                        return array.join();
                    }
                    //
                    function setTexture2D(texture, slot) {
                        var textureProperties = properties.get(texture);
                        if (texture.isVideoTexture)
                            updateVideoTexture(texture);
                        if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
                            var image = texture.image;
                            if (image === null) {
                                console.warn('THREE.WebGLRenderer: Texture marked for update but no image data found.');
                            } else if (image.complete === false) {
                                console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
                            } else {
                                uploadTexture(textureProperties, texture, slot);
                                return;
                            }
                        }
                        state.activeTexture(33984 + slot);
                        state.bindTexture(3553, textureProperties.__webglTexture);
                    }

                    function setTexture2DArray(texture, slot) {
                        var textureProperties = properties.get(texture);
                        if (texture.version > 0 && textureProperties.__version !== texture.version) {
                            uploadTexture(textureProperties, texture, slot);
                            return;
                        }
                        state.activeTexture(33984 + slot);
                        state.bindTexture(35866, textureProperties.__webglTexture);
                    }

                    function setTexture3D(texture, slot) {
                        var textureProperties = properties.get(texture);
                        if (texture.version > 0 && textureProperties.__version !== texture.version) {
                            uploadTexture(textureProperties, texture, slot);
                            return;
                        }
                        state.activeTexture(33984 + slot);
                        state.bindTexture(32879, textureProperties.__webglTexture);
                    }

                    function setTextureCube(texture, slot) {
                        var textureProperties = properties.get(texture);
                        if (texture.version > 0 && textureProperties.__version !== texture.version) {
                            uploadCubeTexture(textureProperties, texture, slot);
                            return;
                        }
                        state.activeTexture(33984 + slot);
                        state.bindTexture(34067, textureProperties.__webglTexture);
                    }
                    var wrappingToGL = (_a = {},
                        _a[RepeatWrapping] = 10497,
                        _a[ClampToEdgeWrapping] = 33071,
                        _a[MirroredRepeatWrapping] = 33648,
                        _a);
                    var filterToGL = (_b = {},
                        _b[NearestFilter] = 9728,
                        _b[NearestMipmapNearestFilter] = 9984,
                        _b[NearestMipmapLinearFilter] = 9986,
                        _b[LinearFilter] = 9729,
                        _b[LinearMipmapNearestFilter] = 9985,
                        _b[LinearMipmapLinearFilter] = 9987,
                        _b);

                    function setTextureParameters(textureType, texture, supportsMips) {
                        if (supportsMips) {
                            _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
                            _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
                            if (textureType === 32879 || textureType === 35866) {
                                _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
                            }
                            _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
                            _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
                        } else {
                            _gl.texParameteri(textureType, 10242, 33071);
                            _gl.texParameteri(textureType, 10243, 33071);
                            if (textureType === 32879 || textureType === 35866) {
                                _gl.texParameteri(textureType, 32882, 33071);
                            }
                            if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
                                console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
                            }
                            _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
                            _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
                            if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
                                console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
                            }
                        }
                        if (extensions.has('EXT_texture_filter_anisotropic') === true) {
                            var extension = extensions.get('EXT_texture_filter_anisotropic');
                            if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false)
                                return; // verify extension for WebGL 1 and WebGL 2
                            if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false))
                                return; // verify extension for WebGL 1 only
                            if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                                properties.get(texture).__currentAnisotropy = texture.anisotropy;
                            }
                        }
                    }

                    function initTexture(textureProperties, texture) {
                        var forceUpload = false;
                        if (textureProperties.__webglInit === undefined) {
                            textureProperties.__webglInit = true;
                            texture.addEventListener('dispose', onTextureDispose);
                        }
                        // create Source <-> WebGLTextures mapping if necessary
                        var source = texture.source;
                        var webglTextures = _sources.get(source);
                        if (webglTextures === undefined) {
                            webglTextures = {};
                            _sources.set(source, webglTextures);
                        }
                        // check if there is already a WebGLTexture object for the given texture parameters
                        var textureCacheKey = getTextureCacheKey(texture);
                        if (textureCacheKey !== textureProperties.__cacheKey) {
                            // if not, create a new instance of WebGLTexture
                            if (webglTextures[textureCacheKey] === undefined) {
                                // create new entry
                                webglTextures[textureCacheKey] = {
                                    texture: _gl.createTexture(),
                                    usedTimes: 0
                                };
                                info.memory.textures++;
                                // when a new instance of WebGLTexture was created, a texture upload is required
                                // even if the image contents are identical
                                forceUpload = true;
                            }
                            webglTextures[textureCacheKey].usedTimes++;
                            // every time the texture cache key changes, it's necessary to check if an instance of
                            // WebGLTexture can be deleted in order to avoid a memory leak.
                            var webglTexture = webglTextures[textureProperties.__cacheKey];
                            if (webglTexture !== undefined) {
                                webglTextures[textureProperties.__cacheKey].usedTimes--;
                                if (webglTexture.usedTimes === 0) {
                                    deleteTexture(texture);
                                }
                            }
                            // store references to cache key and WebGLTexture object
                            textureProperties.__cacheKey = textureCacheKey;
                            textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
                        }
                        return forceUpload;
                    }

                    function uploadTexture(textureProperties, texture, slot) {
                        var textureType = 3553;
                        if (texture.isDataArrayTexture)
                            textureType = 35866;
                        if (texture.isData3DTexture)
                            textureType = 32879;
                        var forceUpload = initTexture(textureProperties, texture);
                        var source = texture.source;
                        state.activeTexture(33984 + slot);
                        state.bindTexture(textureType, textureProperties.__webglTexture);
                        if (source.version !== source.__currentVersion || forceUpload === true) {
                            _gl.pixelStorei(37440, texture.flipY);
                            _gl.pixelStorei(37441, texture.premultiplyAlpha);
                            _gl.pixelStorei(3317, texture.unpackAlignment);
                            _gl.pixelStorei(37443, 0);
                            var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
                            var image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
                            image = verifyColorSpace(texture, image);
                            var supportsMips = isPowerOfTwo$1(image) || isWebGL2,
                                glFormat = utils.convert(texture.format, texture.encoding);
                            var glType = utils.convert(texture.type),
                                glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);
                            setTextureParameters(textureType, texture, supportsMips);
                            var mipmap = void 0;
                            var mipmaps = texture.mipmaps;
                            var useTexStorage = (isWebGL2 && texture.isVideoTexture !== true);
                            var allocateMemory = (textureProperties.__version === undefined);
                            var levels = getMipLevels(texture, image, supportsMips);
                            if (texture.isDepthTexture) {
                                // populate depth texture with dummy data
                                glInternalFormat = 6402;
                                if (isWebGL2) {
                                    if (texture.type === FloatType) {
                                        glInternalFormat = 36012;
                                    } else if (texture.type === UnsignedIntType) {
                                        glInternalFormat = 33190;
                                    } else if (texture.type === UnsignedInt248Type) {
                                        glInternalFormat = 35056;
                                    } else {
                                        glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D
                                    }
                                } else {
                                    if (texture.type === FloatType) {
                                        console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
                                    }
                                }
                                // validation checks for WebGL 1
                                if (texture.format === DepthFormat && glInternalFormat === 6402) {
                                    // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                                    // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
                                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                                    if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
                                        console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
                                        texture.type = UnsignedShortType;
                                        glType = utils.convert(texture.type);
                                    }
                                }
                                if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
                                    // Depth stencil textures need the DEPTH_STENCIL internal format
                                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                                    glInternalFormat = 34041;
                                    // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
                                    // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
                                    // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
                                    if (texture.type !== UnsignedInt248Type) {
                                        console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
                                        texture.type = UnsignedInt248Type;
                                        glType = utils.convert(texture.type);
                                    }
                                }
                                //
                                if (useTexStorage && allocateMemory) {
                                    state.texStorage2D(3553, 1, glInternalFormat, image.width, image.height);
                                } else {
                                    state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
                                }
                            } else if (texture.isDataTexture) {
                                // use manually created mipmaps if available
                                // if there are no manual mipmaps
                                // set 0 level mipmap and then use GL to generate other mipmap levels
                                if (mipmaps.length > 0 && supportsMips) {
                                    if (useTexStorage && allocateMemory) {
                                        state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
                                    }
                                    for (var i = 0, il = mipmaps.length; i < il; i++) {
                                        mipmap = mipmaps[i];
                                        if (useTexStorage) {
                                            state.texSubImage2D(3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                                        } else {
                                            state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                                        }
                                    }
                                    texture.generateMipmaps = false;
                                } else {
                                    if (useTexStorage) {
                                        if (allocateMemory) {
                                            state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
                                        }
                                        state.texSubImage2D(3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
                                    } else {
                                        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
                                    }
                                }
                            } else if (texture.isCompressedTexture) {
                                if (useTexStorage && allocateMemory) {
                                    state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
                                }
                                for (var i = 0, il = mipmaps.length; i < il; i++) {
                                    mipmap = mipmaps[i];
                                    if (texture.format !== RGBAFormat) {
                                        if (glFormat !== null) {
                                            if (useTexStorage) {
                                                state.compressedTexSubImage2D(3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                                            } else {
                                                state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                                            }
                                        } else {
                                            console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                                        }
                                    } else {
                                        if (useTexStorage) {
                                            state.texSubImage2D(3553, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                                        } else {
                                            state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                                        }
                                    }
                                }
                            } else if (texture.isDataArrayTexture) {
                                if (useTexStorage) {
                                    if (allocateMemory) {
                                        state.texStorage3D(35866, levels, glInternalFormat, image.width, image.height, image.depth);
                                    }
                                    state.texSubImage3D(35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
                                } else {
                                    state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
                                }
                            } else if (texture.isData3DTexture) {
                                if (useTexStorage) {
                                    if (allocateMemory) {
                                        state.texStorage3D(32879, levels, glInternalFormat, image.width, image.height, image.depth);
                                    }
                                    state.texSubImage3D(32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
                                } else {
                                    state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
                                }
                            } else if (texture.isFramebufferTexture) {
                                if (useTexStorage && allocateMemory) {
                                    state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
                                } else {
                                    state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
                                }
                            } else {
                                // regular Texture (image, video, canvas)
                                // use manually created mipmaps if available
                                // if there are no manual mipmaps
                                // set 0 level mipmap and then use GL to generate other mipmap levels
                                if (mipmaps.length > 0 && supportsMips) {
                                    if (useTexStorage && allocateMemory) {
                                        state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
                                    }
                                    for (var i = 0, il = mipmaps.length; i < il; i++) {
                                        mipmap = mipmaps[i];
                                        if (useTexStorage) {
                                            state.texSubImage2D(3553, i, 0, 0, glFormat, glType, mipmap);
                                        } else {
                                            state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
                                        }
                                    }
                                    texture.generateMipmaps = false;
                                } else {
                                    if (useTexStorage) {
                                        if (allocateMemory) {
                                            state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
                                        }
                                        state.texSubImage2D(3553, 0, 0, 0, glFormat, glType, image);
                                    } else {
                                        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
                                    }
                                }
                            }
                            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
                                generateMipmap(textureType);
                            }
                            source.__currentVersion = source.version;
                            if (texture.onUpdate)
                                texture.onUpdate(texture);
                        }
                        textureProperties.__version = texture.version;
                    }

                    function uploadCubeTexture(textureProperties, texture, slot) {
                        if (texture.image.length !== 6)
                            return;
                        var forceUpload = initTexture(textureProperties, texture);
                        var source = texture.source;
                        state.activeTexture(33984 + slot);
                        state.bindTexture(34067, textureProperties.__webglTexture);
                        if (source.version !== source.__currentVersion || forceUpload === true) {
                            _gl.pixelStorei(37440, texture.flipY);
                            _gl.pixelStorei(37441, texture.premultiplyAlpha);
                            _gl.pixelStorei(3317, texture.unpackAlignment);
                            _gl.pixelStorei(37443, 0);
                            var isCompressed = (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
                            var isDataTexture = (texture.image[0] && texture.image[0].isDataTexture);
                            var cubeImage = [];
                            for (var i = 0; i < 6; i++) {
                                if (!isCompressed && !isDataTexture) {
                                    cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
                                } else {
                                    cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
                                }
                                cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
                            }
                            var image = cubeImage[0],
                                supportsMips = isPowerOfTwo$1(image) || isWebGL2,
                                glFormat = utils.convert(texture.format, texture.encoding),
                                glType = utils.convert(texture.type),
                                glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
                            var useTexStorage = (isWebGL2 && texture.isVideoTexture !== true);
                            var allocateMemory = (textureProperties.__version === undefined);
                            var levels = getMipLevels(texture, image, supportsMips);
                            setTextureParameters(34067, texture, supportsMips);
                            var mipmaps = void 0;
                            if (isCompressed) {
                                if (useTexStorage && allocateMemory) {
                                    state.texStorage2D(34067, levels, glInternalFormat, image.width, image.height);
                                }
                                for (var i = 0; i < 6; i++) {
                                    mipmaps = cubeImage[i].mipmaps;
                                    for (var j = 0; j < mipmaps.length; j++) {
                                        var mipmap = mipmaps[j];
                                        if (texture.format !== RGBAFormat) {
                                            if (glFormat !== null) {
                                                if (useTexStorage) {
                                                    state.compressedTexSubImage2D(34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                                                } else {
                                                    state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                                                }
                                            } else {
                                                console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
                                            }
                                        } else {
                                            if (useTexStorage) {
                                                state.texSubImage2D(34069 + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                                            } else {
                                                state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                                            }
                                        }
                                    }
                                }
                            } else {
                                mipmaps = texture.mipmaps;
                                if (useTexStorage && allocateMemory) {
                                    // TODO: Uniformly handle mipmap definitions
                                    // Normal textures and compressed cube textures define base level + mips with their mipmap array
                                    // Uncompressed cube textures use their mipmap array only for mips (no base level)
                                    if (mipmaps.length > 0)
                                        levels++;
                                    state.texStorage2D(34067, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
                                }
                                for (var i = 0; i < 6; i++) {
                                    if (isDataTexture) {
                                        if (useTexStorage) {
                                            state.texSubImage2D(34069 + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);
                                        } else {
                                            state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
                                        }
                                        for (var j = 0; j < mipmaps.length; j++) {
                                            var mipmap = mipmaps[j];
                                            var mipmapImage = mipmap.image[i].image;
                                            if (useTexStorage) {
                                                state.texSubImage2D(34069 + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                                            } else {
                                                state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
                                            }
                                        }
                                    } else {
                                        if (useTexStorage) {
                                            state.texSubImage2D(34069 + i, 0, 0, 0, glFormat, glType, cubeImage[i]);
                                        } else {
                                            state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
                                        }
                                        for (var j = 0; j < mipmaps.length; j++) {
                                            var mipmap = mipmaps[j];
                                            if (useTexStorage) {
                                                state.texSubImage2D(34069 + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);
                                            } else {
                                                state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
                                            }
                                        }
                                    }
                                }
                            }
                            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
                                // We assume images for cube map have the same size.
                                generateMipmap(34067);
                            }
                            source.__currentVersion = source.version;
                            if (texture.onUpdate)
                                texture.onUpdate(texture);
                        }
                        textureProperties.__version = texture.version;
                    }
                    // Render targets
                    // Setup storage for target texture and bind it to correct framebuffer
                    function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
                        var glFormat = utils.convert(texture.format, texture.encoding);
                        var glType = utils.convert(texture.type);
                        var glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
                        var renderTargetProperties = properties.get(renderTarget);
                        if (!renderTargetProperties.__hasExternalTextures) {
                            if (textureTarget === 32879 || textureTarget === 35866) {
                                state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
                            } else {
                                state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
                            }
                        }
                        state.bindFramebuffer(36160, framebuffer);
                        if (useMultisampledRTT(renderTarget)) {
                            multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
                        } else {
                            _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
                        }
                        state.bindFramebuffer(36160, null);
                    }
                    // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
                    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
                        _gl.bindRenderbuffer(36161, renderbuffer);
                        if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
                            var glInternalFormat = 33189;
                            if (isMultisample || useMultisampledRTT(renderTarget)) {
                                var depthTexture = renderTarget.depthTexture;
                                if (depthTexture && depthTexture.isDepthTexture) {
                                    if (depthTexture.type === FloatType) {
                                        glInternalFormat = 36012;
                                    } else if (depthTexture.type === UnsignedIntType) {
                                        glInternalFormat = 33190;
                                    }
                                }
                                var samples = getRenderTargetSamples(renderTarget);
                                if (useMultisampledRTT(renderTarget)) {
                                    multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                                } else {
                                    _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                                }
                            } else {
                                _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
                            }
                            _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
                        } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
                            var samples = getRenderTargetSamples(renderTarget);
                            if (isMultisample && useMultisampledRTT(renderTarget) === false) {
                                _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
                            } else if (useMultisampledRTT(renderTarget)) {
                                multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, 35056, renderTarget.width, renderTarget.height);
                            } else {
                                _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
                            }
                            _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
                        } else {
                            // Use the first texture for MRT so far
                            var texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
                            var glFormat = utils.convert(texture.format, texture.encoding);
                            var glType = utils.convert(texture.type);
                            var glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
                            var samples = getRenderTargetSamples(renderTarget);
                            if (isMultisample && useMultisampledRTT(renderTarget) === false) {
                                _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                            } else if (useMultisampledRTT(renderTarget)) {
                                multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                            } else {
                                _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
                            }
                        }
                        _gl.bindRenderbuffer(36161, null);
                    }
                    // Setup resources for a Depth Texture for a FBO (needs an extension)
                    function setupDepthTexture(framebuffer, renderTarget) {
                        var isCube = (renderTarget && renderTarget.isWebGLCubeRenderTarget);
                        if (isCube)
                            throw new Error('Depth Texture with cube render targets is not supported');
                        state.bindFramebuffer(36160, framebuffer);
                        if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
                            throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
                        }
                        // upload an empty depth texture with framebuffer size
                        if (!properties.get(renderTarget.depthTexture).__webglTexture ||
                            renderTarget.depthTexture.image.width !== renderTarget.width ||
                            renderTarget.depthTexture.image.height !== renderTarget.height) {
                            renderTarget.depthTexture.image.width = renderTarget.width;
                            renderTarget.depthTexture.image.height = renderTarget.height;
                            renderTarget.depthTexture.needsUpdate = true;
                        }
                        setTexture2D(renderTarget.depthTexture, 0);
                        var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
                        var samples = getRenderTargetSamples(renderTarget);
                        if (renderTarget.depthTexture.format === DepthFormat) {
                            if (useMultisampledRTT(renderTarget)) {
                                multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, webglDepthTexture, 0, samples);
                            } else {
                                _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
                            }
                        } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
                            if (useMultisampledRTT(renderTarget)) {
                                multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, webglDepthTexture, 0, samples);
                            } else {
                                _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
                            }
                        } else {
                            throw new Error('Unknown depthTexture format');
                        }
                    }
                    // Setup GL resources for a non-texture depth buffer
                    function setupDepthRenderbuffer(renderTarget) {
                        var renderTargetProperties = properties.get(renderTarget);
                        var isCube = (renderTarget.isWebGLCubeRenderTarget === true);
                        if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
                            if (isCube)
                                throw new Error('target.depthTexture not supported in Cube render targets');
                            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
                        } else {
                            if (isCube) {
                                renderTargetProperties.__webglDepthbuffer = [];
                                for (var i = 0; i < 6; i++) {
                                    state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
                                    renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                                    setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
                                }
                            } else {
                                state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
                                renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
                            }
                        }
                        state.bindFramebuffer(36160, null);
                    }
                    // rebind framebuffer with external textures
                    function rebindTextures(renderTarget, colorTexture, depthTexture) {
                        var renderTargetProperties = properties.get(renderTarget);
                        if (colorTexture !== undefined) {
                            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553);
                        }
                        if (depthTexture !== undefined) {
                            setupDepthRenderbuffer(renderTarget);
                        }
                    }
                    // Set up GL resources for the render target
                    function setupRenderTarget(renderTarget) {
                        var texture = renderTarget.texture;
                        var renderTargetProperties = properties.get(renderTarget);
                        var textureProperties = properties.get(texture);
                        renderTarget.addEventListener('dispose', onRenderTargetDispose);
                        if (renderTarget.isWebGLMultipleRenderTargets !== true) {
                            if (textureProperties.__webglTexture === undefined) {
                                textureProperties.__webglTexture = _gl.createTexture();
                            }
                            textureProperties.__version = texture.version;
                            info.memory.textures++;
                        }
                        var isCube = (renderTarget.isWebGLCubeRenderTarget === true);
                        var isMultipleRenderTargets = (renderTarget.isWebGLMultipleRenderTargets === true);
                        var supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
                        // Setup framebuffer
                        if (isCube) {
                            renderTargetProperties.__webglFramebuffer = [];
                            for (var i = 0; i < 6; i++) {
                                renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
                            }
                        } else {
                            renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
                            if (isMultipleRenderTargets) {
                                if (capabilities.drawBuffers) {
                                    var textures = renderTarget.texture;
                                    for (var i = 0, il = textures.length; i < il; i++) {
                                        var attachmentProperties = properties.get(textures[i]);
                                        if (attachmentProperties.__webglTexture === undefined) {
                                            attachmentProperties.__webglTexture = _gl.createTexture();
                                            info.memory.textures++;
                                        }
                                    }
                                } else {
                                    console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');
                                }
                            } else if ((isWebGL2 && renderTarget.samples > 0) && useMultisampledRTT(renderTarget) === false) {
                                renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                                renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
                                _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
                                var glFormat = utils.convert(texture.format, texture.encoding);
                                var glType = utils.convert(texture.type);
                                var glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
                                var samples = getRenderTargetSamples(renderTarget);
                                _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                                state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
                                _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
                                _gl.bindRenderbuffer(36161, null);
                                if (renderTarget.depthBuffer) {
                                    renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                                    setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
                                }
                                state.bindFramebuffer(36160, null);
                            }
                        }
                        // Setup color buffer
                        if (isCube) {
                            state.bindTexture(34067, textureProperties.__webglTexture);
                            setTextureParameters(34067, texture, supportsMips);
                            for (var i = 0; i < 6; i++) {
                                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, 36064, 34069 + i);
                            }
                            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
                                generateMipmap(34067);
                            }
                            state.unbindTexture();
                        } else if (isMultipleRenderTargets) {
                            var textures = renderTarget.texture;
                            for (var i = 0, il = textures.length; i < il; i++) {
                                var attachment = textures[i];
                                var attachmentProperties = properties.get(attachment);
                                state.bindTexture(3553, attachmentProperties.__webglTexture);
                                setTextureParameters(3553, attachment, supportsMips);
                                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i, 3553);
                                if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
                                    generateMipmap(3553);
                                }
                            }
                            state.unbindTexture();
                        } else {
                            var glTextureType = 3553;
                            if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
                                if (isWebGL2) {
                                    glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;
                                } else {
                                    console.error('THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.');
                                }
                            }
                            state.bindTexture(glTextureType, textureProperties.__webglTexture);
                            setTextureParameters(glTextureType, texture, supportsMips);
                            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
                            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
                                generateMipmap(glTextureType);
                            }
                            state.unbindTexture();
                        }
                        // Setup depth and stencil buffers
                        if (renderTarget.depthBuffer) {
                            setupDepthRenderbuffer(renderTarget);
                        }
                    }

                    function updateRenderTargetMipmap(renderTarget) {
                        var supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
                        var textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
                        for (var i = 0, il = textures.length; i < il; i++) {
                            var texture = textures[i];
                            if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
                                var target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
                                var webglTexture = properties.get(texture).__webglTexture;
                                state.bindTexture(target, webglTexture);
                                generateMipmap(target);
                                state.unbindTexture();
                            }
                        }
                    }

                    function updateMultisampleRenderTarget(renderTarget) {
                        if ((isWebGL2 && renderTarget.samples > 0) && useMultisampledRTT(renderTarget) === false) {
                            var width = renderTarget.width;
                            var height = renderTarget.height;
                            var mask = 16384;
                            var invalidationArray = [36064];
                            var depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
                            if (renderTarget.depthBuffer) {
                                invalidationArray.push(depthStyle);
                            }
                            var renderTargetProperties = properties.get(renderTarget);
                            var ignoreDepthValues = (renderTargetProperties.__ignoreDepthValues !== undefined) ? renderTargetProperties.__ignoreDepthValues : false;
                            if (ignoreDepthValues === false) {
                                if (renderTarget.depthBuffer)
                                    mask |= 256;
                                if (renderTarget.stencilBuffer)
                                    mask |= 1024;
                            }
                            state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
                            state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
                            if (ignoreDepthValues === true) {
                                _gl.invalidateFramebuffer(36008, [depthStyle]);
                                _gl.invalidateFramebuffer(36009, [depthStyle]);
                            }
                            _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
                            if (supportsInvalidateFramebuffer) {
                                _gl.invalidateFramebuffer(36008, invalidationArray);
                            }
                            state.bindFramebuffer(36008, null);
                            state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
                        }
                    }

                    function getRenderTargetSamples(renderTarget) {
                        return Math.min(maxSamples, renderTarget.samples);
                    }

                    function useMultisampledRTT(renderTarget) {
                        var renderTargetProperties = properties.get(renderTarget);
                        return isWebGL2 && renderTarget.samples > 0 && extensions.has('WEBGL_multisampled_render_to_texture') === true && renderTargetProperties.__useRenderToTexture !== false;
                    }

                    function updateVideoTexture(texture) {
                        var frame = info.render.frame;
                        // Check the last frame we updated the VideoTexture
                        if (_videoTextures.get(texture) !== frame) {
                            _videoTextures.set(texture, frame);
                            texture.update();
                        }
                    }

                    function verifyColorSpace(texture, image) {
                        var encoding = texture.encoding;
                        var format = texture.format;
                        var type = texture.type;
                        if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat)
                            return image;
                        if (encoding !== LinearEncoding) {
                            // sRGB
                            if (encoding === sRGBEncoding) {
                                if (isWebGL2 === false) {
                                    // in WebGL 1, try to use EXT_sRGB extension and unsized formats
                                    if (extensions.has('EXT_sRGB') === true && format === RGBAFormat) {
                                        texture.format = _SRGBAFormat;
                                        // it's not possible to generate mips in WebGL 1 with this extension
                                        texture.minFilter = LinearFilter;
                                        texture.generateMipmaps = false;
                                    } else {
                                        // slow fallback (CPU decode)
                                        image = ImageUtils.sRGBToLinear(image);
                                    }
                                } else {
                                    // in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format
                                    if (format !== RGBAFormat || type !== UnsignedByteType) {
                                        console.warn('THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.');
                                    }
                                }
                            } else {
                                console.error('THREE.WebGLTextures: Unsupported texture encoding:', encoding);
                            }
                        }
                        return image;
                    }
                    //
                    this.allocateTextureUnit = allocateTextureUnit;
                    this.resetTextureUnits = resetTextureUnits;
                    this.setTexture2D = setTexture2D;
                    this.setTexture2DArray = setTexture2DArray;
                    this.setTexture3D = setTexture3D;
                    this.setTextureCube = setTextureCube;
                    this.rebindTextures = rebindTextures;
                    this.setupRenderTarget = setupRenderTarget;
                    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
                    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
                    this.setupDepthRenderbuffer = setupDepthRenderbuffer;
                    this.setupFrameBufferTexture = setupFrameBufferTexture;
                    this.useMultisampledRTT = useMultisampledRTT;
                }

                function WebGLUtils(gl, extensions, capabilities) {
                    var isWebGL2 = capabilities.isWebGL2;

                    function convert(p, encoding) {
                        if (encoding === void 0) {
                            encoding = null;
                        }
                        var extension;
                        if (p === UnsignedByteType)
                            return 5121;
                        if (p === UnsignedShort4444Type)
                            return 32819;
                        if (p === UnsignedShort5551Type)
                            return 32820;
                        if (p === ByteType)
                            return 5120;
                        if (p === ShortType)
                            return 5122;
                        if (p === UnsignedShortType)
                            return 5123;
                        if (p === IntType)
                            return 5124;
                        if (p === UnsignedIntType)
                            return 5125;
                        if (p === FloatType)
                            return 5126;
                        if (p === HalfFloatType) {
                            if (isWebGL2)
                                return 5131;
                            extension = extensions.get('OES_texture_half_float');
                            if (extension !== null) {
                                return extension.HALF_FLOAT_OES;
                            } else {
                                return null;
                            }
                        }
                        if (p === AlphaFormat)
                            return 6406;
                        if (p === RGBAFormat)
                            return 6408;
                        if (p === LuminanceFormat)
                            return 6409;
                        if (p === LuminanceAlphaFormat)
                            return 6410;
                        if (p === DepthFormat)
                            return 6402;
                        if (p === DepthStencilFormat)
                            return 34041;
                        if (p === RedFormat)
                            return 6403;
                        if (p === RGBFormat) {
                            console.warn('THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228');
                            return 6408;
                        }
                        // WebGL 1 sRGB fallback
                        if (p === _SRGBAFormat) {
                            extension = extensions.get('EXT_sRGB');
                            if (extension !== null) {
                                return extension.SRGB_ALPHA_EXT;
                            } else {
                                return null;
                            }
                        }
                        // WebGL2 formats.
                        if (p === RedIntegerFormat)
                            return 36244;
                        if (p === RGFormat)
                            return 33319;
                        if (p === RGIntegerFormat)
                            return 33320;
                        if (p === RGBAIntegerFormat)
                            return 36249;
                        // S3TC
                        if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
                            if (encoding === sRGBEncoding) {
                                extension = extensions.get('WEBGL_compressed_texture_s3tc_srgb');
                                if (extension !== null) {
                                    if (p === RGB_S3TC_DXT1_Format)
                                        return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                    if (p === RGBA_S3TC_DXT1_Format)
                                        return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                    if (p === RGBA_S3TC_DXT3_Format)
                                        return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                    if (p === RGBA_S3TC_DXT5_Format)
                                        return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                                } else {
                                    return null;
                                }
                            } else {
                                extension = extensions.get('WEBGL_compressed_texture_s3tc');
                                if (extension !== null) {
                                    if (p === RGB_S3TC_DXT1_Format)
                                        return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                    if (p === RGBA_S3TC_DXT1_Format)
                                        return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                    if (p === RGBA_S3TC_DXT3_Format)
                                        return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                    if (p === RGBA_S3TC_DXT5_Format)
                                        return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                                } else {
                                    return null;
                                }
                            }
                        }
                        // PVRTC
                        if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
                            extension = extensions.get('WEBGL_compressed_texture_pvrtc');
                            if (extension !== null) {
                                if (p === RGB_PVRTC_4BPPV1_Format)
                                    return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                if (p === RGB_PVRTC_2BPPV1_Format)
                                    return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                if (p === RGBA_PVRTC_4BPPV1_Format)
                                    return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                if (p === RGBA_PVRTC_2BPPV1_Format)
                                    return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                            } else {
                                return null;
                            }
                        }
                        // ETC1
                        if (p === RGB_ETC1_Format) {
                            extension = extensions.get('WEBGL_compressed_texture_etc1');
                            if (extension !== null) {
                                return extension.COMPRESSED_RGB_ETC1_WEBGL;
                            } else {
                                return null;
                            }
                        }
                        // ETC2
                        if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
                            extension = extensions.get('WEBGL_compressed_texture_etc');
                            if (extension !== null) {
                                if (p === RGB_ETC2_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
                                if (p === RGBA_ETC2_EAC_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
                            } else {
                                return null;
                            }
                        }
                        // ASTC
                        if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
                            p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
                            p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
                            p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
                            p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
                            extension = extensions.get('WEBGL_compressed_texture_astc');
                            if (extension !== null) {
                                if (p === RGBA_ASTC_4x4_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
                                if (p === RGBA_ASTC_5x4_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
                                if (p === RGBA_ASTC_5x5_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
                                if (p === RGBA_ASTC_6x5_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
                                if (p === RGBA_ASTC_6x6_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
                                if (p === RGBA_ASTC_8x5_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
                                if (p === RGBA_ASTC_8x6_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
                                if (p === RGBA_ASTC_8x8_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
                                if (p === RGBA_ASTC_10x5_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
                                if (p === RGBA_ASTC_10x6_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
                                if (p === RGBA_ASTC_10x8_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
                                if (p === RGBA_ASTC_10x10_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
                                if (p === RGBA_ASTC_12x10_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
                                if (p === RGBA_ASTC_12x12_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
                            } else {
                                return null;
                            }
                        }
                        // BPTC
                        if (p === RGBA_BPTC_Format) {
                            extension = extensions.get('EXT_texture_compression_bptc');
                            if (extension !== null) {
                                if (p === RGBA_BPTC_Format)
                                    return (encoding === sRGBEncoding) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                            } else {
                                return null;
                            }
                        }
                        //
                        if (p === UnsignedInt248Type) {
                            if (isWebGL2)
                                return 34042;
                            extension = extensions.get('WEBGL_depth_texture');
                            if (extension !== null) {
                                return extension.UNSIGNED_INT_24_8_WEBGL;
                            } else {
                                return null;
                            }
                        }
                    }
                    return {
                        convert: convert
                    };
                }
                var ArrayCamera = /** @class */ (function(_super) {
                    __extends(ArrayCamera, _super);

                    function ArrayCamera(array) {
                        if (array === void 0) {
                            array = [];
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.cameras = array;
                        return _this_1;
                    }
                    return ArrayCamera;
                }(PerspectiveCamera));
                ArrayCamera.prototype.isArrayCamera = true;
                var Group = /** @class */ (function(_super) {
                    __extends(Group, _super);

                    function Group() {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'Group';
                        return _this_1;
                    }
                    return Group;
                }(Object3D));
                Group.prototype.isGroup = true;
                var _moveEvent = {
                    type: 'move'
                };
                var WebXRController = /** @class */ (function() {
                    function WebXRController() {
                        this._targetRay = null;
                        this._grip = null;
                        this._hand = null;
                    }
                    WebXRController.prototype.getHandSpace = function() {
                        if (this._hand === null) {
                            this._hand = new Group();
                            this._hand.matrixAutoUpdate = false;
                            this._hand.visible = false;
                            this._hand.joints = {};
                            this._hand.inputState = {
                                pinching: false
                            };
                        }
                        return this._hand;
                    };
                    WebXRController.prototype.getTargetRaySpace = function() {
                        if (this._targetRay === null) {
                            this._targetRay = new Group();
                            this._targetRay.matrixAutoUpdate = false;
                            this._targetRay.visible = false;
                            this._targetRay.hasLinearVelocity = false;
                            this._targetRay.linearVelocity = new Vector3();
                            this._targetRay.hasAngularVelocity = false;
                            this._targetRay.angularVelocity = new Vector3();
                        }
                        return this._targetRay;
                    };
                    WebXRController.prototype.getGripSpace = function() {
                        if (this._grip === null) {
                            this._grip = new Group();
                            this._grip.matrixAutoUpdate = false;
                            this._grip.visible = false;
                            this._grip.hasLinearVelocity = false;
                            this._grip.linearVelocity = new Vector3();
                            this._grip.hasAngularVelocity = false;
                            this._grip.angularVelocity = new Vector3();
                        }
                        return this._grip;
                    };
                    WebXRController.prototype.dispatchEvent = function(event) {
                        if (this._targetRay !== null) {
                            this._targetRay.dispatchEvent(event);
                        }
                        if (this._grip !== null) {
                            this._grip.dispatchEvent(event);
                        }
                        if (this._hand !== null) {
                            this._hand.dispatchEvent(event);
                        }
                        return this;
                    };
                    WebXRController.prototype.disconnect = function(inputSource) {
                        this.dispatchEvent({
                            type: 'disconnected',
                            data: inputSource
                        });
                        if (this._targetRay !== null) {
                            this._targetRay.visible = false;
                        }
                        if (this._grip !== null) {
                            this._grip.visible = false;
                        }
                        if (this._hand !== null) {
                            this._hand.visible = false;
                        }
                        return this;
                    };
                    WebXRController.prototype.update = function(inputSource, frame, referenceSpace) {
                        var e_2, _a;
                        var inputPose = null;
                        var gripPose = null;
                        var handPose = null;
                        var targetRay = this._targetRay;
                        var grip = this._grip;
                        var hand = this._hand;
                        if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
                            if (targetRay !== null) {
                                inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
                                if (inputPose !== null) {
                                    targetRay.matrix.fromArray(inputPose.transform.matrix);
                                    targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                                    if (inputPose.linearVelocity) {
                                        targetRay.hasLinearVelocity = true;
                                        targetRay.linearVelocity.copy(inputPose.linearVelocity);
                                    } else {
                                        targetRay.hasLinearVelocity = false;
                                    }
                                    if (inputPose.angularVelocity) {
                                        targetRay.hasAngularVelocity = true;
                                        targetRay.angularVelocity.copy(inputPose.angularVelocity);
                                    } else {
                                        targetRay.hasAngularVelocity = false;
                                    }
                                    this.dispatchEvent(_moveEvent);
                                }
                            }
                            if (hand && inputSource.hand) {
                                handPose = true;
                                try {
                                    for (var _b = __values(inputSource.hand.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                                        var inputjoint = _c.value;
                                        // Update the joints groups with the XRJoint poses
                                        var jointPose = frame.getJointPose(inputjoint, referenceSpace);
                                        if (hand.joints[inputjoint.jointName] === undefined) {
                                            // The transform of this joint will be updated with the joint pose on each frame
                                            var joint_1 = new Group();
                                            joint_1.matrixAutoUpdate = false;
                                            joint_1.visible = false;
                                            hand.joints[inputjoint.jointName] = joint_1;
                                            // ??
                                            hand.add(joint_1);
                                        }
                                        var joint = hand.joints[inputjoint.jointName];
                                        if (jointPose !== null) {
                                            joint.matrix.fromArray(jointPose.transform.matrix);
                                            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                                            joint.jointRadius = jointPose.radius;
                                        }
                                        joint.visible = jointPose !== null;
                                    }
                                } catch (e_2_1) {
                                    e_2 = {
                                        error: e_2_1
                                    };
                                } finally {
                                    try {
                                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                    } finally {
                                        if (e_2) throw e_2.error;
                                    }
                                }
                                // Custom events
                                // Check pinchz
                                var indexTip = hand.joints['index-finger-tip'];
                                var thumbTip = hand.joints['thumb-tip'];
                                var distance = indexTip.position.distanceTo(thumbTip.position);
                                var distanceToPinch = 0.02;
                                var threshold = 0.005;
                                if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                                    hand.inputState.pinching = false;
                                    this.dispatchEvent({
                                        type: 'pinchend',
                                        handedness: inputSource.handedness,
                                        target: this
                                    });
                                } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                                    hand.inputState.pinching = true;
                                    this.dispatchEvent({
                                        type: 'pinchstart',
                                        handedness: inputSource.handedness,
                                        target: this
                                    });
                                }
                            } else {
                                if (grip !== null && inputSource.gripSpace) {
                                    gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                                    if (gripPose !== null) {
                                        grip.matrix.fromArray(gripPose.transform.matrix);
                                        grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                                        if (gripPose.linearVelocity) {
                                            grip.hasLinearVelocity = true;
                                            grip.linearVelocity.copy(gripPose.linearVelocity);
                                        } else {
                                            grip.hasLinearVelocity = false;
                                        }
                                        if (gripPose.angularVelocity) {
                                            grip.hasAngularVelocity = true;
                                            grip.angularVelocity.copy(gripPose.angularVelocity);
                                        } else {
                                            grip.hasAngularVelocity = false;
                                        }
                                    }
                                }
                            }
                        }
                        if (targetRay !== null) {
                            targetRay.visible = (inputPose !== null);
                        }
                        if (grip !== null) {
                            grip.visible = (gripPose !== null);
                        }
                        if (hand !== null) {
                            hand.visible = (handPose !== null);
                        }
                        return this;
                    };
                    return WebXRController;
                }());
                var DepthTexture = /** @class */ (function(_super) {
                    __extends(DepthTexture, _super);

                    function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
                        var _this_1 = this;
                        format = format !== undefined ? format : DepthFormat;
                        if (format !== DepthFormat && format !== DepthStencilFormat) {
                            throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
                        }
                        if (type === undefined && format === DepthFormat)
                            type = UnsignedShortType;
                        if (type === undefined && format === DepthStencilFormat)
                            type = UnsignedInt248Type;
                        _this_1 = _super.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) || this;
                        _this_1.image = {
                            width: width,
                            height: height
                        };
                        _this_1.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
                        _this_1.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
                        _this_1.flipY = false;
                        _this_1.generateMipmaps = false;
                        return _this_1;
                    }
                    return DepthTexture;
                }(Texture));
                DepthTexture.prototype.isDepthTexture = true;
                var WebXRManager = /** @class */ (function(_super) {
                    __extends(WebXRManager, _super);

                    function WebXRManager(renderer, gl) {
                        var _this_1 = _super.call(this) || this;
                        var scope = _this_1;
                        var session = null;
                        var framebufferScaleFactor = 1.0;
                        var referenceSpace = null;
                        var referenceSpaceType = 'local-floor';
                        var pose = null;
                        var glBinding = null;
                        var glProjLayer = null;
                        var glBaseLayer = null;
                        var xrFrame = null;
                        var attributes = gl.getContextAttributes();
                        var initialRenderTarget = null;
                        var newRenderTarget = null;
                        var controllers = [];
                        var inputSourcesMap = new Map();
                        //
                        var cameraL = new PerspectiveCamera();
                        cameraL.layers.enable(1);
                        cameraL.viewport = new Vector4();
                        var cameraR = new PerspectiveCamera();
                        cameraR.layers.enable(2);
                        cameraR.viewport = new Vector4();
                        var cameras = [cameraL, cameraR];
                        var cameraVR = new ArrayCamera();
                        cameraVR.layers.enable(1);
                        cameraVR.layers.enable(2);
                        var _currentDepthNear = null;
                        var _currentDepthFar = null;
                        //
                        _this_1.cameraAutoUpdate = true;
                        _this_1.enabled = false;
                        _this_1.isPresenting = false;
                        _this_1.getController = function(index) {
                            var controller = controllers[index];
                            if (controller === undefined) {
                                controller = new WebXRController();
                                controllers[index] = controller;
                            }
                            return controller.getTargetRaySpace();
                        };
                        _this_1.getControllerGrip = function(index) {
                            var controller = controllers[index];
                            if (controller === undefined) {
                                controller = new WebXRController();
                                controllers[index] = controller;
                            }
                            return controller.getGripSpace();
                        };
                        _this_1.getHand = function(index) {
                            var controller = controllers[index];
                            if (controller === undefined) {
                                controller = new WebXRController();
                                controllers[index] = controller;
                            }
                            return controller.getHandSpace();
                        };
                        //
                        function onSessionEvent(event) {
                            var controller = inputSourcesMap.get(event.inputSource);
                            if (controller) {
                                controller.dispatchEvent({
                                    type: event.type,
                                    data: event.inputSource
                                });
                            }
                        }

                        function onSessionEnd() {
                            inputSourcesMap.forEach(function(controller, inputSource) {
                                controller.disconnect(inputSource);
                            });
                            inputSourcesMap.clear();
                            _currentDepthNear = null;
                            _currentDepthFar = null;
                            // restore framebuffer/rendering state
                            renderer.setRenderTarget(initialRenderTarget);
                            glBaseLayer = null;
                            glProjLayer = null;
                            glBinding = null;
                            session = null;
                            newRenderTarget = null;
                            //
                            animation.stop();
                            scope.isPresenting = false;
                            scope.dispatchEvent({
                                type: 'sessionend'
                            });
                        }
                        _this_1.setFramebufferScaleFactor = function(value) {
                            framebufferScaleFactor = value;
                            if (scope.isPresenting === true) {
                                console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
                            }
                        };
                        _this_1.setReferenceSpaceType = function(value) {
                            referenceSpaceType = value;
                            if (scope.isPresenting === true) {
                                console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
                            }
                        };
                        _this_1.getReferenceSpace = function() {
                            return referenceSpace;
                        };
                        _this_1.getBaseLayer = function() {
                            return glProjLayer !== null ? glProjLayer : glBaseLayer;
                        };
                        _this_1.getBinding = function() {
                            return glBinding;
                        };
                        _this_1.getFrame = function() {
                            return xrFrame;
                        };
                        _this_1.getSession = function() {
                            return session;
                        };
                        _this_1.setSession = function(value) {
                            return __awaiter(this, void 0, void 0, function() {
                                var layerInit, depthFormat, depthType, glDepthFormat, projectionlayerInit, renderTargetProperties;
                                return __generator(this, function(_a) {
                                    switch (_a.label) {
                                        case 0:
                                            session = value;
                                            if (!(session !== null)) return [3 /*break*/ , 4];
                                            initialRenderTarget = renderer.getRenderTarget();
                                            session.addEventListener('select', onSessionEvent);
                                            session.addEventListener('selectstart', onSessionEvent);
                                            session.addEventListener('selectend', onSessionEvent);
                                            session.addEventListener('squeeze', onSessionEvent);
                                            session.addEventListener('squeezestart', onSessionEvent);
                                            session.addEventListener('squeezeend', onSessionEvent);
                                            session.addEventListener('end', onSessionEnd);
                                            session.addEventListener('inputsourceschange', onInputSourcesChange);
                                            if (!(attributes.xrCompatible !== true)) return [3 /*break*/ , 2];
                                            return [4 /*yield*/ , gl.makeXRCompatible()];
                                        case 1:
                                            _a.sent();
                                            _a.label = 2;
                                        case 2:
                                            if ((session.renderState.layers === undefined) || (renderer.capabilities.isWebGL2 === false)) {
                                                layerInit = {
                                                    antialias: (session.renderState.layers === undefined) ? attributes.antialias : true,
                                                    alpha: attributes.alpha,
                                                    depth: attributes.depth,
                                                    stencil: attributes.stencil,
                                                    framebufferScaleFactor: framebufferScaleFactor
                                                };
                                                glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                                                session.updateRenderState({
                                                    baseLayer: glBaseLayer
                                                });
                                                newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
                                                    format: RGBAFormat,
                                                    type: UnsignedByteType,
                                                    encoding: renderer.outputEncoding
                                                });
                                            } else {
                                                depthFormat = null;
                                                depthType = null;
                                                glDepthFormat = null;
                                                if (attributes.depth) {
                                                    glDepthFormat = attributes.stencil ? 35056 : 33190;
                                                    depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
                                                    depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;
                                                }
                                                projectionlayerInit = {
                                                    colorFormat: (renderer.outputEncoding === sRGBEncoding) ? 35907 : 32856,
                                                    depthFormat: glDepthFormat,
                                                    scaleFactor: framebufferScaleFactor
                                                };
                                                glBinding = new XRWebGLBinding(session, gl);
                                                glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                                                session.updateRenderState({
                                                    layers: [glProjLayer]
                                                });
                                                newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
                                                    format: RGBAFormat,
                                                    type: UnsignedByteType,
                                                    depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),
                                                    stencilBuffer: attributes.stencil,
                                                    encoding: renderer.outputEncoding,
                                                    samples: attributes.antialias ? 4 : 0
                                                });
                                                renderTargetProperties = renderer.properties.get(newRenderTarget);
                                                renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
                                            }
                                            newRenderTarget.isXRRenderTarget = true; // TODO Remove this when possible, see #23278
                                            // Set foveation to maximum.
                                            this.setFoveation(1.0);
                                            return [4 /*yield*/ , session.requestReferenceSpace(referenceSpaceType)];
                                        case 3:
                                            referenceSpace = _a.sent();
                                            animation.setContext(session);
                                            animation.start();
                                            scope.isPresenting = true;
                                            scope.dispatchEvent({
                                                type: 'sessionstart'
                                            });
                                            _a.label = 4;
                                        case 4:
                                            return [2 /*return*/ ];
                                    }
                                });
                            });
                        };

                        function onInputSourcesChange(event) {
                            var inputSources = session.inputSources;
                            // Assign inputSources to available controllers
                            for (var i = 0; i < controllers.length; i++) {
                                inputSourcesMap.set(inputSources[i], controllers[i]);
                            }
                            // Notify disconnected
                            for (var i = 0; i < event.removed.length; i++) {
                                var inputSource = event.removed[i];
                                var controller = inputSourcesMap.get(inputSource);
                                if (controller) {
                                    controller.dispatchEvent({
                                        type: 'disconnected',
                                        data: inputSource
                                    });
                                    inputSourcesMap.delete(inputSource);
                                }
                            }
                            // Notify connected
                            for (var i = 0; i < event.added.length; i++) {
                                var inputSource = event.added[i];
                                var controller = inputSourcesMap.get(inputSource);
                                if (controller) {
                                    controller.dispatchEvent({
                                        type: 'connected',
                                        data: inputSource
                                    });
                                }
                            }
                        }
                        //
                        var cameraLPos = new Vector3();
                        var cameraRPos = new Vector3();
                        /**
                         * Assumes 2 cameras that are parallel and share an X-axis, and that
                         * the cameras' projection and world matrices have already been set.
                         * And that near and far planes are identical for both cameras.
                         * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
                         */
                        function setProjectionFromUnion(camera, cameraL, cameraR) {
                            cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
                            cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
                            var ipd = cameraLPos.distanceTo(cameraRPos);
                            var projL = cameraL.projectionMatrix.elements;
                            var projR = cameraR.projectionMatrix.elements;
                            // VR systems will have identical far and near planes, and
                            // most likely identical top and bottom frustum extents.
                            // Use the left camera for these values.
                            var near = projL[14] / (projL[10] - 1);
                            var far = projL[14] / (projL[10] + 1);
                            var topFov = (projL[9] + 1) / projL[5];
                            var bottomFov = (projL[9] - 1) / projL[5];
                            var leftFov = (projL[8] - 1) / projL[0];
                            var rightFov = (projR[8] + 1) / projR[0];
                            var left = near * leftFov;
                            var right = near * rightFov;
                            // Calculate the new camera's position offset from the
                            // left camera. xOffset should be roughly half `ipd`.
                            var zOffset = ipd / (-leftFov + rightFov);
                            var xOffset = zOffset * -leftFov;
                            // TODO: Better way to apply this offset?
                            cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
                            camera.translateX(xOffset);
                            camera.translateZ(zOffset);
                            camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
                            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
                            // Find the union of the frustum values of the cameras and scale
                            // the values so that the near plane's position does not change in world space,
                            // although must now be relative to the new union camera.
                            var near2 = near + zOffset;
                            var far2 = far + zOffset;
                            var left2 = left - xOffset;
                            var right2 = right + (ipd - xOffset);
                            var top2 = topFov * far / far2 * near2;
                            var bottom2 = bottomFov * far / far2 * near2;
                            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
                        }

                        function updateCamera(camera, parent) {
                            if (parent === null) {
                                camera.matrixWorld.copy(camera.matrix);
                            } else {
                                camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
                            }
                            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
                        }
                        _this_1.updateCamera = function(camera) {
                            if (session === null)
                                return;
                            cameraVR.near = cameraR.near = cameraL.near = camera.near;
                            cameraVR.far = cameraR.far = cameraL.far = camera.far;
                            if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
                                // Note that the new renderState won't apply until the next frame. See #18320
                                session.updateRenderState({
                                    depthNear: cameraVR.near,
                                    depthFar: cameraVR.far
                                });
                                _currentDepthNear = cameraVR.near;
                                _currentDepthFar = cameraVR.far;
                            }
                            var parent = camera.parent;
                            var cameras = cameraVR.cameras;
                            updateCamera(cameraVR, parent);
                            for (var i = 0; i < cameras.length; i++) {
                                updateCamera(cameras[i], parent);
                            }
                            cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
                            // update user camera and its children
                            camera.position.copy(cameraVR.position);
                            camera.quaternion.copy(cameraVR.quaternion);
                            camera.scale.copy(cameraVR.scale);
                            camera.matrix.copy(cameraVR.matrix);
                            camera.matrixWorld.copy(cameraVR.matrixWorld);
                            var children = camera.children;
                            for (var i = 0, l = children.length; i < l; i++) {
                                children[i].updateMatrixWorld(true);
                            }
                            // update projection matrix for proper view frustum culling
                            if (cameras.length === 2) {
                                setProjectionFromUnion(cameraVR, cameraL, cameraR);
                            } else {
                                // assume single camera setup (AR)
                                cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
                            }
                        };
                        _this_1.getCamera = function() {
                            return cameraVR;
                        };
                        _this_1.getFoveation = function() {
                            if (glProjLayer !== null) {
                                return glProjLayer.fixedFoveation;
                            }
                            if (glBaseLayer !== null) {
                                return glBaseLayer.fixedFoveation;
                            }
                            return undefined;
                        };
                        _this_1.setFoveation = function(foveation) {
                            // 0 = no foveation = full resolution
                            // 1 = maximum foveation = the edges render at lower resolution
                            if (glProjLayer !== null) {
                                glProjLayer.fixedFoveation = foveation;
                            }
                            if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {
                                glBaseLayer.fixedFoveation = foveation;
                            }
                        };
                        // Animation Loop
                        var onAnimationFrameCallback = null;

                        function onAnimationFrame(time, frame) {
                            pose = frame.getViewerPose(referenceSpace);
                            xrFrame = frame;
                            if (pose !== null) {
                                var views = pose.views;
                                if (glBaseLayer !== null) {
                                    renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
                                    renderer.setRenderTarget(newRenderTarget);
                                }
                                var cameraVRNeedsUpdate = false;
                                // check if it's necessary to rebuild cameraVR's camera list
                                if (views.length !== cameraVR.cameras.length) {
                                    cameraVR.cameras.length = 0;
                                    cameraVRNeedsUpdate = true;
                                }
                                for (var i = 0; i < views.length; i++) {
                                    var view = views[i];
                                    var viewport = null;
                                    if (glBaseLayer !== null) {
                                        viewport = glBaseLayer.getViewport(view);
                                    } else {
                                        var glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                                        viewport = glSubImage.viewport;
                                        // For side-by-side projection, we only produce a single texture for both eyes.
                                        if (i === 0) {
                                            renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture);
                                            renderer.setRenderTarget(newRenderTarget);
                                        }
                                    }
                                    var camera = cameras[i];
                                    camera.matrix.fromArray(view.transform.matrix);
                                    camera.projectionMatrix.fromArray(view.projectionMatrix);
                                    camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                                    if (i === 0) {
                                        cameraVR.matrix.copy(camera.matrix);
                                    }
                                    if (cameraVRNeedsUpdate === true) {
                                        cameraVR.cameras.push(camera);
                                    }
                                }
                            }
                            //
                            var inputSources = session.inputSources;
                            for (var i = 0; i < controllers.length; i++) {
                                var controller = controllers[i];
                                var inputSource = inputSources[i];
                                controller.update(inputSource, frame, referenceSpace);
                            }
                            if (onAnimationFrameCallback)
                                onAnimationFrameCallback(time, frame);
                            xrFrame = null;
                        }
                        var animation = new WebGLAnimation();
                        animation.setAnimationLoop(onAnimationFrame);
                        _this_1.setAnimationLoop = function(callback) {
                            onAnimationFrameCallback = callback;
                        };
                        _this_1.dispose = function() {};
                        return _this_1;
                    }
                    return WebXRManager;
                }(EventDispatcher));

                function WebGLMaterials(renderer, properties) {
                    function refreshFogUniforms(uniforms, fog) {
                        uniforms.fogColor.value.copy(fog.color);
                        if (fog.isFog) {
                            uniforms.fogNear.value = fog.near;
                            uniforms.fogFar.value = fog.far;
                        } else if (fog.isFogExp2) {
                            uniforms.fogDensity.value = fog.density;
                        }
                    }

                    function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
                        if (material.isMeshBasicMaterial) {
                            refreshUniformsCommon(uniforms, material);
                        } else if (material.isMeshLambertMaterial) {
                            refreshUniformsCommon(uniforms, material);
                        } else if (material.isMeshToonMaterial) {
                            refreshUniformsCommon(uniforms, material);
                            refreshUniformsToon(uniforms, material);
                        } else if (material.isMeshPhongMaterial) {
                            refreshUniformsCommon(uniforms, material);
                            refreshUniformsPhong(uniforms, material);
                        } else if (material.isMeshStandardMaterial) {
                            refreshUniformsCommon(uniforms, material);
                            refreshUniformsStandard(uniforms, material);
                            if (material.isMeshPhysicalMaterial) {
                                refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
                            }
                        } else if (material.isMeshMatcapMaterial) {
                            refreshUniformsCommon(uniforms, material);
                            refreshUniformsMatcap(uniforms, material);
                        } else if (material.isMeshDepthMaterial) {
                            refreshUniformsCommon(uniforms, material);
                        } else if (material.isMeshDistanceMaterial) {
                            refreshUniformsCommon(uniforms, material);
                            refreshUniformsDistance(uniforms, material);
                        } else if (material.isMeshNormalMaterial) {
                            refreshUniformsCommon(uniforms, material);
                        } else if (material.isLineBasicMaterial) {
                            refreshUniformsLine(uniforms, material);
                            if (material.isLineDashedMaterial) {
                                refreshUniformsDash(uniforms, material);
                            }
                        } else if (material.isPointsMaterial) {
                            refreshUniformsPoints(uniforms, material, pixelRatio, height);
                        } else if (material.isSpriteMaterial) {
                            refreshUniformsSprites(uniforms, material);
                        } else if (material.isShadowMaterial) {
                            uniforms.color.value.copy(material.color);
                            uniforms.opacity.value = material.opacity;
                        } else if (material.isShaderMaterial) {
                            material.uniformsNeedUpdate = false; // #15581
                        }
                    }

                    function refreshUniformsCommon(uniforms, material) {
                        uniforms.opacity.value = material.opacity;
                        if (material.color) {
                            uniforms.diffuse.value.copy(material.color);
                        }
                        if (material.emissive) {
                            uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
                        }
                        if (material.map) {
                            uniforms.map.value = material.map;
                        }
                        if (material.alphaMap) {
                            uniforms.alphaMap.value = material.alphaMap;
                        }
                        if (material.bumpMap) {
                            uniforms.bumpMap.value = material.bumpMap;
                            uniforms.bumpScale.value = material.bumpScale;
                            if (material.side === BackSide)
                                uniforms.bumpScale.value *= -1;
                        }
                        if (material.displacementMap) {
                            uniforms.displacementMap.value = material.displacementMap;
                            uniforms.displacementScale.value = material.displacementScale;
                            uniforms.displacementBias.value = material.displacementBias;
                        }
                        if (material.emissiveMap) {
                            uniforms.emissiveMap.value = material.emissiveMap;
                        }
                        if (material.normalMap) {
                            uniforms.normalMap.value = material.normalMap;
                            uniforms.normalScale.value.copy(material.normalScale);
                            if (material.side === BackSide)
                                uniforms.normalScale.value.negate();
                        }
                        if (material.specularMap) {
                            uniforms.specularMap.value = material.specularMap;
                        }
                        if (material.alphaTest > 0) {
                            uniforms.alphaTest.value = material.alphaTest;
                        }
                        var envMap = properties.get(material).envMap;
                        if (envMap) {
                            uniforms.envMap.value = envMap;
                            uniforms.flipEnvMap.value = (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) ? -1 : 1;
                            uniforms.reflectivity.value = material.reflectivity;
                            uniforms.ior.value = material.ior;
                            uniforms.refractionRatio.value = material.refractionRatio;
                        }
                        if (material.lightMap) {
                            uniforms.lightMap.value = material.lightMap;
                            // artist-friendly light intensity scaling factor
                            var scaleFactor = (renderer.physicallyCorrectLights !== true) ? Math.PI : 1;
                            uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
                        }
                        if (material.aoMap) {
                            uniforms.aoMap.value = material.aoMap;
                            uniforms.aoMapIntensity.value = material.aoMapIntensity;
                        }
                        // uv repeat and offset setting priorities
                        // 1. color map
                        // 2. specular map
                        // 3. displacementMap map
                        // 4. normal map
                        // 5. bump map
                        // 6. roughnessMap map
                        // 7. metalnessMap map
                        // 8. alphaMap map
                        // 9. emissiveMap map
                        // 10. clearcoat map
                        // 11. clearcoat normal map
                        // 12. clearcoat roughnessMap map
                        // 13. specular intensity map
                        // 14. specular tint map
                        // 15. transmission map
                        // 16. thickness map
                        var uvScaleMap;
                        if (material.map) {
                            uvScaleMap = material.map;
                        } else if (material.specularMap) {
                            uvScaleMap = material.specularMap;
                        } else if (material.displacementMap) {
                            uvScaleMap = material.displacementMap;
                        } else if (material.normalMap) {
                            uvScaleMap = material.normalMap;
                        } else if (material.bumpMap) {
                            uvScaleMap = material.bumpMap;
                        } else if (material.roughnessMap) {
                            uvScaleMap = material.roughnessMap;
                        } else if (material.metalnessMap) {
                            uvScaleMap = material.metalnessMap;
                        } else if (material.alphaMap) {
                            uvScaleMap = material.alphaMap;
                        } else if (material.emissiveMap) {
                            uvScaleMap = material.emissiveMap;
                        } else if (material.clearcoatMap) {
                            uvScaleMap = material.clearcoatMap;
                        } else if (material.clearcoatNormalMap) {
                            uvScaleMap = material.clearcoatNormalMap;
                        } else if (material.clearcoatRoughnessMap) {
                            uvScaleMap = material.clearcoatRoughnessMap;
                        } else if (material.specularIntensityMap) {
                            uvScaleMap = material.specularIntensityMap;
                        } else if (material.specularColorMap) {
                            uvScaleMap = material.specularColorMap;
                        } else if (material.transmissionMap) {
                            uvScaleMap = material.transmissionMap;
                        } else if (material.thicknessMap) {
                            uvScaleMap = material.thicknessMap;
                        } else if (material.sheenColorMap) {
                            uvScaleMap = material.sheenColorMap;
                        } else if (material.sheenRoughnessMap) {
                            uvScaleMap = material.sheenRoughnessMap;
                        }
                        if (uvScaleMap !== undefined) {
                            // backwards compatibility
                            if (uvScaleMap.isWebGLRenderTarget) {
                                uvScaleMap = uvScaleMap.texture;
                            }
                            if (uvScaleMap.matrixAutoUpdate === true) {
                                uvScaleMap.updateMatrix();
                            }
                            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
                        }
                        // uv repeat and offset setting priorities for uv2
                        // 1. ao map
                        // 2. light map
                        var uv2ScaleMap;
                        if (material.aoMap) {
                            uv2ScaleMap = material.aoMap;
                        } else if (material.lightMap) {
                            uv2ScaleMap = material.lightMap;
                        }
                        if (uv2ScaleMap !== undefined) {
                            // backwards compatibility
                            if (uv2ScaleMap.isWebGLRenderTarget) {
                                uv2ScaleMap = uv2ScaleMap.texture;
                            }
                            if (uv2ScaleMap.matrixAutoUpdate === true) {
                                uv2ScaleMap.updateMatrix();
                            }
                            uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
                        }
                    }

                    function refreshUniformsLine(uniforms, material) {
                        uniforms.diffuse.value.copy(material.color);
                        uniforms.opacity.value = material.opacity;
                    }

                    function refreshUniformsDash(uniforms, material) {
                        uniforms.dashSize.value = material.dashSize;
                        uniforms.totalSize.value = material.dashSize + material.gapSize;
                        uniforms.scale.value = material.scale;
                    }

                    function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
                        uniforms.diffuse.value.copy(material.color);
                        uniforms.opacity.value = material.opacity;
                        uniforms.size.value = material.size * pixelRatio;
                        uniforms.scale.value = height * 0.5;
                        if (material.map) {
                            uniforms.map.value = material.map;
                        }
                        if (material.alphaMap) {
                            uniforms.alphaMap.value = material.alphaMap;
                        }
                        if (material.alphaTest > 0) {
                            uniforms.alphaTest.value = material.alphaTest;
                        }
                        // uv repeat and offset setting priorities
                        // 1. color map
                        // 2. alpha map
                        var uvScaleMap;
                        if (material.map) {
                            uvScaleMap = material.map;
                        } else if (material.alphaMap) {
                            uvScaleMap = material.alphaMap;
                        }
                        if (uvScaleMap !== undefined) {
                            if (uvScaleMap.matrixAutoUpdate === true) {
                                uvScaleMap.updateMatrix();
                            }
                            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
                        }
                    }

                    function refreshUniformsSprites(uniforms, material) {
                        uniforms.diffuse.value.copy(material.color);
                        uniforms.opacity.value = material.opacity;
                        uniforms.rotation.value = material.rotation;
                        if (material.map) {
                            uniforms.map.value = material.map;
                        }
                        if (material.alphaMap) {
                            uniforms.alphaMap.value = material.alphaMap;
                        }
                        if (material.alphaTest > 0) {
                            uniforms.alphaTest.value = material.alphaTest;
                        }
                        // uv repeat and offset setting priorities
                        // 1. color map
                        // 2. alpha map
                        var uvScaleMap;
                        if (material.map) {
                            uvScaleMap = material.map;
                        } else if (material.alphaMap) {
                            uvScaleMap = material.alphaMap;
                        }
                        if (uvScaleMap !== undefined) {
                            if (uvScaleMap.matrixAutoUpdate === true) {
                                uvScaleMap.updateMatrix();
                            }
                            uniforms.uvTransform.value.copy(uvScaleMap.matrix);
                        }
                    }

                    function refreshUniformsPhong(uniforms, material) {
                        uniforms.specular.value.copy(material.specular);
                        uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )
                    }

                    function refreshUniformsToon(uniforms, material) {
                        if (material.gradientMap) {
                            uniforms.gradientMap.value = material.gradientMap;
                        }
                    }

                    function refreshUniformsStandard(uniforms, material) {
                        uniforms.roughness.value = material.roughness;
                        uniforms.metalness.value = material.metalness;
                        if (material.roughnessMap) {
                            uniforms.roughnessMap.value = material.roughnessMap;
                        }
                        if (material.metalnessMap) {
                            uniforms.metalnessMap.value = material.metalnessMap;
                        }
                        var envMap = properties.get(material).envMap;
                        if (envMap) {
                            //uniforms.envMap.value = material.envMap; // part of uniforms common
                            uniforms.envMapIntensity.value = material.envMapIntensity;
                        }
                    }

                    function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
                        uniforms.ior.value = material.ior; // also part of uniforms common
                        if (material.sheen > 0) {
                            uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
                            uniforms.sheenRoughness.value = material.sheenRoughness;
                            if (material.sheenColorMap) {
                                uniforms.sheenColorMap.value = material.sheenColorMap;
                            }
                            if (material.sheenRoughnessMap) {
                                uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
                            }
                        }
                        if (material.clearcoat > 0) {
                            uniforms.clearcoat.value = material.clearcoat;
                            uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
                            if (material.clearcoatMap) {
                                uniforms.clearcoatMap.value = material.clearcoatMap;
                            }
                            if (material.clearcoatRoughnessMap) {
                                uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
                            }
                            if (material.clearcoatNormalMap) {
                                uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
                                uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
                                if (material.side === BackSide) {
                                    uniforms.clearcoatNormalScale.value.negate();
                                }
                            }
                        }
                        if (material.transmission > 0) {
                            uniforms.transmission.value = material.transmission;
                            uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
                            uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
                            if (material.transmissionMap) {
                                uniforms.transmissionMap.value = material.transmissionMap;
                            }
                            uniforms.thickness.value = material.thickness;
                            if (material.thicknessMap) {
                                uniforms.thicknessMap.value = material.thicknessMap;
                            }
                            uniforms.attenuationDistance.value = material.attenuationDistance;
                            uniforms.attenuationColor.value.copy(material.attenuationColor);
                        }
                        uniforms.specularIntensity.value = material.specularIntensity;
                        uniforms.specularColor.value.copy(material.specularColor);
                        if (material.specularIntensityMap) {
                            uniforms.specularIntensityMap.value = material.specularIntensityMap;
                        }
                        if (material.specularColorMap) {
                            uniforms.specularColorMap.value = material.specularColorMap;
                        }
                    }

                    function refreshUniformsMatcap(uniforms, material) {
                        if (material.matcap) {
                            uniforms.matcap.value = material.matcap;
                        }
                    }

                    function refreshUniformsDistance(uniforms, material) {
                        uniforms.referencePosition.value.copy(material.referencePosition);
                        uniforms.nearDistance.value = material.nearDistance;
                        uniforms.farDistance.value = material.farDistance;
                    }
                    return {
                        refreshFogUniforms: refreshFogUniforms,
                        refreshMaterialUniforms: refreshMaterialUniforms
                    };
                }

                function createCanvasElement() {
                    var canvas = createElementNS('canvas');
                    canvas.style.display = 'block';
                    return canvas;
                }

                function WebGLRenderer(parameters) {
                    if (parameters === void 0) {
                        parameters = {};
                    }
                    var _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
                        _context = parameters.context !== undefined ? parameters.context : null,
                        _depth = parameters.depth !== undefined ? parameters.depth : true,
                        _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
                        _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
                        _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
                        _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
                        _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
                        _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;
                    var _alpha;
                    if (parameters.context !== undefined) {
                        _alpha = _context.getContextAttributes().alpha;
                    } else {
                        _alpha = parameters.alpha !== undefined ? parameters.alpha : false;
                    }
                    var currentRenderList = null;
                    var currentRenderState = null;
                    // render() can be called from within a callback triggered by another render.
                    // We track this so that the nested render call gets its list and state isolated from the parent render call.
                    var renderListStack = [];
                    var renderStateStack = [];
                    // public properties
                    this.domElement = _canvas;
                    // Debug configuration container
                    this.debug = {
                        /**
                         * Enables error checking and reporting when shader programs are being compiled
                         * @type {boolean}
                         */
                        checkShaderErrors: true
                    };
                    // clearing
                    this.autoClear = true;
                    this.autoClearColor = true;
                    this.autoClearDepth = true;
                    this.autoClearStencil = true;
                    // scene graph
                    this.sortObjects = true;
                    // user-defined clipping
                    this.clippingPlanes = [];
                    this.localClippingEnabled = false;
                    // physically based shading
                    this.outputEncoding = LinearEncoding;
                    // physical lights
                    this.physicallyCorrectLights = false;
                    // tone mapping
                    this.toneMapping = NoToneMapping;
                    this.toneMappingExposure = 1.0;
                    // internal properties
                    var _this = this;
                    var _isContextLost = false;
                    // internal state cache
                    var _currentActiveCubeFace = 0;
                    var _currentActiveMipmapLevel = 0;
                    var _currentRenderTarget = null;
                    var _currentMaterialId = -1;
                    var _currentCamera = null;
                    var _currentViewport = new Vector4();
                    var _currentScissor = new Vector4();
                    var _currentScissorTest = null;
                    //
                    var _width = _canvas.width;
                    var _height = _canvas.height;
                    var _pixelRatio = 1;
                    var _opaqueSort = null;
                    var _transparentSort = null;
                    var _viewport = new Vector4(0, 0, _width, _height);
                    var _scissor = new Vector4(0, 0, _width, _height);
                    var _scissorTest = false;
                    // frustum
                    var _frustum = new Frustum();
                    // clipping
                    var _clippingEnabled = false;
                    var _localClippingEnabled = false;
                    // transmission
                    var _transmissionRenderTarget = null;
                    // camera matrices cache
                    var _projScreenMatrix = new Matrix4();
                    var _vector2 = new Vector2();
                    var _vector3 = new Vector3();
                    var _emptyScene = {
                        background: null,
                        fog: null,
                        environment: null,
                        overrideMaterial: null,
                        isScene: true
                    };

                    function getTargetPixelRatio() {
                        return _currentRenderTarget === null ? _pixelRatio : 1;
                    }
                    // initialize
                    var _gl = _context;

                    function getContext(contextNames, contextAttributes) {
                        for (var i = 0; i < contextNames.length; i++) {
                            var contextName = contextNames[i];
                            var context = _canvas.getContext(contextName, contextAttributes);
                            if (context !== null)
                                return context;
                        }
                        return null;
                    }
                    try {
                        var contextAttributes = {
                            alpha: true,
                            depth: _depth,
                            stencil: _stencil,
                            antialias: _antialias,
                            premultipliedAlpha: _premultipliedAlpha,
                            preserveDrawingBuffer: _preserveDrawingBuffer,
                            powerPreference: _powerPreference,
                            failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
                        };
                        // OffscreenCanvas does not have setAttribute, see #22811
                        if ('setAttribute' in _canvas)
                            _canvas.setAttribute('data-engine', "three.js r".concat(REVISION));
                        // event listeners must be registered before WebGL context is created, see #12753
                        _canvas.addEventListener('webglcontextlost', onContextLost, false);
                        _canvas.addEventListener('webglcontextrestored', onContextRestore, false);
                        if (_gl === null) {
                            var contextNames = ['webgl2', 'webgl', 'experimental-webgl'];
                            if (_this.isWebGL1Renderer === true) {
                                contextNames.shift();
                            }
                            _gl = getContext(contextNames, contextAttributes);
                            if (_gl === null) {
                                if (getContext(contextNames)) {
                                    throw new Error('Error creating WebGL context with your selected attributes.');
                                } else {
                                    throw new Error('Error creating WebGL context.');
                                }
                            }
                        }
                        // Some experimental-webgl implementations do not have getShaderPrecisionFormat
                        if (_gl.getShaderPrecisionFormat === undefined) {
                            _gl.getShaderPrecisionFormat = function() {
                                return {
                                    'rangeMin': 1,
                                    'rangeMax': 1,
                                    'precision': 1
                                };
                            };
                        }
                    } catch (error) {
                        console.error('THREE.WebGLRenderer: ' + error.message);
                        throw error;
                    }
                    var extensions, capabilities, state, info;
                    var properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
                    var programCache, materials, renderLists, renderStates, clipping, shadowMap;
                    var background, morphtargets, bufferRenderer, indexedBufferRenderer;
                    var utils, bindingStates;

                    function initGLContext() {
                        extensions = new WebGLExtensions(_gl);
                        capabilities = new WebGLCapabilities(_gl, extensions, parameters);
                        extensions.init(capabilities);
                        utils = new WebGLUtils(_gl, extensions, capabilities);
                        state = new WebGLState(_gl, extensions, capabilities);
                        info = new WebGLInfo(_gl);
                        properties = new WebGLProperties();
                        textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
                        cubemaps = new WebGLCubeMaps(_this);
                        cubeuvmaps = new WebGLCubeUVMaps(_this);
                        attributes = new WebGLAttributes(_gl, capabilities);
                        bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
                        geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
                        objects = new WebGLObjects(_gl, geometries, attributes, info);
                        morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
                        clipping = new WebGLClipping(properties);
                        programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
                        materials = new WebGLMaterials(_this, properties);
                        renderLists = new WebGLRenderLists();
                        renderStates = new WebGLRenderStates(extensions, capabilities);
                        background = new WebGLBackground(_this, cubemaps, state, objects, _alpha, _premultipliedAlpha);
                        shadowMap = new WebGLShadowMap(_this, objects, capabilities);
                        bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
                        indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
                        info.programs = programCache.programs;
                        _this.capabilities = capabilities;
                        _this.extensions = extensions;
                        _this.properties = properties;
                        _this.renderLists = renderLists;
                        _this.shadowMap = shadowMap;
                        _this.state = state;
                        _this.info = info;
                    }
                    initGLContext();
                    // xr
                    var xr = new WebXRManager(_this, _gl);
                    this.xr = xr;
                    // API
                    this.getContext = function() {
                        return _gl;
                    };
                    this.getContextAttributes = function() {
                        return _gl.getContextAttributes();
                    };
                    this.forceContextLoss = function() {
                        var extension = extensions.get('WEBGL_lose_context');
                        if (extension)
                            extension.loseContext();
                    };
                    this.forceContextRestore = function() {
                        var extension = extensions.get('WEBGL_lose_context');
                        if (extension)
                            extension.restoreContext();
                    };
                    this.getPixelRatio = function() {
                        return _pixelRatio;
                    };
                    this.setPixelRatio = function(value) {
                        if (value === undefined)
                            return;
                        _pixelRatio = value;
                        this.setSize(_width, _height, false);
                    };
                    this.getSize = function(target) {
                        return target.set(_width, _height);
                    };
                    this.setSize = function(width, height, updateStyle) {
                        if (xr.isPresenting) {
                            console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
                            return;
                        }
                        _width = width;
                        _height = height;
                        _canvas.width = Math.floor(width * _pixelRatio);
                        _canvas.height = Math.floor(height * _pixelRatio);
                        if (updateStyle !== false) {
                            _canvas.style.width = width + 'px';
                            _canvas.style.height = height + 'px';
                        }
                        this.setViewport(0, 0, width, height);
                    };
                    this.getDrawingBufferSize = function(target) {
                        return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
                    };
                    this.setDrawingBufferSize = function(width, height, pixelRatio) {
                        _width = width;
                        _height = height;
                        _pixelRatio = pixelRatio;
                        _canvas.width = Math.floor(width * pixelRatio);
                        _canvas.height = Math.floor(height * pixelRatio);
                        this.setViewport(0, 0, width, height);
                    };
                    this.getCurrentViewport = function(target) {
                        return target.copy(_currentViewport);
                    };
                    this.getViewport = function(target) {
                        return target.copy(_viewport);
                    };
                    this.setViewport = function(x, y, width, height) {
                        if (x.isVector4) {
                            _viewport.set(x.x, x.y, x.z, x.w);
                        } else {
                            _viewport.set(x, y, width, height);
                        }
                        state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
                    };
                    this.getScissor = function(target) {
                        return target.copy(_scissor);
                    };
                    this.setScissor = function(x, y, width, height) {
                        if (x.isVector4) {
                            _scissor.set(x.x, x.y, x.z, x.w);
                        } else {
                            _scissor.set(x, y, width, height);
                        }
                        state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
                    };
                    this.getScissorTest = function() {
                        return _scissorTest;
                    };
                    this.setScissorTest = function(boolean) {
                        state.setScissorTest(_scissorTest = boolean);
                    };
                    this.setOpaqueSort = function(method) {
                        _opaqueSort = method;
                    };
                    this.setTransparentSort = function(method) {
                        _transparentSort = method;
                    };
                    // Clearing
                    this.getClearColor = function(target) {
                        return target.copy(background.getClearColor());
                    };
                    this.setClearColor = function() {
                        background.setClearColor.apply(background, arguments);
                    };
                    this.getClearAlpha = function() {
                        return background.getClearAlpha();
                    };
                    this.setClearAlpha = function() {
                        background.setClearAlpha.apply(background, arguments);
                    };
                    this.clear = function(color, depth, stencil) {
                        if (color === void 0) {
                            color = true;
                        }
                        if (depth === void 0) {
                            depth = true;
                        }
                        if (stencil === void 0) {
                            stencil = true;
                        }
                        var bits = 0;
                        if (color)
                            bits |= 16384;
                        if (depth)
                            bits |= 256;
                        if (stencil)
                            bits |= 1024;
                        _gl.clear(bits);
                    };
                    this.clearColor = function() {
                        this.clear(true, false, false);
                    };
                    this.clearDepth = function() {
                        this.clear(false, true, false);
                    };
                    this.clearStencil = function() {
                        this.clear(false, false, true);
                    };
                    //
                    this.dispose = function() {
                        _canvas.removeEventListener('webglcontextlost', onContextLost, false);
                        _canvas.removeEventListener('webglcontextrestored', onContextRestore, false);
                        renderLists.dispose();
                        renderStates.dispose();
                        properties.dispose();
                        cubemaps.dispose();
                        cubeuvmaps.dispose();
                        objects.dispose();
                        bindingStates.dispose();
                        programCache.dispose();
                        xr.dispose();
                        xr.removeEventListener('sessionstart', onXRSessionStart);
                        xr.removeEventListener('sessionend', onXRSessionEnd);
                        if (_transmissionRenderTarget) {
                            _transmissionRenderTarget.dispose();
                            _transmissionRenderTarget = null;
                        }
                        animation.stop();
                    };
                    // Events
                    function onContextLost(event) {
                        event.preventDefault();
                        console.log('THREE.WebGLRenderer: Context Lost.');
                        _isContextLost = true;
                    }

                    function onContextRestore( /* event */ ) {
                        console.log('THREE.WebGLRenderer: Context Restored.');
                        _isContextLost = false;
                        var infoAutoReset = info.autoReset;
                        var shadowMapEnabled = shadowMap.enabled;
                        var shadowMapAutoUpdate = shadowMap.autoUpdate;
                        var shadowMapNeedsUpdate = shadowMap.needsUpdate;
                        var shadowMapType = shadowMap.type;
                        initGLContext();
                        info.autoReset = infoAutoReset;
                        shadowMap.enabled = shadowMapEnabled;
                        shadowMap.autoUpdate = shadowMapAutoUpdate;
                        shadowMap.needsUpdate = shadowMapNeedsUpdate;
                        shadowMap.type = shadowMapType;
                    }

                    function onMaterialDispose(event) {
                        var material = event.target;
                        material.removeEventListener('dispose', onMaterialDispose);
                        deallocateMaterial(material);
                    }
                    // Buffer deallocation
                    function deallocateMaterial(material) {
                        releaseMaterialProgramReferences(material);
                        properties.remove(material);
                    }

                    function releaseMaterialProgramReferences(material) {
                        var programs = properties.get(material).programs;
                        if (programs !== undefined) {
                            programs.forEach(function(program) {
                                programCache.releaseProgram(program);
                            });
                            if (material.isShaderMaterial) {
                                programCache.releaseShaderCache(material);
                            }
                        }
                    }
                    // Buffer rendering
                    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
                        if (scene === null)
                            scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)
                        var frontFaceCW = (object.isMesh && object.matrixWorld.determinant() < 0);
                        var program = setProgram(camera, scene, geometry, material, object);
                        state.setMaterial(material, frontFaceCW);
                        //
                        var index = geometry.index;
                        var position = geometry.attributes.position;
                        //
                        if (index === null) {
                            if (position === undefined || position.count === 0)
                                return;
                        } else if (index.count === 0) {
                            return;
                        }
                        //
                        var rangeFactor = 1;
                        if (material.wireframe === true) {
                            index = geometries.getWireframeAttribute(geometry);
                            rangeFactor = 2;
                        }
                        bindingStates.setup(object, material, program, geometry, index);
                        var attribute;
                        var renderer = bufferRenderer;
                        if (index !== null) {
                            attribute = attributes.get(index);
                            renderer = indexedBufferRenderer;
                            renderer.setIndex(attribute);
                        }
                        //
                        var dataCount = (index !== null) ? index.count : position.count;
                        var rangeStart = geometry.drawRange.start * rangeFactor;
                        var rangeCount = geometry.drawRange.count * rangeFactor;
                        var groupStart = group !== null ? group.start * rangeFactor : 0;
                        var groupCount = group !== null ? group.count * rangeFactor : Infinity;
                        var drawStart = Math.max(rangeStart, groupStart);
                        var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
                        var drawCount = Math.max(0, drawEnd - drawStart + 1);
                        if (drawCount === 0)
                            return;
                        //
                        if (object.isMesh) {
                            if (material.wireframe === true) {
                                state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                                renderer.setMode(1);
                            } else {
                                renderer.setMode(4);
                            }
                        } else if (object.isLine) {
                            var lineWidth = material.linewidth;
                            if (lineWidth === undefined)
                                lineWidth = 1; // Not using Line*Material
                            state.setLineWidth(lineWidth * getTargetPixelRatio());
                            if (object.isLineSegments) {
                                renderer.setMode(1);
                            } else if (object.isLineLoop) {
                                renderer.setMode(2);
                            } else {
                                renderer.setMode(3);
                            }
                        } else if (object.isPoints) {
                            renderer.setMode(0);
                        } else if (object.isSprite) {
                            renderer.setMode(4);
                        }
                        if (object.isInstancedMesh) {
                            renderer.renderInstances(drawStart, drawCount, object.count);
                        } else if (geometry.isInstancedBufferGeometry) {
                            var instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
                            renderer.renderInstances(drawStart, drawCount, instanceCount);
                        } else {
                            renderer.render(drawStart, drawCount);
                        }
                    };
                    // Compile
                    this.compile = function(scene, camera) {
                        currentRenderState = renderStates.get(scene);
                        currentRenderState.init();
                        renderStateStack.push(currentRenderState);
                        scene.traverseVisible(function(object) {
                            if (object.isLight && object.layers.test(camera.layers)) {
                                currentRenderState.pushLight(object);
                                if (object.castShadow) {
                                    currentRenderState.pushShadow(object);
                                }
                            }
                        });
                        currentRenderState.setupLights(_this.physicallyCorrectLights);
                        scene.traverse(function(object) {
                            var material = object.material;
                            if (material) {
                                if (Array.isArray(material)) {
                                    for (var i = 0; i < material.length; i++) {
                                        var material2 = material[i];
                                        getProgram(material2, scene, object);
                                    }
                                } else {
                                    getProgram(material, scene, object);
                                }
                            }
                        });
                        renderStateStack.pop();
                        currentRenderState = null;
                    };
                    // Animation Loop
                    var onAnimationFrameCallback = null;

                    function onAnimationFrame(time) {
                        if (onAnimationFrameCallback)
                            onAnimationFrameCallback(time);
                    }

                    function onXRSessionStart() {
                        animation.stop();
                    }

                    function onXRSessionEnd() {
                        animation.start();
                    }
                    var animation = new WebGLAnimation();
                    animation.setAnimationLoop(onAnimationFrame);
                    if (typeof self !== 'undefined')
                        animation.setContext(self);
                    this.setAnimationLoop = function(callback) {
                        onAnimationFrameCallback = callback;
                        xr.setAnimationLoop(callback);
                        (callback === null) ? animation.stop(): animation.start();
                    };
                    xr.addEventListener('sessionstart', onXRSessionStart);
                    xr.addEventListener('sessionend', onXRSessionEnd);
                    // Rendering
                    this.render = function(scene, camera) {
                        if (camera !== undefined && camera.isCamera !== true) {
                            console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
                            return;
                        }
                        if (_isContextLost === true)
                            return;
                        // update scene graph
                        if (scene.autoUpdate === true)
                            scene.updateMatrixWorld();
                        // update camera matrices and frustum
                        if (camera.parent === null)
                            camera.updateMatrixWorld();
                        if (xr.enabled === true && xr.isPresenting === true) {
                            if (xr.cameraAutoUpdate === true)
                                xr.updateCamera(camera);
                            camera = xr.getCamera(); // use XR camera for rendering
                        }
                        //
                        if (scene.isScene === true)
                            scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
                        currentRenderState = renderStates.get(scene, renderStateStack.length);
                        currentRenderState.init();
                        renderStateStack.push(currentRenderState);
                        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                        _frustum.setFromProjectionMatrix(_projScreenMatrix);
                        _localClippingEnabled = this.localClippingEnabled;
                        _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
                        currentRenderList = renderLists.get(scene, renderListStack.length);
                        currentRenderList.init();
                        renderListStack.push(currentRenderList);
                        projectObject(scene, camera, 0, _this.sortObjects);
                        currentRenderList.finish();
                        if (_this.sortObjects === true) {
                            currentRenderList.sort(_opaqueSort, _transparentSort);
                        }
                        //
                        if (_clippingEnabled === true)
                            clipping.beginShadows();
                        var shadowsArray = currentRenderState.state.shadowsArray;
                        shadowMap.render(shadowsArray, scene, camera);
                        if (_clippingEnabled === true)
                            clipping.endShadows();
                        //
                        if (this.info.autoReset === true)
                            this.info.reset();
                        //
                        background.render(currentRenderList, scene);
                        // render scene
                        currentRenderState.setupLights(_this.physicallyCorrectLights);
                        if (camera.isArrayCamera) {
                            var cameras = camera.cameras;
                            for (var i = 0, l = cameras.length; i < l; i++) {
                                var camera2 = cameras[i];
                                renderScene(currentRenderList, scene, camera2, camera2.viewport);
                            }
                        } else {
                            renderScene(currentRenderList, scene, camera);
                        }
                        //
                        if (_currentRenderTarget !== null) {
                            // resolve multisample renderbuffers to a single-sample texture if necessary
                            textures.updateMultisampleRenderTarget(_currentRenderTarget);
                            // Generate mipmap if we're using any kind of mipmap filtering
                            textures.updateRenderTargetMipmap(_currentRenderTarget);
                        }
                        //
                        if (scene.isScene === true)
                            scene.onAfterRender(_this, scene, camera);
                        // _gl.finish();
                        bindingStates.resetDefaultState();
                        _currentMaterialId = -1;
                        _currentCamera = null;
                        renderStateStack.pop();
                        if (renderStateStack.length > 0) {
                            currentRenderState = renderStateStack[renderStateStack.length - 1];
                        } else {
                            currentRenderState = null;
                        }
                        renderListStack.pop();
                        if (renderListStack.length > 0) {
                            currentRenderList = renderListStack[renderListStack.length - 1];
                        } else {
                            currentRenderList = null;
                        }
                    };

                    function projectObject(object, camera, groupOrder, sortObjects) {
                        if (object.visible === false)
                            return;
                        var visible = object.layers.test(camera.layers);
                        if (visible) {
                            if (object.isGroup) {
                                groupOrder = object.renderOrder;
                            } else if (object.isLOD) {
                                if (object.autoUpdate === true)
                                    object.update(camera);
                            } else if (object.isLight) {
                                currentRenderState.pushLight(object);
                                if (object.castShadow) {
                                    currentRenderState.pushShadow(object);
                                }
                            } else if (object.isSprite) {
                                if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                                    if (sortObjects) {
                                        _vector3.setFromMatrixPosition(object.matrixWorld)
                                            .applyMatrix4(_projScreenMatrix);
                                    }
                                    var geometry = objects.update(object);
                                    var material = object.material;
                                    if (material.visible) {
                                        currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                                    }
                                }
                            } else if (object.isMesh || object.isLine || object.isPoints) {
                                if (object.isSkinnedMesh) {
                                    // update skeleton only once in a frame
                                    if (object.skeleton.frame !== info.render.frame) {
                                        object.skeleton.update();
                                        object.skeleton.frame = info.render.frame;
                                    }
                                }
                                if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                                    if (sortObjects) {
                                        _vector3.setFromMatrixPosition(object.matrixWorld)
                                            .applyMatrix4(_projScreenMatrix);
                                    }
                                    var geometry = objects.update(object);
                                    var material = object.material;
                                    if (Array.isArray(material)) {
                                        var groups = geometry.groups;
                                        for (var i = 0, l = groups.length; i < l; i++) {
                                            var group = groups[i];
                                            var groupMaterial = material[group.materialIndex];
                                            if (groupMaterial && groupMaterial.visible) {
                                                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                                            }
                                        }
                                    } else if (material.visible) {
                                        currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
                                    }
                                }
                            }
                        }
                        var children = object.children;
                        for (var i = 0, l = children.length; i < l; i++) {
                            projectObject(children[i], camera, groupOrder, sortObjects);
                        }
                    }

                    function renderScene(currentRenderList, scene, camera, viewport) {
                        var opaqueObjects = currentRenderList.opaque;
                        var transmissiveObjects = currentRenderList.transmissive;
                        var transparentObjects = currentRenderList.transparent;
                        currentRenderState.setupLightsView(camera);
                        if (transmissiveObjects.length > 0)
                            renderTransmissionPass(opaqueObjects, scene, camera);
                        if (viewport)
                            state.viewport(_currentViewport.copy(viewport));
                        if (opaqueObjects.length > 0)
                            renderObjects(opaqueObjects, scene, camera);
                        if (transmissiveObjects.length > 0)
                            renderObjects(transmissiveObjects, scene, camera);
                        if (transparentObjects.length > 0)
                            renderObjects(transparentObjects, scene, camera);
                        // Ensure depth buffer writing is enabled so it can be cleared on next render
                        state.buffers.depth.setTest(true);
                        state.buffers.depth.setMask(true);
                        state.buffers.color.setMask(true);
                        state.setPolygonOffset(false);
                    }

                    function renderTransmissionPass(opaqueObjects, scene, camera) {
                        var isWebGL2 = capabilities.isWebGL2;
                        if (_transmissionRenderTarget === null) {
                            _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
                                generateMipmaps: true,
                                type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
                                minFilter: LinearMipmapLinearFilter,
                                samples: (isWebGL2 && _antialias === true) ? 4 : 0
                            });
                        }
                        _this.getDrawingBufferSize(_vector2);
                        if (isWebGL2) {
                            _transmissionRenderTarget.setSize(_vector2.x, _vector2.y);
                        } else {
                            _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector2.x), floorPowerOfTwo(_vector2.y));
                        }
                        //
                        var currentRenderTarget = _this.getRenderTarget();
                        _this.setRenderTarget(_transmissionRenderTarget);
                        _this.clear();
                        // Turn off the features which can affect the frag color for opaque objects pass.
                        // Otherwise they are applied twice in opaque objects pass and transmission objects pass.
                        var currentToneMapping = _this.toneMapping;
                        _this.toneMapping = NoToneMapping;
                        renderObjects(opaqueObjects, scene, camera);
                        _this.toneMapping = currentToneMapping;
                        textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
                        textures.updateRenderTargetMipmap(_transmissionRenderTarget);
                        _this.setRenderTarget(currentRenderTarget);
                    }

                    function renderObjects(renderList, scene, camera) {
                        var overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
                        for (var i = 0, l = renderList.length; i < l; i++) {
                            var renderItem = renderList[i];
                            var object = renderItem.object;
                            var geometry = renderItem.geometry;
                            var material = overrideMaterial === null ? renderItem.material : overrideMaterial;
                            var group = renderItem.group;
                            if (object.layers.test(camera.layers)) {
                                renderObject(object, scene, camera, geometry, material, group);
                            }
                        }
                    }

                    function renderObject(object, scene, camera, geometry, material, group) {
                        object.onBeforeRender(_this, scene, camera, geometry, material, group);
                        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
                        object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
                        material.onBeforeRender(_this, scene, camera, geometry, object, group);
                        if (material.transparent === true && material.side === DoubleSide) {
                            material.side = BackSide;
                            material.needsUpdate = true;
                            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
                            material.side = FrontSide;
                            material.needsUpdate = true;
                            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
                            material.side = DoubleSide;
                        } else {
                            _this.renderBufferDirect(camera, scene, geometry, material, object, group);
                        }
                        object.onAfterRender(_this, scene, camera, geometry, material, group);
                    }

                    function getProgram(material, scene, object) {
                        if (scene.isScene !== true)
                            scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
                        var materialProperties = properties.get(material);
                        var lights = currentRenderState.state.lights;
                        var shadowsArray = currentRenderState.state.shadowsArray;
                        var lightsStateVersion = lights.state.version;
                        var parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
                        var programCacheKey = programCache.getProgramCacheKey(parameters);
                        var programs = materialProperties.programs;
                        // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change
                        materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
                        materialProperties.fog = scene.fog;
                        materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
                        if (programs === undefined) {
                            // new material
                            material.addEventListener('dispose', onMaterialDispose);
                            programs = new Map();
                            materialProperties.programs = programs;
                        }
                        var program = programs.get(programCacheKey);
                        if (program !== undefined) {
                            // early out if program and light state is identical
                            if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
                                updateCommonMaterialProperties(material, parameters);
                                return program;
                            }
                        } else {
                            parameters.uniforms = programCache.getUniforms(material);
                            material.onBuild(object, parameters, _this);
                            material.onBeforeCompile(parameters, _this);
                            program = programCache.acquireProgram(parameters, programCacheKey);
                            programs.set(programCacheKey, program);
                            materialProperties.uniforms = parameters.uniforms;
                        }
                        var uniforms = materialProperties.uniforms;
                        if ((!material.isShaderMaterial && !material.isRawShaderMaterial) || material.clipping === true) {
                            uniforms.clippingPlanes = clipping.uniform;
                        }
                        updateCommonMaterialProperties(material, parameters);
                        // store the light setup it was created for
                        materialProperties.needsLights = materialNeedsLights(material);
                        materialProperties.lightsStateVersion = lightsStateVersion;
                        if (materialProperties.needsLights) {
                            // wire up the material to this renderer's lighting state
                            uniforms.ambientLightColor.value = lights.state.ambient;
                            uniforms.lightProbe.value = lights.state.probe;
                            uniforms.directionalLights.value = lights.state.directional;
                            uniforms.directionalLightShadows.value = lights.state.directionalShadow;
                            uniforms.spotLights.value = lights.state.spot;
                            uniforms.spotLightShadows.value = lights.state.spotShadow;
                            uniforms.rectAreaLights.value = lights.state.rectArea;
                            uniforms.ltc_1.value = lights.state.rectAreaLTC1;
                            uniforms.ltc_2.value = lights.state.rectAreaLTC2;
                            uniforms.pointLights.value = lights.state.point;
                            uniforms.pointLightShadows.value = lights.state.pointShadow;
                            uniforms.hemisphereLights.value = lights.state.hemi;
                            uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
                            uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
                            uniforms.spotShadowMap.value = lights.state.spotShadowMap;
                            uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
                            uniforms.pointShadowMap.value = lights.state.pointShadowMap;
                            uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
                            // TODO (abelnation): add area lights shadow info to uniforms
                        }
                        var progUniforms = program.getUniforms();
                        var uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
                        materialProperties.currentProgram = program;
                        materialProperties.uniformsList = uniformsList;
                        return program;
                    }

                    function updateCommonMaterialProperties(material, parameters) {
                        var materialProperties = properties.get(material);
                        materialProperties.outputEncoding = parameters.outputEncoding;
                        materialProperties.instancing = parameters.instancing;
                        materialProperties.skinning = parameters.skinning;
                        materialProperties.morphTargets = parameters.morphTargets;
                        materialProperties.morphNormals = parameters.morphNormals;
                        materialProperties.morphColors = parameters.morphColors;
                        materialProperties.morphTargetsCount = parameters.morphTargetsCount;
                        materialProperties.numClippingPlanes = parameters.numClippingPlanes;
                        materialProperties.numIntersection = parameters.numClipIntersection;
                        materialProperties.vertexAlphas = parameters.vertexAlphas;
                        materialProperties.vertexTangents = parameters.vertexTangents;
                        materialProperties.toneMapping = parameters.toneMapping;
                    }

                    function setProgram(camera, scene, geometry, material, object) {
                        if (scene.isScene !== true)
                            scene = _emptyScene; // scene could be a Mesh, Line, Points, ...
                        textures.resetTextureUnits();
                        var fog = scene.fog;
                        var environment = material.isMeshStandardMaterial ? scene.environment : null;
                        var encoding = (_currentRenderTarget === null) ? _this.outputEncoding : (_currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding);
                        var envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
                        var vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
                        var vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
                        var morphTargets = !!geometry.morphAttributes.position;
                        var morphNormals = !!geometry.morphAttributes.normal;
                        var morphColors = !!geometry.morphAttributes.color;
                        var toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;
                        var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
                        var morphTargetsCount = (morphAttribute !== undefined) ? morphAttribute.length : 0;
                        var materialProperties = properties.get(material);
                        var lights = currentRenderState.state.lights;
                        if (_clippingEnabled === true) {
                            if (_localClippingEnabled === true || camera !== _currentCamera) {
                                var useCache = camera === _currentCamera &&
                                    material.id === _currentMaterialId;
                                // we might want to call this function with some ClippingGroup
                                // object instead of the material, once it becomes feasible
                                // (#8465, #8379)
                                clipping.setState(material, camera, useCache);
                            }
                        }
                        //
                        var needsProgramChange = false;
                        if (material.version === materialProperties.__version) {
                            if (materialProperties.needsLights && (materialProperties.lightsStateVersion !== lights.state.version)) {
                                needsProgramChange = true;
                            } else if (materialProperties.outputEncoding !== encoding) {
                                needsProgramChange = true;
                            } else if (object.isInstancedMesh && materialProperties.instancing === false) {
                                needsProgramChange = true;
                            } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
                                needsProgramChange = true;
                            } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
                                needsProgramChange = true;
                            } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
                                needsProgramChange = true;
                            } else if (materialProperties.envMap !== envMap) {
                                needsProgramChange = true;
                            } else if (material.fog && materialProperties.fog !== fog) {
                                needsProgramChange = true;
                            } else if (materialProperties.numClippingPlanes !== undefined &&
                                (materialProperties.numClippingPlanes !== clipping.numPlanes ||
                                    materialProperties.numIntersection !== clipping.numIntersection)) {
                                needsProgramChange = true;
                            } else if (materialProperties.vertexAlphas !== vertexAlphas) {
                                needsProgramChange = true;
                            } else if (materialProperties.vertexTangents !== vertexTangents) {
                                needsProgramChange = true;
                            } else if (materialProperties.morphTargets !== morphTargets) {
                                needsProgramChange = true;
                            } else if (materialProperties.morphNormals !== morphNormals) {
                                needsProgramChange = true;
                            } else if (materialProperties.morphColors !== morphColors) {
                                needsProgramChange = true;
                            } else if (materialProperties.toneMapping !== toneMapping) {
                                needsProgramChange = true;
                            } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
                                needsProgramChange = true;
                            }
                        } else {
                            needsProgramChange = true;
                            materialProperties.__version = material.version;
                        }
                        //
                        var program = materialProperties.currentProgram;
                        if (needsProgramChange === true) {
                            program = getProgram(material, scene, object);
                        }
                        var refreshProgram = false;
                        var refreshMaterial = false;
                        var refreshLights = false;
                        var p_uniforms = program.getUniforms(),
                            m_uniforms = materialProperties.uniforms;
                        if (state.useProgram(program.program)) {
                            refreshProgram = true;
                            refreshMaterial = true;
                            refreshLights = true;
                        }
                        if (material.id !== _currentMaterialId) {
                            _currentMaterialId = material.id;
                            refreshMaterial = true;
                        }
                        if (refreshProgram || _currentCamera !== camera) {
                            p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
                            if (capabilities.logarithmicDepthBuffer) {
                                p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
                            }
                            if (_currentCamera !== camera) {
                                _currentCamera = camera;
                                // lighting uniforms depend on the camera so enforce an update
                                // now, in case this material supports lights - or later, when
                                // the next material that does gets activated:
                                refreshMaterial = true; // set to true on material change
                                refreshLights = true; // remains set until update done
                            }
                            // load material specific uniforms
                            // (shader material also gets them for the sake of genericity)
                            if (material.isShaderMaterial ||
                                material.isMeshPhongMaterial ||
                                material.isMeshToonMaterial ||
                                material.isMeshStandardMaterial ||
                                material.envMap) {
                                var uCamPos = p_uniforms.map.cameraPosition;
                                if (uCamPos !== undefined) {
                                    uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
                                }
                            }
                            if (material.isMeshPhongMaterial ||
                                material.isMeshToonMaterial ||
                                material.isMeshLambertMaterial ||
                                material.isMeshBasicMaterial ||
                                material.isMeshStandardMaterial ||
                                material.isShaderMaterial) {
                                p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
                            }
                            if (material.isMeshPhongMaterial ||
                                material.isMeshToonMaterial ||
                                material.isMeshLambertMaterial ||
                                material.isMeshBasicMaterial ||
                                material.isMeshStandardMaterial ||
                                material.isShaderMaterial ||
                                material.isShadowMaterial ||
                                object.isSkinnedMesh) {
                                p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
                            }
                        }
                        // skinning and morph target uniforms must be set even if material didn't change
                        // auto-setting of texture unit for bone and morph texture must go before other textures
                        // otherwise textures used for skinning and morphing can take over texture units reserved for other material textures
                        if (object.isSkinnedMesh) {
                            p_uniforms.setOptional(_gl, object, 'bindMatrix');
                            p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
                            var skeleton = object.skeleton;
                            if (skeleton) {
                                if (capabilities.floatVertexTextures) {
                                    if (skeleton.boneTexture === null)
                                        skeleton.computeBoneTexture();
                                    p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
                                    p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
                                } else {
                                    p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
                                }
                            }
                        }
                        var morphAttributes = geometry.morphAttributes;
                        if (morphAttributes.position !== undefined || morphAttributes.normal !== undefined || (morphAttributes.color !== undefined && capabilities.isWebGL2 === true)) {
                            morphtargets.update(object, geometry, material, program);
                        }
                        if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
                            materialProperties.receiveShadow = object.receiveShadow;
                            p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
                        }
                        if (refreshMaterial) {
                            p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
                            if (materialProperties.needsLights) {
                                // the current material requires lighting info
                                // note: all lighting uniforms are always set correctly
                                // they simply reference the renderer's state for their
                                // values
                                //
                                // use the current material's .needsUpdate flags to set
                                // the GL state when required
                                markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
                            }
                            // refresh uniforms common to several materials
                            if (fog && material.fog) {
                                materials.refreshFogUniforms(m_uniforms, fog);
                            }
                            materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
                            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
                        }
                        if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
                            WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
                            material.uniformsNeedUpdate = false;
                        }
                        if (material.isSpriteMaterial) {
                            p_uniforms.setValue(_gl, 'center', object.center);
                        }
                        // common matrices
                        p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
                        p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
                        p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
                        return program;
                    }
                    // If uniforms are marked as clean, they don't need to be loaded to the GPU.
                    function markUniformsLightsNeedsUpdate(uniforms, value) {
                        uniforms.ambientLightColor.needsUpdate = value;
                        uniforms.lightProbe.needsUpdate = value;
                        uniforms.directionalLights.needsUpdate = value;
                        uniforms.directionalLightShadows.needsUpdate = value;
                        uniforms.pointLights.needsUpdate = value;
                        uniforms.pointLightShadows.needsUpdate = value;
                        uniforms.spotLights.needsUpdate = value;
                        uniforms.spotLightShadows.needsUpdate = value;
                        uniforms.rectAreaLights.needsUpdate = value;
                        uniforms.hemisphereLights.needsUpdate = value;
                    }

                    function materialNeedsLights(material) {
                        return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
                            material.isMeshStandardMaterial || material.isShadowMaterial ||
                            (material.isShaderMaterial && material.lights === true);
                    }
                    this.getActiveCubeFace = function() {
                        return _currentActiveCubeFace;
                    };
                    this.getActiveMipmapLevel = function() {
                        return _currentActiveMipmapLevel;
                    };
                    this.getRenderTarget = function() {
                        return _currentRenderTarget;
                    };
                    this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
                        properties.get(renderTarget.texture).__webglTexture = colorTexture;
                        properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
                        var renderTargetProperties = properties.get(renderTarget);
                        renderTargetProperties.__hasExternalTextures = true;
                        if (renderTargetProperties.__hasExternalTextures) {
                            renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;
                            if (!renderTargetProperties.__autoAllocateDepthBuffer) {
                                // The multisample_render_to_texture extension doesn't work properly if there
                                // are midframe flushes and an external depth buffer. Disable use of the extension.
                                if (extensions.has('WEBGL_multisampled_render_to_texture') === true) {
                                    console.warn('THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided');
                                    renderTargetProperties.__useRenderToTexture = false;
                                }
                            }
                        }
                    };
                    this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
                        var renderTargetProperties = properties.get(renderTarget);
                        renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
                        renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined;
                    };
                    this.setRenderTarget = function(renderTarget, activeCubeFace, activeMipmapLevel) {
                        if (activeCubeFace === void 0) {
                            activeCubeFace = 0;
                        }
                        if (activeMipmapLevel === void 0) {
                            activeMipmapLevel = 0;
                        }
                        _currentRenderTarget = renderTarget;
                        _currentActiveCubeFace = activeCubeFace;
                        _currentActiveMipmapLevel = activeMipmapLevel;
                        var useDefaultFramebuffer = true;
                        if (renderTarget) {
                            var renderTargetProperties = properties.get(renderTarget);
                            if (renderTargetProperties.__useDefaultFramebuffer !== undefined) {
                                // We need to make sure to rebind the framebuffer.
                                state.bindFramebuffer(36160, null);
                                useDefaultFramebuffer = false;
                            } else if (renderTargetProperties.__webglFramebuffer === undefined) {
                                textures.setupRenderTarget(renderTarget);
                            } else if (renderTargetProperties.__hasExternalTextures) {
                                // Color and depth texture must be rebound in order for the swapchain to update.
                                textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
                            }
                        }
                        var framebuffer = null;
                        var isCube = false;
                        var isRenderTarget3D = false;
                        if (renderTarget) {
                            var texture = renderTarget.texture;
                            if (texture.isData3DTexture || texture.isDataArrayTexture) {
                                isRenderTarget3D = true;
                            }
                            var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
                            if (renderTarget.isWebGLCubeRenderTarget) {
                                framebuffer = __webglFramebuffer[activeCubeFace];
                                isCube = true;
                            } else if ((capabilities.isWebGL2 && renderTarget.samples > 0) && textures.useMultisampledRTT(renderTarget) === false) {
                                framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
                            } else {
                                framebuffer = __webglFramebuffer;
                            }
                            _currentViewport.copy(renderTarget.viewport);
                            _currentScissor.copy(renderTarget.scissor);
                            _currentScissorTest = renderTarget.scissorTest;
                        } else {
                            _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
                            _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
                            _currentScissorTest = _scissorTest;
                        }
                        var framebufferBound = state.bindFramebuffer(36160, framebuffer);
                        if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
                            state.drawBuffers(renderTarget, framebuffer);
                        }
                        state.viewport(_currentViewport);
                        state.scissor(_currentScissor);
                        state.setScissorTest(_currentScissorTest);
                        if (isCube) {
                            var textureProperties = properties.get(renderTarget.texture);
                            _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
                        } else if (isRenderTarget3D) {
                            var textureProperties = properties.get(renderTarget.texture);
                            var layer = activeCubeFace || 0;
                            _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
                        }
                        _currentMaterialId = -1; // reset current material to ensure correct uniform bindings
                    };
                    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
                        if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
                            console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
                            return;
                        }
                        var framebuffer = properties.get(renderTarget).__webglFramebuffer;
                        if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
                            framebuffer = framebuffer[activeCubeFaceIndex];
                        }
                        if (framebuffer) {
                            state.bindFramebuffer(36160, framebuffer);
                            try {
                                var texture = renderTarget.texture;
                                var textureFormat = texture.format;
                                var textureType = texture.type;
                                if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
                                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                                    return;
                                }
                                var halfFloatSupportedByExt = (textureType === HalfFloatType) && (extensions.has('EXT_color_buffer_half_float') || (capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float')));
                                if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && // Edge and Chrome Mac < 52 (#9513)
                                    !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
                                    !halfFloatSupportedByExt) {
                                    console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                                    return;
                                }
                                // the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
                                if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {
                                    _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
                                }
                            } finally {
                                // restore framebuffer of current render target if necessary
                                var framebuffer_1 = (_currentRenderTarget !== null) ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
                                state.bindFramebuffer(36160, framebuffer_1);
                            }
                        }
                    };
                    this.copyFramebufferToTexture = function(position, texture, level) {
                        if (level === void 0) {
                            level = 0;
                        }
                        if (texture.isFramebufferTexture !== true) {
                            console.error('THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.');
                            return;
                        }
                        var levelScale = Math.pow(2, -level);
                        var width = Math.floor(texture.image.width * levelScale);
                        var height = Math.floor(texture.image.height * levelScale);
                        textures.setTexture2D(texture, 0);
                        _gl.copyTexSubImage2D(3553, level, 0, 0, position.x, position.y, width, height);
                        state.unbindTexture();
                    };
                    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level) {
                        if (level === void 0) {
                            level = 0;
                        }
                        var width = srcTexture.image.width;
                        var height = srcTexture.image.height;
                        var glFormat = utils.convert(dstTexture.format);
                        var glType = utils.convert(dstTexture.type);
                        textures.setTexture2D(dstTexture, 0);
                        // As another texture upload may have changed pixelStorei
                        // parameters, make sure they are correct for the dstTexture
                        _gl.pixelStorei(37440, dstTexture.flipY);
                        _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
                        _gl.pixelStorei(3317, dstTexture.unpackAlignment);
                        if (srcTexture.isDataTexture) {
                            _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
                        } else {
                            if (srcTexture.isCompressedTexture) {
                                _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
                            } else {
                                _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
                            }
                        }
                        // Generate mipmaps only when copying level 0
                        if (level === 0 && dstTexture.generateMipmaps)
                            _gl.generateMipmap(3553);
                        state.unbindTexture();
                    };
                    this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level) {
                        if (level === void 0) {
                            level = 0;
                        }
                        if (_this.isWebGL1Renderer) {
                            console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');
                            return;
                        }
                        var width = sourceBox.max.x - sourceBox.min.x + 1;
                        var height = sourceBox.max.y - sourceBox.min.y + 1;
                        var depth = sourceBox.max.z - sourceBox.min.z + 1;
                        var glFormat = utils.convert(dstTexture.format);
                        var glType = utils.convert(dstTexture.type);
                        var glTarget;
                        if (dstTexture.isData3DTexture) {
                            textures.setTexture3D(dstTexture, 0);
                            glTarget = 32879;
                        } else if (dstTexture.isDataArrayTexture) {
                            textures.setTexture2DArray(dstTexture, 0);
                            glTarget = 35866;
                        } else {
                            console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');
                            return;
                        }
                        _gl.pixelStorei(37440, dstTexture.flipY);
                        _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
                        _gl.pixelStorei(3317, dstTexture.unpackAlignment);
                        var unpackRowLen = _gl.getParameter(3314);
                        var unpackImageHeight = _gl.getParameter(32878);
                        var unpackSkipPixels = _gl.getParameter(3316);
                        var unpackSkipRows = _gl.getParameter(3315);
                        var unpackSkipImages = _gl.getParameter(32877);
                        var image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
                        _gl.pixelStorei(3314, image.width);
                        _gl.pixelStorei(32878, image.height);
                        _gl.pixelStorei(3316, sourceBox.min.x);
                        _gl.pixelStorei(3315, sourceBox.min.y);
                        _gl.pixelStorei(32877, sourceBox.min.z);
                        if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
                            _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
                        } else {
                            if (srcTexture.isCompressedTexture) {
                                console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');
                                _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
                            } else {
                                _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
                            }
                        }
                        _gl.pixelStorei(3314, unpackRowLen);
                        _gl.pixelStorei(32878, unpackImageHeight);
                        _gl.pixelStorei(3316, unpackSkipPixels);
                        _gl.pixelStorei(3315, unpackSkipRows);
                        _gl.pixelStorei(32877, unpackSkipImages);
                        // Generate mipmaps only when copying level 0
                        if (level === 0 && dstTexture.generateMipmaps)
                            _gl.generateMipmap(glTarget);
                        state.unbindTexture();
                    };
                    this.initTexture = function(texture) {
                        textures.setTexture2D(texture, 0);
                        state.unbindTexture();
                    };
                    this.resetState = function() {
                        _currentActiveCubeFace = 0;
                        _currentActiveMipmapLevel = 0;
                        _currentRenderTarget = null;
                        state.reset();
                        bindingStates.reset();
                    };
                    if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
                        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
                            detail: this
                        }));
                    }
                }
                WebGLRenderer.prototype.isWebGLRenderer = true;
                var WebGL1Renderer = /** @class */ (function(_super) {
                    __extends(WebGL1Renderer, _super);

                    function WebGL1Renderer() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    return WebGL1Renderer;
                }(WebGLRenderer));
                WebGL1Renderer.prototype.isWebGL1Renderer = true;
                var FogExp2 = /** @class */ (function() {
                    function FogExp2(color, density) {
                        if (density === void 0) {
                            density = 0.00025;
                        }
                        this.name = '';
                        this.color = new Color(color);
                        this.density = density;
                    }
                    FogExp2.prototype.clone = function() {
                        return new FogExp2(this.color, this.density);
                    };
                    FogExp2.prototype.toJSON = function( /* meta */ ) {
                        return {
                            type: 'FogExp2',
                            color: this.color.getHex(),
                            density: this.density
                        };
                    };
                    return FogExp2;
                }());
                FogExp2.prototype.isFogExp2 = true;
                var Fog = /** @class */ (function() {
                    function Fog(color, near, far) {
                        if (near === void 0) {
                            near = 1;
                        }
                        if (far === void 0) {
                            far = 1000;
                        }
                        this.name = '';
                        this.color = new Color(color);
                        this.near = near;
                        this.far = far;
                    }
                    Fog.prototype.clone = function() {
                        return new Fog(this.color, this.near, this.far);
                    };
                    Fog.prototype.toJSON = function( /* meta */ ) {
                        return {
                            type: 'Fog',
                            color: this.color.getHex(),
                            near: this.near,
                            far: this.far
                        };
                    };
                    return Fog;
                }());
                Fog.prototype.isFog = true;
                var Scene = /** @class */ (function(_super) {
                    __extends(Scene, _super);

                    function Scene() {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'Scene';
                        _this_1.background = null;
                        _this_1.environment = null;
                        _this_1.fog = null;
                        _this_1.overrideMaterial = null;
                        _this_1.autoUpdate = true; // checked by the renderer
                        if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
                            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
                                detail: _this_1
                            }));
                        }
                        return _this_1;
                    }
                    Scene.prototype.copy = function(source, recursive) {
                        _super.prototype.copy.call(this, source, recursive);
                        if (source.background !== null)
                            this.background = source.background.clone();
                        if (source.environment !== null)
                            this.environment = source.environment.clone();
                        if (source.fog !== null)
                            this.fog = source.fog.clone();
                        if (source.overrideMaterial !== null)
                            this.overrideMaterial = source.overrideMaterial.clone();
                        this.autoUpdate = source.autoUpdate;
                        this.matrixAutoUpdate = source.matrixAutoUpdate;
                        return this;
                    };
                    Scene.prototype.toJSON = function(meta) {
                        var data = _super.prototype.toJSON.call(this, meta);
                        if (this.fog !== null)
                            data.object.fog = this.fog.toJSON();
                        return data;
                    };
                    return Scene;
                }(Object3D));
                Scene.prototype.isScene = true;
                var InterleavedBuffer = /** @class */ (function() {
                    function InterleavedBuffer(array, stride) {
                        this.array = array;
                        this.stride = stride;
                        this.count = array !== undefined ? array.length / stride : 0;
                        this.usage = StaticDrawUsage;
                        this.updateRange = {
                            offset: 0,
                            count: -1
                        };
                        this.version = 0;
                        this.uuid = generateUUID();
                    }
                    InterleavedBuffer.prototype.onUploadCallback = function() {};
                    Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
                        set: function(value) {
                            if (value === true)
                                this.version++;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    InterleavedBuffer.prototype.setUsage = function(value) {
                        this.usage = value;
                        return this;
                    };
                    InterleavedBuffer.prototype.copy = function(source) {
                        this.array = new source.array.constructor(source.array);
                        this.count = source.count;
                        this.stride = source.stride;
                        this.usage = source.usage;
                        return this;
                    };
                    InterleavedBuffer.prototype.copyAt = function(index1, attribute, index2) {
                        index1 *= this.stride;
                        index2 *= attribute.stride;
                        for (var i = 0, l = this.stride; i < l; i++) {
                            this.array[index1 + i] = attribute.array[index2 + i];
                        }
                        return this;
                    };
                    InterleavedBuffer.prototype.set = function(value, offset) {
                        if (offset === void 0) {
                            offset = 0;
                        }
                        this.array.set(value, offset);
                        return this;
                    };
                    InterleavedBuffer.prototype.clone = function(data) {
                        if (data.arrayBuffers === undefined) {
                            data.arrayBuffers = {};
                        }
                        if (this.array.buffer._uuid === undefined) {
                            this.array.buffer._uuid = generateUUID();
                        }
                        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
                            data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
                        }
                        var array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
                        var ib = new this.constructor(array, this.stride);
                        ib.setUsage(this.usage);
                        return ib;
                    };
                    InterleavedBuffer.prototype.onUpload = function(callback) {
                        this.onUploadCallback = callback;
                        return this;
                    };
                    InterleavedBuffer.prototype.toJSON = function(data) {
                        if (data.arrayBuffers === undefined) {
                            data.arrayBuffers = {};
                        }
                        // generate UUID for array buffer if necessary
                        if (this.array.buffer._uuid === undefined) {
                            this.array.buffer._uuid = generateUUID();
                        }
                        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
                            data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
                        }
                        //
                        return {
                            uuid: this.uuid,
                            buffer: this.array.buffer._uuid,
                            type: this.array.constructor.name,
                            stride: this.stride
                        };
                    };
                    return InterleavedBuffer;
                }());
                InterleavedBuffer.prototype.isInterleavedBuffer = true;
                var _vector$6 = /*@__PURE__*/ new Vector3();
                var InterleavedBufferAttribute = /** @class */ (function() {
                    function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
                        if (normalized === void 0) {
                            normalized = false;
                        }
                        this.name = '';
                        this.data = interleavedBuffer;
                        this.itemSize = itemSize;
                        this.offset = offset;
                        this.normalized = normalized === true;
                    }
                    Object.defineProperty(InterleavedBufferAttribute.prototype, "count", {
                        get: function() {
                            return this.data.count;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(InterleavedBufferAttribute.prototype, "array", {
                        get: function() {
                            return this.data.array;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(InterleavedBufferAttribute.prototype, "needsUpdate", {
                        set: function(value) {
                            this.data.needsUpdate = value;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    InterleavedBufferAttribute.prototype.applyMatrix4 = function(m) {
                        for (var i = 0, l = this.data.count; i < l; i++) {
                            _vector$6.fromBufferAttribute(this, i);
                            _vector$6.applyMatrix4(m);
                            this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
                        }
                        return this;
                    };
                    InterleavedBufferAttribute.prototype.applyNormalMatrix = function(m) {
                        for (var i = 0, l = this.count; i < l; i++) {
                            _vector$6.fromBufferAttribute(this, i);
                            _vector$6.applyNormalMatrix(m);
                            this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
                        }
                        return this;
                    };
                    InterleavedBufferAttribute.prototype.transformDirection = function(m) {
                        for (var i = 0, l = this.count; i < l; i++) {
                            _vector$6.fromBufferAttribute(this, i);
                            _vector$6.transformDirection(m);
                            this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
                        }
                        return this;
                    };
                    InterleavedBufferAttribute.prototype.setX = function(index, x) {
                        this.data.array[index * this.data.stride + this.offset] = x;
                        return this;
                    };
                    InterleavedBufferAttribute.prototype.setY = function(index, y) {
                        this.data.array[index * this.data.stride + this.offset + 1] = y;
                        return this;
                    };
                    InterleavedBufferAttribute.prototype.setZ = function(index, z) {
                        this.data.array[index * this.data.stride + this.offset + 2] = z;
                        return this;
                    };
                    InterleavedBufferAttribute.prototype.setW = function(index, w) {
                        this.data.array[index * this.data.stride + this.offset + 3] = w;
                        return this;
                    };
                    InterleavedBufferAttribute.prototype.getX = function(index) {
                        return this.data.array[index * this.data.stride + this.offset];
                    };
                    InterleavedBufferAttribute.prototype.getY = function(index) {
                        return this.data.array[index * this.data.stride + this.offset + 1];
                    };
                    InterleavedBufferAttribute.prototype.getZ = function(index) {
                        return this.data.array[index * this.data.stride + this.offset + 2];
                    };
                    InterleavedBufferAttribute.prototype.getW = function(index) {
                        return this.data.array[index * this.data.stride + this.offset + 3];
                    };
                    InterleavedBufferAttribute.prototype.setXY = function(index, x, y) {
                        index = index * this.data.stride + this.offset;
                        this.data.array[index + 0] = x;
                        this.data.array[index + 1] = y;
                        return this;
                    };
                    InterleavedBufferAttribute.prototype.setXYZ = function(index, x, y, z) {
                        index = index * this.data.stride + this.offset;
                        this.data.array[index + 0] = x;
                        this.data.array[index + 1] = y;
                        this.data.array[index + 2] = z;
                        return this;
                    };
                    InterleavedBufferAttribute.prototype.setXYZW = function(index, x, y, z, w) {
                        index = index * this.data.stride + this.offset;
                        this.data.array[index + 0] = x;
                        this.data.array[index + 1] = y;
                        this.data.array[index + 2] = z;
                        this.data.array[index + 3] = w;
                        return this;
                    };
                    InterleavedBufferAttribute.prototype.clone = function(data) {
                        if (data === undefined) {
                            console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
                            var array = [];
                            for (var i = 0; i < this.count; i++) {
                                var index = i * this.data.stride + this.offset;
                                for (var j = 0; j < this.itemSize; j++) {
                                    array.push(this.data.array[index + j]);
                                }
                            }
                            return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
                        } else {
                            if (data.interleavedBuffers === undefined) {
                                data.interleavedBuffers = {};
                            }
                            if (data.interleavedBuffers[this.data.uuid] === undefined) {
                                data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
                            }
                            return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
                        }
                    };
                    InterleavedBufferAttribute.prototype.toJSON = function(data) {
                        if (data === undefined) {
                            console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
                            var array = [];
                            for (var i = 0; i < this.count; i++) {
                                var index = i * this.data.stride + this.offset;
                                for (var j = 0; j < this.itemSize; j++) {
                                    array.push(this.data.array[index + j]);
                                }
                            }
                            // deinterleave data and save it as an ordinary buffer attribute for now
                            return {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: array,
                                normalized: this.normalized
                            };
                        } else {
                            // save as true interlaved attribtue
                            if (data.interleavedBuffers === undefined) {
                                data.interleavedBuffers = {};
                            }
                            if (data.interleavedBuffers[this.data.uuid] === undefined) {
                                data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
                            }
                            return {
                                isInterleavedBufferAttribute: true,
                                itemSize: this.itemSize,
                                data: this.data.uuid,
                                offset: this.offset,
                                normalized: this.normalized
                            };
                        }
                    };
                    return InterleavedBufferAttribute;
                }());
                InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
                var SpriteMaterial = /** @class */ (function(_super) {
                    __extends(SpriteMaterial, _super);

                    function SpriteMaterial(parameters) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'SpriteMaterial';
                        _this_1.color = new Color(0xffffff);
                        _this_1.map = null;
                        _this_1.alphaMap = null;
                        _this_1.rotation = 0;
                        _this_1.sizeAttenuation = true;
                        _this_1.transparent = true;
                        _this_1.setValues(parameters);
                        return _this_1;
                    }
                    SpriteMaterial.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.color.copy(source.color);
                        this.map = source.map;
                        this.alphaMap = source.alphaMap;
                        this.rotation = source.rotation;
                        this.sizeAttenuation = source.sizeAttenuation;
                        return this;
                    };
                    return SpriteMaterial;
                }(Material));
                SpriteMaterial.prototype.isSpriteMaterial = true;
                var _geometry;
                var _intersectPoint = /*@__PURE__*/ new Vector3();
                var _worldScale = /*@__PURE__*/ new Vector3();
                var _mvPosition = /*@__PURE__*/ new Vector3();
                var _alignedPosition = /*@__PURE__*/ new Vector2();
                var _rotatedPosition = /*@__PURE__*/ new Vector2();
                var _viewWorldMatrix = /*@__PURE__*/ new Matrix4();
                var _vA = /*@__PURE__*/ new Vector3();
                var _vB = /*@__PURE__*/ new Vector3();
                var _vC = /*@__PURE__*/ new Vector3();
                var _uvA = /*@__PURE__*/ new Vector2();
                var _uvB = /*@__PURE__*/ new Vector2();
                var _uvC = /*@__PURE__*/ new Vector2();
                var Sprite = /** @class */ (function(_super) {
                    __extends(Sprite, _super);

                    function Sprite(material) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'Sprite';
                        if (_geometry === undefined) {
                            _geometry = new BufferGeometry();
                            var float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0,
                                0.5, -0.5, 0, 1, 0,
                                0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1
                            ]);
                            var interleavedBuffer = new InterleavedBuffer(float32Array, 5);
                            _geometry.setIndex([0, 1, 2, 0, 2, 3]);
                            _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
                            _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
                        }
                        _this_1.geometry = _geometry;
                        _this_1.material = (material !== undefined) ? material : new SpriteMaterial();
                        _this_1.center = new Vector2(0.5, 0.5);
                        return _this_1;
                    }
                    Sprite.prototype.raycast = function(raycaster, intersects) {
                        if (raycaster.camera === null) {
                            console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
                        }
                        _worldScale.setFromMatrixScale(this.matrixWorld);
                        _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
                        this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
                        _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
                        if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
                            _worldScale.multiplyScalar(-_mvPosition.z);
                        }
                        var rotation = this.material.rotation;
                        var sin, cos;
                        if (rotation !== 0) {
                            cos = Math.cos(rotation);
                            sin = Math.sin(rotation);
                        }
                        var center = this.center;
                        transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
                        transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
                        transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
                        _uvA.set(0, 0);
                        _uvB.set(1, 0);
                        _uvC.set(1, 1);
                        // check first triangle
                        var intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
                        if (intersect === null) {
                            // check second triangle
                            transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
                            _uvB.set(0, 1);
                            intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
                            if (intersect === null) {
                                return;
                            }
                        }
                        var distance = raycaster.ray.origin.distanceTo(_intersectPoint);
                        if (distance < raycaster.near || distance > raycaster.far)
                            return;
                        intersects.push({
                            distance: distance,
                            point: _intersectPoint.clone(),
                            uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
                            face: null,
                            object: this
                        });
                    };
                    Sprite.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        if (source.center !== undefined)
                            this.center.copy(source.center);
                        this.material = source.material;
                        return this;
                    };
                    return Sprite;
                }(Object3D));
                Sprite.prototype.isSprite = true;

                function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
                    // compute position in camera space
                    _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
                    // to check if rotation is not zero
                    if (sin !== undefined) {
                        _rotatedPosition.x = (cos * _alignedPosition.x) - (sin * _alignedPosition.y);
                        _rotatedPosition.y = (sin * _alignedPosition.x) + (cos * _alignedPosition.y);
                    } else {
                        _rotatedPosition.copy(_alignedPosition);
                    }
                    vertexPosition.copy(mvPosition);
                    vertexPosition.x += _rotatedPosition.x;
                    vertexPosition.y += _rotatedPosition.y;
                    // transform to world space
                    vertexPosition.applyMatrix4(_viewWorldMatrix);
                }
                var _v1$2 = /*@__PURE__*/ new Vector3();
                var _v2$1 = /*@__PURE__*/ new Vector3();
                var LOD = /** @class */ (function(_super) {
                    __extends(LOD, _super);

                    function LOD() {
                        var _this_1 = _super.call(this) || this;
                        _this_1._currentLevel = 0;
                        _this_1.type = 'LOD';
                        Object.defineProperties(_this_1, {
                            levels: {
                                enumerable: true,
                                value: []
                            },
                            isLOD: {
                                value: true,
                            }
                        });
                        _this_1.autoUpdate = true;
                        return _this_1;
                    }
                    LOD.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source, false);
                        var levels = source.levels;
                        for (var i = 0, l = levels.length; i < l; i++) {
                            var level = levels[i];
                            this.addLevel(level.object.clone(), level.distance);
                        }
                        this.autoUpdate = source.autoUpdate;
                        return this;
                    };
                    LOD.prototype.addLevel = function(object, distance) {
                        if (distance === void 0) {
                            distance = 0;
                        }
                        distance = Math.abs(distance);
                        var levels = this.levels;
                        var l;
                        for (l = 0; l < levels.length; l++) {
                            if (distance < levels[l].distance) {
                                break;
                            }
                        }
                        levels.splice(l, 0, {
                            distance: distance,
                            object: object
                        });
                        this.add(object);
                        return this;
                    };
                    LOD.prototype.getCurrentLevel = function() {
                        return this._currentLevel;
                    };
                    LOD.prototype.getObjectForDistance = function(distance) {
                        var levels = this.levels;
                        if (levels.length > 0) {
                            var i = void 0,
                                l = void 0;
                            for (i = 1, l = levels.length; i < l; i++) {
                                if (distance < levels[i].distance) {
                                    break;
                                }
                            }
                            return levels[i - 1].object;
                        }
                        return null;
                    };
                    LOD.prototype.raycast = function(raycaster, intersects) {
                        var levels = this.levels;
                        if (levels.length > 0) {
                            _v1$2.setFromMatrixPosition(this.matrixWorld);
                            var distance = raycaster.ray.origin.distanceTo(_v1$2);
                            this.getObjectForDistance(distance).raycast(raycaster, intersects);
                        }
                    };
                    LOD.prototype.update = function(camera) {
                        var levels = this.levels;
                        if (levels.length > 1) {
                            _v1$2.setFromMatrixPosition(camera.matrixWorld);
                            _v2$1.setFromMatrixPosition(this.matrixWorld);
                            var distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
                            levels[0].object.visible = true;
                            var i = void 0,
                                l = void 0;
                            for (i = 1, l = levels.length; i < l; i++) {
                                if (distance >= levels[i].distance) {
                                    levels[i - 1].object.visible = false;
                                    levels[i].object.visible = true;
                                } else {
                                    break;
                                }
                            }
                            this._currentLevel = i - 1;
                            for (; i < l; i++) {
                                levels[i].object.visible = false;
                            }
                        }
                    };
                    LOD.prototype.toJSON = function(meta) {
                        var data = _super.prototype.toJSON.call(this, meta);
                        if (this.autoUpdate === false)
                            data.object.autoUpdate = false;
                        data.object.levels = [];
                        var levels = this.levels;
                        for (var i = 0, l = levels.length; i < l; i++) {
                            var level = levels[i];
                            data.object.levels.push({
                                object: level.object.uuid,
                                distance: level.distance
                            });
                        }
                        return data;
                    };
                    return LOD;
                }(Object3D));
                var _basePosition = /*@__PURE__*/ new Vector3();
                var _skinIndex = /*@__PURE__*/ new Vector4();
                var _skinWeight = /*@__PURE__*/ new Vector4();
                var _vector$5 = /*@__PURE__*/ new Vector3();
                var _matrix = /*@__PURE__*/ new Matrix4();
                var SkinnedMesh = /** @class */ (function(_super) {
                    __extends(SkinnedMesh, _super);

                    function SkinnedMesh(geometry, material) {
                        var _this_1 = _super.call(this, geometry, material) || this;
                        _this_1.type = 'SkinnedMesh';
                        _this_1.bindMode = 'attached';
                        _this_1.bindMatrix = new Matrix4();
                        _this_1.bindMatrixInverse = new Matrix4();
                        return _this_1;
                    }
                    SkinnedMesh.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.bindMode = source.bindMode;
                        this.bindMatrix.copy(source.bindMatrix);
                        this.bindMatrixInverse.copy(source.bindMatrixInverse);
                        this.skeleton = source.skeleton;
                        return this;
                    };
                    SkinnedMesh.prototype.bind = function(skeleton, bindMatrix) {
                        this.skeleton = skeleton;
                        if (bindMatrix === undefined) {
                            this.updateMatrixWorld(true);
                            this.skeleton.calculateInverses();
                            bindMatrix = this.matrixWorld;
                        }
                        this.bindMatrix.copy(bindMatrix);
                        this.bindMatrixInverse.copy(bindMatrix).invert();
                    };
                    SkinnedMesh.prototype.pose = function() {
                        this.skeleton.pose();
                    };
                    SkinnedMesh.prototype.normalizeSkinWeights = function() {
                        var vector = new Vector4();
                        var skinWeight = this.geometry.attributes.skinWeight;
                        for (var i = 0, l = skinWeight.count; i < l; i++) {
                            vector.fromBufferAttribute(skinWeight, i);
                            var scale = 1.0 / vector.manhattanLength();
                            if (scale !== Infinity) {
                                vector.multiplyScalar(scale);
                            } else {
                                vector.set(1, 0, 0, 0); // do something reasonable
                            }
                            skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
                        }
                    };
                    SkinnedMesh.prototype.updateMatrixWorld = function(force) {
                        _super.prototype.updateMatrixWorld.call(this, force);
                        if (this.bindMode === 'attached') {
                            this.bindMatrixInverse.copy(this.matrixWorld).invert();
                        } else if (this.bindMode === 'detached') {
                            this.bindMatrixInverse.copy(this.bindMatrix).invert();
                        } else {
                            console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
                        }
                    };
                    SkinnedMesh.prototype.boneTransform = function(index, target) {
                        var skeleton = this.skeleton;
                        var geometry = this.geometry;
                        _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
                        _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
                        _basePosition.copy(target).applyMatrix4(this.bindMatrix);
                        target.set(0, 0, 0);
                        for (var i = 0; i < 4; i++) {
                            var weight = _skinWeight.getComponent(i);
                            if (weight !== 0) {
                                var boneIndex = _skinIndex.getComponent(i);
                                _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
                                target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
                            }
                        }
                        return target.applyMatrix4(this.bindMatrixInverse);
                    };
                    return SkinnedMesh;
                }(Mesh));
                SkinnedMesh.prototype.isSkinnedMesh = true;
                var Bone = /** @class */ (function(_super) {
                    __extends(Bone, _super);

                    function Bone() {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'Bone';
                        return _this_1;
                    }
                    return Bone;
                }(Object3D));
                Bone.prototype.isBone = true;
                var DataTexture = /** @class */ (function(_super) {
                    __extends(DataTexture, _super);

                    function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
                        if (data === void 0) {
                            data = null;
                        }
                        if (width === void 0) {
                            width = 1;
                        }
                        if (height === void 0) {
                            height = 1;
                        }
                        if (magFilter === void 0) {
                            magFilter = NearestFilter;
                        }
                        if (minFilter === void 0) {
                            minFilter = NearestFilter;
                        }
                        var _this_1 = _super.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) || this;
                        _this_1.image = {
                            data: data,
                            width: width,
                            height: height
                        };
                        _this_1.generateMipmaps = false;
                        _this_1.flipY = false;
                        _this_1.unpackAlignment = 1;
                        return _this_1;
                    }
                    return DataTexture;
                }(Texture));
                DataTexture.prototype.isDataTexture = true;
                var _offsetMatrix = /*@__PURE__*/ new Matrix4();
                var _identityMatrix = /*@__PURE__*/ new Matrix4();
                var Skeleton = /** @class */ (function() {
                    function Skeleton(bones, boneInverses) {
                        if (bones === void 0) {
                            bones = [];
                        }
                        if (boneInverses === void 0) {
                            boneInverses = [];
                        }
                        this.uuid = generateUUID();
                        this.bones = bones.slice(0);
                        this.boneInverses = boneInverses;
                        this.boneMatrices = null;
                        this.boneTexture = null;
                        this.boneTextureSize = 0;
                        this.frame = -1;
                        this.init();
                    }
                    Skeleton.prototype.init = function() {
                        var bones = this.bones;
                        var boneInverses = this.boneInverses;
                        this.boneMatrices = new Float32Array(bones.length * 16);
                        // calculate inverse bone matrices if necessary
                        if (boneInverses.length === 0) {
                            this.calculateInverses();
                        } else {
                            // handle special case
                            if (bones.length !== boneInverses.length) {
                                console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
                                this.boneInverses = [];
                                for (var i = 0, il = this.bones.length; i < il; i++) {
                                    this.boneInverses.push(new Matrix4());
                                }
                            }
                        }
                    };
                    Skeleton.prototype.calculateInverses = function() {
                        this.boneInverses.length = 0;
                        for (var i = 0, il = this.bones.length; i < il; i++) {
                            var inverse = new Matrix4();
                            if (this.bones[i]) {
                                inverse.copy(this.bones[i].matrixWorld).invert();
                            }
                            this.boneInverses.push(inverse);
                        }
                    };
                    Skeleton.prototype.pose = function() {
                        // recover the bind-time world matrices
                        for (var i = 0, il = this.bones.length; i < il; i++) {
                            var bone = this.bones[i];
                            if (bone) {
                                bone.matrixWorld.copy(this.boneInverses[i]).invert();
                            }
                        }
                        // compute the local matrices, positions, rotations and scales
                        for (var i = 0, il = this.bones.length; i < il; i++) {
                            var bone = this.bones[i];
                            if (bone) {
                                if (bone.parent && bone.parent.isBone) {
                                    bone.matrix.copy(bone.parent.matrixWorld).invert();
                                    bone.matrix.multiply(bone.matrixWorld);
                                } else {
                                    bone.matrix.copy(bone.matrixWorld);
                                }
                                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
                            }
                        }
                    };
                    Skeleton.prototype.update = function() {
                        var bones = this.bones;
                        var boneInverses = this.boneInverses;
                        var boneMatrices = this.boneMatrices;
                        var boneTexture = this.boneTexture;
                        // flatten bone matrices to array
                        for (var i = 0, il = bones.length; i < il; i++) {
                            // compute the offset between the current and the original transform
                            var matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
                            _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
                            _offsetMatrix.toArray(boneMatrices, i * 16);
                        }
                        if (boneTexture !== null) {
                            boneTexture.needsUpdate = true;
                        }
                    };
                    Skeleton.prototype.clone = function() {
                        return new Skeleton(this.bones, this.boneInverses);
                    };
                    Skeleton.prototype.computeBoneTexture = function() {
                        // layout (1 matrix = 4 pixels)
                        //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                        //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
                        //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
                        //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
                        //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
                        var size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix
                        size = ceilPowerOfTwo(size);
                        size = Math.max(size, 4);
                        var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
                        boneMatrices.set(this.boneMatrices); // copy current values
                        var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
                        boneTexture.needsUpdate = true;
                        this.boneMatrices = boneMatrices;
                        this.boneTexture = boneTexture;
                        this.boneTextureSize = size;
                        return this;
                    };
                    Skeleton.prototype.getBoneByName = function(name) {
                        for (var i = 0, il = this.bones.length; i < il; i++) {
                            var bone = this.bones[i];
                            if (bone.name === name) {
                                return bone;
                            }
                        }
                        return undefined;
                    };
                    Skeleton.prototype.dispose = function() {
                        if (this.boneTexture !== null) {
                            this.boneTexture.dispose();
                            this.boneTexture = null;
                        }
                    };
                    Skeleton.prototype.fromJSON = function(json, bones) {
                        this.uuid = json.uuid;
                        for (var i = 0, l = json.bones.length; i < l; i++) {
                            var uuid = json.bones[i];
                            var bone = bones[uuid];
                            if (bone === undefined) {
                                console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
                                bone = new Bone();
                            }
                            this.bones.push(bone);
                            this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
                        }
                        this.init();
                        return this;
                    };
                    Skeleton.prototype.toJSON = function() {
                        var data = {
                            metadata: {
                                version: 4.5,
                                type: 'Skeleton',
                                generator: 'Skeleton.toJSON'
                            },
                            bones: [],
                            boneInverses: []
                        };
                        data.uuid = this.uuid;
                        var bones = this.bones;
                        var boneInverses = this.boneInverses;
                        for (var i = 0, l = bones.length; i < l; i++) {
                            var bone = bones[i];
                            data.bones.push(bone.uuid);
                            var boneInverse = boneInverses[i];
                            data.boneInverses.push(boneInverse.toArray());
                        }
                        return data;
                    };
                    return Skeleton;
                }());
                var InstancedBufferAttribute = /** @class */ (function(_super) {
                    __extends(InstancedBufferAttribute, _super);

                    function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
                        if (meshPerAttribute === void 0) {
                            meshPerAttribute = 1;
                        }
                        var _this_1 = this;
                        if (typeof normalized === 'number') {
                            meshPerAttribute = normalized;
                            normalized = false;
                            console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
                        }
                        _this_1 = _super.call(this, array, itemSize, normalized) || this;
                        _this_1.meshPerAttribute = meshPerAttribute;
                        return _this_1;
                    }
                    InstancedBufferAttribute.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.meshPerAttribute = source.meshPerAttribute;
                        return this;
                    };
                    InstancedBufferAttribute.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this);
                        data.meshPerAttribute = this.meshPerAttribute;
                        data.isInstancedBufferAttribute = true;
                        return data;
                    };
                    return InstancedBufferAttribute;
                }(BufferAttribute));
                InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
                var _instanceLocalMatrix = /*@__PURE__*/ new Matrix4();
                var _instanceWorldMatrix = /*@__PURE__*/ new Matrix4();
                var _instanceIntersects = [];
                var _mesh = /*@__PURE__*/ new Mesh();
                var InstancedMesh = /** @class */ (function(_super) {
                    __extends(InstancedMesh, _super);

                    function InstancedMesh(geometry, material, count) {
                        var _this_1 = _super.call(this, geometry, material) || this;
                        _this_1.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
                        _this_1.instanceColor = null;
                        _this_1.count = count;
                        _this_1.frustumCulled = false;
                        return _this_1;
                    }
                    InstancedMesh.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.instanceMatrix.copy(source.instanceMatrix);
                        if (source.instanceColor !== null)
                            this.instanceColor = source.instanceColor.clone();
                        this.count = source.count;
                        return this;
                    };
                    InstancedMesh.prototype.getColorAt = function(index, color) {
                        color.fromArray(this.instanceColor.array, index * 3);
                    };
                    InstancedMesh.prototype.getMatrixAt = function(index, matrix) {
                        matrix.fromArray(this.instanceMatrix.array, index * 16);
                    };
                    InstancedMesh.prototype.raycast = function(raycaster, intersects) {
                        var matrixWorld = this.matrixWorld;
                        var raycastTimes = this.count;
                        _mesh.geometry = this.geometry;
                        _mesh.material = this.material;
                        if (_mesh.material === undefined)
                            return;
                        for (var instanceId = 0; instanceId < raycastTimes; instanceId++) {
                            // calculate the world matrix for each instance
                            this.getMatrixAt(instanceId, _instanceLocalMatrix);
                            _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
                            // the mesh represents this single instance
                            _mesh.matrixWorld = _instanceWorldMatrix;
                            _mesh.raycast(raycaster, _instanceIntersects);
                            // process the result of raycast
                            for (var i = 0, l = _instanceIntersects.length; i < l; i++) {
                                var intersect = _instanceIntersects[i];
                                intersect.instanceId = instanceId;
                                intersect.object = this;
                                intersects.push(intersect);
                            }
                            _instanceIntersects.length = 0;
                        }
                    };
                    InstancedMesh.prototype.setColorAt = function(index, color) {
                        if (this.instanceColor === null) {
                            this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
                        }
                        color.toArray(this.instanceColor.array, index * 3);
                    };
                    InstancedMesh.prototype.setMatrixAt = function(index, matrix) {
                        matrix.toArray(this.instanceMatrix.array, index * 16);
                    };
                    InstancedMesh.prototype.updateMorphTargets = function() {};
                    InstancedMesh.prototype.dispose = function() {
                        this.dispatchEvent({
                            type: 'dispose'
                        });
                    };
                    return InstancedMesh;
                }(Mesh));
                InstancedMesh.prototype.isInstancedMesh = true;
                var LineBasicMaterial = /** @class */ (function(_super) {
                    __extends(LineBasicMaterial, _super);

                    function LineBasicMaterial(parameters) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'LineBasicMaterial';
                        _this_1.color = new Color(0xffffff);
                        _this_1.linewidth = 1;
                        _this_1.linecap = 'round';
                        _this_1.linejoin = 'round';
                        _this_1.setValues(parameters);
                        return _this_1;
                    }
                    LineBasicMaterial.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.color.copy(source.color);
                        this.linewidth = source.linewidth;
                        this.linecap = source.linecap;
                        this.linejoin = source.linejoin;
                        return this;
                    };
                    return LineBasicMaterial;
                }(Material));
                LineBasicMaterial.prototype.isLineBasicMaterial = true;
                var _start$1 = /*@__PURE__*/ new Vector3();
                var _end$1 = /*@__PURE__*/ new Vector3();
                var _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
                var _ray$1 = /*@__PURE__*/ new Ray();
                var _sphere$1 = /*@__PURE__*/ new Sphere();
                var Line = /** @class */ (function(_super) {
                    __extends(Line, _super);

                    function Line(geometry, material) {
                        if (geometry === void 0) {
                            geometry = new BufferGeometry();
                        }
                        if (material === void 0) {
                            material = new LineBasicMaterial();
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'Line';
                        _this_1.geometry = geometry;
                        _this_1.material = material;
                        _this_1.updateMorphTargets();
                        return _this_1;
                    }
                    Line.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.material = source.material;
                        this.geometry = source.geometry;
                        return this;
                    };
                    Line.prototype.computeLineDistances = function() {
                        var geometry = this.geometry;
                        if (geometry.isBufferGeometry) {
                            // we assume non-indexed geometry
                            if (geometry.index === null) {
                                var positionAttribute = geometry.attributes.position;
                                var lineDistances = [0];
                                for (var i = 1, l = positionAttribute.count; i < l; i++) {
                                    _start$1.fromBufferAttribute(positionAttribute, i - 1);
                                    _end$1.fromBufferAttribute(positionAttribute, i);
                                    lineDistances[i] = lineDistances[i - 1];
                                    lineDistances[i] += _start$1.distanceTo(_end$1);
                                }
                                geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
                            } else {
                                console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
                            }
                        } else if (geometry.isGeometry) {
                            console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
                        }
                        return this;
                    };
                    Line.prototype.raycast = function(raycaster, intersects) {
                        var geometry = this.geometry;
                        var matrixWorld = this.matrixWorld;
                        var threshold = raycaster.params.Line.threshold;
                        var drawRange = geometry.drawRange;
                        // Checking boundingSphere distance to ray
                        if (geometry.boundingSphere === null)
                            geometry.computeBoundingSphere();
                        _sphere$1.copy(geometry.boundingSphere);
                        _sphere$1.applyMatrix4(matrixWorld);
                        _sphere$1.radius += threshold;
                        if (raycaster.ray.intersectsSphere(_sphere$1) === false)
                            return;
                        //
                        _inverseMatrix$1.copy(matrixWorld).invert();
                        _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
                        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
                        var localThresholdSq = localThreshold * localThreshold;
                        var vStart = new Vector3();
                        var vEnd = new Vector3();
                        var interSegment = new Vector3();
                        var interRay = new Vector3();
                        var step = this.isLineSegments ? 2 : 1;
                        if (geometry.isBufferGeometry) {
                            var index = geometry.index;
                            var attributes = geometry.attributes;
                            var positionAttribute = attributes.position;
                            if (index !== null) {
                                var start = Math.max(0, drawRange.start);
                                var end = Math.min(index.count, (drawRange.start + drawRange.count));
                                for (var i = start, l = end - 1; i < l; i += step) {
                                    var a = index.getX(i);
                                    var b = index.getX(i + 1);
                                    vStart.fromBufferAttribute(positionAttribute, a);
                                    vEnd.fromBufferAttribute(positionAttribute, b);
                                    var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                                    if (distSq > localThresholdSq)
                                        continue;
                                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                                    var distance = raycaster.ray.origin.distanceTo(interRay);
                                    if (distance < raycaster.near || distance > raycaster.far)
                                        continue;
                                    intersects.push({
                                        distance: distance,
                                        // What do we want? intersection point on the ray or on the segment??
                                        // point: raycaster.ray.at( distance ),
                                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                        index: i,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    });
                                }
                            } else {
                                var start = Math.max(0, drawRange.start);
                                var end = Math.min(positionAttribute.count, (drawRange.start + drawRange.count));
                                for (var i = start, l = end - 1; i < l; i += step) {
                                    vStart.fromBufferAttribute(positionAttribute, i);
                                    vEnd.fromBufferAttribute(positionAttribute, i + 1);
                                    var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
                                    if (distSq > localThresholdSq)
                                        continue;
                                    interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation
                                    var distance = raycaster.ray.origin.distanceTo(interRay);
                                    if (distance < raycaster.near || distance > raycaster.far)
                                        continue;
                                    intersects.push({
                                        distance: distance,
                                        // What do we want? intersection point on the ray or on the segment??
                                        // point: raycaster.ray.at( distance ),
                                        point: interSegment.clone().applyMatrix4(this.matrixWorld),
                                        index: i,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    });
                                }
                            }
                        } else if (geometry.isGeometry) {
                            console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
                        }
                    };
                    Line.prototype.updateMorphTargets = function() {
                        var geometry = this.geometry;
                        if (geometry.isBufferGeometry) {
                            var morphAttributes = geometry.morphAttributes;
                            var keys = Object.keys(morphAttributes);
                            if (keys.length > 0) {
                                var morphAttribute = morphAttributes[keys[0]];
                                if (morphAttribute !== undefined) {
                                    this.morphTargetInfluences = [];
                                    this.morphTargetDictionary = {};
                                    for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
                                        var name = morphAttribute[m].name || String(m);
                                        this.morphTargetInfluences.push(0);
                                        this.morphTargetDictionary[name] = m;
                                    }
                                }
                            }
                        } else {
                            var morphTargets = geometry.morphTargets;
                            if (morphTargets !== undefined && morphTargets.length > 0) {
                                console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
                            }
                        }
                    };
                    return Line;
                }(Object3D));
                Line.prototype.isLine = true;
                var _start = /*@__PURE__*/ new Vector3();
                var _end = /*@__PURE__*/ new Vector3();
                var LineSegments = /** @class */ (function(_super) {
                    __extends(LineSegments, _super);

                    function LineSegments(geometry, material) {
                        var _this_1 = _super.call(this, geometry, material) || this;
                        _this_1.type = 'LineSegments';
                        return _this_1;
                    }
                    LineSegments.prototype.computeLineDistances = function() {
                        var geometry = this.geometry;
                        if (geometry.isBufferGeometry) {
                            // we assume non-indexed geometry
                            if (geometry.index === null) {
                                var positionAttribute = geometry.attributes.position;
                                var lineDistances = [];
                                for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
                                    _start.fromBufferAttribute(positionAttribute, i);
                                    _end.fromBufferAttribute(positionAttribute, i + 1);
                                    lineDistances[i] = (i === 0) ? 0 : lineDistances[i - 1];
                                    lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
                                }
                                geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
                            } else {
                                console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
                            }
                        } else if (geometry.isGeometry) {
                            console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
                        }
                        return this;
                    };
                    return LineSegments;
                }(Line));
                LineSegments.prototype.isLineSegments = true;
                var LineLoop = /** @class */ (function(_super) {
                    __extends(LineLoop, _super);

                    function LineLoop(geometry, material) {
                        var _this_1 = _super.call(this, geometry, material) || this;
                        _this_1.type = 'LineLoop';
                        return _this_1;
                    }
                    return LineLoop;
                }(Line));
                LineLoop.prototype.isLineLoop = true;
                var PointsMaterial = /** @class */ (function(_super) {
                    __extends(PointsMaterial, _super);

                    function PointsMaterial(parameters) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'PointsMaterial';
                        _this_1.color = new Color(0xffffff);
                        _this_1.map = null;
                        _this_1.alphaMap = null;
                        _this_1.size = 1;
                        _this_1.sizeAttenuation = true;
                        _this_1.setValues(parameters);
                        return _this_1;
                    }
                    PointsMaterial.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.color.copy(source.color);
                        this.map = source.map;
                        this.alphaMap = source.alphaMap;
                        this.size = source.size;
                        this.sizeAttenuation = source.sizeAttenuation;
                        return this;
                    };
                    return PointsMaterial;
                }(Material));
                PointsMaterial.prototype.isPointsMaterial = true;
                var _inverseMatrix = /*@__PURE__*/ new Matrix4();
                var _ray = /*@__PURE__*/ new Ray();
                var _sphere = /*@__PURE__*/ new Sphere();
                var _position$2 = /*@__PURE__*/ new Vector3();
                var Points = /** @class */ (function(_super) {
                    __extends(Points, _super);

                    function Points(geometry, material) {
                        if (geometry === void 0) {
                            geometry = new BufferGeometry();
                        }
                        if (material === void 0) {
                            material = new PointsMaterial();
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'Points';
                        _this_1.geometry = geometry;
                        _this_1.material = material;
                        _this_1.updateMorphTargets();
                        return _this_1;
                    }
                    Points.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.material = source.material;
                        this.geometry = source.geometry;
                        return this;
                    };
                    Points.prototype.raycast = function(raycaster, intersects) {
                        var geometry = this.geometry;
                        var matrixWorld = this.matrixWorld;
                        var threshold = raycaster.params.Points.threshold;
                        var drawRange = geometry.drawRange;
                        // Checking boundingSphere distance to ray
                        if (geometry.boundingSphere === null)
                            geometry.computeBoundingSphere();
                        _sphere.copy(geometry.boundingSphere);
                        _sphere.applyMatrix4(matrixWorld);
                        _sphere.radius += threshold;
                        if (raycaster.ray.intersectsSphere(_sphere) === false)
                            return;
                        //
                        _inverseMatrix.copy(matrixWorld).invert();
                        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
                        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
                        var localThresholdSq = localThreshold * localThreshold;
                        if (geometry.isBufferGeometry) {
                            var index = geometry.index;
                            var attributes = geometry.attributes;
                            var positionAttribute = attributes.position;
                            if (index !== null) {
                                var start = Math.max(0, drawRange.start);
                                var end = Math.min(index.count, (drawRange.start + drawRange.count));
                                for (var i = start, il = end; i < il; i++) {
                                    var a = index.getX(i);
                                    _position$2.fromBufferAttribute(positionAttribute, a);
                                    testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
                                }
                            } else {
                                var start = Math.max(0, drawRange.start);
                                var end = Math.min(positionAttribute.count, (drawRange.start + drawRange.count));
                                for (var i = start, l = end; i < l; i++) {
                                    _position$2.fromBufferAttribute(positionAttribute, i);
                                    testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
                                }
                            }
                        } else {
                            console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
                        }
                    };
                    Points.prototype.updateMorphTargets = function() {
                        var geometry = this.geometry;
                        if (geometry.isBufferGeometry) {
                            var morphAttributes = geometry.morphAttributes;
                            var keys = Object.keys(morphAttributes);
                            if (keys.length > 0) {
                                var morphAttribute = morphAttributes[keys[0]];
                                if (morphAttribute !== undefined) {
                                    this.morphTargetInfluences = [];
                                    this.morphTargetDictionary = {};
                                    for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
                                        var name = morphAttribute[m].name || String(m);
                                        this.morphTargetInfluences.push(0);
                                        this.morphTargetDictionary[name] = m;
                                    }
                                }
                            }
                        } else {
                            var morphTargets = geometry.morphTargets;
                            if (morphTargets !== undefined && morphTargets.length > 0) {
                                console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
                            }
                        }
                    };
                    return Points;
                }(Object3D));
                Points.prototype.isPoints = true;

                function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
                    var rayPointDistanceSq = _ray.distanceSqToPoint(point);
                    if (rayPointDistanceSq < localThresholdSq) {
                        var intersectPoint = new Vector3();
                        _ray.closestPointToPoint(point, intersectPoint);
                        intersectPoint.applyMatrix4(matrixWorld);
                        var distance = raycaster.ray.origin.distanceTo(intersectPoint);
                        if (distance < raycaster.near || distance > raycaster.far)
                            return;
                        intersects.push({
                            distance: distance,
                            distanceToRay: Math.sqrt(rayPointDistanceSq),
                            point: intersectPoint,
                            index: index,
                            face: null,
                            object: object
                        });
                    }
                }
                var VideoTexture = /** @class */ (function(_super) {
                    __extends(VideoTexture, _super);

                    function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
                        var _this_1 = _super.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) || this;
                        _this_1.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
                        _this_1.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
                        _this_1.generateMipmaps = false;
                        var scope = _this_1;

                        function updateVideo() {
                            scope.needsUpdate = true;
                            video.requestVideoFrameCallback(updateVideo);
                        }
                        if ('requestVideoFrameCallback' in video) {
                            video.requestVideoFrameCallback(updateVideo);
                        }
                        return _this_1;
                    }
                    VideoTexture.prototype.clone = function() {
                        return new this.constructor(this.image).copy(this);
                    };
                    VideoTexture.prototype.update = function() {
                        var video = this.image;
                        var hasVideoFrameCallback = 'requestVideoFrameCallback' in video;
                        if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
                            this.needsUpdate = true;
                        }
                    };
                    return VideoTexture;
                }(Texture));
                VideoTexture.prototype.isVideoTexture = true;
                var FramebufferTexture = /** @class */ (function(_super) {
                    __extends(FramebufferTexture, _super);

                    function FramebufferTexture(width, height, format) {
                        var _this_1 = _super.call(this, {
                            width: width,
                            height: height
                        }) || this;
                        _this_1.format = format;
                        _this_1.magFilter = NearestFilter;
                        _this_1.minFilter = NearestFilter;
                        _this_1.generateMipmaps = false;
                        _this_1.needsUpdate = true;
                        return _this_1;
                    }
                    return FramebufferTexture;
                }(Texture));
                FramebufferTexture.prototype.isFramebufferTexture = true;
                var CompressedTexture = /** @class */ (function(_super) {
                    __extends(CompressedTexture, _super);

                    function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
                        var _this_1 = _super.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) || this;
                        _this_1.image = {
                            width: width,
                            height: height
                        };
                        _this_1.mipmaps = mipmaps;
                        // no flipping for cube textures
                        // (also flipping doesn't work for compressed textures )
                        _this_1.flipY = false;
                        // can't generate mipmaps for compressed textures
                        // mips must be embedded in DDS files
                        _this_1.generateMipmaps = false;
                        return _this_1;
                    }
                    return CompressedTexture;
                }(Texture));
                CompressedTexture.prototype.isCompressedTexture = true;
                var CanvasTexture = /** @class */ (function(_super) {
                    __extends(CanvasTexture, _super);

                    function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
                        var _this_1 = _super.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) || this;
                        _this_1.needsUpdate = true;
                        return _this_1;
                    }
                    return CanvasTexture;
                }(Texture));
                CanvasTexture.prototype.isCanvasTexture = true;
                /**
                 * Extensible curve object.
                 *
                 * Some common of curve methods:
                 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
                 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
                 * .getPoints(), .getSpacedPoints()
                 * .getLength()
                 * .updateArcLengths()
                 *
                 * This following curves inherit from THREE.Curve:
                 *
                 * -- 2D curves --
                 * THREE.ArcCurve
                 * THREE.CubicBezierCurve
                 * THREE.EllipseCurve
                 * THREE.LineCurve
                 * THREE.QuadraticBezierCurve
                 * THREE.SplineCurve
                 *
                 * -- 3D curves --
                 * THREE.CatmullRomCurve3
                 * THREE.CubicBezierCurve3
                 * THREE.LineCurve3
                 * THREE.QuadraticBezierCurve3
                 *
                 * A series of curves can be represented as a THREE.CurvePath.
                 *
                 **/
                var Curve = /** @class */ (function() {
                    function Curve() {
                        this.type = 'Curve';
                        this.arcLengthDivisions = 200;
                    }
                    // Virtual base class method to overwrite and implement in subclasses
                    //	- t [0 .. 1]
                    Curve.prototype.getPoint = function( /* t, optionalTarget */ ) {
                        console.warn('THREE.Curve: .getPoint() not implemented.');
                        return null;
                    };
                    // Get point at relative position in curve according to arc length
                    // - u [0 .. 1]
                    Curve.prototype.getPointAt = function(u, optionalTarget) {
                        var t = this.getUtoTmapping(u);
                        return this.getPoint(t, optionalTarget);
                    };
                    // Get sequence of points using getPoint( t )
                    Curve.prototype.getPoints = function(divisions) {
                        if (divisions === void 0) {
                            divisions = 5;
                        }
                        var points = [];
                        for (var d = 0; d <= divisions; d++) {
                            points.push(this.getPoint(d / divisions));
                        }
                        return points;
                    };
                    // Get sequence of points using getPointAt( u )
                    Curve.prototype.getSpacedPoints = function(divisions) {
                        if (divisions === void 0) {
                            divisions = 5;
                        }
                        var points = [];
                        for (var d = 0; d <= divisions; d++) {
                            points.push(this.getPointAt(d / divisions));
                        }
                        return points;
                    };
                    // Get total curve arc length
                    Curve.prototype.getLength = function() {
                        var lengths = this.getLengths();
                        return lengths[lengths.length - 1];
                    };
                    // Get list of cumulative segment lengths
                    Curve.prototype.getLengths = function(divisions) {
                        if (divisions === void 0) {
                            divisions = this.arcLengthDivisions;
                        }
                        if (this.cacheArcLengths &&
                            (this.cacheArcLengths.length === divisions + 1) &&
                            !this.needsUpdate) {
                            return this.cacheArcLengths;
                        }
                        this.needsUpdate = false;
                        var cache = [];
                        var current, last = this.getPoint(0);
                        var sum = 0;
                        cache.push(0);
                        for (var p = 1; p <= divisions; p++) {
                            current = this.getPoint(p / divisions);
                            sum += current.distanceTo(last);
                            cache.push(sum);
                            last = current;
                        }
                        this.cacheArcLengths = cache;
                        return cache; // { sums: cache, sum: sum }; Sum is in the last element.
                    };
                    Curve.prototype.updateArcLengths = function() {
                        this.needsUpdate = true;
                        this.getLengths();
                    };
                    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
                    Curve.prototype.getUtoTmapping = function(u, distance) {
                        var arcLengths = this.getLengths();
                        var i = 0;
                        var il = arcLengths.length;
                        var targetArcLength; // The targeted u distance value to get
                        if (distance) {
                            targetArcLength = distance;
                        } else {
                            targetArcLength = u * arcLengths[il - 1];
                        }
                        // binary search for the index with largest value smaller than target u distance
                        var low = 0,
                            high = il - 1,
                            comparison;
                        while (low <= high) {
                            i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
                            comparison = arcLengths[i] - targetArcLength;
                            if (comparison < 0) {
                                low = i + 1;
                            } else if (comparison > 0) {
                                high = i - 1;
                            } else {
                                high = i;
                                break;
                                // DONE
                            }
                        }
                        i = high;
                        if (arcLengths[i] === targetArcLength) {
                            return i / (il - 1);
                        }
                        // we could get finer grain at lengths, or use simple interpolation between two points
                        var lengthBefore = arcLengths[i];
                        var lengthAfter = arcLengths[i + 1];
                        var segmentLength = lengthAfter - lengthBefore;
                        // determine where we are between the 'before' and 'after' points
                        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
                        // add that fractional amount to t
                        var t = (i + segmentFraction) / (il - 1);
                        return t;
                    };
                    // Returns a unit vector tangent at t
                    // In case any sub curve does not implement its tangent derivation,
                    // 2 points a small delta apart will be used to find its gradient
                    // which seems to give a reasonable approximation
                    Curve.prototype.getTangent = function(t, optionalTarget) {
                        var delta = 0.0001;
                        var t1 = t - delta;
                        var t2 = t + delta;
                        // Capping in case of danger
                        if (t1 < 0)
                            t1 = 0;
                        if (t2 > 1)
                            t2 = 1;
                        var pt1 = this.getPoint(t1);
                        var pt2 = this.getPoint(t2);
                        var tangent = optionalTarget || ((pt1.isVector2) ? new Vector2() : new Vector3());
                        tangent.copy(pt2).sub(pt1).normalize();
                        return tangent;
                    };
                    Curve.prototype.getTangentAt = function(u, optionalTarget) {
                        var t = this.getUtoTmapping(u);
                        return this.getTangent(t, optionalTarget);
                    };
                    Curve.prototype.computeFrenetFrames = function(segments, closed) {
                        // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
                        var normal = new Vector3();
                        var tangents = [];
                        var normals = [];
                        var binormals = [];
                        var vec = new Vector3();
                        var mat = new Matrix4();
                        // compute the tangent vectors for each segment on the curve
                        for (var i = 0; i <= segments; i++) {
                            var u = i / segments;
                            tangents[i] = this.getTangentAt(u, new Vector3());
                        }
                        // select an initial normal vector perpendicular to the first tangent vector,
                        // and in the direction of the minimum tangent xyz component
                        normals[0] = new Vector3();
                        binormals[0] = new Vector3();
                        var min = Number.MAX_VALUE;
                        var tx = Math.abs(tangents[0].x);
                        var ty = Math.abs(tangents[0].y);
                        var tz = Math.abs(tangents[0].z);
                        if (tx <= min) {
                            min = tx;
                            normal.set(1, 0, 0);
                        }
                        if (ty <= min) {
                            min = ty;
                            normal.set(0, 1, 0);
                        }
                        if (tz <= min) {
                            normal.set(0, 0, 1);
                        }
                        vec.crossVectors(tangents[0], normal).normalize();
                        normals[0].crossVectors(tangents[0], vec);
                        binormals[0].crossVectors(tangents[0], normals[0]);
                        // compute the slowly-varying normal and binormal vectors for each segment on the curve
                        for (var i = 1; i <= segments; i++) {
                            normals[i] = normals[i - 1].clone();
                            binormals[i] = binormals[i - 1].clone();
                            vec.crossVectors(tangents[i - 1], tangents[i]);
                            if (vec.length() > Number.EPSILON) {
                                vec.normalize();
                                var theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors
                                normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
                            }
                            binormals[i].crossVectors(tangents[i], normals[i]);
                        }
                        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
                        if (closed === true) {
                            var theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
                            theta /= segments;
                            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
                                theta = -theta;
                            }
                            for (var i = 1; i <= segments; i++) {
                                // twist a little...
                                normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
                                binormals[i].crossVectors(tangents[i], normals[i]);
                            }
                        }
                        return {
                            tangents: tangents,
                            normals: normals,
                            binormals: binormals
                        };
                    };
                    Curve.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    Curve.prototype.copy = function(source) {
                        this.arcLengthDivisions = source.arcLengthDivisions;
                        return this;
                    };
                    Curve.prototype.toJSON = function() {
                        var data = {
                            metadata: {
                                version: 4.5,
                                type: 'Curve',
                                generator: 'Curve.toJSON'
                            }
                        };
                        data.arcLengthDivisions = this.arcLengthDivisions;
                        data.type = this.type;
                        return data;
                    };
                    Curve.prototype.fromJSON = function(json) {
                        this.arcLengthDivisions = json.arcLengthDivisions;
                        return this;
                    };
                    return Curve;
                }());
                var EllipseCurve = /** @class */ (function(_super) {
                    __extends(EllipseCurve, _super);

                    function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
                        if (aX === void 0) {
                            aX = 0;
                        }
                        if (aY === void 0) {
                            aY = 0;
                        }
                        if (xRadius === void 0) {
                            xRadius = 1;
                        }
                        if (yRadius === void 0) {
                            yRadius = 1;
                        }
                        if (aStartAngle === void 0) {
                            aStartAngle = 0;
                        }
                        if (aEndAngle === void 0) {
                            aEndAngle = Math.PI * 2;
                        }
                        if (aClockwise === void 0) {
                            aClockwise = false;
                        }
                        if (aRotation === void 0) {
                            aRotation = 0;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'EllipseCurve';
                        _this_1.aX = aX;
                        _this_1.aY = aY;
                        _this_1.xRadius = xRadius;
                        _this_1.yRadius = yRadius;
                        _this_1.aStartAngle = aStartAngle;
                        _this_1.aEndAngle = aEndAngle;
                        _this_1.aClockwise = aClockwise;
                        _this_1.aRotation = aRotation;
                        return _this_1;
                    }
                    EllipseCurve.prototype.getPoint = function(t, optionalTarget) {
                        var point = optionalTarget || new Vector2();
                        var twoPi = Math.PI * 2;
                        var deltaAngle = this.aEndAngle - this.aStartAngle;
                        var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
                        // ensures that deltaAngle is 0 .. 2 PI
                        while (deltaAngle < 0)
                            deltaAngle += twoPi;
                        while (deltaAngle > twoPi)
                            deltaAngle -= twoPi;
                        if (deltaAngle < Number.EPSILON) {
                            if (samePoints) {
                                deltaAngle = 0;
                            } else {
                                deltaAngle = twoPi;
                            }
                        }
                        if (this.aClockwise === true && !samePoints) {
                            if (deltaAngle === twoPi) {
                                deltaAngle = -twoPi;
                            } else {
                                deltaAngle = deltaAngle - twoPi;
                            }
                        }
                        var angle = this.aStartAngle + t * deltaAngle;
                        var x = this.aX + this.xRadius * Math.cos(angle);
                        var y = this.aY + this.yRadius * Math.sin(angle);
                        if (this.aRotation !== 0) {
                            var cos = Math.cos(this.aRotation);
                            var sin = Math.sin(this.aRotation);
                            var tx = x - this.aX;
                            var ty = y - this.aY;
                            // Rotate the point about the center of the ellipse.
                            x = tx * cos - ty * sin + this.aX;
                            y = tx * sin + ty * cos + this.aY;
                        }
                        return point.set(x, y);
                    };
                    EllipseCurve.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.aX = source.aX;
                        this.aY = source.aY;
                        this.xRadius = source.xRadius;
                        this.yRadius = source.yRadius;
                        this.aStartAngle = source.aStartAngle;
                        this.aEndAngle = source.aEndAngle;
                        this.aClockwise = source.aClockwise;
                        this.aRotation = source.aRotation;
                        return this;
                    };
                    EllipseCurve.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this);
                        data.aX = this.aX;
                        data.aY = this.aY;
                        data.xRadius = this.xRadius;
                        data.yRadius = this.yRadius;
                        data.aStartAngle = this.aStartAngle;
                        data.aEndAngle = this.aEndAngle;
                        data.aClockwise = this.aClockwise;
                        data.aRotation = this.aRotation;
                        return data;
                    };
                    EllipseCurve.prototype.fromJSON = function(json) {
                        _super.prototype.fromJSON.call(this, json);
                        this.aX = json.aX;
                        this.aY = json.aY;
                        this.xRadius = json.xRadius;
                        this.yRadius = json.yRadius;
                        this.aStartAngle = json.aStartAngle;
                        this.aEndAngle = json.aEndAngle;
                        this.aClockwise = json.aClockwise;
                        this.aRotation = json.aRotation;
                        return this;
                    };
                    return EllipseCurve;
                }(Curve));
                EllipseCurve.prototype.isEllipseCurve = true;
                var ArcCurve = /** @class */ (function(_super) {
                    __extends(ArcCurve, _super);

                    function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
                        var _this_1 = _super.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise) || this;
                        _this_1.type = 'ArcCurve';
                        return _this_1;
                    }
                    return ArcCurve;
                }(EllipseCurve));
                ArcCurve.prototype.isArcCurve = true;
                /**
                 * Centripetal CatmullRom Curve - which is useful for avoiding
                 * cusps and self-intersections in non-uniform catmull rom curves.
                 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
                 *
                 * curve.type accepts centripetal(default), chordal and catmullrom
                 * curve.tension is used for catmullrom which defaults to 0.5
                 */
                /*
                Based on an optimized c++ solution in
                 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
                 - http://ideone.com/NoEbVM

                This CubicPoly class could be used for reusing some variables and calculations,
                but for three.js curve use, it could be possible inlined and flatten into a single function call
                which can be placed in CurveUtils.
                */
                function CubicPoly() {
                    var c0 = 0,
                        c1 = 0,
                        c2 = 0,
                        c3 = 0;
                    /*
                     * Compute coefficients for a cubic polynomial
                     *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
                     * such that
                     *   p(0) = x0, p(1) = x1
                     *  and
                     *   p'(0) = t0, p'(1) = t1.
                     */
                    function init(x0, x1, t0, t1) {
                        c0 = x0;
                        c1 = t0;
                        c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
                        c3 = 2 * x0 - 2 * x1 + t0 + t1;
                    }
                    return {
                        initCatmullRom: function(x0, x1, x2, x3, tension) {
                            init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
                        },
                        initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
                            // compute tangents when parameterized in [t1,t2]
                            var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
                            var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
                            // rescale tangents for parametrization in [0,1]
                            t1 *= dt1;
                            t2 *= dt1;
                            init(x1, x2, t1, t2);
                        },
                        calc: function(t) {
                            var t2 = t * t;
                            var t3 = t2 * t;
                            return c0 + c1 * t + c2 * t2 + c3 * t3;
                        }
                    };
                }
                //
                var tmp = new Vector3();
                var px = new CubicPoly(),
                    py = new CubicPoly(),
                    pz = new CubicPoly();
                var CatmullRomCurve3 = /** @class */ (function(_super) {
                    __extends(CatmullRomCurve3, _super);

                    function CatmullRomCurve3(points, closed, curveType, tension) {
                        if (points === void 0) {
                            points = [];
                        }
                        if (closed === void 0) {
                            closed = false;
                        }
                        if (curveType === void 0) {
                            curveType = 'centripetal';
                        }
                        if (tension === void 0) {
                            tension = 0.5;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'CatmullRomCurve3';
                        _this_1.points = points;
                        _this_1.closed = closed;
                        _this_1.curveType = curveType;
                        _this_1.tension = tension;
                        return _this_1;
                    }
                    CatmullRomCurve3.prototype.getPoint = function(t, optionalTarget) {
                        if (optionalTarget === void 0) {
                            optionalTarget = new Vector3();
                        }
                        var point = optionalTarget;
                        var points = this.points;
                        var l = points.length;
                        var p = (l - (this.closed ? 0 : 1)) * t;
                        var intPoint = Math.floor(p);
                        var weight = p - intPoint;
                        if (this.closed) {
                            intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
                        } else if (weight === 0 && intPoint === l - 1) {
                            intPoint = l - 2;
                            weight = 1;
                        }
                        var p0, p3; // 4 points (p1 & p2 defined below)
                        if (this.closed || intPoint > 0) {
                            p0 = points[(intPoint - 1) % l];
                        } else {
                            // extrapolate first point
                            tmp.subVectors(points[0], points[1]).add(points[0]);
                            p0 = tmp;
                        }
                        var p1 = points[intPoint % l];
                        var p2 = points[(intPoint + 1) % l];
                        if (this.closed || intPoint + 2 < l) {
                            p3 = points[(intPoint + 2) % l];
                        } else {
                            // extrapolate last point
                            tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
                            p3 = tmp;
                        }
                        if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
                            // init Centripetal / Chordal Catmull-Rom
                            var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
                            var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
                            var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
                            var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
                            // safety check for repeated points
                            if (dt1 < 1e-4)
                                dt1 = 1.0;
                            if (dt0 < 1e-4)
                                dt0 = dt1;
                            if (dt2 < 1e-4)
                                dt2 = dt1;
                            px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
                            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
                            pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
                        } else if (this.curveType === 'catmullrom') {
                            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
                            py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
                            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
                        }
                        point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
                        return point;
                    };
                    CatmullRomCurve3.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.points = [];
                        for (var i = 0, l = source.points.length; i < l; i++) {
                            var point = source.points[i];
                            this.points.push(point.clone());
                        }
                        this.closed = source.closed;
                        this.curveType = source.curveType;
                        this.tension = source.tension;
                        return this;
                    };
                    CatmullRomCurve3.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this);
                        data.points = [];
                        for (var i = 0, l = this.points.length; i < l; i++) {
                            var point = this.points[i];
                            data.points.push(point.toArray());
                        }
                        data.closed = this.closed;
                        data.curveType = this.curveType;
                        data.tension = this.tension;
                        return data;
                    };
                    CatmullRomCurve3.prototype.fromJSON = function(json) {
                        _super.prototype.fromJSON.call(this, json);
                        this.points = [];
                        for (var i = 0, l = json.points.length; i < l; i++) {
                            var point = json.points[i];
                            this.points.push(new Vector3().fromArray(point));
                        }
                        this.closed = json.closed;
                        this.curveType = json.curveType;
                        this.tension = json.tension;
                        return this;
                    };
                    return CatmullRomCurve3;
                }(Curve));
                CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
                /**
                 * Bezier Curves formulas obtained from
                 * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
                 */
                function CatmullRom(t, p0, p1, p2, p3) {
                    var v0 = (p2 - p0) * 0.5;
                    var v1 = (p3 - p1) * 0.5;
                    var t2 = t * t;
                    var t3 = t * t2;
                    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
                }
                //
                function QuadraticBezierP0(t, p) {
                    var k = 1 - t;
                    return k * k * p;
                }

                function QuadraticBezierP1(t, p) {
                    return 2 * (1 - t) * t * p;
                }

                function QuadraticBezierP2(t, p) {
                    return t * t * p;
                }

                function QuadraticBezier(t, p0, p1, p2) {
                    return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) +
                        QuadraticBezierP2(t, p2);
                }
                //
                function CubicBezierP0(t, p) {
                    var k = 1 - t;
                    return k * k * k * p;
                }

                function CubicBezierP1(t, p) {
                    var k = 1 - t;
                    return 3 * k * k * t * p;
                }

                function CubicBezierP2(t, p) {
                    return 3 * (1 - t) * t * t * p;
                }

                function CubicBezierP3(t, p) {
                    return t * t * t * p;
                }

                function CubicBezier(t, p0, p1, p2, p3) {
                    return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) +
                        CubicBezierP3(t, p3);
                }
                var CubicBezierCurve = /** @class */ (function(_super) {
                    __extends(CubicBezierCurve, _super);

                    function CubicBezierCurve(v0, v1, v2, v3) {
                        if (v0 === void 0) {
                            v0 = new Vector2();
                        }
                        if (v1 === void 0) {
                            v1 = new Vector2();
                        }
                        if (v2 === void 0) {
                            v2 = new Vector2();
                        }
                        if (v3 === void 0) {
                            v3 = new Vector2();
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'CubicBezierCurve';
                        _this_1.v0 = v0;
                        _this_1.v1 = v1;
                        _this_1.v2 = v2;
                        _this_1.v3 = v3;
                        return _this_1;
                    }
                    CubicBezierCurve.prototype.getPoint = function(t, optionalTarget) {
                        if (optionalTarget === void 0) {
                            optionalTarget = new Vector2();
                        }
                        var point = optionalTarget;
                        var v0 = this.v0,
                            v1 = this.v1,
                            v2 = this.v2,
                            v3 = this.v3;
                        point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
                        return point;
                    };
                    CubicBezierCurve.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.v0.copy(source.v0);
                        this.v1.copy(source.v1);
                        this.v2.copy(source.v2);
                        this.v3.copy(source.v3);
                        return this;
                    };
                    CubicBezierCurve.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this);
                        data.v0 = this.v0.toArray();
                        data.v1 = this.v1.toArray();
                        data.v2 = this.v2.toArray();
                        data.v3 = this.v3.toArray();
                        return data;
                    };
                    CubicBezierCurve.prototype.fromJSON = function(json) {
                        _super.prototype.fromJSON.call(this, json);
                        this.v0.fromArray(json.v0);
                        this.v1.fromArray(json.v1);
                        this.v2.fromArray(json.v2);
                        this.v3.fromArray(json.v3);
                        return this;
                    };
                    return CubicBezierCurve;
                }(Curve));
                CubicBezierCurve.prototype.isCubicBezierCurve = true;
                var CubicBezierCurve3 = /** @class */ (function(_super) {
                    __extends(CubicBezierCurve3, _super);

                    function CubicBezierCurve3(v0, v1, v2, v3) {
                        if (v0 === void 0) {
                            v0 = new Vector3();
                        }
                        if (v1 === void 0) {
                            v1 = new Vector3();
                        }
                        if (v2 === void 0) {
                            v2 = new Vector3();
                        }
                        if (v3 === void 0) {
                            v3 = new Vector3();
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'CubicBezierCurve3';
                        _this_1.v0 = v0;
                        _this_1.v1 = v1;
                        _this_1.v2 = v2;
                        _this_1.v3 = v3;
                        return _this_1;
                    }
                    CubicBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
                        if (optionalTarget === void 0) {
                            optionalTarget = new Vector3();
                        }
                        var point = optionalTarget;
                        var v0 = this.v0,
                            v1 = this.v1,
                            v2 = this.v2,
                            v3 = this.v3;
                        point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
                        return point;
                    };
                    CubicBezierCurve3.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.v0.copy(source.v0);
                        this.v1.copy(source.v1);
                        this.v2.copy(source.v2);
                        this.v3.copy(source.v3);
                        return this;
                    };
                    CubicBezierCurve3.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this);
                        data.v0 = this.v0.toArray();
                        data.v1 = this.v1.toArray();
                        data.v2 = this.v2.toArray();
                        data.v3 = this.v3.toArray();
                        return data;
                    };
                    CubicBezierCurve3.prototype.fromJSON = function(json) {
                        _super.prototype.fromJSON.call(this, json);
                        this.v0.fromArray(json.v0);
                        this.v1.fromArray(json.v1);
                        this.v2.fromArray(json.v2);
                        this.v3.fromArray(json.v3);
                        return this;
                    };
                    return CubicBezierCurve3;
                }(Curve));
                CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
                var LineCurve = /** @class */ (function(_super) {
                    __extends(LineCurve, _super);

                    function LineCurve(v1, v2) {
                        if (v1 === void 0) {
                            v1 = new Vector2();
                        }
                        if (v2 === void 0) {
                            v2 = new Vector2();
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'LineCurve';
                        _this_1.v1 = v1;
                        _this_1.v2 = v2;
                        return _this_1;
                    }
                    LineCurve.prototype.getPoint = function(t, optionalTarget) {
                        if (optionalTarget === void 0) {
                            optionalTarget = new Vector2();
                        }
                        var point = optionalTarget;
                        if (t === 1) {
                            point.copy(this.v2);
                        } else {
                            point.copy(this.v2).sub(this.v1);
                            point.multiplyScalar(t).add(this.v1);
                        }
                        return point;
                    };
                    // Line curve is linear, so we can overwrite default getPointAt
                    LineCurve.prototype.getPointAt = function(u, optionalTarget) {
                        return this.getPoint(u, optionalTarget);
                    };
                    LineCurve.prototype.getTangent = function(t, optionalTarget) {
                        var tangent = optionalTarget || new Vector2();
                        tangent.copy(this.v2).sub(this.v1).normalize();
                        return tangent;
                    };
                    LineCurve.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.v1.copy(source.v1);
                        this.v2.copy(source.v2);
                        return this;
                    };
                    LineCurve.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this);
                        data.v1 = this.v1.toArray();
                        data.v2 = this.v2.toArray();
                        return data;
                    };
                    LineCurve.prototype.fromJSON = function(json) {
                        _super.prototype.fromJSON.call(this, json);
                        this.v1.fromArray(json.v1);
                        this.v2.fromArray(json.v2);
                        return this;
                    };
                    return LineCurve;
                }(Curve));
                LineCurve.prototype.isLineCurve = true;
                var LineCurve3 = /** @class */ (function(_super) {
                    __extends(LineCurve3, _super);

                    function LineCurve3(v1, v2) {
                        if (v1 === void 0) {
                            v1 = new Vector3();
                        }
                        if (v2 === void 0) {
                            v2 = new Vector3();
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'LineCurve3';
                        _this_1.isLineCurve3 = true;
                        _this_1.v1 = v1;
                        _this_1.v2 = v2;
                        return _this_1;
                    }
                    LineCurve3.prototype.getPoint = function(t, optionalTarget) {
                        if (optionalTarget === void 0) {
                            optionalTarget = new Vector3();
                        }
                        var point = optionalTarget;
                        if (t === 1) {
                            point.copy(this.v2);
                        } else {
                            point.copy(this.v2).sub(this.v1);
                            point.multiplyScalar(t).add(this.v1);
                        }
                        return point;
                    };
                    // Line curve is linear, so we can overwrite default getPointAt
                    LineCurve3.prototype.getPointAt = function(u, optionalTarget) {
                        return this.getPoint(u, optionalTarget);
                    };
                    LineCurve3.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.v1.copy(source.v1);
                        this.v2.copy(source.v2);
                        return this;
                    };
                    LineCurve3.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this);
                        data.v1 = this.v1.toArray();
                        data.v2 = this.v2.toArray();
                        return data;
                    };
                    LineCurve3.prototype.fromJSON = function(json) {
                        _super.prototype.fromJSON.call(this, json);
                        this.v1.fromArray(json.v1);
                        this.v2.fromArray(json.v2);
                        return this;
                    };
                    return LineCurve3;
                }(Curve));
                var QuadraticBezierCurve = /** @class */ (function(_super) {
                    __extends(QuadraticBezierCurve, _super);

                    function QuadraticBezierCurve(v0, v1, v2) {
                        if (v0 === void 0) {
                            v0 = new Vector2();
                        }
                        if (v1 === void 0) {
                            v1 = new Vector2();
                        }
                        if (v2 === void 0) {
                            v2 = new Vector2();
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'QuadraticBezierCurve';
                        _this_1.v0 = v0;
                        _this_1.v1 = v1;
                        _this_1.v2 = v2;
                        return _this_1;
                    }
                    QuadraticBezierCurve.prototype.getPoint = function(t, optionalTarget) {
                        if (optionalTarget === void 0) {
                            optionalTarget = new Vector2();
                        }
                        var point = optionalTarget;
                        var v0 = this.v0,
                            v1 = this.v1,
                            v2 = this.v2;
                        point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
                        return point;
                    };
                    QuadraticBezierCurve.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.v0.copy(source.v0);
                        this.v1.copy(source.v1);
                        this.v2.copy(source.v2);
                        return this;
                    };
                    QuadraticBezierCurve.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this);
                        data.v0 = this.v0.toArray();
                        data.v1 = this.v1.toArray();
                        data.v2 = this.v2.toArray();
                        return data;
                    };
                    QuadraticBezierCurve.prototype.fromJSON = function(json) {
                        _super.prototype.fromJSON.call(this, json);
                        this.v0.fromArray(json.v0);
                        this.v1.fromArray(json.v1);
                        this.v2.fromArray(json.v2);
                        return this;
                    };
                    return QuadraticBezierCurve;
                }(Curve));
                QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
                var QuadraticBezierCurve3 = /** @class */ (function(_super) {
                    __extends(QuadraticBezierCurve3, _super);

                    function QuadraticBezierCurve3(v0, v1, v2) {
                        if (v0 === void 0) {
                            v0 = new Vector3();
                        }
                        if (v1 === void 0) {
                            v1 = new Vector3();
                        }
                        if (v2 === void 0) {
                            v2 = new Vector3();
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'QuadraticBezierCurve3';
                        _this_1.v0 = v0;
                        _this_1.v1 = v1;
                        _this_1.v2 = v2;
                        return _this_1;
                    }
                    QuadraticBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
                        if (optionalTarget === void 0) {
                            optionalTarget = new Vector3();
                        }
                        var point = optionalTarget;
                        var v0 = this.v0,
                            v1 = this.v1,
                            v2 = this.v2;
                        point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
                        return point;
                    };
                    QuadraticBezierCurve3.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.v0.copy(source.v0);
                        this.v1.copy(source.v1);
                        this.v2.copy(source.v2);
                        return this;
                    };
                    QuadraticBezierCurve3.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this);
                        data.v0 = this.v0.toArray();
                        data.v1 = this.v1.toArray();
                        data.v2 = this.v2.toArray();
                        return data;
                    };
                    QuadraticBezierCurve3.prototype.fromJSON = function(json) {
                        _super.prototype.fromJSON.call(this, json);
                        this.v0.fromArray(json.v0);
                        this.v1.fromArray(json.v1);
                        this.v2.fromArray(json.v2);
                        return this;
                    };
                    return QuadraticBezierCurve3;
                }(Curve));
                QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
                var SplineCurve = /** @class */ (function(_super) {
                    __extends(SplineCurve, _super);

                    function SplineCurve(points) {
                        if (points === void 0) {
                            points = [];
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'SplineCurve';
                        _this_1.points = points;
                        return _this_1;
                    }
                    SplineCurve.prototype.getPoint = function(t, optionalTarget) {
                        if (optionalTarget === void 0) {
                            optionalTarget = new Vector2();
                        }
                        var point = optionalTarget;
                        var points = this.points;
                        var p = (points.length - 1) * t;
                        var intPoint = Math.floor(p);
                        var weight = p - intPoint;
                        var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
                        var p1 = points[intPoint];
                        var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
                        var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
                        point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
                        return point;
                    };
                    SplineCurve.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.points = [];
                        for (var i = 0, l = source.points.length; i < l; i++) {
                            var point = source.points[i];
                            this.points.push(point.clone());
                        }
                        return this;
                    };
                    SplineCurve.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this);
                        data.points = [];
                        for (var i = 0, l = this.points.length; i < l; i++) {
                            var point = this.points[i];
                            data.points.push(point.toArray());
                        }
                        return data;
                    };
                    SplineCurve.prototype.fromJSON = function(json) {
                        _super.prototype.fromJSON.call(this, json);
                        this.points = [];
                        for (var i = 0, l = json.points.length; i < l; i++) {
                            var point = json.points[i];
                            this.points.push(new Vector2().fromArray(point));
                        }
                        return this;
                    };
                    return SplineCurve;
                }(Curve));
                SplineCurve.prototype.isSplineCurve = true;
                var Curves = /*#__PURE__*/ Object.freeze({
                    __proto__: null,
                    ArcCurve: ArcCurve,
                    CatmullRomCurve3: CatmullRomCurve3,
                    CubicBezierCurve: CubicBezierCurve,
                    CubicBezierCurve3: CubicBezierCurve3,
                    EllipseCurve: EllipseCurve,
                    LineCurve: LineCurve,
                    LineCurve3: LineCurve3,
                    QuadraticBezierCurve: QuadraticBezierCurve,
                    QuadraticBezierCurve3: QuadraticBezierCurve3,
                    SplineCurve: SplineCurve
                });
                /**************************************************************
                 *	Curved Path - a curve path is simply a array of connected
                 *  curves, but retains the api of a curve
                 **************************************************************/
                var CurvePath = /** @class */ (function(_super) {
                    __extends(CurvePath, _super);

                    function CurvePath() {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'CurvePath';
                        _this_1.curves = [];
                        _this_1.autoClose = false; // Automatically closes the path
                        return _this_1;
                    }
                    CurvePath.prototype.add = function(curve) {
                        this.curves.push(curve);
                    };
                    CurvePath.prototype.closePath = function() {
                        // Add a line curve if start and end of lines are not connected
                        var startPoint = this.curves[0].getPoint(0);
                        var endPoint = this.curves[this.curves.length - 1].getPoint(1);
                        if (!startPoint.equals(endPoint)) {
                            this.curves.push(new LineCurve(endPoint, startPoint));
                        }
                    };
                    // To get accurate point with reference to
                    // entire path distance at time t,
                    // following has to be done:
                    // 1. Length of each sub path have to be known
                    // 2. Locate and identify type of curve
                    // 3. Get t for the curve
                    // 4. Return curve.getPointAt(t')
                    CurvePath.prototype.getPoint = function(t, optionalTarget) {
                        var d = t * this.getLength();
                        var curveLengths = this.getCurveLengths();
                        var i = 0;
                        // To think about boundaries points.
                        while (i < curveLengths.length) {
                            if (curveLengths[i] >= d) {
                                var diff = curveLengths[i] - d;
                                var curve = this.curves[i];
                                var segmentLength = curve.getLength();
                                var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                                return curve.getPointAt(u, optionalTarget);
                            }
                            i++;
                        }
                        return null;
                        // loop where sum != 0, sum > d , sum+1 <d
                    };
                    // We cannot use the default THREE.Curve getPoint() with getLength() because in
                    // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
                    // getPoint() depends on getLength
                    CurvePath.prototype.getLength = function() {
                        var lens = this.getCurveLengths();
                        return lens[lens.length - 1];
                    };
                    // cacheLengths must be recalculated.
                    CurvePath.prototype.updateArcLengths = function() {
                        this.needsUpdate = true;
                        this.cacheLengths = null;
                        this.getCurveLengths();
                    };
                    // Compute lengths and cache them
                    // We cannot overwrite getLengths() because UtoT mapping uses it.
                    CurvePath.prototype.getCurveLengths = function() {
                        // We use cache values if curves and cache array are same length
                        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
                            return this.cacheLengths;
                        }
                        // Get length of sub-curve
                        // Push sums into cached array
                        var lengths = [];
                        var sums = 0;
                        for (var i = 0, l = this.curves.length; i < l; i++) {
                            sums += this.curves[i].getLength();
                            lengths.push(sums);
                        }
                        this.cacheLengths = lengths;
                        return lengths;
                    };
                    CurvePath.prototype.getSpacedPoints = function(divisions) {
                        if (divisions === void 0) {
                            divisions = 40;
                        }
                        var points = [];
                        for (var i = 0; i <= divisions; i++) {
                            points.push(this.getPoint(i / divisions));
                        }
                        if (this.autoClose) {
                            points.push(points[0]);
                        }
                        return points;
                    };
                    CurvePath.prototype.getPoints = function(divisions) {
                        if (divisions === void 0) {
                            divisions = 12;
                        }
                        var points = [];
                        var last;
                        for (var i = 0, curves = this.curves; i < curves.length; i++) {
                            var curve = curves[i];
                            var resolution = curve.isEllipseCurve ? divisions * 2 :
                                (curve.isLineCurve || curve.isLineCurve3) ? 1 :
                                curve.isSplineCurve ? divisions * curve.points.length :
                                divisions;
                            var pts = curve.getPoints(resolution);
                            for (var j = 0; j < pts.length; j++) {
                                var point = pts[j];
                                if (last && last.equals(point))
                                    continue; // ensures no consecutive points are duplicates
                                points.push(point);
                                last = point;
                            }
                        }
                        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
                            points.push(points[0]);
                        }
                        return points;
                    };
                    CurvePath.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.curves = [];
                        for (var i = 0, l = source.curves.length; i < l; i++) {
                            var curve = source.curves[i];
                            this.curves.push(curve.clone());
                        }
                        this.autoClose = source.autoClose;
                        return this;
                    };
                    CurvePath.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this);
                        data.autoClose = this.autoClose;
                        data.curves = [];
                        for (var i = 0, l = this.curves.length; i < l; i++) {
                            var curve = this.curves[i];
                            data.curves.push(curve.toJSON());
                        }
                        return data;
                    };
                    CurvePath.prototype.fromJSON = function(json) {
                        _super.prototype.fromJSON.call(this, json);
                        this.autoClose = json.autoClose;
                        this.curves = [];
                        for (var i = 0, l = json.curves.length; i < l; i++) {
                            var curve = json.curves[i];
                            this.curves.push(new Curves[curve.type]().fromJSON(curve));
                        }
                        return this;
                    };
                    return CurvePath;
                }(Curve));
                var Path = /** @class */ (function(_super) {
                    __extends(Path, _super);

                    function Path(points) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'Path';
                        _this_1.currentPoint = new Vector2();
                        if (points) {
                            _this_1.setFromPoints(points);
                        }
                        return _this_1;
                    }
                    Path.prototype.setFromPoints = function(points) {
                        this.moveTo(points[0].x, points[0].y);
                        for (var i = 1, l = points.length; i < l; i++) {
                            this.lineTo(points[i].x, points[i].y);
                        }
                        return this;
                    };
                    Path.prototype.moveTo = function(x, y) {
                        this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?
                        return this;
                    };
                    Path.prototype.lineTo = function(x, y) {
                        var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
                        this.curves.push(curve);
                        this.currentPoint.set(x, y);
                        return this;
                    };
                    Path.prototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
                        var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
                        this.curves.push(curve);
                        this.currentPoint.set(aX, aY);
                        return this;
                    };
                    Path.prototype.bezierCurveTo = function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
                        var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
                        this.curves.push(curve);
                        this.currentPoint.set(aX, aY);
                        return this;
                    };
                    Path.prototype.splineThru = function(pts /*Array of Vector*/ ) {
                        var npts = [this.currentPoint.clone()].concat(pts);
                        var curve = new SplineCurve(npts);
                        this.curves.push(curve);
                        this.currentPoint.copy(pts[pts.length - 1]);
                        return this;
                    };
                    Path.prototype.arc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
                        var x0 = this.currentPoint.x;
                        var y0 = this.currentPoint.y;
                        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
                        return this;
                    };
                    Path.prototype.absarc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
                        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
                        return this;
                    };
                    Path.prototype.ellipse = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
                        var x0 = this.currentPoint.x;
                        var y0 = this.currentPoint.y;
                        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
                        return this;
                    };
                    Path.prototype.absellipse = function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
                        var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
                        if (this.curves.length > 0) {
                            // if a previous curve is present, attempt to join
                            var firstPoint = curve.getPoint(0);
                            if (!firstPoint.equals(this.currentPoint)) {
                                this.lineTo(firstPoint.x, firstPoint.y);
                            }
                        }
                        this.curves.push(curve);
                        var lastPoint = curve.getPoint(1);
                        this.currentPoint.copy(lastPoint);
                        return this;
                    };
                    Path.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.currentPoint.copy(source.currentPoint);
                        return this;
                    };
                    Path.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this);
                        data.currentPoint = this.currentPoint.toArray();
                        return data;
                    };
                    Path.prototype.fromJSON = function(json) {
                        _super.prototype.fromJSON.call(this, json);
                        this.currentPoint.fromArray(json.currentPoint);
                        return this;
                    };
                    return Path;
                }(CurvePath));
                var LatheGeometry = /** @class */ (function(_super) {
                    __extends(LatheGeometry, _super);

                    function LatheGeometry(points, segments, phiStart, phiLength) {
                        if (points === void 0) {
                            points = [new Vector2(0, 0.5), new Vector2(0.5, 0), new Vector2(0, -0.5)];
                        }
                        if (segments === void 0) {
                            segments = 12;
                        }
                        if (phiStart === void 0) {
                            phiStart = 0;
                        }
                        if (phiLength === void 0) {
                            phiLength = Math.PI * 2;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'LatheGeometry';
                        _this_1.parameters = {
                            points: points,
                            segments: segments,
                            phiStart: phiStart,
                            phiLength: phiLength
                        };
                        segments = Math.floor(segments);
                        // clamp phiLength so it's in range of [ 0, 2PI ]
                        phiLength = clamp(phiLength, 0, Math.PI * 2);
                        // buffers
                        var indices = [];
                        var vertices = [];
                        var uvs = [];
                        var initNormals = [];
                        var normals = [];
                        // helper variables
                        var inverseSegments = 1.0 / segments;
                        var vertex = new Vector3();
                        var uv = new Vector2();
                        var normal = new Vector3();
                        var curNormal = new Vector3();
                        var prevNormal = new Vector3();
                        var dx = 0;
                        var dy = 0;
                        // pre-compute normals for initial "meridian"
                        for (var j = 0; j <= (points.length - 1); j++) {
                            switch (j) {
                                case 0: // special handling for 1st vertex on path
                                    dx = points[j + 1].x - points[j].x;
                                    dy = points[j + 1].y - points[j].y;
                                    normal.x = dy * 1.0;
                                    normal.y = -dx;
                                    normal.z = dy * 0.0;
                                    prevNormal.copy(normal);
                                    normal.normalize();
                                    initNormals.push(normal.x, normal.y, normal.z);
                                    break;
                                case (points.length - 1): // special handling for last Vertex on path
                                    initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
                                    break;
                                default: // default handling for all vertices in between
                                    dx = points[j + 1].x - points[j].x;
                                    dy = points[j + 1].y - points[j].y;
                                    normal.x = dy * 1.0;
                                    normal.y = -dx;
                                    normal.z = dy * 0.0;
                                    curNormal.copy(normal);
                                    normal.x += prevNormal.x;
                                    normal.y += prevNormal.y;
                                    normal.z += prevNormal.z;
                                    normal.normalize();
                                    initNormals.push(normal.x, normal.y, normal.z);
                                    prevNormal.copy(curNormal);
                            }
                        }
                        // generate vertices, uvs and normals
                        for (var i = 0; i <= segments; i++) {
                            var phi = phiStart + i * inverseSegments * phiLength;
                            var sin = Math.sin(phi);
                            var cos = Math.cos(phi);
                            for (var j = 0; j <= (points.length - 1); j++) {
                                // vertex
                                vertex.x = points[j].x * sin;
                                vertex.y = points[j].y;
                                vertex.z = points[j].x * cos;
                                vertices.push(vertex.x, vertex.y, vertex.z);
                                // uv
                                uv.x = i / segments;
                                uv.y = j / (points.length - 1);
                                uvs.push(uv.x, uv.y);
                                // normal
                                var x = initNormals[3 * j + 0] * sin;
                                var y = initNormals[3 * j + 1];
                                var z = initNormals[3 * j + 0] * cos;
                                normals.push(x, y, z);
                            }
                        }
                        // indices
                        for (var i = 0; i < segments; i++) {
                            for (var j = 0; j < (points.length - 1); j++) {
                                var base = j + i * points.length;
                                var a = base;
                                var b = base + points.length;
                                var c = base + points.length + 1;
                                var d = base + 1;
                                // faces
                                indices.push(a, b, d);
                                indices.push(c, d, b);
                            }
                        }
                        // build geometry
                        _this_1.setIndex(indices);
                        _this_1.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        _this_1.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
                        _this_1.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        return _this_1;
                    }
                    LatheGeometry.fromJSON = function(data) {
                        return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
                    };
                    return LatheGeometry;
                }(BufferGeometry));
                var CapsuleGeometry = /** @class */ (function(_super) {
                    __extends(CapsuleGeometry, _super);

                    function CapsuleGeometry(radius, length, capSegments, radialSegments) {
                        if (radius === void 0) {
                            radius = 1;
                        }
                        if (length === void 0) {
                            length = 1;
                        }
                        if (capSegments === void 0) {
                            capSegments = 4;
                        }
                        if (radialSegments === void 0) {
                            radialSegments = 8;
                        }
                        var _this_1 = this;
                        var path = new Path();
                        path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
                        path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
                        _this_1 = _super.call(this, path.getPoints(capSegments), radialSegments) || this;
                        _this_1.type = 'CapsuleGeometry';
                        _this_1.parameters = {
                            radius: radius,
                            height: length,
                            capSegments: capSegments,
                            radialSegments: radialSegments,
                        };
                        return _this_1;
                    }
                    CapsuleGeometry.fromJSON = function(data) {
                        return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
                    };
                    return CapsuleGeometry;
                }(LatheGeometry));
                var CircleGeometry = /** @class */ (function(_super) {
                    __extends(CircleGeometry, _super);

                    function CircleGeometry(radius, segments, thetaStart, thetaLength) {
                        if (radius === void 0) {
                            radius = 1;
                        }
                        if (segments === void 0) {
                            segments = 8;
                        }
                        if (thetaStart === void 0) {
                            thetaStart = 0;
                        }
                        if (thetaLength === void 0) {
                            thetaLength = Math.PI * 2;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'CircleGeometry';
                        _this_1.parameters = {
                            radius: radius,
                            segments: segments,
                            thetaStart: thetaStart,
                            thetaLength: thetaLength
                        };
                        segments = Math.max(3, segments);
                        // buffers
                        var indices = [];
                        var vertices = [];
                        var normals = [];
                        var uvs = [];
                        // helper variables
                        var vertex = new Vector3();
                        var uv = new Vector2();
                        // center point
                        vertices.push(0, 0, 0);
                        normals.push(0, 0, 1);
                        uvs.push(0.5, 0.5);
                        for (var s = 0, i = 3; s <= segments; s++, i += 3) {
                            var segment = thetaStart + s / segments * thetaLength;
                            // vertex
                            vertex.x = radius * Math.cos(segment);
                            vertex.y = radius * Math.sin(segment);
                            vertices.push(vertex.x, vertex.y, vertex.z);
                            // normal
                            normals.push(0, 0, 1);
                            // uvs
                            uv.x = (vertices[i] / radius + 1) / 2;
                            uv.y = (vertices[i + 1] / radius + 1) / 2;
                            uvs.push(uv.x, uv.y);
                        }
                        // indices
                        for (var i = 1; i <= segments; i++) {
                            indices.push(i, i + 1, 0);
                        }
                        // build geometry
                        _this_1.setIndex(indices);
                        _this_1.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        _this_1.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        _this_1.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
                        return _this_1;
                    }
                    CircleGeometry.fromJSON = function(data) {
                        return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
                    };
                    return CircleGeometry;
                }(BufferGeometry));
                var CylinderGeometry = /** @class */ (function(_super) {
                    __extends(CylinderGeometry, _super);

                    function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
                        if (radiusTop === void 0) {
                            radiusTop = 1;
                        }
                        if (radiusBottom === void 0) {
                            radiusBottom = 1;
                        }
                        if (height === void 0) {
                            height = 1;
                        }
                        if (radialSegments === void 0) {
                            radialSegments = 8;
                        }
                        if (heightSegments === void 0) {
                            heightSegments = 1;
                        }
                        if (openEnded === void 0) {
                            openEnded = false;
                        }
                        if (thetaStart === void 0) {
                            thetaStart = 0;
                        }
                        if (thetaLength === void 0) {
                            thetaLength = Math.PI * 2;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'CylinderGeometry';
                        _this_1.parameters = {
                            radiusTop: radiusTop,
                            radiusBottom: radiusBottom,
                            height: height,
                            radialSegments: radialSegments,
                            heightSegments: heightSegments,
                            openEnded: openEnded,
                            thetaStart: thetaStart,
                            thetaLength: thetaLength
                        };
                        var scope = _this_1;
                        radialSegments = Math.floor(radialSegments);
                        heightSegments = Math.floor(heightSegments);
                        // buffers
                        var indices = [];
                        var vertices = [];
                        var normals = [];
                        var uvs = [];
                        // helper variables
                        var index = 0;
                        var indexArray = [];
                        var halfHeight = height / 2;
                        var groupStart = 0;
                        // generate geometry
                        generateTorso();
                        if (openEnded === false) {
                            if (radiusTop > 0)
                                generateCap(true);
                            if (radiusBottom > 0)
                                generateCap(false);
                        }
                        // build geometry
                        _this_1.setIndex(indices);
                        _this_1.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        _this_1.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        _this_1.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

                        function generateTorso() {
                            var normal = new Vector3();
                            var vertex = new Vector3();
                            var groupCount = 0;
                            // this will be used to calculate the normal
                            var slope = (radiusBottom - radiusTop) / height;
                            // generate vertices, normals and uvs
                            for (var y = 0; y <= heightSegments; y++) {
                                var indexRow = [];
                                var v = y / heightSegments;
                                // calculate the radius of the current row
                                var radius = v * (radiusBottom - radiusTop) + radiusTop;
                                for (var x = 0; x <= radialSegments; x++) {
                                    var u = x / radialSegments;
                                    var theta = u * thetaLength + thetaStart;
                                    var sinTheta = Math.sin(theta);
                                    var cosTheta = Math.cos(theta);
                                    // vertex
                                    vertex.x = radius * sinTheta;
                                    vertex.y = -v * height + halfHeight;
                                    vertex.z = radius * cosTheta;
                                    vertices.push(vertex.x, vertex.y, vertex.z);
                                    // normal
                                    normal.set(sinTheta, slope, cosTheta).normalize();
                                    normals.push(normal.x, normal.y, normal.z);
                                    // uv
                                    uvs.push(u, 1 - v);
                                    // save index of vertex in respective row
                                    indexRow.push(index++);
                                }
                                // now save vertices of the row in our index array
                                indexArray.push(indexRow);
                            }
                            // generate indices
                            for (var x = 0; x < radialSegments; x++) {
                                for (var y = 0; y < heightSegments; y++) {
                                    // we use the index array to access the correct indices
                                    var a = indexArray[y][x];
                                    var b = indexArray[y + 1][x];
                                    var c = indexArray[y + 1][x + 1];
                                    var d = indexArray[y][x + 1];
                                    // faces
                                    indices.push(a, b, d);
                                    indices.push(b, c, d);
                                    // update group counter
                                    groupCount += 6;
                                }
                            }
                            // add a group to the geometry. this will ensure multi material support
                            scope.addGroup(groupStart, groupCount, 0);
                            // calculate new start value for groups
                            groupStart += groupCount;
                        }

                        function generateCap(top) {
                            // save the index of the first center vertex
                            var centerIndexStart = index;
                            var uv = new Vector2();
                            var vertex = new Vector3();
                            var groupCount = 0;
                            var radius = (top === true) ? radiusTop : radiusBottom;
                            var sign = (top === true) ? 1 : -1;
                            // first we generate the center vertex data of the cap.
                            // because the geometry needs one set of uvs per face,
                            // we must generate a center vertex per face/segment
                            for (var x = 1; x <= radialSegments; x++) {
                                // vertex
                                vertices.push(0, halfHeight * sign, 0);
                                // normal
                                normals.push(0, sign, 0);
                                // uv
                                uvs.push(0.5, 0.5);
                                // increase index
                                index++;
                            }
                            // save the index of the last center vertex
                            var centerIndexEnd = index;
                            // now we generate the surrounding vertices, normals and uvs
                            for (var x = 0; x <= radialSegments; x++) {
                                var u = x / radialSegments;
                                var theta = u * thetaLength + thetaStart;
                                var cosTheta = Math.cos(theta);
                                var sinTheta = Math.sin(theta);
                                // vertex
                                vertex.x = radius * sinTheta;
                                vertex.y = halfHeight * sign;
                                vertex.z = radius * cosTheta;
                                vertices.push(vertex.x, vertex.y, vertex.z);
                                // normal
                                normals.push(0, sign, 0);
                                // uv
                                uv.x = (cosTheta * 0.5) + 0.5;
                                uv.y = (sinTheta * 0.5 * sign) + 0.5;
                                uvs.push(uv.x, uv.y);
                                // increase index
                                index++;
                            }
                            // generate indices
                            for (var x = 0; x < radialSegments; x++) {
                                var c = centerIndexStart + x;
                                var i = centerIndexEnd + x;
                                if (top === true) {
                                    // face top
                                    indices.push(i, i + 1, c);
                                } else {
                                    // face bottom
                                    indices.push(i + 1, i, c);
                                }
                                groupCount += 3;
                            }
                            // add a group to the geometry. this will ensure multi material support
                            scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
                            // calculate new start value for groups
                            groupStart += groupCount;
                        }
                        return _this_1;
                    }
                    CylinderGeometry.fromJSON = function(data) {
                        return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                    };
                    return CylinderGeometry;
                }(BufferGeometry));
                var ConeGeometry = /** @class */ (function(_super) {
                    __extends(ConeGeometry, _super);

                    function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
                        if (radius === void 0) {
                            radius = 1;
                        }
                        if (height === void 0) {
                            height = 1;
                        }
                        if (radialSegments === void 0) {
                            radialSegments = 8;
                        }
                        if (heightSegments === void 0) {
                            heightSegments = 1;
                        }
                        if (openEnded === void 0) {
                            openEnded = false;
                        }
                        if (thetaStart === void 0) {
                            thetaStart = 0;
                        }
                        if (thetaLength === void 0) {
                            thetaLength = Math.PI * 2;
                        }
                        var _this_1 = _super.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) || this;
                        _this_1.type = 'ConeGeometry';
                        _this_1.parameters = {
                            radius: radius,
                            height: height,
                            radialSegments: radialSegments,
                            heightSegments: heightSegments,
                            openEnded: openEnded,
                            thetaStart: thetaStart,
                            thetaLength: thetaLength
                        };
                        return _this_1;
                    }
                    ConeGeometry.fromJSON = function(data) {
                        return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
                    };
                    return ConeGeometry;
                }(CylinderGeometry));
                var PolyhedronGeometry = /** @class */ (function(_super) {
                    __extends(PolyhedronGeometry, _super);

                    function PolyhedronGeometry(vertices, indices, radius, detail) {
                        if (vertices === void 0) {
                            vertices = [];
                        }
                        if (indices === void 0) {
                            indices = [];
                        }
                        if (radius === void 0) {
                            radius = 1;
                        }
                        if (detail === void 0) {
                            detail = 0;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'PolyhedronGeometry';
                        _this_1.parameters = {
                            vertices: vertices,
                            indices: indices,
                            radius: radius,
                            detail: detail
                        };
                        // default buffer data
                        var vertexBuffer = [];
                        var uvBuffer = [];
                        // the subdivision creates the vertex buffer data
                        subdivide(detail);
                        // all vertices should lie on a conceptual sphere with a given radius
                        applyRadius(radius);
                        // finally, create the uv data
                        generateUVs();
                        // build non-indexed geometry
                        _this_1.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
                        _this_1.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
                        _this_1.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
                        if (detail === 0) {
                            _this_1.computeVertexNormals(); // flat normals
                        } else {
                            _this_1.normalizeNormals(); // smooth normals
                        }
                        // helper functions
                        function subdivide(detail) {
                            var a = new Vector3();
                            var b = new Vector3();
                            var c = new Vector3();
                            // iterate over all faces and apply a subdivison with the given detail value
                            for (var i = 0; i < indices.length; i += 3) {
                                // get the vertices of the face
                                getVertexByIndex(indices[i + 0], a);
                                getVertexByIndex(indices[i + 1], b);
                                getVertexByIndex(indices[i + 2], c);
                                // perform subdivision
                                subdivideFace(a, b, c, detail);
                            }
                        }

                        function subdivideFace(a, b, c, detail) {
                            var cols = detail + 1;
                            // we use this multidimensional array as a data structure for creating the subdivision
                            var v = [];
                            // construct all of the vertices for this subdivision
                            for (var i = 0; i <= cols; i++) {
                                v[i] = [];
                                var aj = a.clone().lerp(c, i / cols);
                                var bj = b.clone().lerp(c, i / cols);
                                var rows = cols - i;
                                for (var j = 0; j <= rows; j++) {
                                    if (j === 0 && i === cols) {
                                        v[i][j] = aj;
                                    } else {
                                        v[i][j] = aj.clone().lerp(bj, j / rows);
                                    }
                                }
                            }
                            // construct all of the faces
                            for (var i = 0; i < cols; i++) {
                                for (var j = 0; j < 2 * (cols - i) - 1; j++) {
                                    var k = Math.floor(j / 2);
                                    if (j % 2 === 0) {
                                        pushVertex(v[i][k + 1]);
                                        pushVertex(v[i + 1][k]);
                                        pushVertex(v[i][k]);
                                    } else {
                                        pushVertex(v[i][k + 1]);
                                        pushVertex(v[i + 1][k + 1]);
                                        pushVertex(v[i + 1][k]);
                                    }
                                }
                            }
                        }

                        function applyRadius(radius) {
                            var vertex = new Vector3();
                            // iterate over the entire buffer and apply the radius to each vertex
                            for (var i = 0; i < vertexBuffer.length; i += 3) {
                                vertex.x = vertexBuffer[i + 0];
                                vertex.y = vertexBuffer[i + 1];
                                vertex.z = vertexBuffer[i + 2];
                                vertex.normalize().multiplyScalar(radius);
                                vertexBuffer[i + 0] = vertex.x;
                                vertexBuffer[i + 1] = vertex.y;
                                vertexBuffer[i + 2] = vertex.z;
                            }
                        }

                        function generateUVs() {
                            var vertex = new Vector3();
                            for (var i = 0; i < vertexBuffer.length; i += 3) {
                                vertex.x = vertexBuffer[i + 0];
                                vertex.y = vertexBuffer[i + 1];
                                vertex.z = vertexBuffer[i + 2];
                                var u = azimuth(vertex) / 2 / Math.PI + 0.5;
                                var v = inclination(vertex) / Math.PI + 0.5;
                                uvBuffer.push(u, 1 - v);
                            }
                            correctUVs();
                            correctSeam();
                        }

                        function correctSeam() {
                            // handle case when face straddles the seam, see #3269
                            for (var i = 0; i < uvBuffer.length; i += 6) {
                                // uv data of a single face
                                var x0 = uvBuffer[i + 0];
                                var x1 = uvBuffer[i + 2];
                                var x2 = uvBuffer[i + 4];
                                var max = Math.max(x0, x1, x2);
                                var min = Math.min(x0, x1, x2);
                                // 0.9 is somewhat arbitrary
                                if (max > 0.9 && min < 0.1) {
                                    if (x0 < 0.2)
                                        uvBuffer[i + 0] += 1;
                                    if (x1 < 0.2)
                                        uvBuffer[i + 2] += 1;
                                    if (x2 < 0.2)
                                        uvBuffer[i + 4] += 1;
                                }
                            }
                        }

                        function pushVertex(vertex) {
                            vertexBuffer.push(vertex.x, vertex.y, vertex.z);
                        }

                        function getVertexByIndex(index, vertex) {
                            var stride = index * 3;
                            vertex.x = vertices[stride + 0];
                            vertex.y = vertices[stride + 1];
                            vertex.z = vertices[stride + 2];
                        }

                        function correctUVs() {
                            var a = new Vector3();
                            var b = new Vector3();
                            var c = new Vector3();
                            var centroid = new Vector3();
                            var uvA = new Vector2();
                            var uvB = new Vector2();
                            var uvC = new Vector2();
                            for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
                                a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
                                b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
                                c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
                                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                                centroid.copy(a).add(b).add(c).divideScalar(3);
                                var azi = azimuth(centroid);
                                correctUV(uvA, j + 0, a, azi);
                                correctUV(uvB, j + 2, b, azi);
                                correctUV(uvC, j + 4, c, azi);
                            }
                        }

                        function correctUV(uv, stride, vector, azimuth) {
                            if ((azimuth < 0) && (uv.x === 1)) {
                                uvBuffer[stride] = uv.x - 1;
                            }
                            if ((vector.x === 0) && (vector.z === 0)) {
                                uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
                            }
                        }
                        // Angle around the Y axis, counter-clockwise when looking from above.
                        function azimuth(vector) {
                            return Math.atan2(vector.z, -vector.x);
                        }
                        // Angle above the XZ plane.
                        function inclination(vector) {
                            return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)));
                        }
                        return _this_1;
                    }
                    PolyhedronGeometry.fromJSON = function(data) {
                        return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
                    };
                    return PolyhedronGeometry;
                }(BufferGeometry));
                var DodecahedronGeometry = /** @class */ (function(_super) {
                    __extends(DodecahedronGeometry, _super);

                    function DodecahedronGeometry(radius, detail) {
                        if (radius === void 0) {
                            radius = 1;
                        }
                        if (detail === void 0) {
                            detail = 0;
                        }
                        var _this_1 = this;
                        var t = (1 + Math.sqrt(5)) / 2;
                        var r = 1 / t;
                        var vertices = [
                            // (1, 1, 1)
                            -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1,
                            1, -1, -1, 1, -1, 1,
                            1, 1, -1, 1, 1, 1,
                            // (0, 1/, )
                            0, -r, -t, 0, -r, t,
                            0, r, -t, 0, r, t,
                            // (1/, , 0)
                            -r, -t, 0, -r, t, 0,
                            r, -t, 0, r, t, 0,
                            // (, 0, 1/)
                            -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r
                        ];
                        var indices = [
                            3, 11, 7, 3, 7, 15, 3, 15, 13,
                            7, 19, 17, 7, 17, 6, 7, 6, 15,
                            17, 4, 8, 17, 8, 10, 17, 10, 6,
                            8, 0, 16, 8, 16, 2, 8, 2, 10,
                            0, 12, 1, 0, 1, 18, 0, 18, 16,
                            6, 10, 2, 6, 2, 13, 6, 13, 15,
                            2, 16, 18, 2, 18, 3, 2, 3, 13,
                            18, 1, 9, 18, 9, 11, 18, 11, 3,
                            4, 14, 12, 4, 12, 0, 4, 0, 8,
                            11, 9, 5, 11, 5, 19, 11, 19, 7,
                            19, 5, 14, 19, 14, 4, 19, 4, 17,
                            1, 12, 14, 1, 14, 5, 1, 5, 9
                        ];
                        _this_1 = _super.call(this, vertices, indices, radius, detail) || this;
                        _this_1.type = 'DodecahedronGeometry';
                        _this_1.parameters = {
                            radius: radius,
                            detail: detail
                        };
                        return _this_1;
                    }
                    DodecahedronGeometry.fromJSON = function(data) {
                        return new DodecahedronGeometry(data.radius, data.detail);
                    };
                    return DodecahedronGeometry;
                }(PolyhedronGeometry));
                var _v0 = new Vector3();
                var _v1$1 = new Vector3();
                var _normal = new Vector3();
                var _triangle = new Triangle();
                var EdgesGeometry = /** @class */ (function(_super) {
                    __extends(EdgesGeometry, _super);

                    function EdgesGeometry(geometry, thresholdAngle) {
                        if (geometry === void 0) {
                            geometry = null;
                        }
                        if (thresholdAngle === void 0) {
                            thresholdAngle = 1;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'EdgesGeometry';
                        _this_1.parameters = {
                            geometry: geometry,
                            thresholdAngle: thresholdAngle
                        };
                        if (geometry !== null) {
                            var precisionPoints = 4;
                            var precision = Math.pow(10, precisionPoints);
                            var thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
                            var indexAttr = geometry.getIndex();
                            var positionAttr = geometry.getAttribute('position');
                            var indexCount = indexAttr ? indexAttr.count : positionAttr.count;
                            var indexArr = [0, 0, 0];
                            var vertKeys = ['a', 'b', 'c'];
                            var hashes = new Array(3);
                            var edgeData = {};
                            var vertices = [];
                            for (var i = 0; i < indexCount; i += 3) {
                                if (indexAttr) {
                                    indexArr[0] = indexAttr.getX(i);
                                    indexArr[1] = indexAttr.getX(i + 1);
                                    indexArr[2] = indexAttr.getX(i + 2);
                                } else {
                                    indexArr[0] = i;
                                    indexArr[1] = i + 1;
                                    indexArr[2] = i + 2;
                                }
                                var a = _triangle.a,
                                    b = _triangle.b,
                                    c = _triangle.c;
                                a.fromBufferAttribute(positionAttr, indexArr[0]);
                                b.fromBufferAttribute(positionAttr, indexArr[1]);
                                c.fromBufferAttribute(positionAttr, indexArr[2]);
                                _triangle.getNormal(_normal);
                                // create hashes for the edge from the vertices
                                hashes[0] = "".concat(Math.round(a.x * precision), ",").concat(Math.round(a.y * precision), ",").concat(Math.round(a.z * precision));
                                hashes[1] = "".concat(Math.round(b.x * precision), ",").concat(Math.round(b.y * precision), ",").concat(Math.round(b.z * precision));
                                hashes[2] = "".concat(Math.round(c.x * precision), ",").concat(Math.round(c.y * precision), ",").concat(Math.round(c.z * precision));
                                // skip degenerate triangles
                                if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
                                    continue;
                                }
                                // iterate over every edge
                                for (var j = 0; j < 3; j++) {
                                    // get the first and next vertex making up the edge
                                    var jNext = (j + 1) % 3;
                                    var vecHash0 = hashes[j];
                                    var vecHash1 = hashes[jNext];
                                    var v0 = _triangle[vertKeys[j]];
                                    var v1 = _triangle[vertKeys[jNext]];
                                    var hash = "".concat(vecHash0, "_").concat(vecHash1);
                                    var reverseHash = "".concat(vecHash1, "_").concat(vecHash0);
                                    if (reverseHash in edgeData && edgeData[reverseHash]) {
                                        // if we found a sibling edge add it into the vertex array if
                                        // it meets the angle threshold and delete the edge from the map.
                                        if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                                            vertices.push(v0.x, v0.y, v0.z);
                                            vertices.push(v1.x, v1.y, v1.z);
                                        }
                                        edgeData[reverseHash] = null;
                                    } else if (!(hash in edgeData)) {
                                        // if we've already got an edge here then skip adding a new one
                                        edgeData[hash] = {
                                            index0: indexArr[j],
                                            index1: indexArr[jNext],
                                            normal: _normal.clone(),
                                        };
                                    }
                                }
                            }
                            // iterate over all remaining, unmatched edges and add them to the vertex array
                            for (var key in edgeData) {
                                if (edgeData[key]) {
                                    var _a = edgeData[key],
                                        index0 = _a.index0,
                                        index1 = _a.index1;
                                    _v0.fromBufferAttribute(positionAttr, index0);
                                    _v1$1.fromBufferAttribute(positionAttr, index1);
                                    vertices.push(_v0.x, _v0.y, _v0.z);
                                    vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
                                }
                            }
                            _this_1.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        }
                        return _this_1;
                    }
                    return EdgesGeometry;
                }(BufferGeometry));
                var Shape = /** @class */ (function(_super) {
                    __extends(Shape, _super);

                    function Shape(points) {
                        var _this_1 = _super.call(this, points) || this;
                        _this_1.uuid = generateUUID();
                        _this_1.type = 'Shape';
                        _this_1.holes = [];
                        return _this_1;
                    }
                    Shape.prototype.getPointsHoles = function(divisions) {
                        var holesPts = [];
                        for (var i = 0, l = this.holes.length; i < l; i++) {
                            holesPts[i] = this.holes[i].getPoints(divisions);
                        }
                        return holesPts;
                    };
                    // get points of shape and holes (keypoints based on segments parameter)
                    Shape.prototype.extractPoints = function(divisions) {
                        return {
                            shape: this.getPoints(divisions),
                            holes: this.getPointsHoles(divisions)
                        };
                    };
                    Shape.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.holes = [];
                        for (var i = 0, l = source.holes.length; i < l; i++) {
                            var hole = source.holes[i];
                            this.holes.push(hole.clone());
                        }
                        return this;
                    };
                    Shape.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this);
                        data.uuid = this.uuid;
                        data.holes = [];
                        for (var i = 0, l = this.holes.length; i < l; i++) {
                            var hole = this.holes[i];
                            data.holes.push(hole.toJSON());
                        }
                        return data;
                    };
                    Shape.prototype.fromJSON = function(json) {
                        _super.prototype.fromJSON.call(this, json);
                        this.uuid = json.uuid;
                        this.holes = [];
                        for (var i = 0, l = json.holes.length; i < l; i++) {
                            var hole = json.holes[i];
                            this.holes.push(new Path().fromJSON(hole));
                        }
                        return this;
                    };
                    return Shape;
                }(Path));
                /**
                 * Port from https://github.com/mapbox/earcut (v2.2.2)
                 */
                var Earcut = {
                    triangulate: function(data, holeIndices, dim) {
                        if (dim === void 0) {
                            dim = 2;
                        }
                        var hasHoles = holeIndices && holeIndices.length;
                        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
                        var outerNode = linkedList(data, 0, outerLen, dim, true);
                        var triangles = [];
                        if (!outerNode || outerNode.next === outerNode.prev)
                            return triangles;
                        var minX, minY, maxX, maxY, x, y, invSize;
                        if (hasHoles)
                            outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
                        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
                        if (data.length > 80 * dim) {
                            minX = maxX = data[0];
                            minY = maxY = data[1];
                            for (var i = dim; i < outerLen; i += dim) {
                                x = data[i];
                                y = data[i + 1];
                                if (x < minX)
                                    minX = x;
                                if (y < minY)
                                    minY = y;
                                if (x > maxX)
                                    maxX = x;
                                if (y > maxY)
                                    maxY = y;
                            }
                            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
                            invSize = Math.max(maxX - minX, maxY - minY);
                            invSize = invSize !== 0 ? 1 / invSize : 0;
                        }
                        earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
                        return triangles;
                    }
                };
                // create a circular doubly linked list from polygon points in the specified winding order
                function linkedList(data, start, end, dim, clockwise) {
                    var i, last;
                    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
                        for (i = start; i < end; i += dim)
                            last = insertNode(i, data[i], data[i + 1], last);
                    } else {
                        for (i = end - dim; i >= start; i -= dim)
                            last = insertNode(i, data[i], data[i + 1], last);
                    }
                    if (last && equals(last, last.next)) {
                        removeNode(last);
                        last = last.next;
                    }
                    return last;
                }
                // eliminate colinear or duplicate points
                function filterPoints(start, end) {
                    if (!start)
                        return start;
                    if (!end)
                        end = start;
                    var p = start,
                        again;
                    do {
                        again = false;
                        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                            removeNode(p);
                            p = end = p.prev;
                            if (p === p.next)
                                break;
                            again = true;
                        } else {
                            p = p.next;
                        }
                    } while (again || p !== end);
                    return end;
                }
                // main ear slicing loop which triangulates a polygon (given as a linked list)
                function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
                    if (!ear)
                        return;
                    // interlink polygon nodes in z-order
                    if (!pass && invSize)
                        indexCurve(ear, minX, minY, invSize);
                    var stop = ear,
                        prev, next;
                    // iterate through ears, slicing them one by one
                    while (ear.prev !== ear.next) {
                        prev = ear.prev;
                        next = ear.next;
                        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                            // cut off the triangle
                            triangles.push(prev.i / dim);
                            triangles.push(ear.i / dim);
                            triangles.push(next.i / dim);
                            removeNode(ear);
                            // skipping the next vertex leads to less sliver triangles
                            ear = next.next;
                            stop = next.next;
                            continue;
                        }
                        ear = next;
                        // if we looped through the whole remaining polygon and can't find any more ears
                        if (ear === stop) {
                            // try filtering points and slicing again
                            if (!pass) {
                                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                                // if this didn't work, try curing all small self-intersections locally
                            } else if (pass === 1) {
                                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                                // as a last resort, try splitting the remaining polygon into two
                            } else if (pass === 2) {
                                splitEarcut(ear, triangles, dim, minX, minY, invSize);
                            }
                            break;
                        }
                    }
                }
                // check whether a polygon node forms a valid ear with adjacent nodes
                function isEar(ear) {
                    var a = ear.prev,
                        b = ear,
                        c = ear.next;
                    if (area(a, b, c) >= 0)
                        return false; // reflex, can't be an ear
                    // now make sure we don't have other points inside the potential ear
                    var p = ear.next.next;
                    while (p !== ear.prev) {
                        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                            area(p.prev, p, p.next) >= 0)
                            return false;
                        p = p.next;
                    }
                    return true;
                }

                function isEarHashed(ear, minX, minY, invSize) {
                    var a = ear.prev,
                        b = ear,
                        c = ear.next;
                    if (area(a, b, c) >= 0)
                        return false; // reflex, can't be an ear
                    // triangle bbox; min & max are calculated like this for speed
                    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
                        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
                        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
                        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
                    // z-order range for the current triangle bbox;
                    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
                        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
                    var p = ear.prevZ,
                        n = ear.nextZ;
                    // look for points inside the triangle in both directions
                    while (p && p.z >= minZ && n && n.z <= maxZ) {
                        if (p !== ear.prev && p !== ear.next &&
                            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                            area(p.prev, p, p.next) >= 0)
                            return false;
                        p = p.prevZ;
                        if (n !== ear.prev && n !== ear.next &&
                            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                            area(n.prev, n, n.next) >= 0)
                            return false;
                        n = n.nextZ;
                    }
                    // look for remaining points in decreasing z-order
                    while (p && p.z >= minZ) {
                        if (p !== ear.prev && p !== ear.next &&
                            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                            area(p.prev, p, p.next) >= 0)
                            return false;
                        p = p.prevZ;
                    }
                    // look for remaining points in increasing z-order
                    while (n && n.z <= maxZ) {
                        if (n !== ear.prev && n !== ear.next &&
                            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                            area(n.prev, n, n.next) >= 0)
                            return false;
                        n = n.nextZ;
                    }
                    return true;
                }
                // go through all polygon nodes and cure small local self-intersections
                function cureLocalIntersections(start, triangles, dim) {
                    var p = start;
                    do {
                        var a = p.prev,
                            b = p.next.next;
                        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                            triangles.push(a.i / dim);
                            triangles.push(p.i / dim);
                            triangles.push(b.i / dim);
                            // remove two nodes involved
                            removeNode(p);
                            removeNode(p.next);
                            p = start = b;
                        }
                        p = p.next;
                    } while (p !== start);
                    return filterPoints(p);
                }
                // try splitting polygon into two and triangulate them independently
                function splitEarcut(start, triangles, dim, minX, minY, invSize) {
                    // look for a valid diagonal that divides the polygon into two
                    var a = start;
                    do {
                        var b = a.next.next;
                        while (b !== a.prev) {
                            if (a.i !== b.i && isValidDiagonal(a, b)) {
                                // split the polygon in two by the diagonal
                                var c = splitPolygon(a, b);
                                // filter colinear points around the cuts
                                a = filterPoints(a, a.next);
                                c = filterPoints(c, c.next);
                                // run earcut on each half
                                earcutLinked(a, triangles, dim, minX, minY, invSize);
                                earcutLinked(c, triangles, dim, minX, minY, invSize);
                                return;
                            }
                            b = b.next;
                        }
                        a = a.next;
                    } while (a !== start);
                }
                // link every hole into the outer loop, producing a single-ring polygon without holes
                function eliminateHoles(data, holeIndices, outerNode, dim) {
                    var queue = [];
                    var i, len, start, end, list;
                    for (i = 0, len = holeIndices.length; i < len; i++) {
                        start = holeIndices[i] * dim;
                        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                        list = linkedList(data, start, end, dim, false);
                        if (list === list.next)
                            list.steiner = true;
                        queue.push(getLeftmost(list));
                    }
                    queue.sort(compareX);
                    // process holes from left to right
                    for (i = 0; i < queue.length; i++) {
                        eliminateHole(queue[i], outerNode);
                        outerNode = filterPoints(outerNode, outerNode.next);
                    }
                    return outerNode;
                }

                function compareX(a, b) {
                    return a.x - b.x;
                }
                // find a bridge between vertices that connects hole with an outer ring and link it
                function eliminateHole(hole, outerNode) {
                    outerNode = findHoleBridge(hole, outerNode);
                    if (outerNode) {
                        var b = splitPolygon(outerNode, hole);
                        // filter collinear points around the cuts
                        filterPoints(outerNode, outerNode.next);
                        filterPoints(b, b.next);
                    }
                }
                // David Eberly's algorithm for finding a bridge between hole and outer polygon
                function findHoleBridge(hole, outerNode) {
                    var p = outerNode;
                    var hx = hole.x;
                    var hy = hole.y;
                    var qx = -Infinity,
                        m;
                    // find a segment intersected by a ray from the hole's leftmost point to the left;
                    // segment's endpoint with lesser x will be potential connection point
                    do {
                        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                            if (x <= hx && x > qx) {
                                qx = x;
                                if (x === hx) {
                                    if (hy === p.y)
                                        return p;
                                    if (hy === p.next.y)
                                        return p.next;
                                }
                                m = p.x < p.next.x ? p : p.next;
                            }
                        }
                        p = p.next;
                    } while (p !== outerNode);
                    if (!m)
                        return null;
                    if (hx === qx)
                        return m; // hole touches outer segment; pick leftmost endpoint
                    // look for points inside the triangle of hole point, segment intersection and endpoint;
                    // if there are no points found, we have a valid connection;
                    // otherwise choose the point of the minimum angle with the ray as connection point
                    var stop = m,
                        mx = m.x,
                        my = m.y;
                    var tanMin = Infinity,
                        tan;
                    p = m;
                    do {
                        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                            pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
                            if (locallyInside(p, hole) && (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                                m = p;
                                tanMin = tan;
                            }
                        }
                        p = p.next;
                    } while (p !== stop);
                    return m;
                }
                // whether sector in vertex m contains sector in vertex p in the same coordinates
                function sectorContainsSector(m, p) {
                    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
                }
                // interlink polygon nodes in z-order
                function indexCurve(start, minX, minY, invSize) {
                    var p = start;
                    do {
                        if (p.z === null)
                            p.z = zOrder(p.x, p.y, minX, minY, invSize);
                        p.prevZ = p.prev;
                        p.nextZ = p.next;
                        p = p.next;
                    } while (p !== start);
                    p.prevZ.nextZ = null;
                    p.prevZ = null;
                    sortLinked(p);
                }
                // Simon Tatham's linked list merge sort algorithm
                // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
                function sortLinked(list) {
                    var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
                    do {
                        p = list;
                        list = null;
                        tail = null;
                        numMerges = 0;
                        while (p) {
                            numMerges++;
                            q = p;
                            pSize = 0;
                            for (i = 0; i < inSize; i++) {
                                pSize++;
                                q = q.nextZ;
                                if (!q)
                                    break;
                            }
                            qSize = inSize;
                            while (pSize > 0 || (qSize > 0 && q)) {
                                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                                    e = p;
                                    p = p.nextZ;
                                    pSize--;
                                } else {
                                    e = q;
                                    q = q.nextZ;
                                    qSize--;
                                }
                                if (tail)
                                    tail.nextZ = e;
                                else
                                    list = e;
                                e.prevZ = tail;
                                tail = e;
                            }
                            p = q;
                        }
                        tail.nextZ = null;
                        inSize *= 2;
                    } while (numMerges > 1);
                    return list;
                }
                // z-order of a point given coords and inverse of the longer side of data bbox
                function zOrder(x, y, minX, minY, invSize) {
                    // coords are transformed into non-negative 15-bit integer range
                    x = 32767 * (x - minX) * invSize;
                    y = 32767 * (y - minY) * invSize;
                    x = (x | (x << 8)) & 0x00FF00FF;
                    x = (x | (x << 4)) & 0x0F0F0F0F;
                    x = (x | (x << 2)) & 0x33333333;
                    x = (x | (x << 1)) & 0x55555555;
                    y = (y | (y << 8)) & 0x00FF00FF;
                    y = (y | (y << 4)) & 0x0F0F0F0F;
                    y = (y | (y << 2)) & 0x33333333;
                    y = (y | (y << 1)) & 0x55555555;
                    return x | (y << 1);
                }
                // find the leftmost node of a polygon ring
                function getLeftmost(start) {
                    var p = start,
                        leftmost = start;
                    do {
                        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y))
                            leftmost = p;
                        p = p.next;
                    } while (p !== start);
                    return leftmost;
                }
                // check if a point lies within a convex triangle
                function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
                    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
                        (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
                        (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
                }
                // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
                function isValidDiagonal(a, b) {
                    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // doesn't intersect other edges
                        (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
                            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
                            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
                }
                // signed area of a triangle
                function area(p, q, r) {
                    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
                }
                // check if two points are equal
                function equals(p1, p2) {
                    return p1.x === p2.x && p1.y === p2.y;
                }
                // check if two segments intersect
                function intersects(p1, q1, p2, q2) {
                    var o1 = sign(area(p1, q1, p2));
                    var o2 = sign(area(p1, q1, q2));
                    var o3 = sign(area(p2, q2, p1));
                    var o4 = sign(area(p2, q2, q1));
                    if (o1 !== o2 && o3 !== o4)
                        return true; // general case
                    if (o1 === 0 && onSegment(p1, p2, q1))
                        return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
                    if (o2 === 0 && onSegment(p1, q2, q1))
                        return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
                    if (o3 === 0 && onSegment(p2, p1, q2))
                        return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
                    if (o4 === 0 && onSegment(p2, q1, q2))
                        return true; // p2, q2 and q1 are collinear and q1 lies on p2q2
                    return false;
                }
                // for collinear points p, q, r, check if point q lies on segment pr
                function onSegment(p, q, r) {
                    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
                }

                function sign(num) {
                    return num > 0 ? 1 : num < 0 ? -1 : 0;
                }
                // check if a polygon diagonal intersects any polygon segments
                function intersectsPolygon(a, b) {
                    var p = a;
                    do {
                        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                            intersects(p, p.next, a, b))
                            return true;
                        p = p.next;
                    } while (p !== a);
                    return false;
                }
                // check if a polygon diagonal is locally inside the polygon
                function locallyInside(a, b) {
                    return area(a.prev, a, a.next) < 0 ?
                        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
                        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
                }
                // check if the middle point of a polygon diagonal is inside the polygon
                function middleInside(a, b) {
                    var p = a,
                        inside = false;
                    var px = (a.x + b.x) / 2,
                        py = (a.y + b.y) / 2;
                    do {
                        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                            (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                            inside = !inside;
                        p = p.next;
                    } while (p !== a);
                    return inside;
                }
                // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
                // if one belongs to the outer ring and another to a hole, it merges it into a single ring
                function splitPolygon(a, b) {
                    var a2 = new Node(a.i, a.x, a.y),
                        b2 = new Node(b.i, b.x, b.y),
                        an = a.next,
                        bp = b.prev;
                    a.next = b;
                    b.prev = a;
                    a2.next = an;
                    an.prev = a2;
                    b2.next = a2;
                    a2.prev = b2;
                    bp.next = b2;
                    b2.prev = bp;
                    return b2;
                }
                // create a node and optionally link it with previous one (in a circular doubly linked list)
                function insertNode(i, x, y, last) {
                    var p = new Node(i, x, y);
                    if (!last) {
                        p.prev = p;
                        p.next = p;
                    } else {
                        p.next = last.next;
                        p.prev = last;
                        last.next.prev = p;
                        last.next = p;
                    }
                    return p;
                }

                function removeNode(p) {
                    p.next.prev = p.prev;
                    p.prev.next = p.next;
                    if (p.prevZ)
                        p.prevZ.nextZ = p.nextZ;
                    if (p.nextZ)
                        p.nextZ.prevZ = p.prevZ;
                }

                function Node(i, x, y) {
                    // vertex index in coordinates array
                    this.i = i;
                    // vertex coordinates
                    this.x = x;
                    this.y = y;
                    // previous and next vertex nodes in a polygon ring
                    this.prev = null;
                    this.next = null;
                    // z-order curve value
                    this.z = null;
                    // previous and next nodes in z-order
                    this.prevZ = null;
                    this.nextZ = null;
                    // indicates whether this is a steiner point
                    this.steiner = false;
                }

                function signedArea(data, start, end, dim) {
                    var sum = 0;
                    for (var i = start, j = end - dim; i < end; i += dim) {
                        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
                        j = i;
                    }
                    return sum;
                }
                var ShapeUtils = /** @class */ (function() {
                    function ShapeUtils() {}
                    // calculate area of the contour polygon
                    ShapeUtils.area = function(contour) {
                        var n = contour.length;
                        var a = 0.0;
                        for (var p = n - 1, q = 0; q < n; p = q++) {
                            a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
                        }
                        return a * 0.5;
                    };
                    ShapeUtils.isClockWise = function(pts) {
                        return ShapeUtils.area(pts) < 0;
                    };
                    ShapeUtils.triangulateShape = function(contour, holes) {
                        var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
                        var holeIndices = []; // array of hole indices
                        var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
                        removeDupEndPts(contour);
                        addContour(vertices, contour);
                        //
                        var holeIndex = contour.length;
                        holes.forEach(removeDupEndPts);
                        for (var i = 0; i < holes.length; i++) {
                            holeIndices.push(holeIndex);
                            holeIndex += holes[i].length;
                            addContour(vertices, holes[i]);
                        }
                        //
                        var triangles = Earcut.triangulate(vertices, holeIndices);
                        //
                        for (var i = 0; i < triangles.length; i += 3) {
                            faces.push(triangles.slice(i, i + 3));
                        }
                        return faces;
                    };
                    return ShapeUtils;
                }());

                function removeDupEndPts(points) {
                    var l = points.length;
                    if (l > 2 && points[l - 1].equals(points[0])) {
                        points.pop();
                    }
                }

                function addContour(vertices, contour) {
                    for (var i = 0; i < contour.length; i++) {
                        vertices.push(contour[i].x);
                        vertices.push(contour[i].y);
                    }
                }
                /**
                 * Creates extruded geometry from a path shape.
                 *
                 * parameters = {
                 *
                 *  curveSegments: <int>, // number of points on the curves
                 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
                 *  depth: <float>, // Depth to extrude the shape
                 *
                 *  bevelEnabled: <bool>, // turn on bevel
                 *  bevelThickness: <float>, // how deep into the original shape bevel goes
                 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
                 *  bevelOffset: <float>, // how far from shape outline does bevel start
                 *  bevelSegments: <int>, // number of bevel layers
                 *
                 *  extrudePath: <THREE.Curve> // curve to extrude shape along
                 *
                 *  UVGenerator: <Object> // object that provides UV generator functions
                 *
                 * }
                 */
                var ExtrudeGeometry = /** @class */ (function(_super) {
                    __extends(ExtrudeGeometry, _super);

                    function ExtrudeGeometry(shapes, options) {
                        if (shapes === void 0) {
                            shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]);
                        }
                        if (options === void 0) {
                            options = {};
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'ExtrudeGeometry';
                        _this_1.parameters = {
                            shapes: shapes,
                            options: options
                        };
                        shapes = Array.isArray(shapes) ? shapes : [shapes];
                        var scope = _this_1;
                        var verticesArray = [];
                        var uvArray = [];
                        for (var i = 0, l = shapes.length; i < l; i++) {
                            var shape = shapes[i];
                            addShape(shape);
                        }
                        // build geometry
                        _this_1.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
                        _this_1.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
                        _this_1.computeVertexNormals();
                        // functions
                        function addShape(shape) {
                            var placeholder = [];
                            // options
                            var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
                            var steps = options.steps !== undefined ? options.steps : 1;
                            var depth = options.depth !== undefined ? options.depth : 1;
                            var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
                            var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
                            var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
                            var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
                            var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
                            var extrudePath = options.extrudePath;
                            var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;
                            // deprecated options
                            if (options.amount !== undefined) {
                                console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
                                depth = options.amount;
                            }
                            //
                            var extrudePts, extrudeByPath = false;
                            var splineTube, binormal, normal, position2;
                            if (extrudePath) {
                                extrudePts = extrudePath.getSpacedPoints(steps);
                                extrudeByPath = true;
                                bevelEnabled = false; // bevels not supported for path extrusion
                                // SETUP TNB variables
                                // TODO1 - have a .isClosed in spline?
                                splineTube = extrudePath.computeFrenetFrames(steps, false);
                                // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
                                binormal = new Vector3();
                                normal = new Vector3();
                                position2 = new Vector3();
                            }
                            // Safeguards if bevels are not enabled
                            if (!bevelEnabled) {
                                bevelSegments = 0;
                                bevelThickness = 0;
                                bevelSize = 0;
                                bevelOffset = 0;
                            }
                            // Variables initialization
                            var shapePoints = shape.extractPoints(curveSegments);
                            var vertices = shapePoints.shape;
                            var holes = shapePoints.holes;
                            var reverse = !ShapeUtils.isClockWise(vertices);
                            if (reverse) {
                                vertices = vertices.reverse();
                                // Maybe we should also check if holes are in the opposite direction, just to be safe ...
                                for (var h = 0, hl = holes.length; h < hl; h++) {
                                    var ahole = holes[h];
                                    if (ShapeUtils.isClockWise(ahole)) {
                                        holes[h] = ahole.reverse();
                                    }
                                }
                            }
                            var faces = ShapeUtils.triangulateShape(vertices, holes);
                            /* Vertices */
                            var contour = vertices; // vertices has all points but contour has only points of circumference
                            for (var h = 0, hl = holes.length; h < hl; h++) {
                                var ahole = holes[h];
                                vertices = vertices.concat(ahole);
                            }

                            function scalePt2(pt, vec, size) {
                                if (!vec)
                                    console.error('THREE.ExtrudeGeometry: vec does not exist');
                                return vec.clone().multiplyScalar(size).add(pt);
                            }
                            var vlen = vertices.length,
                                flen = faces.length;
                            // Find directions for point movement
                            function getBevelVec(inPt, inPrev, inNext) {
                                // computes for inPt the corresponding point inPt' on a new contour
                                //   shifted by 1 unit (length of normalized vector) to the left
                                // if we walk along contour clockwise, this new contour is outside the old one
                                //
                                // inPt' is the intersection of the two lines parallel to the two
                                //  adjacent edges of inPt at a distance of 1 unit on the left side.
                                var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
                                // good reading for geometry algorithms (here: line-line intersection)
                                // http://geomalgorithms.com/a05-_intersect-1.html
                                var v_prev_x = inPt.x - inPrev.x,
                                    v_prev_y = inPt.y - inPrev.y;
                                var v_next_x = inNext.x - inPt.x,
                                    v_next_y = inNext.y - inPt.y;
                                var v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
                                // check for collinear edges
                                var collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
                                if (Math.abs(collinear0) > Number.EPSILON) {
                                    // not collinear
                                    // length of vectors for normalizing
                                    var v_prev_len = Math.sqrt(v_prev_lensq);
                                    var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                                    // shift adjacent points by unit vectors to the left
                                    var ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
                                    var ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);
                                    var ptNextShift_x = (inNext.x - v_next_y / v_next_len);
                                    var ptNextShift_y = (inNext.y + v_next_x / v_next_len);
                                    // scaling factor for v_prev to intersection point
                                    var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y -
                                            (ptNextShift_y - ptPrevShift_y) * v_next_x) /
                                        (v_prev_x * v_next_y - v_prev_y * v_next_x);
                                    // vector from inPt to intersection point
                                    v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
                                    v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);
                                    // Don't normalize!, otherwise sharp corners become ugly
                                    //  but prevent crazy spikes
                                    var v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
                                    if (v_trans_lensq <= 2) {
                                        return new Vector2(v_trans_x, v_trans_y);
                                    } else {
                                        shrink_by = Math.sqrt(v_trans_lensq / 2);
                                    }
                                } else {
                                    // handle special case of collinear edges
                                    var direction_eq = false; // assumes: opposite
                                    if (v_prev_x > Number.EPSILON) {
                                        if (v_next_x > Number.EPSILON) {
                                            direction_eq = true;
                                        }
                                    } else {
                                        if (v_prev_x < -Number.EPSILON) {
                                            if (v_next_x < -Number.EPSILON) {
                                                direction_eq = true;
                                            }
                                        } else {
                                            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                                                direction_eq = true;
                                            }
                                        }
                                    }
                                    if (direction_eq) {
                                        // console.log("Warning: lines are a straight sequence");
                                        v_trans_x = -v_prev_y;
                                        v_trans_y = v_prev_x;
                                        shrink_by = Math.sqrt(v_prev_lensq);
                                    } else {
                                        // console.log("Warning: lines are a straight spike");
                                        v_trans_x = v_prev_x;
                                        v_trans_y = v_prev_y;
                                        shrink_by = Math.sqrt(v_prev_lensq / 2);
                                    }
                                }
                                return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
                            }
                            var contourMovements = [];
                            for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                                if (j === il)
                                    j = 0;
                                if (k === il)
                                    k = 0;
                                //  (j)---(i)---(k)
                                // console.log('i,j,k', i, j , k)
                                contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
                            }
                            var holesMovements = [];
                            var oneHoleMovements, verticesMovements = contourMovements.concat();
                            for (var h = 0, hl = holes.length; h < hl; h++) {
                                var ahole = holes[h];
                                oneHoleMovements = [];
                                for (var i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                                    if (j === il)
                                        j = 0;
                                    if (k === il)
                                        k = 0;
                                    //  (j)---(i)---(k)
                                    oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
                                }
                                holesMovements.push(oneHoleMovements);
                                verticesMovements = verticesMovements.concat(oneHoleMovements);
                            }
                            // Loop bevelSegments, 1 for the front, 1 for the back
                            for (var b = 0; b < bevelSegments; b++) {
                                //for ( b = bevelSegments; b > 0; b -- ) {
                                var t = b / bevelSegments;
                                var z = bevelThickness * Math.cos(t * Math.PI / 2);
                                var bs_1 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                                // contract shape
                                for (var i = 0, il = contour.length; i < il; i++) {
                                    var vert = scalePt2(contour[i], contourMovements[i], bs_1);
                                    v(vert.x, vert.y, -z);
                                }
                                // expand holes
                                for (var h = 0, hl = holes.length; h < hl; h++) {
                                    var ahole = holes[h];
                                    oneHoleMovements = holesMovements[h];
                                    for (var i = 0, il = ahole.length; i < il; i++) {
                                        var vert = scalePt2(ahole[i], oneHoleMovements[i], bs_1);
                                        v(vert.x, vert.y, -z);
                                    }
                                }
                            }
                            var bs = bevelSize + bevelOffset;
                            // Back facing vertices
                            for (var i = 0; i < vlen; i++) {
                                var vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                                if (!extrudeByPath) {
                                    v(vert.x, vert.y, 0);
                                } else {
                                    // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
                                    normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                                    binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                                    position2.copy(extrudePts[0]).add(normal).add(binormal);
                                    v(position2.x, position2.y, position2.z);
                                }
                            }
                            // Add stepped vertices...
                            // Including front facing vertices
                            for (var s = 1; s <= steps; s++) {
                                for (var i = 0; i < vlen; i++) {
                                    var vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                                    if (!extrudeByPath) {
                                        v(vert.x, vert.y, depth / steps * s);
                                    } else {
                                        // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
                                        normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                                        binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                                        position2.copy(extrudePts[s]).add(normal).add(binormal);
                                        v(position2.x, position2.y, position2.z);
                                    }
                                }
                            }
                            // Add bevel segments planes
                            //for ( b = 1; b <= bevelSegments; b ++ ) {
                            for (var b = bevelSegments - 1; b >= 0; b--) {
                                var t = b / bevelSegments;
                                var z = bevelThickness * Math.cos(t * Math.PI / 2);
                                var bs_2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                                // contract shape
                                for (var i = 0, il = contour.length; i < il; i++) {
                                    var vert = scalePt2(contour[i], contourMovements[i], bs_2);
                                    v(vert.x, vert.y, depth + z);
                                }
                                // expand holes
                                for (var h = 0, hl = holes.length; h < hl; h++) {
                                    var ahole = holes[h];
                                    oneHoleMovements = holesMovements[h];
                                    for (var i = 0, il = ahole.length; i < il; i++) {
                                        var vert = scalePt2(ahole[i], oneHoleMovements[i], bs_2);
                                        if (!extrudeByPath) {
                                            v(vert.x, vert.y, depth + z);
                                        } else {
                                            v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                                        }
                                    }
                                }
                            }
                            /* Faces */
                            // Top and bottom faces
                            buildLidFaces();
                            // Sides faces
                            buildSideFaces();
                            /////  Internal functions
                            function buildLidFaces() {
                                var start = verticesArray.length / 3;
                                if (bevelEnabled) {
                                    var layer = 0; // steps + 1
                                    var offset = vlen * layer;
                                    // Bottom faces
                                    for (var i = 0; i < flen; i++) {
                                        var face = faces[i];
                                        f3(face[2] + offset, face[1] + offset, face[0] + offset);
                                    }
                                    layer = steps + bevelSegments * 2;
                                    offset = vlen * layer;
                                    // Top faces
                                    for (var i = 0; i < flen; i++) {
                                        var face = faces[i];
                                        f3(face[0] + offset, face[1] + offset, face[2] + offset);
                                    }
                                } else {
                                    // Bottom faces
                                    for (var i = 0; i < flen; i++) {
                                        var face = faces[i];
                                        f3(face[2], face[1], face[0]);
                                    }
                                    // Top faces
                                    for (var i = 0; i < flen; i++) {
                                        var face = faces[i];
                                        f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
                                    }
                                }
                                scope.addGroup(start, verticesArray.length / 3 - start, 0);
                            }
                            // Create faces for the z-sides of the shape
                            function buildSideFaces() {
                                var start = verticesArray.length / 3;
                                var layeroffset = 0;
                                sidewalls(contour, layeroffset);
                                layeroffset += contour.length;
                                for (var h = 0, hl = holes.length; h < hl; h++) {
                                    var ahole = holes[h];
                                    sidewalls(ahole, layeroffset);
                                    //, true
                                    layeroffset += ahole.length;
                                }
                                scope.addGroup(start, verticesArray.length / 3 - start, 1);
                            }

                            function sidewalls(contour, layeroffset) {
                                var i = contour.length;
                                while (--i >= 0) {
                                    var j = i;
                                    var k = i - 1;
                                    if (k < 0)
                                        k = contour.length - 1;
                                    //console.log('b', i,j, i-1, k,vertices.length);
                                    for (var s = 0, sl = (steps + bevelSegments * 2); s < sl; s++) {
                                        var slen1 = vlen * s;
                                        var slen2 = vlen * (s + 1);
                                        var a = layeroffset + j + slen1,
                                            b = layeroffset + k + slen1,
                                            c = layeroffset + k + slen2,
                                            d = layeroffset + j + slen2;
                                        f4(a, b, c, d);
                                    }
                                }
                            }

                            function v(x, y, z) {
                                placeholder.push(x);
                                placeholder.push(y);
                                placeholder.push(z);
                            }

                            function f3(a, b, c) {
                                addVertex(a);
                                addVertex(b);
                                addVertex(c);
                                var nextIndex = verticesArray.length / 3;
                                var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                                addUV(uvs[0]);
                                addUV(uvs[1]);
                                addUV(uvs[2]);
                            }

                            function f4(a, b, c, d) {
                                addVertex(a);
                                addVertex(b);
                                addVertex(d);
                                addVertex(b);
                                addVertex(c);
                                addVertex(d);
                                var nextIndex = verticesArray.length / 3;
                                var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                                addUV(uvs[0]);
                                addUV(uvs[1]);
                                addUV(uvs[3]);
                                addUV(uvs[1]);
                                addUV(uvs[2]);
                                addUV(uvs[3]);
                            }

                            function addVertex(index) {
                                verticesArray.push(placeholder[index * 3 + 0]);
                                verticesArray.push(placeholder[index * 3 + 1]);
                                verticesArray.push(placeholder[index * 3 + 2]);
                            }

                            function addUV(vector2) {
                                uvArray.push(vector2.x);
                                uvArray.push(vector2.y);
                            }
                        }
                        return _this_1;
                    }
                    ExtrudeGeometry.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this);
                        var shapes = this.parameters.shapes;
                        var options = this.parameters.options;
                        return toJSON$1(shapes, options, data);
                    };
                    ExtrudeGeometry.fromJSON = function(data, shapes) {
                        var geometryShapes = [];
                        for (var j = 0, jl = data.shapes.length; j < jl; j++) {
                            var shape = shapes[data.shapes[j]];
                            geometryShapes.push(shape);
                        }
                        var extrudePath = data.options.extrudePath;
                        if (extrudePath !== undefined) {
                            data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
                        }
                        return new ExtrudeGeometry(geometryShapes, data.options);
                    };
                    return ExtrudeGeometry;
                }(BufferGeometry));
                var WorldUVGenerator = {
                    generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
                        var a_x = vertices[indexA * 3];
                        var a_y = vertices[indexA * 3 + 1];
                        var b_x = vertices[indexB * 3];
                        var b_y = vertices[indexB * 3 + 1];
                        var c_x = vertices[indexC * 3];
                        var c_y = vertices[indexC * 3 + 1];
                        return [
                            new Vector2(a_x, a_y),
                            new Vector2(b_x, b_y),
                            new Vector2(c_x, c_y)
                        ];
                    },
                    generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
                        var a_x = vertices[indexA * 3];
                        var a_y = vertices[indexA * 3 + 1];
                        var a_z = vertices[indexA * 3 + 2];
                        var b_x = vertices[indexB * 3];
                        var b_y = vertices[indexB * 3 + 1];
                        var b_z = vertices[indexB * 3 + 2];
                        var c_x = vertices[indexC * 3];
                        var c_y = vertices[indexC * 3 + 1];
                        var c_z = vertices[indexC * 3 + 2];
                        var d_x = vertices[indexD * 3];
                        var d_y = vertices[indexD * 3 + 1];
                        var d_z = vertices[indexD * 3 + 2];
                        if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
                            return [
                                new Vector2(a_x, 1 - a_z),
                                new Vector2(b_x, 1 - b_z),
                                new Vector2(c_x, 1 - c_z),
                                new Vector2(d_x, 1 - d_z)
                            ];
                        } else {
                            return [
                                new Vector2(a_y, 1 - a_z),
                                new Vector2(b_y, 1 - b_z),
                                new Vector2(c_y, 1 - c_z),
                                new Vector2(d_y, 1 - d_z)
                            ];
                        }
                    }
                };

                function toJSON$1(shapes, options, data) {
                    data.shapes = [];
                    if (Array.isArray(shapes)) {
                        for (var i = 0, l = shapes.length; i < l; i++) {
                            var shape = shapes[i];
                            data.shapes.push(shape.uuid);
                        }
                    } else {
                        data.shapes.push(shapes.uuid);
                    }
                    if (options.extrudePath !== undefined)
                        data.options.extrudePath = options.extrudePath.toJSON();
                    return data;
                }
                var IcosahedronGeometry = /** @class */ (function(_super) {
                    __extends(IcosahedronGeometry, _super);

                    function IcosahedronGeometry(radius, detail) {
                        if (radius === void 0) {
                            radius = 1;
                        }
                        if (detail === void 0) {
                            detail = 0;
                        }
                        var _this_1 = this;
                        var t = (1 + Math.sqrt(5)) / 2;
                        var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0,
                            0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t,
                            t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1
                        ];
                        var indices = [
                            0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11,
                            1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8,
                            3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
                            4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
                        ];
                        _this_1 = _super.call(this, vertices, indices, radius, detail) || this;
                        _this_1.type = 'IcosahedronGeometry';
                        _this_1.parameters = {
                            radius: radius,
                            detail: detail
                        };
                        return _this_1;
                    }
                    IcosahedronGeometry.fromJSON = function(data) {
                        return new IcosahedronGeometry(data.radius, data.detail);
                    };
                    return IcosahedronGeometry;
                }(PolyhedronGeometry));
                var OctahedronGeometry = /** @class */ (function(_super) {
                    __extends(OctahedronGeometry, _super);

                    function OctahedronGeometry(radius, detail) {
                        if (radius === void 0) {
                            radius = 1;
                        }
                        if (detail === void 0) {
                            detail = 0;
                        }
                        var _this_1 = this;
                        var vertices = [
                            1, 0, 0, -1, 0, 0, 0, 1, 0,
                            0, -1, 0, 0, 0, 1, 0, 0, -1
                        ];
                        var indices = [
                            0, 2, 4, 0, 4, 3, 0, 3, 5,
                            0, 5, 2, 1, 2, 5, 1, 5, 3,
                            1, 3, 4, 1, 4, 2
                        ];
                        _this_1 = _super.call(this, vertices, indices, radius, detail) || this;
                        _this_1.type = 'OctahedronGeometry';
                        _this_1.parameters = {
                            radius: radius,
                            detail: detail
                        };
                        return _this_1;
                    }
                    OctahedronGeometry.fromJSON = function(data) {
                        return new OctahedronGeometry(data.radius, data.detail);
                    };
                    return OctahedronGeometry;
                }(PolyhedronGeometry));
                var RingGeometry = /** @class */ (function(_super) {
                    __extends(RingGeometry, _super);

                    function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
                        if (innerRadius === void 0) {
                            innerRadius = 0.5;
                        }
                        if (outerRadius === void 0) {
                            outerRadius = 1;
                        }
                        if (thetaSegments === void 0) {
                            thetaSegments = 8;
                        }
                        if (phiSegments === void 0) {
                            phiSegments = 1;
                        }
                        if (thetaStart === void 0) {
                            thetaStart = 0;
                        }
                        if (thetaLength === void 0) {
                            thetaLength = Math.PI * 2;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'RingGeometry';
                        _this_1.parameters = {
                            innerRadius: innerRadius,
                            outerRadius: outerRadius,
                            thetaSegments: thetaSegments,
                            phiSegments: phiSegments,
                            thetaStart: thetaStart,
                            thetaLength: thetaLength
                        };
                        thetaSegments = Math.max(3, thetaSegments);
                        phiSegments = Math.max(1, phiSegments);
                        // buffers
                        var indices = [];
                        var vertices = [];
                        var normals = [];
                        var uvs = [];
                        // some helper variables
                        var radius = innerRadius;
                        var radiusStep = ((outerRadius - innerRadius) / phiSegments);
                        var vertex = new Vector3();
                        var uv = new Vector2();
                        // generate vertices, normals and uvs
                        for (var j = 0; j <= phiSegments; j++) {
                            for (var i = 0; i <= thetaSegments; i++) {
                                // values are generate from the inside of the ring to the outside
                                var segment = thetaStart + i / thetaSegments * thetaLength;
                                // vertex
                                vertex.x = radius * Math.cos(segment);
                                vertex.y = radius * Math.sin(segment);
                                vertices.push(vertex.x, vertex.y, vertex.z);
                                // normal
                                normals.push(0, 0, 1);
                                // uv
                                uv.x = (vertex.x / outerRadius + 1) / 2;
                                uv.y = (vertex.y / outerRadius + 1) / 2;
                                uvs.push(uv.x, uv.y);
                            }
                            // increase the radius for next row of vertices
                            radius += radiusStep;
                        }
                        // indices
                        for (var j = 0; j < phiSegments; j++) {
                            var thetaSegmentLevel = j * (thetaSegments + 1);
                            for (var i = 0; i < thetaSegments; i++) {
                                var segment = i + thetaSegmentLevel;
                                var a = segment;
                                var b = segment + thetaSegments + 1;
                                var c = segment + thetaSegments + 2;
                                var d = segment + 1;
                                // faces
                                indices.push(a, b, d);
                                indices.push(b, c, d);
                            }
                        }
                        // build geometry
                        _this_1.setIndex(indices);
                        _this_1.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        _this_1.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        _this_1.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
                        return _this_1;
                    }
                    RingGeometry.fromJSON = function(data) {
                        return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
                    };
                    return RingGeometry;
                }(BufferGeometry));
                var ShapeGeometry = /** @class */ (function(_super) {
                    __extends(ShapeGeometry, _super);

                    function ShapeGeometry(shapes, curveSegments) {
                        if (shapes === void 0) {
                            shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]);
                        }
                        if (curveSegments === void 0) {
                            curveSegments = 12;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'ShapeGeometry';
                        _this_1.parameters = {
                            shapes: shapes,
                            curveSegments: curveSegments
                        };
                        // buffers
                        var indices = [];
                        var vertices = [];
                        var normals = [];
                        var uvs = [];
                        // helper variables
                        var groupStart = 0;
                        var groupCount = 0;
                        // allow single and array values for "shapes" parameter
                        if (Array.isArray(shapes) === false) {
                            addShape(shapes);
                        } else {
                            for (var i = 0; i < shapes.length; i++) {
                                addShape(shapes[i]);
                                _this_1.addGroup(groupStart, groupCount, i); // enables MultiMaterial support
                                groupStart += groupCount;
                                groupCount = 0;
                            }
                        }
                        // build geometry
                        _this_1.setIndex(indices);
                        _this_1.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        _this_1.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        _this_1.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
                        // helper functions
                        function addShape(shape) {
                            var indexOffset = vertices.length / 3;
                            var points = shape.extractPoints(curveSegments);
                            var shapeVertices = points.shape;
                            var shapeHoles = points.holes;
                            // check direction of vertices
                            if (ShapeUtils.isClockWise(shapeVertices) === false) {
                                shapeVertices = shapeVertices.reverse();
                            }
                            for (var i = 0, l = shapeHoles.length; i < l; i++) {
                                var shapeHole = shapeHoles[i];
                                if (ShapeUtils.isClockWise(shapeHole) === true) {
                                    shapeHoles[i] = shapeHole.reverse();
                                }
                            }
                            var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
                            // join vertices of inner and outer paths to a single array
                            for (var i = 0, l = shapeHoles.length; i < l; i++) {
                                var shapeHole = shapeHoles[i];
                                shapeVertices = shapeVertices.concat(shapeHole);
                            }
                            // vertices, normals, uvs
                            for (var i = 0, l = shapeVertices.length; i < l; i++) {
                                var vertex_1 = shapeVertices[i];
                                vertices.push(vertex_1.x, vertex_1.y, 0);
                                normals.push(0, 0, 1);
                                uvs.push(vertex_1.x, vertex_1.y); // world uvs
                            }
                            // incides
                            for (var i = 0, l = faces.length; i < l; i++) {
                                var face = faces[i];
                                var a = face[0] + indexOffset;
                                var b = face[1] + indexOffset;
                                var c = face[2] + indexOffset;
                                indices.push(a, b, c);
                                groupCount += 3;
                            }
                        }
                        return _this_1;
                    }
                    ShapeGeometry.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this);
                        var shapes = this.parameters.shapes;
                        return toJSON(shapes, data);
                    };
                    ShapeGeometry.fromJSON = function(data, shapes) {
                        var geometryShapes = [];
                        for (var j = 0, jl = data.shapes.length; j < jl; j++) {
                            var shape = shapes[data.shapes[j]];
                            geometryShapes.push(shape);
                        }
                        return new ShapeGeometry(geometryShapes, data.curveSegments);
                    };
                    return ShapeGeometry;
                }(BufferGeometry));

                function toJSON(shapes, data) {
                    data.shapes = [];
                    if (Array.isArray(shapes)) {
                        for (var i = 0, l = shapes.length; i < l; i++) {
                            var shape = shapes[i];
                            data.shapes.push(shape.uuid);
                        }
                    } else {
                        data.shapes.push(shapes.uuid);
                    }
                    return data;
                }
                var SphereGeometry = /** @class */ (function(_super) {
                    __extends(SphereGeometry, _super);

                    function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
                        if (radius === void 0) {
                            radius = 1;
                        }
                        if (widthSegments === void 0) {
                            widthSegments = 32;
                        }
                        if (heightSegments === void 0) {
                            heightSegments = 16;
                        }
                        if (phiStart === void 0) {
                            phiStart = 0;
                        }
                        if (phiLength === void 0) {
                            phiLength = Math.PI * 2;
                        }
                        if (thetaStart === void 0) {
                            thetaStart = 0;
                        }
                        if (thetaLength === void 0) {
                            thetaLength = Math.PI;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'SphereGeometry';
                        _this_1.parameters = {
                            radius: radius,
                            widthSegments: widthSegments,
                            heightSegments: heightSegments,
                            phiStart: phiStart,
                            phiLength: phiLength,
                            thetaStart: thetaStart,
                            thetaLength: thetaLength
                        };
                        widthSegments = Math.max(3, Math.floor(widthSegments));
                        heightSegments = Math.max(2, Math.floor(heightSegments));
                        var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
                        var index = 0;
                        var grid = [];
                        var vertex = new Vector3();
                        var normal = new Vector3();
                        // buffers
                        var indices = [];
                        var vertices = [];
                        var normals = [];
                        var uvs = [];
                        // generate vertices, normals and uvs
                        for (var iy = 0; iy <= heightSegments; iy++) {
                            var verticesRow = [];
                            var v = iy / heightSegments;
                            // special case for the poles
                            var uOffset = 0;
                            if (iy == 0 && thetaStart == 0) {
                                uOffset = 0.5 / widthSegments;
                            } else if (iy == heightSegments && thetaEnd == Math.PI) {
                                uOffset = -0.5 / widthSegments;
                            }
                            for (var ix = 0; ix <= widthSegments; ix++) {
                                var u = ix / widthSegments;
                                // vertex
                                vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                                vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                                vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                                vertices.push(vertex.x, vertex.y, vertex.z);
                                // normal
                                normal.copy(vertex).normalize();
                                normals.push(normal.x, normal.y, normal.z);
                                // uv
                                uvs.push(u + uOffset, 1 - v);
                                verticesRow.push(index++);
                            }
                            grid.push(verticesRow);
                        }
                        // indices
                        for (var iy = 0; iy < heightSegments; iy++) {
                            for (var ix = 0; ix < widthSegments; ix++) {
                                var a = grid[iy][ix + 1];
                                var b = grid[iy][ix];
                                var c = grid[iy + 1][ix];
                                var d = grid[iy + 1][ix + 1];
                                if (iy !== 0 || thetaStart > 0)
                                    indices.push(a, b, d);
                                if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
                                    indices.push(b, c, d);
                            }
                        }
                        // build geometry
                        _this_1.setIndex(indices);
                        _this_1.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        _this_1.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        _this_1.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
                        return _this_1;
                    }
                    SphereGeometry.fromJSON = function(data) {
                        return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
                    };
                    return SphereGeometry;
                }(BufferGeometry));
                var TetrahedronGeometry = /** @class */ (function(_super) {
                    __extends(TetrahedronGeometry, _super);

                    function TetrahedronGeometry(radius, detail) {
                        if (radius === void 0) {
                            radius = 1;
                        }
                        if (detail === void 0) {
                            detail = 0;
                        }
                        var _this_1 = this;
                        var vertices = [
                            1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1
                        ];
                        var indices = [
                            2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1
                        ];
                        _this_1 = _super.call(this, vertices, indices, radius, detail) || this;
                        _this_1.type = 'TetrahedronGeometry';
                        _this_1.parameters = {
                            radius: radius,
                            detail: detail
                        };
                        return _this_1;
                    }
                    TetrahedronGeometry.fromJSON = function(data) {
                        return new TetrahedronGeometry(data.radius, data.detail);
                    };
                    return TetrahedronGeometry;
                }(PolyhedronGeometry));
                var TorusGeometry = /** @class */ (function(_super) {
                    __extends(TorusGeometry, _super);

                    function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
                        if (radius === void 0) {
                            radius = 1;
                        }
                        if (tube === void 0) {
                            tube = 0.4;
                        }
                        if (radialSegments === void 0) {
                            radialSegments = 8;
                        }
                        if (tubularSegments === void 0) {
                            tubularSegments = 6;
                        }
                        if (arc === void 0) {
                            arc = Math.PI * 2;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'TorusGeometry';
                        _this_1.parameters = {
                            radius: radius,
                            tube: tube,
                            radialSegments: radialSegments,
                            tubularSegments: tubularSegments,
                            arc: arc
                        };
                        radialSegments = Math.floor(radialSegments);
                        tubularSegments = Math.floor(tubularSegments);
                        // buffers
                        var indices = [];
                        var vertices = [];
                        var normals = [];
                        var uvs = [];
                        // helper variables
                        var center = new Vector3();
                        var vertex = new Vector3();
                        var normal = new Vector3();
                        // generate vertices, normals and uvs
                        for (var j = 0; j <= radialSegments; j++) {
                            for (var i = 0; i <= tubularSegments; i++) {
                                var u = i / tubularSegments * arc;
                                var v = j / radialSegments * Math.PI * 2;
                                // vertex
                                vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                                vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                                vertex.z = tube * Math.sin(v);
                                vertices.push(vertex.x, vertex.y, vertex.z);
                                // normal
                                center.x = radius * Math.cos(u);
                                center.y = radius * Math.sin(u);
                                normal.subVectors(vertex, center).normalize();
                                normals.push(normal.x, normal.y, normal.z);
                                // uv
                                uvs.push(i / tubularSegments);
                                uvs.push(j / radialSegments);
                            }
                        }
                        // generate indices
                        for (var j = 1; j <= radialSegments; j++) {
                            for (var i = 1; i <= tubularSegments; i++) {
                                // indices
                                var a = (tubularSegments + 1) * j + i - 1;
                                var b = (tubularSegments + 1) * (j - 1) + i - 1;
                                var c = (tubularSegments + 1) * (j - 1) + i;
                                var d = (tubularSegments + 1) * j + i;
                                // faces
                                indices.push(a, b, d);
                                indices.push(b, c, d);
                            }
                        }
                        // build geometry
                        _this_1.setIndex(indices);
                        _this_1.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        _this_1.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        _this_1.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
                        return _this_1;
                    }
                    TorusGeometry.fromJSON = function(data) {
                        return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
                    };
                    return TorusGeometry;
                }(BufferGeometry));
                var TorusKnotGeometry = /** @class */ (function(_super) {
                    __extends(TorusKnotGeometry, _super);

                    function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
                        if (radius === void 0) {
                            radius = 1;
                        }
                        if (tube === void 0) {
                            tube = 0.4;
                        }
                        if (tubularSegments === void 0) {
                            tubularSegments = 64;
                        }
                        if (radialSegments === void 0) {
                            radialSegments = 8;
                        }
                        if (p === void 0) {
                            p = 2;
                        }
                        if (q === void 0) {
                            q = 3;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'TorusKnotGeometry';
                        _this_1.parameters = {
                            radius: radius,
                            tube: tube,
                            tubularSegments: tubularSegments,
                            radialSegments: radialSegments,
                            p: p,
                            q: q
                        };
                        tubularSegments = Math.floor(tubularSegments);
                        radialSegments = Math.floor(radialSegments);
                        // buffers
                        var indices = [];
                        var vertices = [];
                        var normals = [];
                        var uvs = [];
                        // helper variables
                        var vertex = new Vector3();
                        var normal = new Vector3();
                        var P1 = new Vector3();
                        var P2 = new Vector3();
                        var B = new Vector3();
                        var T = new Vector3();
                        var N = new Vector3();
                        // generate vertices, normals and uvs
                        for (var i = 0; i <= tubularSegments; ++i) {
                            // the radian "u" is used to calculate the position on the torus curve of the current tubular segment
                            var u = i / tubularSegments * p * Math.PI * 2;
                            // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
                            // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
                            calculatePositionOnCurve(u, p, q, radius, P1);
                            calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
                            // calculate orthonormal basis
                            T.subVectors(P2, P1);
                            N.addVectors(P2, P1);
                            B.crossVectors(T, N);
                            N.crossVectors(B, T);
                            // normalize B, N. T can be ignored, we don't use it
                            B.normalize();
                            N.normalize();
                            for (var j = 0; j <= radialSegments; ++j) {
                                // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
                                // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
                                var v = j / radialSegments * Math.PI * 2;
                                var cx = -tube * Math.cos(v);
                                var cy = tube * Math.sin(v);
                                // now calculate the final vertex position.
                                // first we orient the extrusion with our basis vectors, then we add it to the current position on the curve
                                vertex.x = P1.x + (cx * N.x + cy * B.x);
                                vertex.y = P1.y + (cx * N.y + cy * B.y);
                                vertex.z = P1.z + (cx * N.z + cy * B.z);
                                vertices.push(vertex.x, vertex.y, vertex.z);
                                // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
                                normal.subVectors(vertex, P1).normalize();
                                normals.push(normal.x, normal.y, normal.z);
                                // uv
                                uvs.push(i / tubularSegments);
                                uvs.push(j / radialSegments);
                            }
                        }
                        // generate indices
                        for (var j = 1; j <= tubularSegments; j++) {
                            for (var i = 1; i <= radialSegments; i++) {
                                // indices
                                var a = (radialSegments + 1) * (j - 1) + (i - 1);
                                var b = (radialSegments + 1) * j + (i - 1);
                                var c = (radialSegments + 1) * j + i;
                                var d = (radialSegments + 1) * (j - 1) + i;
                                // faces
                                indices.push(a, b, d);
                                indices.push(b, c, d);
                            }
                        }
                        // build geometry
                        _this_1.setIndex(indices);
                        _this_1.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        _this_1.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        _this_1.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
                        // this function calculates the current position on the torus curve
                        function calculatePositionOnCurve(u, p, q, radius, position) {
                            var cu = Math.cos(u);
                            var su = Math.sin(u);
                            var quOverP = q / p * u;
                            var cs = Math.cos(quOverP);
                            position.x = radius * (2 + cs) * 0.5 * cu;
                            position.y = radius * (2 + cs) * su * 0.5;
                            position.z = radius * Math.sin(quOverP) * 0.5;
                        }
                        return _this_1;
                    }
                    TorusKnotGeometry.fromJSON = function(data) {
                        return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
                    };
                    return TorusKnotGeometry;
                }(BufferGeometry));
                var TubeGeometry = /** @class */ (function(_super) {
                    __extends(TubeGeometry, _super);

                    function TubeGeometry(path, tubularSegments, radius, radialSegments, closed) {
                        if (path === void 0) {
                            path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0));
                        }
                        if (tubularSegments === void 0) {
                            tubularSegments = 64;
                        }
                        if (radius === void 0) {
                            radius = 1;
                        }
                        if (radialSegments === void 0) {
                            radialSegments = 8;
                        }
                        if (closed === void 0) {
                            closed = false;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'TubeGeometry';
                        _this_1.parameters = {
                            path: path,
                            tubularSegments: tubularSegments,
                            radius: radius,
                            radialSegments: radialSegments,
                            closed: closed
                        };
                        var frames = path.computeFrenetFrames(tubularSegments, closed);
                        // expose internals
                        _this_1.tangents = frames.tangents;
                        _this_1.normals = frames.normals;
                        _this_1.binormals = frames.binormals;
                        // helper variables
                        var vertex = new Vector3();
                        var normal = new Vector3();
                        var uv = new Vector2();
                        var P = new Vector3();
                        // buffer
                        var vertices = [];
                        var normals = [];
                        var uvs = [];
                        var indices = [];
                        // create buffer data
                        generateBufferData();
                        // build geometry
                        _this_1.setIndex(indices);
                        _this_1.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        _this_1.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        _this_1.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
                        // functions
                        function generateBufferData() {
                            for (var i = 0; i < tubularSegments; i++) {
                                generateSegment(i);
                            }
                            // if the geometry is not closed, generate the last row of vertices and normals
                            // at the regular position on the given path
                            //
                            // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
                            generateSegment((closed === false) ? tubularSegments : 0);
                            // uvs are generated in a separate function.
                            // this makes it easy compute correct values for closed geometries
                            generateUVs();
                            // finally create faces
                            generateIndices();
                        }

                        function generateSegment(i) {
                            // we use getPointAt to sample evenly distributed points from the given path
                            P = path.getPointAt(i / tubularSegments, P);
                            // retrieve corresponding normal and binormal
                            var N = frames.normals[i];
                            var B = frames.binormals[i];
                            // generate normals and vertices for the current segment
                            for (var j = 0; j <= radialSegments; j++) {
                                var v = j / radialSegments * Math.PI * 2;
                                var sin = Math.sin(v);
                                var cos = -Math.cos(v);
                                // normal
                                normal.x = (cos * N.x + sin * B.x);
                                normal.y = (cos * N.y + sin * B.y);
                                normal.z = (cos * N.z + sin * B.z);
                                normal.normalize();
                                normals.push(normal.x, normal.y, normal.z);
                                // vertex
                                vertex.x = P.x + radius * normal.x;
                                vertex.y = P.y + radius * normal.y;
                                vertex.z = P.z + radius * normal.z;
                                vertices.push(vertex.x, vertex.y, vertex.z);
                            }
                        }

                        function generateIndices() {
                            for (var j = 1; j <= tubularSegments; j++) {
                                for (var i = 1; i <= radialSegments; i++) {
                                    var a = (radialSegments + 1) * (j - 1) + (i - 1);
                                    var b = (radialSegments + 1) * j + (i - 1);
                                    var c = (radialSegments + 1) * j + i;
                                    var d = (radialSegments + 1) * (j - 1) + i;
                                    // faces
                                    indices.push(a, b, d);
                                    indices.push(b, c, d);
                                }
                            }
                        }

                        function generateUVs() {
                            for (var i = 0; i <= tubularSegments; i++) {
                                for (var j = 0; j <= radialSegments; j++) {
                                    uv.x = i / tubularSegments;
                                    uv.y = j / radialSegments;
                                    uvs.push(uv.x, uv.y);
                                }
                            }
                        }
                        return _this_1;
                    }
                    TubeGeometry.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this);
                        data.path = this.parameters.path.toJSON();
                        return data;
                    };
                    TubeGeometry.fromJSON = function(data) {
                        // This only works for built-in curves (e.g. CatmullRomCurve3).
                        // User defined curves or instances of CurvePath will not be deserialized.
                        return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
                    };
                    return TubeGeometry;
                }(BufferGeometry));
                var WireframeGeometry = /** @class */ (function(_super) {
                    __extends(WireframeGeometry, _super);

                    function WireframeGeometry(geometry) {
                        if (geometry === void 0) {
                            geometry = null;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'WireframeGeometry';
                        _this_1.parameters = {
                            geometry: geometry
                        };
                        if (geometry !== null) {
                            // buffer
                            var vertices = [];
                            var edges = new Set();
                            // helper variables
                            var start = new Vector3();
                            var end = new Vector3();
                            if (geometry.index !== null) {
                                // indexed BufferGeometry
                                var position = geometry.attributes.position;
                                var indices = geometry.index;
                                var groups = geometry.groups;
                                if (groups.length === 0) {
                                    groups = [{
                                        start: 0,
                                        count: indices.count,
                                        materialIndex: 0
                                    }];
                                }
                                // create a data structure that contains all edges without duplicates
                                for (var o = 0, ol = groups.length; o < ol; ++o) {
                                    var group = groups[o];
                                    var groupStart = group.start;
                                    var groupCount = group.count;
                                    for (var i = groupStart, l = (groupStart + groupCount); i < l; i += 3) {
                                        for (var j = 0; j < 3; j++) {
                                            var index1 = indices.getX(i + j);
                                            var index2 = indices.getX(i + (j + 1) % 3);
                                            start.fromBufferAttribute(position, index1);
                                            end.fromBufferAttribute(position, index2);
                                            if (isUniqueEdge(start, end, edges) === true) {
                                                vertices.push(start.x, start.y, start.z);
                                                vertices.push(end.x, end.y, end.z);
                                            }
                                        }
                                    }
                                }
                            } else {
                                // non-indexed BufferGeometry
                                var position = geometry.attributes.position;
                                for (var i = 0, l = (position.count / 3); i < l; i++) {
                                    for (var j = 0; j < 3; j++) {
                                        // three edges per triangle, an edge is represented as (index1, index2)
                                        // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
                                        var index1 = 3 * i + j;
                                        var index2 = 3 * i + ((j + 1) % 3);
                                        start.fromBufferAttribute(position, index1);
                                        end.fromBufferAttribute(position, index2);
                                        if (isUniqueEdge(start, end, edges) === true) {
                                            vertices.push(start.x, start.y, start.z);
                                            vertices.push(end.x, end.y, end.z);
                                        }
                                    }
                                }
                            }
                            // build geometry
                            _this_1.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        }
                        return _this_1;
                    }
                    return WireframeGeometry;
                }(BufferGeometry));

                function isUniqueEdge(start, end, edges) {
                    var hash1 = "".concat(start.x, ",").concat(start.y, ",").concat(start.z, "-").concat(end.x, ",").concat(end.y, ",").concat(end.z);
                    var hash2 = "".concat(end.x, ",").concat(end.y, ",").concat(end.z, "-").concat(start.x, ",").concat(start.y, ",").concat(start.z); // coincident edge
                    if (edges.has(hash1) === true || edges.has(hash2) === true) {
                        return false;
                    } else {
                        edges.add(hash1);
                        edges.add(hash2);
                        return true;
                    }
                }
                var Geometries = /*#__PURE__*/ Object.freeze({
                    __proto__: null,
                    BoxGeometry: BoxGeometry,
                    BoxBufferGeometry: BoxGeometry,
                    CapsuleGeometry: CapsuleGeometry,
                    CapsuleBufferGeometry: CapsuleGeometry,
                    CircleGeometry: CircleGeometry,
                    CircleBufferGeometry: CircleGeometry,
                    ConeGeometry: ConeGeometry,
                    ConeBufferGeometry: ConeGeometry,
                    CylinderGeometry: CylinderGeometry,
                    CylinderBufferGeometry: CylinderGeometry,
                    DodecahedronGeometry: DodecahedronGeometry,
                    DodecahedronBufferGeometry: DodecahedronGeometry,
                    EdgesGeometry: EdgesGeometry,
                    ExtrudeGeometry: ExtrudeGeometry,
                    ExtrudeBufferGeometry: ExtrudeGeometry,
                    IcosahedronGeometry: IcosahedronGeometry,
                    IcosahedronBufferGeometry: IcosahedronGeometry,
                    LatheGeometry: LatheGeometry,
                    LatheBufferGeometry: LatheGeometry,
                    OctahedronGeometry: OctahedronGeometry,
                    OctahedronBufferGeometry: OctahedronGeometry,
                    PlaneGeometry: PlaneGeometry,
                    PlaneBufferGeometry: PlaneGeometry,
                    PolyhedronGeometry: PolyhedronGeometry,
                    PolyhedronBufferGeometry: PolyhedronGeometry,
                    RingGeometry: RingGeometry,
                    RingBufferGeometry: RingGeometry,
                    ShapeGeometry: ShapeGeometry,
                    ShapeBufferGeometry: ShapeGeometry,
                    SphereGeometry: SphereGeometry,
                    SphereBufferGeometry: SphereGeometry,
                    TetrahedronGeometry: TetrahedronGeometry,
                    TetrahedronBufferGeometry: TetrahedronGeometry,
                    TorusGeometry: TorusGeometry,
                    TorusBufferGeometry: TorusGeometry,
                    TorusKnotGeometry: TorusKnotGeometry,
                    TorusKnotBufferGeometry: TorusKnotGeometry,
                    TubeGeometry: TubeGeometry,
                    TubeBufferGeometry: TubeGeometry,
                    WireframeGeometry: WireframeGeometry
                });
                var ShadowMaterial = /** @class */ (function(_super) {
                    __extends(ShadowMaterial, _super);

                    function ShadowMaterial(parameters) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'ShadowMaterial';
                        _this_1.color = new Color(0x000000);
                        _this_1.transparent = true;
                        _this_1.setValues(parameters);
                        return _this_1;
                    }
                    ShadowMaterial.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.color.copy(source.color);
                        return this;
                    };
                    return ShadowMaterial;
                }(Material));
                ShadowMaterial.prototype.isShadowMaterial = true;
                var RawShaderMaterial = /** @class */ (function(_super) {
                    __extends(RawShaderMaterial, _super);

                    function RawShaderMaterial(parameters) {
                        var _this_1 = _super.call(this, parameters) || this;
                        _this_1.type = 'RawShaderMaterial';
                        return _this_1;
                    }
                    return RawShaderMaterial;
                }(ShaderMaterial));
                RawShaderMaterial.prototype.isRawShaderMaterial = true;
                var MeshStandardMaterial = /** @class */ (function(_super) {
                    __extends(MeshStandardMaterial, _super);

                    function MeshStandardMaterial(parameters) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.defines = {
                            'STANDARD': ''
                        };
                        _this_1.type = 'MeshStandardMaterial';
                        _this_1.color = new Color(0xffffff); // diffuse
                        _this_1.roughness = 1.0;
                        _this_1.metalness = 0.0;
                        _this_1.map = null;
                        _this_1.lightMap = null;
                        _this_1.lightMapIntensity = 1.0;
                        _this_1.aoMap = null;
                        _this_1.aoMapIntensity = 1.0;
                        _this_1.emissive = new Color(0x000000);
                        _this_1.emissiveIntensity = 1.0;
                        _this_1.emissiveMap = null;
                        _this_1.bumpMap = null;
                        _this_1.bumpScale = 1;
                        _this_1.normalMap = null;
                        _this_1.normalMapType = TangentSpaceNormalMap;
                        _this_1.normalScale = new Vector2(1, 1);
                        _this_1.displacementMap = null;
                        _this_1.displacementScale = 1;
                        _this_1.displacementBias = 0;
                        _this_1.roughnessMap = null;
                        _this_1.metalnessMap = null;
                        _this_1.alphaMap = null;
                        _this_1.envMap = null;
                        _this_1.envMapIntensity = 1.0;
                        _this_1.wireframe = false;
                        _this_1.wireframeLinewidth = 1;
                        _this_1.wireframeLinecap = 'round';
                        _this_1.wireframeLinejoin = 'round';
                        _this_1.flatShading = false;
                        _this_1.setValues(parameters);
                        return _this_1;
                    }
                    MeshStandardMaterial.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.defines = {
                            'STANDARD': ''
                        };
                        this.color.copy(source.color);
                        this.roughness = source.roughness;
                        this.metalness = source.metalness;
                        this.map = source.map;
                        this.lightMap = source.lightMap;
                        this.lightMapIntensity = source.lightMapIntensity;
                        this.aoMap = source.aoMap;
                        this.aoMapIntensity = source.aoMapIntensity;
                        this.emissive.copy(source.emissive);
                        this.emissiveMap = source.emissiveMap;
                        this.emissiveIntensity = source.emissiveIntensity;
                        this.bumpMap = source.bumpMap;
                        this.bumpScale = source.bumpScale;
                        this.normalMap = source.normalMap;
                        this.normalMapType = source.normalMapType;
                        this.normalScale.copy(source.normalScale);
                        this.displacementMap = source.displacementMap;
                        this.displacementScale = source.displacementScale;
                        this.displacementBias = source.displacementBias;
                        this.roughnessMap = source.roughnessMap;
                        this.metalnessMap = source.metalnessMap;
                        this.alphaMap = source.alphaMap;
                        this.envMap = source.envMap;
                        this.envMapIntensity = source.envMapIntensity;
                        this.wireframe = source.wireframe;
                        this.wireframeLinewidth = source.wireframeLinewidth;
                        this.wireframeLinecap = source.wireframeLinecap;
                        this.wireframeLinejoin = source.wireframeLinejoin;
                        this.flatShading = source.flatShading;
                        return this;
                    };
                    return MeshStandardMaterial;
                }(Material));
                MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
                var MeshPhysicalMaterial = /** @class */ (function(_super) {
                    __extends(MeshPhysicalMaterial, _super);

                    function MeshPhysicalMaterial(parameters) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.defines = {
                            'STANDARD': '',
                            'PHYSICAL': ''
                        };
                        _this_1.type = 'MeshPhysicalMaterial';
                        _this_1.clearcoatMap = null;
                        _this_1.clearcoatRoughness = 0.0;
                        _this_1.clearcoatRoughnessMap = null;
                        _this_1.clearcoatNormalScale = new Vector2(1, 1);
                        _this_1.clearcoatNormalMap = null;
                        _this_1.ior = 1.5;
                        Object.defineProperty(_this_1, 'reflectivity', {
                            get: function() {
                                return (clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1));
                            },
                            set: function(reflectivity) {
                                this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
                            }
                        });
                        _this_1.sheenColor = new Color(0x000000);
                        _this_1.sheenColorMap = null;
                        _this_1.sheenRoughness = 1.0;
                        _this_1.sheenRoughnessMap = null;
                        _this_1.transmissionMap = null;
                        _this_1.thickness = 0;
                        _this_1.thicknessMap = null;
                        _this_1.attenuationDistance = 0.0;
                        _this_1.attenuationColor = new Color(1, 1, 1);
                        _this_1.specularIntensity = 1.0;
                        _this_1.specularIntensityMap = null;
                        _this_1.specularColor = new Color(1, 1, 1);
                        _this_1.specularColorMap = null;
                        _this_1._sheen = 0.0;
                        _this_1._clearcoat = 0;
                        _this_1._transmission = 0;
                        _this_1.setValues(parameters);
                        return _this_1;
                    }
                    Object.defineProperty(MeshPhysicalMaterial.prototype, "sheen", {
                        get: function() {
                            return this._sheen;
                        },
                        set: function(value) {
                            if (this._sheen > 0 !== value > 0) {
                                this.version++;
                            }
                            this._sheen = value;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(MeshPhysicalMaterial.prototype, "clearcoat", {
                        get: function() {
                            return this._clearcoat;
                        },
                        set: function(value) {
                            if (this._clearcoat > 0 !== value > 0) {
                                this.version++;
                            }
                            this._clearcoat = value;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    Object.defineProperty(MeshPhysicalMaterial.prototype, "transmission", {
                        get: function() {
                            return this._transmission;
                        },
                        set: function(value) {
                            if (this._transmission > 0 !== value > 0) {
                                this.version++;
                            }
                            this._transmission = value;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    MeshPhysicalMaterial.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.defines = {
                            'STANDARD': '',
                            'PHYSICAL': ''
                        };
                        this.clearcoat = source.clearcoat;
                        this.clearcoatMap = source.clearcoatMap;
                        this.clearcoatRoughness = source.clearcoatRoughness;
                        this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
                        this.clearcoatNormalMap = source.clearcoatNormalMap;
                        this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
                        this.ior = source.ior;
                        this.sheen = source.sheen;
                        this.sheenColor.copy(source.sheenColor);
                        this.sheenColorMap = source.sheenColorMap;
                        this.sheenRoughness = source.sheenRoughness;
                        this.sheenRoughnessMap = source.sheenRoughnessMap;
                        this.transmission = source.transmission;
                        this.transmissionMap = source.transmissionMap;
                        this.thickness = source.thickness;
                        this.thicknessMap = source.thicknessMap;
                        this.attenuationDistance = source.attenuationDistance;
                        this.attenuationColor.copy(source.attenuationColor);
                        this.specularIntensity = source.specularIntensity;
                        this.specularIntensityMap = source.specularIntensityMap;
                        this.specularColor.copy(source.specularColor);
                        this.specularColorMap = source.specularColorMap;
                        return this;
                    };
                    return MeshPhysicalMaterial;
                }(MeshStandardMaterial));
                MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
                var MeshPhongMaterial = /** @class */ (function(_super) {
                    __extends(MeshPhongMaterial, _super);

                    function MeshPhongMaterial(parameters) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'MeshPhongMaterial';
                        _this_1.color = new Color(0xffffff); // diffuse
                        _this_1.specular = new Color(0x111111);
                        _this_1.shininess = 30;
                        _this_1.map = null;
                        _this_1.lightMap = null;
                        _this_1.lightMapIntensity = 1.0;
                        _this_1.aoMap = null;
                        _this_1.aoMapIntensity = 1.0;
                        _this_1.emissive = new Color(0x000000);
                        _this_1.emissiveIntensity = 1.0;
                        _this_1.emissiveMap = null;
                        _this_1.bumpMap = null;
                        _this_1.bumpScale = 1;
                        _this_1.normalMap = null;
                        _this_1.normalMapType = TangentSpaceNormalMap;
                        _this_1.normalScale = new Vector2(1, 1);
                        _this_1.displacementMap = null;
                        _this_1.displacementScale = 1;
                        _this_1.displacementBias = 0;
                        _this_1.specularMap = null;
                        _this_1.alphaMap = null;
                        _this_1.envMap = null;
                        _this_1.combine = MultiplyOperation;
                        _this_1.reflectivity = 1;
                        _this_1.refractionRatio = 0.98;
                        _this_1.wireframe = false;
                        _this_1.wireframeLinewidth = 1;
                        _this_1.wireframeLinecap = 'round';
                        _this_1.wireframeLinejoin = 'round';
                        _this_1.flatShading = false;
                        _this_1.setValues(parameters);
                        return _this_1;
                    }
                    MeshPhongMaterial.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.color.copy(source.color);
                        this.specular.copy(source.specular);
                        this.shininess = source.shininess;
                        this.map = source.map;
                        this.lightMap = source.lightMap;
                        this.lightMapIntensity = source.lightMapIntensity;
                        this.aoMap = source.aoMap;
                        this.aoMapIntensity = source.aoMapIntensity;
                        this.emissive.copy(source.emissive);
                        this.emissiveMap = source.emissiveMap;
                        this.emissiveIntensity = source.emissiveIntensity;
                        this.bumpMap = source.bumpMap;
                        this.bumpScale = source.bumpScale;
                        this.normalMap = source.normalMap;
                        this.normalMapType = source.normalMapType;
                        this.normalScale.copy(source.normalScale);
                        this.displacementMap = source.displacementMap;
                        this.displacementScale = source.displacementScale;
                        this.displacementBias = source.displacementBias;
                        this.specularMap = source.specularMap;
                        this.alphaMap = source.alphaMap;
                        this.envMap = source.envMap;
                        this.combine = source.combine;
                        this.reflectivity = source.reflectivity;
                        this.refractionRatio = source.refractionRatio;
                        this.wireframe = source.wireframe;
                        this.wireframeLinewidth = source.wireframeLinewidth;
                        this.wireframeLinecap = source.wireframeLinecap;
                        this.wireframeLinejoin = source.wireframeLinejoin;
                        this.flatShading = source.flatShading;
                        return this;
                    };
                    return MeshPhongMaterial;
                }(Material));
                MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
                var MeshToonMaterial = /** @class */ (function(_super) {
                    __extends(MeshToonMaterial, _super);

                    function MeshToonMaterial(parameters) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.defines = {
                            'TOON': ''
                        };
                        _this_1.type = 'MeshToonMaterial';
                        _this_1.color = new Color(0xffffff);
                        _this_1.map = null;
                        _this_1.gradientMap = null;
                        _this_1.lightMap = null;
                        _this_1.lightMapIntensity = 1.0;
                        _this_1.aoMap = null;
                        _this_1.aoMapIntensity = 1.0;
                        _this_1.emissive = new Color(0x000000);
                        _this_1.emissiveIntensity = 1.0;
                        _this_1.emissiveMap = null;
                        _this_1.bumpMap = null;
                        _this_1.bumpScale = 1;
                        _this_1.normalMap = null;
                        _this_1.normalMapType = TangentSpaceNormalMap;
                        _this_1.normalScale = new Vector2(1, 1);
                        _this_1.displacementMap = null;
                        _this_1.displacementScale = 1;
                        _this_1.displacementBias = 0;
                        _this_1.alphaMap = null;
                        _this_1.wireframe = false;
                        _this_1.wireframeLinewidth = 1;
                        _this_1.wireframeLinecap = 'round';
                        _this_1.wireframeLinejoin = 'round';
                        _this_1.setValues(parameters);
                        return _this_1;
                    }
                    MeshToonMaterial.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.color.copy(source.color);
                        this.map = source.map;
                        this.gradientMap = source.gradientMap;
                        this.lightMap = source.lightMap;
                        this.lightMapIntensity = source.lightMapIntensity;
                        this.aoMap = source.aoMap;
                        this.aoMapIntensity = source.aoMapIntensity;
                        this.emissive.copy(source.emissive);
                        this.emissiveMap = source.emissiveMap;
                        this.emissiveIntensity = source.emissiveIntensity;
                        this.bumpMap = source.bumpMap;
                        this.bumpScale = source.bumpScale;
                        this.normalMap = source.normalMap;
                        this.normalMapType = source.normalMapType;
                        this.normalScale.copy(source.normalScale);
                        this.displacementMap = source.displacementMap;
                        this.displacementScale = source.displacementScale;
                        this.displacementBias = source.displacementBias;
                        this.alphaMap = source.alphaMap;
                        this.wireframe = source.wireframe;
                        this.wireframeLinewidth = source.wireframeLinewidth;
                        this.wireframeLinecap = source.wireframeLinecap;
                        this.wireframeLinejoin = source.wireframeLinejoin;
                        return this;
                    };
                    return MeshToonMaterial;
                }(Material));
                MeshToonMaterial.prototype.isMeshToonMaterial = true;
                var MeshNormalMaterial = /** @class */ (function(_super) {
                    __extends(MeshNormalMaterial, _super);

                    function MeshNormalMaterial(parameters) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'MeshNormalMaterial';
                        _this_1.bumpMap = null;
                        _this_1.bumpScale = 1;
                        _this_1.normalMap = null;
                        _this_1.normalMapType = TangentSpaceNormalMap;
                        _this_1.normalScale = new Vector2(1, 1);
                        _this_1.displacementMap = null;
                        _this_1.displacementScale = 1;
                        _this_1.displacementBias = 0;
                        _this_1.wireframe = false;
                        _this_1.wireframeLinewidth = 1;
                        _this_1.fog = false;
                        _this_1.flatShading = false;
                        _this_1.setValues(parameters);
                        return _this_1;
                    }
                    MeshNormalMaterial.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.bumpMap = source.bumpMap;
                        this.bumpScale = source.bumpScale;
                        this.normalMap = source.normalMap;
                        this.normalMapType = source.normalMapType;
                        this.normalScale.copy(source.normalScale);
                        this.displacementMap = source.displacementMap;
                        this.displacementScale = source.displacementScale;
                        this.displacementBias = source.displacementBias;
                        this.wireframe = source.wireframe;
                        this.wireframeLinewidth = source.wireframeLinewidth;
                        this.flatShading = source.flatShading;
                        return this;
                    };
                    return MeshNormalMaterial;
                }(Material));
                MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
                var MeshLambertMaterial = /** @class */ (function(_super) {
                    __extends(MeshLambertMaterial, _super);

                    function MeshLambertMaterial(parameters) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'MeshLambertMaterial';
                        _this_1.color = new Color(0xffffff); // diffuse
                        _this_1.map = null;
                        _this_1.lightMap = null;
                        _this_1.lightMapIntensity = 1.0;
                        _this_1.aoMap = null;
                        _this_1.aoMapIntensity = 1.0;
                        _this_1.emissive = new Color(0x000000);
                        _this_1.emissiveIntensity = 1.0;
                        _this_1.emissiveMap = null;
                        _this_1.specularMap = null;
                        _this_1.alphaMap = null;
                        _this_1.envMap = null;
                        _this_1.combine = MultiplyOperation;
                        _this_1.reflectivity = 1;
                        _this_1.refractionRatio = 0.98;
                        _this_1.wireframe = false;
                        _this_1.wireframeLinewidth = 1;
                        _this_1.wireframeLinecap = 'round';
                        _this_1.wireframeLinejoin = 'round';
                        _this_1.setValues(parameters);
                        return _this_1;
                    }
                    MeshLambertMaterial.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.color.copy(source.color);
                        this.map = source.map;
                        this.lightMap = source.lightMap;
                        this.lightMapIntensity = source.lightMapIntensity;
                        this.aoMap = source.aoMap;
                        this.aoMapIntensity = source.aoMapIntensity;
                        this.emissive.copy(source.emissive);
                        this.emissiveMap = source.emissiveMap;
                        this.emissiveIntensity = source.emissiveIntensity;
                        this.specularMap = source.specularMap;
                        this.alphaMap = source.alphaMap;
                        this.envMap = source.envMap;
                        this.combine = source.combine;
                        this.reflectivity = source.reflectivity;
                        this.refractionRatio = source.refractionRatio;
                        this.wireframe = source.wireframe;
                        this.wireframeLinewidth = source.wireframeLinewidth;
                        this.wireframeLinecap = source.wireframeLinecap;
                        this.wireframeLinejoin = source.wireframeLinejoin;
                        return this;
                    };
                    return MeshLambertMaterial;
                }(Material));
                MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
                var MeshMatcapMaterial = /** @class */ (function(_super) {
                    __extends(MeshMatcapMaterial, _super);

                    function MeshMatcapMaterial(parameters) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.defines = {
                            'MATCAP': ''
                        };
                        _this_1.type = 'MeshMatcapMaterial';
                        _this_1.color = new Color(0xffffff); // diffuse
                        _this_1.matcap = null;
                        _this_1.map = null;
                        _this_1.bumpMap = null;
                        _this_1.bumpScale = 1;
                        _this_1.normalMap = null;
                        _this_1.normalMapType = TangentSpaceNormalMap;
                        _this_1.normalScale = new Vector2(1, 1);
                        _this_1.displacementMap = null;
                        _this_1.displacementScale = 1;
                        _this_1.displacementBias = 0;
                        _this_1.alphaMap = null;
                        _this_1.flatShading = false;
                        _this_1.setValues(parameters);
                        return _this_1;
                    }
                    MeshMatcapMaterial.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.defines = {
                            'MATCAP': ''
                        };
                        this.color.copy(source.color);
                        this.matcap = source.matcap;
                        this.map = source.map;
                        this.bumpMap = source.bumpMap;
                        this.bumpScale = source.bumpScale;
                        this.normalMap = source.normalMap;
                        this.normalMapType = source.normalMapType;
                        this.normalScale.copy(source.normalScale);
                        this.displacementMap = source.displacementMap;
                        this.displacementScale = source.displacementScale;
                        this.displacementBias = source.displacementBias;
                        this.alphaMap = source.alphaMap;
                        this.flatShading = source.flatShading;
                        return this;
                    };
                    return MeshMatcapMaterial;
                }(Material));
                MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
                var LineDashedMaterial = /** @class */ (function(_super) {
                    __extends(LineDashedMaterial, _super);

                    function LineDashedMaterial(parameters) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'LineDashedMaterial';
                        _this_1.scale = 1;
                        _this_1.dashSize = 3;
                        _this_1.gapSize = 1;
                        _this_1.setValues(parameters);
                        return _this_1;
                    }
                    LineDashedMaterial.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.scale = source.scale;
                        this.dashSize = source.dashSize;
                        this.gapSize = source.gapSize;
                        return this;
                    };
                    return LineDashedMaterial;
                }(LineBasicMaterial));
                LineDashedMaterial.prototype.isLineDashedMaterial = true;
                var materialLib = {
                    ShadowMaterial: ShadowMaterial,
                    SpriteMaterial: SpriteMaterial,
                    RawShaderMaterial: RawShaderMaterial,
                    ShaderMaterial: ShaderMaterial,
                    PointsMaterial: PointsMaterial,
                    MeshPhysicalMaterial: MeshPhysicalMaterial,
                    MeshStandardMaterial: MeshStandardMaterial,
                    MeshPhongMaterial: MeshPhongMaterial,
                    MeshToonMaterial: MeshToonMaterial,
                    MeshNormalMaterial: MeshNormalMaterial,
                    MeshLambertMaterial: MeshLambertMaterial,
                    MeshDepthMaterial: MeshDepthMaterial,
                    MeshDistanceMaterial: MeshDistanceMaterial,
                    MeshBasicMaterial: MeshBasicMaterial,
                    MeshMatcapMaterial: MeshMatcapMaterial,
                    LineDashedMaterial: LineDashedMaterial,
                    LineBasicMaterial: LineBasicMaterial,
                    Material: Material
                };
                Material.fromType = function(type) {
                    return new materialLib[type]();
                };
                var AnimationUtils = {
                    // same as Array.prototype.slice, but also works on typed arrays
                    arraySlice: function(array, from, to) {
                        if (AnimationUtils.isTypedArray(array)) {
                            // in ios9 array.subarray(from, undefined) will return empty array
                            // but array.subarray(from) or array.subarray(from, len) is correct
                            return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
                        }
                        return array.slice(from, to);
                    },
                    // converts an array to a specific type
                    convertArray: function(array, type, forceClone) {
                        if (!array || // let 'undefined' and 'null' pass
                            !forceClone && array.constructor === type)
                            return array;
                        if (typeof type.BYTES_PER_ELEMENT === 'number') {
                            return new type(array); // create typed array
                        }
                        return Array.prototype.slice.call(array); // create Array
                    },
                    isTypedArray: function(object) {
                        return ArrayBuffer.isView(object) &&
                            !(object instanceof DataView);
                    },
                    // returns an array by which times and values can be sorted
                    getKeyframeOrder: function(times) {
                        function compareTime(i, j) {
                            return times[i] - times[j];
                        }
                        var n = times.length;
                        var result = new Array(n);
                        for (var i = 0; i !== n; ++i)
                            result[i] = i;
                        result.sort(compareTime);
                        return result;
                    },
                    // uses the array previously returned by 'getKeyframeOrder' to sort data
                    sortedArray: function(values, stride, order) {
                        var nValues = values.length;
                        var result = new values.constructor(nValues);
                        for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
                            var srcOffset = order[i] * stride;
                            for (var j = 0; j !== stride; ++j) {
                                result[dstOffset++] = values[srcOffset + j];
                            }
                        }
                        return result;
                    },
                    // function for parsing AOS keyframe formats
                    flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
                        var i = 1,
                            key = jsonKeys[0];
                        while (key !== undefined && key[valuePropertyName] === undefined) {
                            key = jsonKeys[i++];
                        }
                        if (key === undefined)
                            return; // no data
                        var value = key[valuePropertyName];
                        if (value === undefined)
                            return; // no data
                        if (Array.isArray(value)) {
                            do {
                                value = key[valuePropertyName];
                                if (value !== undefined) {
                                    times.push(key.time);
                                    values.push.apply(values, value); // push all elements
                                }
                                key = jsonKeys[i++];
                            } while (key !== undefined);
                        } else if (value.toArray !== undefined) {
                            // ...assume THREE.Math-ish
                            do {
                                value = key[valuePropertyName];
                                if (value !== undefined) {
                                    times.push(key.time);
                                    value.toArray(values, values.length);
                                }
                                key = jsonKeys[i++];
                            } while (key !== undefined);
                        } else {
                            // otherwise push as-is
                            do {
                                value = key[valuePropertyName];
                                if (value !== undefined) {
                                    times.push(key.time);
                                    values.push(value);
                                }
                                key = jsonKeys[i++];
                            } while (key !== undefined);
                        }
                    },
                    subclip: function(sourceClip, name, startFrame, endFrame, fps) {
                        if (fps === void 0) {
                            fps = 30;
                        }
                        var clip = sourceClip.clone();
                        clip.name = name;
                        var tracks = [];
                        for (var i = 0; i < clip.tracks.length; ++i) {
                            var track = clip.tracks[i];
                            var valueSize = track.getValueSize();
                            var times = [];
                            var values = [];
                            for (var j = 0; j < track.times.length; ++j) {
                                var frame = track.times[j] * fps;
                                if (frame < startFrame || frame >= endFrame)
                                    continue;
                                times.push(track.times[j]);
                                for (var k = 0; k < valueSize; ++k) {
                                    values.push(track.values[j * valueSize + k]);
                                }
                            }
                            if (times.length === 0)
                                continue;
                            track.times = AnimationUtils.convertArray(times, track.times.constructor);
                            track.values = AnimationUtils.convertArray(values, track.values.constructor);
                            tracks.push(track);
                        }
                        clip.tracks = tracks;
                        // find minimum .times value across all tracks in the trimmed clip
                        var minStartTime = Infinity;
                        for (var i = 0; i < clip.tracks.length; ++i) {
                            if (minStartTime > clip.tracks[i].times[0]) {
                                minStartTime = clip.tracks[i].times[0];
                            }
                        }
                        // shift all tracks such that clip begins at t=0
                        for (var i = 0; i < clip.tracks.length; ++i) {
                            clip.tracks[i].shift(-1 * minStartTime);
                        }
                        clip.resetDuration();
                        return clip;
                    },
                    makeClipAdditive: function(targetClip, referenceFrame, referenceClip, fps) {
                        if (referenceFrame === void 0) {
                            referenceFrame = 0;
                        }
                        if (referenceClip === void 0) {
                            referenceClip = targetClip;
                        }
                        if (fps === void 0) {
                            fps = 30;
                        }
                        if (fps <= 0)
                            fps = 30;
                        var numTracks = referenceClip.tracks.length;
                        var referenceTime = referenceFrame / fps;
                        var _loop_1 = function(i) {
                            var referenceTrack = referenceClip.tracks[i];
                            var referenceTrackType = referenceTrack.ValueTypeName;
                            // Skip this track if it's non-numeric
                            if (referenceTrackType === 'bool' || referenceTrackType === 'string')
                                return "continue";
                            // Find the track in the target clip whose name and type matches the reference track
                            var targetTrack = targetClip.tracks.find(function(track) {
                                return track.name === referenceTrack.name &&
                                    track.ValueTypeName === referenceTrackType;
                            });
                            if (targetTrack === undefined)
                                return "continue";
                            var referenceOffset = 0;
                            var referenceValueSize = referenceTrack.getValueSize();
                            if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
                                referenceOffset = referenceValueSize / 3;
                            }
                            var targetOffset = 0;
                            var targetValueSize = targetTrack.getValueSize();
                            if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
                                targetOffset = targetValueSize / 3;
                            }
                            var lastIndex = referenceTrack.times.length - 1;
                            var referenceValue = void 0;
                            // Find the value to subtract out of the track
                            if (referenceTime <= referenceTrack.times[0]) {
                                // Reference frame is earlier than the first keyframe, so just use the first keyframe
                                var startIndex = referenceOffset;
                                var endIndex = referenceValueSize - referenceOffset;
                                referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
                            } else if (referenceTime >= referenceTrack.times[lastIndex]) {
                                // Reference frame is after the last keyframe, so just use the last keyframe
                                var startIndex = lastIndex * referenceValueSize + referenceOffset;
                                var endIndex = startIndex + referenceValueSize - referenceOffset;
                                referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
                            } else {
                                // Interpolate to the reference value
                                var interpolant = referenceTrack.createInterpolant();
                                var startIndex = referenceOffset;
                                var endIndex = referenceValueSize - referenceOffset;
                                interpolant.evaluate(referenceTime);
                                referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
                            }
                            // Conjugate the quaternion
                            if (referenceTrackType === 'quaternion') {
                                var referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
                                referenceQuat.toArray(referenceValue);
                            }
                            // Subtract the reference value from all of the track values
                            var numTimes = targetTrack.times.length;
                            for (var j = 0; j < numTimes; ++j) {
                                var valueStart = j * targetValueSize + targetOffset;
                                if (referenceTrackType === 'quaternion') {
                                    // Multiply the conjugate for quaternion track types
                                    Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
                                } else {
                                    var valueEnd = targetValueSize - targetOffset * 2;
                                    // Subtract each value for all other numeric track types
                                    for (var k = 0; k < valueEnd; ++k) {
                                        targetTrack.values[valueStart + k] -= referenceValue[k];
                                    }
                                }
                            }
                        };
                        // Make each track's values relative to the values at the reference frame
                        for (var i = 0; i < numTracks; ++i) {
                            _loop_1(i);
                        }
                        targetClip.blendMode = AdditiveAnimationBlendMode;
                        return targetClip;
                    }
                };
                /**
                 * Abstract base class of interpolants over parametric samples.
                 *
                 * The parameter domain is one dimensional, typically the time or a path
                 * along a curve defined by the data.
                 *
                 * The sample values can have any dimensionality and derived classes may
                 * apply special interpretations to the data.
                 *
                 * This class provides the interval seek in a Template Method, deferring
                 * the actual interpolation to derived classes.
                 *
                 * Time complexity is O(1) for linear access crossing at most two points
                 * and O(log N) for random access, where N is the number of positions.
                 *
                 * References:
                 *
                 * 		http://www.oodesign.com/template-method-pattern.html
                 *
                 */
                var Interpolant = /** @class */ (function() {
                    function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                        this.parameterPositions = parameterPositions;
                        this._cachedIndex = 0;
                        this.resultBuffer = resultBuffer !== undefined ?
                            resultBuffer : new sampleValues.constructor(sampleSize);
                        this.sampleValues = sampleValues;
                        this.valueSize = sampleSize;
                        this.settings = null;
                        this.DefaultSettings_ = {};
                    }
                    Interpolant.prototype.evaluate = function(t) {
                        var pp = this.parameterPositions;
                        var i1 = this._cachedIndex,
                            t1 = pp[i1],
                            t0 = pp[i1 - 1];
                        validate_interval: {
                            seek: {
                                var right = void 0;
                                linear_scan: {
                                    //- See http://jsperf.com/comparison-to-undefined/3
                                    //- slower code:
                                    //-
                                    //- 				if ( t >= t1 || t1 === undefined ) {
                                    forward_scan: if (!(t < t1)) {
                                        for (var giveUpAt = i1 + 2;;) {
                                            if (t1 === undefined) {
                                                if (t < t0)
                                                    break forward_scan;
                                                // after end
                                                i1 = pp.length;
                                                this._cachedIndex = i1;
                                                return this.afterEnd_(i1 - 1, t, t0);
                                            }
                                            if (i1 === giveUpAt)
                                                break; // this loop
                                            t0 = t1;
                                            t1 = pp[++i1];
                                            if (t < t1) {
                                                // we have arrived at the sought interval
                                                break seek;
                                            }
                                        }
                                        // prepare binary search on the right side of the index
                                        right = pp.length;
                                        break linear_scan;
                                    }
                                    //- slower code:
                                    //-					if ( t < t0 || t0 === undefined ) {
                                    if (!(t >= t0)) {
                                        // looping?
                                        var t1global = pp[1];
                                        if (t < t1global) {
                                            i1 = 2; // + 1, using the scan for the details
                                            t0 = t1global;
                                        }
                                        // linear reverse scan
                                        for (var giveUpAt = i1 - 2;;) {
                                            if (t0 === undefined) {
                                                // before start
                                                this._cachedIndex = 0;
                                                return this.beforeStart_(0, t, t1);
                                            }
                                            if (i1 === giveUpAt)
                                                break; // this loop
                                            t1 = t0;
                                            t0 = pp[--i1 - 1];
                                            if (t >= t0) {
                                                // we have arrived at the sought interval
                                                break seek;
                                            }
                                        }
                                        // prepare binary search on the left side of the index
                                        right = i1;
                                        i1 = 0;
                                        break linear_scan;
                                    }
                                    // the interval is valid
                                    break validate_interval;
                                } // linear scan
                                // binary search
                                while (i1 < right) {
                                    var mid = (i1 + right) >>> 1;
                                    if (t < pp[mid]) {
                                        right = mid;
                                    } else {
                                        i1 = mid + 1;
                                    }
                                }
                                t1 = pp[i1];
                                t0 = pp[i1 - 1];
                                // check boundary cases, again
                                if (t0 === undefined) {
                                    this._cachedIndex = 0;
                                    return this.beforeStart_(0, t, t1);
                                }
                                if (t1 === undefined) {
                                    i1 = pp.length;
                                    this._cachedIndex = i1;
                                    return this.afterEnd_(i1 - 1, t0, t);
                                }
                            } // seek
                            this._cachedIndex = i1;
                            this.intervalChanged_(i1, t0, t1);
                        } // validate_interval
                        return this.interpolate_(i1, t0, t, t1);
                    };
                    Interpolant.prototype.getSettings_ = function() {
                        return this.settings || this.DefaultSettings_;
                    };
                    Interpolant.prototype.copySampleValue_ = function(index) {
                        // copies a sample value to the result buffer
                        var result = this.resultBuffer,
                            values = this.sampleValues,
                            stride = this.valueSize,
                            offset = index * stride;
                        for (var i = 0; i !== stride; ++i) {
                            result[i] = values[offset + i];
                        }
                        return result;
                    };
                    // Template methods for derived classes:
                    Interpolant.prototype.interpolate_ = function( /* i1, t0, t, t1 */ ) {
                        throw new Error('call to abstract method');
                        // implementations shall return this.resultBuffer
                    };
                    Interpolant.prototype.intervalChanged_ = function( /* i1, t0, t1 */ ) {
                        // empty
                    };
                    return Interpolant;
                }());
                // ALIAS DEFINITIONS
                Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
                Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
                /**
                 * Fast and simple cubic spline interpolant.
                 *
                 * It was derived from a Hermitian construction setting the first derivative
                 * at each sample position to the linear slope between neighboring positions
                 * over their parameter interval.
                 */
                var CubicInterpolant = /** @class */ (function(_super) {
                    __extends(CubicInterpolant, _super);

                    function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                        var _this_1 = _super.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer) || this;
                        _this_1._weightPrev = -0;
                        _this_1._offsetPrev = -0;
                        _this_1._weightNext = -0;
                        _this_1._offsetNext = -0;
                        _this_1.DefaultSettings_ = {
                            endingStart: ZeroCurvatureEnding,
                            endingEnd: ZeroCurvatureEnding
                        };
                        return _this_1;
                    }
                    CubicInterpolant.prototype.intervalChanged_ = function(i1, t0, t1) {
                        var pp = this.parameterPositions;
                        var iPrev = i1 - 2,
                            iNext = i1 + 1,
                            tPrev = pp[iPrev],
                            tNext = pp[iNext];
                        if (tPrev === undefined) {
                            switch (this.getSettings_().endingStart) {
                                case ZeroSlopeEnding:
                                    // f'(t0) = 0
                                    iPrev = i1;
                                    tPrev = 2 * t0 - t1;
                                    break;
                                case WrapAroundEnding:
                                    // use the other end of the curve
                                    iPrev = pp.length - 2;
                                    tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                                    break;
                                default: // ZeroCurvatureEnding
                                    // f''(t0) = 0 a.k.a. Natural Spline
                                    iPrev = i1;
                                    tPrev = t1;
                            }
                        }
                        if (tNext === undefined) {
                            switch (this.getSettings_().endingEnd) {
                                case ZeroSlopeEnding:
                                    // f'(tN) = 0
                                    iNext = i1;
                                    tNext = 2 * t1 - t0;
                                    break;
                                case WrapAroundEnding:
                                    // use the other end of the curve
                                    iNext = 1;
                                    tNext = t1 + pp[1] - pp[0];
                                    break;
                                default: // ZeroCurvatureEnding
                                    // f''(tN) = 0, a.k.a. Natural Spline
                                    iNext = i1 - 1;
                                    tNext = t0;
                            }
                        }
                        var halfDt = (t1 - t0) * 0.5,
                            stride = this.valueSize;
                        this._weightPrev = halfDt / (t0 - tPrev);
                        this._weightNext = halfDt / (tNext - t1);
                        this._offsetPrev = iPrev * stride;
                        this._offsetNext = iNext * stride;
                    };
                    CubicInterpolant.prototype.interpolate_ = function(i1, t0, t, t1) {
                        var result = this.resultBuffer,
                            values = this.sampleValues,
                            stride = this.valueSize,
                            o1 = i1 * stride,
                            o0 = o1 - stride,
                            oP = this._offsetPrev,
                            oN = this._offsetNext,
                            wP = this._weightPrev,
                            wN = this._weightNext,
                            p = (t - t0) / (t1 - t0),
                            pp = p * p,
                            ppp = pp * p;
                        // evaluate polynomials
                        var sP = -wP * ppp + 2 * wP * pp - wP * p;
                        var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
                        var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
                        var sN = wN * ppp - wN * pp;
                        // combine data linearly
                        for (var i = 0; i !== stride; ++i) {
                            result[i] =
                                sP * values[oP + i] +
                                s0 * values[o0 + i] +
                                s1 * values[o1 + i] +
                                sN * values[oN + i];
                        }
                        return result;
                    };
                    return CubicInterpolant;
                }(Interpolant));
                var LinearInterpolant = /** @class */ (function(_super) {
                    __extends(LinearInterpolant, _super);

                    function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                        return _super.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer) || this;
                    }
                    LinearInterpolant.prototype.interpolate_ = function(i1, t0, t, t1) {
                        var result = this.resultBuffer,
                            values = this.sampleValues,
                            stride = this.valueSize,
                            offset1 = i1 * stride,
                            offset0 = offset1 - stride,
                            weight1 = (t - t0) / (t1 - t0),
                            weight0 = 1 - weight1;
                        for (var i = 0; i !== stride; ++i) {
                            result[i] =
                                values[offset0 + i] * weight0 +
                                values[offset1 + i] * weight1;
                        }
                        return result;
                    };
                    return LinearInterpolant;
                }(Interpolant));
                /**
                 *
                 * Interpolant that evaluates to the sample value at the position preceding
                 * the parameter.
                 */
                var DiscreteInterpolant = /** @class */ (function(_super) {
                    __extends(DiscreteInterpolant, _super);

                    function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                        return _super.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer) || this;
                    }
                    DiscreteInterpolant.prototype.interpolate_ = function(i1 /*, t0, t, t1 */ ) {
                        return this.copySampleValue_(i1 - 1);
                    };
                    return DiscreteInterpolant;
                }(Interpolant));
                var KeyframeTrack = /** @class */ (function() {
                    function KeyframeTrack(name, times, values, interpolation) {
                        if (name === undefined)
                            throw new Error('THREE.KeyframeTrack: track name is undefined');
                        if (times === undefined || times.length === 0)
                            throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
                        this.name = name;
                        this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
                        this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
                        this.setInterpolation(interpolation || this.DefaultInterpolation);
                    }
                    // Serialization (in static context, because of constructor invocation
                    // and automatic invocation of .toJSON):
                    KeyframeTrack.toJSON = function(track) {
                        var trackType = track.constructor;
                        var json;
                        // derived classes can define a static toJSON method
                        if (trackType.toJSON !== this.toJSON) {
                            json = trackType.toJSON(track);
                        } else {
                            // by default, we assume the data can be serialized as-is
                            json = {
                                'name': track.name,
                                'times': AnimationUtils.convertArray(track.times, Array),
                                'values': AnimationUtils.convertArray(track.values, Array)
                            };
                            var interpolation = track.getInterpolation();
                            if (interpolation !== track.DefaultInterpolation) {
                                json.interpolation = interpolation;
                            }
                        }
                        json.type = track.ValueTypeName; // mandatory
                        return json;
                    };
                    KeyframeTrack.prototype.InterpolantFactoryMethodDiscrete = function(result) {
                        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
                    };
                    KeyframeTrack.prototype.InterpolantFactoryMethodLinear = function(result) {
                        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
                    };
                    KeyframeTrack.prototype.InterpolantFactoryMethodSmooth = function(result) {
                        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
                    };
                    KeyframeTrack.prototype.setInterpolation = function(interpolation) {
                        var factoryMethod;
                        switch (interpolation) {
                            case InterpolateDiscrete:
                                factoryMethod = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case InterpolateLinear:
                                factoryMethod = this.InterpolantFactoryMethodLinear;
                                break;
                            case InterpolateSmooth:
                                factoryMethod = this.InterpolantFactoryMethodSmooth;
                                break;
                        }
                        if (factoryMethod === undefined) {
                            var message = 'unsupported interpolation for ' +
                                this.ValueTypeName + ' keyframe track named ' + this.name;
                            if (this.createInterpolant === undefined) {
                                // fall back to default, unless the default itself is messed up
                                if (interpolation !== this.DefaultInterpolation) {
                                    this.setInterpolation(this.DefaultInterpolation);
                                } else {
                                    throw new Error(message); // fatal, in this case
                                }
                            }
                            console.warn('THREE.KeyframeTrack:', message);
                            return this;
                        }
                        this.createInterpolant = factoryMethod;
                        return this;
                    };
                    KeyframeTrack.prototype.getInterpolation = function() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return InterpolateDiscrete;
                            case this.InterpolantFactoryMethodLinear:
                                return InterpolateLinear;
                            case this.InterpolantFactoryMethodSmooth:
                                return InterpolateSmooth;
                        }
                    };
                    KeyframeTrack.prototype.getValueSize = function() {
                        return this.values.length / this.times.length;
                    };
                    // move all keyframes either forwards or backwards in time
                    KeyframeTrack.prototype.shift = function(timeOffset) {
                        if (timeOffset !== 0.0) {
                            var times = this.times;
                            for (var i = 0, n = times.length; i !== n; ++i) {
                                times[i] += timeOffset;
                            }
                        }
                        return this;
                    };
                    // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
                    KeyframeTrack.prototype.scale = function(timeScale) {
                        if (timeScale !== 1.0) {
                            var times = this.times;
                            for (var i = 0, n = times.length; i !== n; ++i) {
                                times[i] *= timeScale;
                            }
                        }
                        return this;
                    };
                    // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
                    // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
                    KeyframeTrack.prototype.trim = function(startTime, endTime) {
                        var times = this.times,
                            nKeys = times.length;
                        var from = 0,
                            to = nKeys - 1;
                        while (from !== nKeys && times[from] < startTime) {
                            ++from;
                        }
                        while (to !== -1 && times[to] > endTime) {
                            --to;
                        }
                        ++to; // inclusive -> exclusive bound
                        if (from !== 0 || to !== nKeys) {
                            // empty tracks are forbidden, so keep at least one keyframe
                            if (from >= to) {
                                to = Math.max(to, 1);
                                from = to - 1;
                            }
                            var stride = this.getValueSize();
                            this.times = AnimationUtils.arraySlice(times, from, to);
                            this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
                        }
                        return this;
                    };
                    // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
                    KeyframeTrack.prototype.validate = function() {
                        var valid = true;
                        var valueSize = this.getValueSize();
                        if (valueSize - Math.floor(valueSize) !== 0) {
                            console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
                            valid = false;
                        }
                        var times = this.times,
                            values = this.values,
                            nKeys = times.length;
                        if (nKeys === 0) {
                            console.error('THREE.KeyframeTrack: Track is empty.', this);
                            valid = false;
                        }
                        var prevTime = null;
                        for (var i = 0; i !== nKeys; i++) {
                            var currTime = times[i];
                            if (typeof currTime === 'number' && isNaN(currTime)) {
                                console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
                                valid = false;
                                break;
                            }
                            if (prevTime !== null && prevTime > currTime) {
                                console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
                                valid = false;
                                break;
                            }
                            prevTime = currTime;
                        }
                        if (values !== undefined) {
                            if (AnimationUtils.isTypedArray(values)) {
                                for (var i = 0, n = values.length; i !== n; ++i) {
                                    var value = values[i];
                                    if (isNaN(value)) {
                                        console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
                                        valid = false;
                                        break;
                                    }
                                }
                            }
                        }
                        return valid;
                    };
                    // removes equivalent sequential keys as common in morph target sequences
                    // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
                    KeyframeTrack.prototype.optimize = function() {
                        // times or values may be shared with other tracks, so overwriting is unsafe
                        var times = AnimationUtils.arraySlice(this.times),
                            values = AnimationUtils.arraySlice(this.values),
                            stride = this.getValueSize(),
                            smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
                            lastIndex = times.length - 1;
                        var writeIndex = 1;
                        for (var i = 1; i < lastIndex; ++i) {
                            var keep = false;
                            var time = times[i];
                            var timeNext = times[i + 1];
                            // remove adjacent keyframes scheduled at the same time
                            if (time !== timeNext && (i !== 1 || time !== times[0])) {
                                if (!smoothInterpolation) {
                                    // remove unnecessary keyframes same as their neighbors
                                    var offset = i * stride,
                                        offsetP = offset - stride,
                                        offsetN = offset + stride;
                                    for (var j = 0; j !== stride; ++j) {
                                        var value = values[offset + j];
                                        if (value !== values[offsetP + j] ||
                                            value !== values[offsetN + j]) {
                                            keep = true;
                                            break;
                                        }
                                    }
                                } else {
                                    keep = true;
                                }
                            }
                            // in-place compaction
                            if (keep) {
                                if (i !== writeIndex) {
                                    times[writeIndex] = times[i];
                                    var readOffset = i * stride,
                                        writeOffset = writeIndex * stride;
                                    for (var j = 0; j !== stride; ++j) {
                                        values[writeOffset + j] = values[readOffset + j];
                                    }
                                }
                                ++writeIndex;
                            }
                        }
                        // flush last keyframe (compaction looks ahead)
                        if (lastIndex > 0) {
                            times[writeIndex] = times[lastIndex];
                            for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
                                values[writeOffset + j] = values[readOffset + j];
                            }
                            ++writeIndex;
                        }
                        if (writeIndex !== times.length) {
                            this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
                            this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
                        } else {
                            this.times = times;
                            this.values = values;
                        }
                        return this;
                    };
                    KeyframeTrack.prototype.clone = function() {
                        var times = AnimationUtils.arraySlice(this.times, 0);
                        var values = AnimationUtils.arraySlice(this.values, 0);
                        var TypedKeyframeTrack = this.constructor;
                        var track = new TypedKeyframeTrack(this.name, times, values);
                        // Interpolant argument to constructor is not saved, so copy the factory method directly.
                        track.createInterpolant = this.createInterpolant;
                        return track;
                    };
                    return KeyframeTrack;
                }());
                KeyframeTrack.prototype.TimeBufferType = Float32Array;
                KeyframeTrack.prototype.ValueBufferType = Float32Array;
                KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
                /**
                 * A Track of Boolean keyframe values.
                 */
                var BooleanKeyframeTrack = /** @class */ (function(_super) {
                    __extends(BooleanKeyframeTrack, _super);

                    function BooleanKeyframeTrack() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    return BooleanKeyframeTrack;
                }(KeyframeTrack));
                BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
                BooleanKeyframeTrack.prototype.ValueBufferType = Array;
                BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
                BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
                BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
                /**
                 * A Track of keyframe values that represent color.
                 */
                var ColorKeyframeTrack = /** @class */ (function(_super) {
                    __extends(ColorKeyframeTrack, _super);

                    function ColorKeyframeTrack() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    return ColorKeyframeTrack;
                }(KeyframeTrack));
                ColorKeyframeTrack.prototype.ValueTypeName = 'color';
                /**
                 * A Track of numeric keyframe values.
                 */
                var NumberKeyframeTrack = /** @class */ (function(_super) {
                    __extends(NumberKeyframeTrack, _super);

                    function NumberKeyframeTrack() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    return NumberKeyframeTrack;
                }(KeyframeTrack));
                NumberKeyframeTrack.prototype.ValueTypeName = 'number';
                /**
                 * Spherical linear unit quaternion interpolant.
                 */
                var QuaternionLinearInterpolant = /** @class */ (function(_super) {
                    __extends(QuaternionLinearInterpolant, _super);

                    function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                        return _super.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer) || this;
                    }
                    QuaternionLinearInterpolant.prototype.interpolate_ = function(i1, t0, t, t1) {
                        var result = this.resultBuffer,
                            values = this.sampleValues,
                            stride = this.valueSize,
                            alpha = (t - t0) / (t1 - t0);
                        var offset = i1 * stride;
                        for (var end = offset + stride; offset !== end; offset += 4) {
                            Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
                        }
                        return result;
                    };
                    return QuaternionLinearInterpolant;
                }(Interpolant));
                /**
                 * A Track of quaternion keyframe values.
                 */
                var QuaternionKeyframeTrack = /** @class */ (function(_super) {
                    __extends(QuaternionKeyframeTrack, _super);

                    function QuaternionKeyframeTrack() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodLinear = function(result) {
                        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
                    };
                    return QuaternionKeyframeTrack;
                }(KeyframeTrack));
                QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
                // ValueBufferType is inherited
                QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
                QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
                /**
                 * A Track that interpolates Strings
                 */
                var StringKeyframeTrack = /** @class */ (function(_super) {
                    __extends(StringKeyframeTrack, _super);

                    function StringKeyframeTrack() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    return StringKeyframeTrack;
                }(KeyframeTrack));
                StringKeyframeTrack.prototype.ValueTypeName = 'string';
                StringKeyframeTrack.prototype.ValueBufferType = Array;
                StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
                StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
                StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
                /**
                 * A Track of vectored keyframe values.
                 */
                var VectorKeyframeTrack = /** @class */ (function(_super) {
                    __extends(VectorKeyframeTrack, _super);

                    function VectorKeyframeTrack() {
                        return _super !== null && _super.apply(this, arguments) || this;
                    }
                    return VectorKeyframeTrack;
                }(KeyframeTrack));
                VectorKeyframeTrack.prototype.ValueTypeName = 'vector';
                var AnimationClip = /** @class */ (function() {
                    function AnimationClip(name, duration, tracks, blendMode) {
                        if (duration === void 0) {
                            duration = -1;
                        }
                        if (blendMode === void 0) {
                            blendMode = NormalAnimationBlendMode;
                        }
                        this.name = name;
                        this.tracks = tracks;
                        this.duration = duration;
                        this.blendMode = blendMode;
                        this.uuid = generateUUID();
                        // this means it should figure out its duration by scanning the tracks
                        if (this.duration < 0) {
                            this.resetDuration();
                        }
                    }
                    AnimationClip.parse = function(json) {
                        var tracks = [],
                            jsonTracks = json.tracks,
                            frameTime = 1.0 / (json.fps || 1.0);
                        for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
                            tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
                        }
                        var clip = new this(json.name, json.duration, tracks, json.blendMode);
                        clip.uuid = json.uuid;
                        return clip;
                    };
                    AnimationClip.toJSON = function(clip) {
                        var tracks = [],
                            clipTracks = clip.tracks;
                        var json = {
                            'name': clip.name,
                            'duration': clip.duration,
                            'tracks': tracks,
                            'uuid': clip.uuid,
                            'blendMode': clip.blendMode
                        };
                        for (var i = 0, n = clipTracks.length; i !== n; ++i) {
                            tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
                        }
                        return json;
                    };
                    AnimationClip.CreateFromMorphTargetSequence = function(name, morphTargetSequence, fps, noLoop) {
                        var numMorphTargets = morphTargetSequence.length;
                        var tracks = [];
                        for (var i = 0; i < numMorphTargets; i++) {
                            var times = [];
                            var values = [];
                            times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
                            values.push(0, 1, 0);
                            var order = AnimationUtils.getKeyframeOrder(times);
                            times = AnimationUtils.sortedArray(times, 1, order);
                            values = AnimationUtils.sortedArray(values, 1, order);
                            // if there is a key at the first frame, duplicate it as the
                            // last frame as well for perfect loop.
                            if (!noLoop && times[0] === 0) {
                                times.push(numMorphTargets);
                                values.push(values[0]);
                            }
                            tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
                        }
                        return new this(name, -1, tracks);
                    };
                    AnimationClip.findByName = function(objectOrClipArray, name) {
                        var clipArray = objectOrClipArray;
                        if (!Array.isArray(objectOrClipArray)) {
                            var o = objectOrClipArray;
                            clipArray = o.geometry && o.geometry.animations || o.animations;
                        }
                        for (var i = 0; i < clipArray.length; i++) {
                            if (clipArray[i].name === name) {
                                return clipArray[i];
                            }
                        }
                        return null;
                    };
                    AnimationClip.CreateClipsFromMorphTargetSequences = function(morphTargets, fps, noLoop) {
                        var animationToMorphTargets = {};
                        // tested with https://regex101.com/ on trick sequences
                        // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
                        var pattern = /^([\w-]*?)([\d]+)$/;
                        // sort morph target names into animation groups based
                        // patterns like Walk_001, Walk_002, Run_001, Run_002
                        for (var i = 0, il = morphTargets.length; i < il; i++) {
                            var morphTarget = morphTargets[i];
                            var parts = morphTarget.name.match(pattern);
                            if (parts && parts.length > 1) {
                                var name = parts[1];
                                var animationMorphTargets = animationToMorphTargets[name];
                                if (!animationMorphTargets) {
                                    animationToMorphTargets[name] = animationMorphTargets = [];
                                }
                                animationMorphTargets.push(morphTarget);
                            }
                        }
                        var clips = [];
                        for (var name in animationToMorphTargets) {
                            clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
                        }
                        return clips;
                    };
                    // parse the animation.hierarchy format
                    AnimationClip.parseAnimation = function(animation, bones) {
                        if (!animation) {
                            console.error('THREE.AnimationClip: No animation in JSONLoader data.');
                            return null;
                        }
                        var addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
                            // only return track if there are actually keys.
                            if (animationKeys.length !== 0) {
                                var times = [];
                                var values = [];
                                AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
                                // empty keys are filtered out, so check again
                                if (times.length !== 0) {
                                    destTracks.push(new trackType(trackName, times, values));
                                }
                            }
                        };
                        var tracks = [];
                        var clipName = animation.name || 'default';
                        var fps = animation.fps || 30;
                        var blendMode = animation.blendMode;
                        // automatic length determination in AnimationClip.
                        var duration = animation.length || -1;
                        var hierarchyTracks = animation.hierarchy || [];
                        for (var h = 0; h < hierarchyTracks.length; h++) {
                            var animationKeys = hierarchyTracks[h].keys;
                            // skip empty tracks
                            if (!animationKeys || animationKeys.length === 0)
                                continue;
                            // process morph targets
                            if (animationKeys[0].morphTargets) {
                                // figure out all morph targets used in this track
                                var morphTargetNames = {};
                                var k = void 0;
                                for (k = 0; k < animationKeys.length; k++) {
                                    if (animationKeys[k].morphTargets) {
                                        for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                                            morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                                        }
                                    }
                                }
                                // create a track for each morph target with all zero
                                // morphTargetInfluences except for the keys in which
                                // the morphTarget is named.
                                for (var morphTargetName in morphTargetNames) {
                                    var times = [];
                                    var values = [];
                                    for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                                        var animationKey = animationKeys[k];
                                        times.push(animationKey.time);
                                        values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0);
                                    }
                                    tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
                                }
                                duration = morphTargetNames.length * fps;
                            } else {
                                // ...assume skeletal animation
                                var boneName = '.bones[' + bones[h].name + ']';
                                addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
                                addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
                                addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
                            }
                        }
                        if (tracks.length === 0) {
                            return null;
                        }
                        var clip = new this(clipName, duration, tracks, blendMode);
                        return clip;
                    };
                    AnimationClip.prototype.resetDuration = function() {
                        var tracks = this.tracks;
                        var duration = 0;
                        for (var i = 0, n = tracks.length; i !== n; ++i) {
                            var track = this.tracks[i];
                            duration = Math.max(duration, track.times[track.times.length - 1]);
                        }
                        this.duration = duration;
                        return this;
                    };
                    AnimationClip.prototype.trim = function() {
                        for (var i = 0; i < this.tracks.length; i++) {
                            this.tracks[i].trim(0, this.duration);
                        }
                        return this;
                    };
                    AnimationClip.prototype.validate = function() {
                        var valid = true;
                        for (var i = 0; i < this.tracks.length; i++) {
                            valid = valid && this.tracks[i].validate();
                        }
                        return valid;
                    };
                    AnimationClip.prototype.optimize = function() {
                        for (var i = 0; i < this.tracks.length; i++) {
                            this.tracks[i].optimize();
                        }
                        return this;
                    };
                    AnimationClip.prototype.clone = function() {
                        var tracks = [];
                        for (var i = 0; i < this.tracks.length; i++) {
                            tracks.push(this.tracks[i].clone());
                        }
                        return new this.constructor(this.name, this.duration, tracks, this.blendMode);
                    };
                    AnimationClip.prototype.toJSON = function() {
                        return this.constructor.toJSON(this);
                    };
                    return AnimationClip;
                }());

                function getTrackTypeForValueTypeName(typeName) {
                    switch (typeName.toLowerCase()) {
                        case 'scalar':
                        case 'double':
                        case 'float':
                        case 'number':
                        case 'integer':
                            return NumberKeyframeTrack;
                        case 'vector':
                        case 'vector2':
                        case 'vector3':
                        case 'vector4':
                            return VectorKeyframeTrack;
                        case 'color':
                            return ColorKeyframeTrack;
                        case 'quaternion':
                            return QuaternionKeyframeTrack;
                        case 'bool':
                        case 'boolean':
                            return BooleanKeyframeTrack;
                        case 'string':
                            return StringKeyframeTrack;
                    }
                    throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
                }

                function parseKeyframeTrack(json) {
                    if (json.type === undefined) {
                        throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
                    }
                    var trackType = getTrackTypeForValueTypeName(json.type);
                    if (json.times === undefined) {
                        var times = [],
                            values = [];
                        AnimationUtils.flattenJSON(json.keys, times, values, 'value');
                        json.times = times;
                        json.values = values;
                    }
                    // derived classes can define a static parse method
                    if (trackType.parse !== undefined) {
                        return trackType.parse(json);
                    } else {
                        // by default, we assume a constructor compatible with the base
                        return new trackType(json.name, json.times, json.values, json.interpolation);
                    }
                }
                var Cache = {
                    enabled: false,
                    files: {},
                    add: function(key, file) {
                        if (this.enabled === false)
                            return;
                        // console.log( 'THREE.Cache', 'Adding key:', key );
                        this.files[key] = file;
                    },
                    get: function(key) {
                        if (this.enabled === false)
                            return;
                        // console.log( 'THREE.Cache', 'Checking key:', key );
                        return this.files[key];
                    },
                    remove: function(key) {
                        delete this.files[key];
                    },
                    clear: function() {
                        this.files = {};
                    }
                };
                var LoadingManager = /** @class */ (function() {
                    function LoadingManager(onLoad, onProgress, onError) {
                        var scope = this;
                        var isLoading = false;
                        var itemsLoaded = 0;
                        var itemsTotal = 0;
                        var urlModifier = undefined;
                        var handlers = [];
                        // Refer to #5689 for the reason why we don't set .onStart
                        // in the constructor
                        this.onStart = undefined;
                        this.onLoad = onLoad;
                        this.onProgress = onProgress;
                        this.onError = onError;
                        this.itemStart = function(url) {
                            itemsTotal++;
                            if (isLoading === false) {
                                if (scope.onStart !== undefined) {
                                    scope.onStart(url, itemsLoaded, itemsTotal);
                                }
                            }
                            isLoading = true;
                        };
                        this.itemEnd = function(url) {
                            itemsLoaded++;
                            if (scope.onProgress !== undefined) {
                                scope.onProgress(url, itemsLoaded, itemsTotal);
                            }
                            if (itemsLoaded === itemsTotal) {
                                isLoading = false;
                                if (scope.onLoad !== undefined) {
                                    scope.onLoad();
                                }
                            }
                        };
                        this.itemError = function(url) {
                            if (scope.onError !== undefined) {
                                scope.onError(url);
                            }
                        };
                        this.resolveURL = function(url) {
                            if (urlModifier) {
                                return urlModifier(url);
                            }
                            return url;
                        };
                        this.setURLModifier = function(transform) {
                            urlModifier = transform;
                            return this;
                        };
                        this.addHandler = function(regex, loader) {
                            handlers.push(regex, loader);
                            return this;
                        };
                        this.removeHandler = function(regex) {
                            var index = handlers.indexOf(regex);
                            if (index !== -1) {
                                handlers.splice(index, 2);
                            }
                            return this;
                        };
                        this.getHandler = function(file) {
                            for (var i = 0, l = handlers.length; i < l; i += 2) {
                                var regex = handlers[i];
                                var loader = handlers[i + 1];
                                if (regex.global)
                                    regex.lastIndex = 0; // see #17920
                                if (regex.test(file)) {
                                    return loader;
                                }
                            }
                            return null;
                        };
                    }
                    return LoadingManager;
                }());
                var DefaultLoadingManager = new LoadingManager();
                var Loader = /** @class */ (function() {
                    function Loader(manager) {
                        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
                        this.crossOrigin = 'anonymous';
                        this.withCredentials = false;
                        this.path = '';
                        this.resourcePath = '';
                        this.requestHeader = {};
                    }
                    Loader.prototype.load = function( /* url, onLoad, onProgress, onError */ ) {};
                    Loader.prototype.loadAsync = function(url, onProgress) {
                        var scope = this;
                        return new Promise(function(resolve, reject) {
                            scope.load(url, resolve, onProgress, reject);
                        });
                    };
                    Loader.prototype.parse = function( /* data */ ) {};
                    Loader.prototype.setCrossOrigin = function(crossOrigin) {
                        this.crossOrigin = crossOrigin;
                        return this;
                    };
                    Loader.prototype.setWithCredentials = function(value) {
                        this.withCredentials = value;
                        return this;
                    };
                    Loader.prototype.setPath = function(path) {
                        this.path = path;
                        return this;
                    };
                    Loader.prototype.setResourcePath = function(resourcePath) {
                        this.resourcePath = resourcePath;
                        return this;
                    };
                    Loader.prototype.setRequestHeader = function(requestHeader) {
                        this.requestHeader = requestHeader;
                        return this;
                    };
                    return Loader;
                }());
                var loading = {};
                var FileLoader = /** @class */ (function(_super) {
                    __extends(FileLoader, _super);

                    function FileLoader(manager) {
                        return _super.call(this, manager) || this;
                    }
                    FileLoader.prototype.load = function(url, onLoad, onProgress, onError) {
                        var _this_1 = this;
                        if (url === undefined)
                            url = '';
                        if (this.path !== undefined)
                            url = this.path + url;
                        url = this.manager.resolveURL(url);
                        var cached = Cache.get(url);
                        if (cached !== undefined) {
                            this.manager.itemStart(url);
                            setTimeout(function() {
                                if (onLoad)
                                    onLoad(cached);
                                _this_1.manager.itemEnd(url);
                            }, 0);
                            return cached;
                        }
                        // Check if request is duplicate
                        if (loading[url] !== undefined) {
                            loading[url].push({
                                onLoad: onLoad,
                                onProgress: onProgress,
                                onError: onError
                            });
                            return;
                        }
                        // Initialise array for duplicate requests
                        loading[url] = [];
                        loading[url].push({
                            onLoad: onLoad,
                            onProgress: onProgress,
                            onError: onError,
                        });
                        // create request
                        var req = new Request(url, {
                            headers: new Headers(this.requestHeader),
                            credentials: this.withCredentials ? 'include' : 'same-origin',
                            // An abort controller could be added within a future PR
                        });
                        // record states ( avoid data race )
                        var mimeType = this.mimeType;
                        var responseType = this.responseType;
                        // start the fetch
                        fetch(req)
                            .then(function(response) {
                                if (response.status === 200 || response.status === 0) {
                                    // Some browsers return HTTP Status 0 when using non-http protocol
                                    // e.g. 'file://' or 'data://'. Handle as success.
                                    if (response.status === 0) {
                                        console.warn('THREE.FileLoader: HTTP Status 0 received.');
                                    }
                                    // Workaround: Checking if response.body === undefined for Alipay browser #23548
                                    if (typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined) {
                                        return response;
                                    }
                                    var callbacks_1 = loading[url];
                                    var reader_1 = response.body.getReader();
                                    var contentLength = response.headers.get('Content-Length');
                                    var total_1 = contentLength ? parseInt(contentLength) : 0;
                                    var lengthComputable_1 = total_1 !== 0;
                                    var loaded_1 = 0;
                                    // periodically read data into the new stream tracking while download progress
                                    var stream = new ReadableStream({
                                        start: function(controller) {
                                            readData();

                                            function readData() {
                                                reader_1.read().then(function(_a) {
                                                    var done = _a.done,
                                                        value = _a.value;
                                                    if (done) {
                                                        controller.close();
                                                    } else {
                                                        loaded_1 += value.byteLength;
                                                        var event = new ProgressEvent('progress', {
                                                            lengthComputable: lengthComputable_1,
                                                            loaded: loaded_1,
                                                            total: total_1
                                                        });
                                                        for (var i = 0, il = callbacks_1.length; i < il; i++) {
                                                            var callback = callbacks_1[i];
                                                            if (callback.onProgress)
                                                                callback.onProgress(event);
                                                        }
                                                        controller.enqueue(value);
                                                        readData();
                                                    }
                                                });
                                            }
                                        }
                                    });
                                    return new Response(stream);
                                } else {
                                    throw Error("fetch for \"".concat(response.url, "\" responded with ").concat(response.status, ": ").concat(response.statusText));
                                }
                            })
                            .then(function(response) {
                                switch (responseType) {
                                    case 'arraybuffer':
                                        return response.arrayBuffer();
                                    case 'blob':
                                        return response.blob();
                                    case 'document':
                                        return response.text()
                                            .then(function(text) {
                                                var parser = new DOMParser();
                                                return parser.parseFromString(text, mimeType);
                                            });
                                    case 'json':
                                        return response.json();
                                    default:
                                        if (mimeType === undefined) {
                                            return response.text();
                                        } else {
                                            // sniff encoding
                                            var re = /charset="?([^;"\s]*)"?/i;
                                            var exec = re.exec(mimeType);
                                            var label = exec && exec[1] ? exec[1].toLowerCase() : undefined;
                                            var decoder_1 = new TextDecoder(label);
                                            return response.arrayBuffer().then(function(ab) {
                                                return decoder_1.decode(ab);
                                            });
                                        }
                                }
                            })
                            .then(function(data) {
                                // Add to cache only on HTTP success, so that we do not cache
                                // error response bodies as proper responses to requests.
                                Cache.add(url, data);
                                var callbacks = loading[url];
                                delete loading[url];
                                for (var i = 0, il = callbacks.length; i < il; i++) {
                                    var callback = callbacks[i];
                                    if (callback.onLoad)
                                        callback.onLoad(data);
                                }
                            })
                            .catch(function(err) {
                                // Abort errors and other errors are handled the same
                                var callbacks = loading[url];
                                if (callbacks === undefined) {
                                    // When onLoad was called and url was deleted in `loading`
                                    _this_1.manager.itemError(url);
                                    throw err;
                                }
                                delete loading[url];
                                for (var i = 0, il = callbacks.length; i < il; i++) {
                                    var callback = callbacks[i];
                                    if (callback.onError)
                                        callback.onError(err);
                                }
                                _this_1.manager.itemError(url);
                            })
                            .finally(function() {
                                _this_1.manager.itemEnd(url);
                            });
                        this.manager.itemStart(url);
                    };
                    FileLoader.prototype.setResponseType = function(value) {
                        this.responseType = value;
                        return this;
                    };
                    FileLoader.prototype.setMimeType = function(value) {
                        this.mimeType = value;
                        return this;
                    };
                    return FileLoader;
                }(Loader));
                var AnimationLoader = /** @class */ (function(_super) {
                    __extends(AnimationLoader, _super);

                    function AnimationLoader(manager) {
                        return _super.call(this, manager) || this;
                    }
                    AnimationLoader.prototype.load = function(url, onLoad, onProgress, onError) {
                        var scope = this;
                        var loader = new FileLoader(this.manager);
                        loader.setPath(this.path);
                        loader.setRequestHeader(this.requestHeader);
                        loader.setWithCredentials(this.withCredentials);
                        loader.load(url, function(text) {
                            try {
                                onLoad(scope.parse(JSON.parse(text)));
                            } catch (e) {
                                if (onError) {
                                    onError(e);
                                } else {
                                    console.error(e);
                                }
                                scope.manager.itemError(url);
                            }
                        }, onProgress, onError);
                    };
                    AnimationLoader.prototype.parse = function(json) {
                        var animations = [];
                        for (var i = 0; i < json.length; i++) {
                            var clip = AnimationClip.parse(json[i]);
                            animations.push(clip);
                        }
                        return animations;
                    };
                    return AnimationLoader;
                }(Loader));
                /**
                 * Abstract Base class to block based textures loader (dds, pvr, ...)
                 *
                 * Sub classes have to implement the parse() method which will be used in load().
                 */
                var CompressedTextureLoader = /** @class */ (function(_super) {
                    __extends(CompressedTextureLoader, _super);

                    function CompressedTextureLoader(manager) {
                        return _super.call(this, manager) || this;
                    }
                    CompressedTextureLoader.prototype.load = function(url, onLoad, onProgress, onError) {
                        var scope = this;
                        var images = [];
                        var texture = new CompressedTexture();
                        var loader = new FileLoader(this.manager);
                        loader.setPath(this.path);
                        loader.setResponseType('arraybuffer');
                        loader.setRequestHeader(this.requestHeader);
                        loader.setWithCredentials(scope.withCredentials);
                        var loaded = 0;

                        function loadTexture(i) {
                            loader.load(url[i], function(buffer) {
                                var texDatas = scope.parse(buffer, true);
                                images[i] = {
                                    width: texDatas.width,
                                    height: texDatas.height,
                                    format: texDatas.format,
                                    mipmaps: texDatas.mipmaps
                                };
                                loaded += 1;
                                if (loaded === 6) {
                                    if (texDatas.mipmapCount === 1)
                                        texture.minFilter = LinearFilter;
                                    texture.image = images;
                                    texture.format = texDatas.format;
                                    texture.needsUpdate = true;
                                    if (onLoad)
                                        onLoad(texture);
                                }
                            }, onProgress, onError);
                        }
                        if (Array.isArray(url)) {
                            for (var i = 0, il = url.length; i < il; ++i) {
                                loadTexture(i);
                            }
                        } else {
                            // compressed cubemap texture stored in a single DDS file
                            loader.load(url, function(buffer) {
                                var texDatas = scope.parse(buffer, true);
                                if (texDatas.isCubemap) {
                                    var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                                    for (var f = 0; f < faces; f++) {
                                        images[f] = {
                                            mipmaps: []
                                        };
                                        for (var i = 0; i < texDatas.mipmapCount; i++) {
                                            images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                                            images[f].format = texDatas.format;
                                            images[f].width = texDatas.width;
                                            images[f].height = texDatas.height;
                                        }
                                    }
                                    texture.image = images;
                                } else {
                                    texture.image.width = texDatas.width;
                                    texture.image.height = texDatas.height;
                                    texture.mipmaps = texDatas.mipmaps;
                                }
                                if (texDatas.mipmapCount === 1) {
                                    texture.minFilter = LinearFilter;
                                }
                                texture.format = texDatas.format;
                                texture.needsUpdate = true;
                                if (onLoad)
                                    onLoad(texture);
                            }, onProgress, onError);
                        }
                        return texture;
                    };
                    return CompressedTextureLoader;
                }(Loader));
                var ImageLoader = /** @class */ (function(_super) {
                    __extends(ImageLoader, _super);

                    function ImageLoader(manager) {
                        return _super.call(this, manager) || this;
                    }
                    ImageLoader.prototype.load = function(url, onLoad, onProgress, onError) {
                        if (this.path !== undefined)
                            url = this.path + url;
                        url = this.manager.resolveURL(url);
                        var scope = this;
                        var cached = Cache.get(url);
                        if (cached !== undefined) {
                            scope.manager.itemStart(url);
                            setTimeout(function() {
                                if (onLoad)
                                    onLoad(cached);
                                scope.manager.itemEnd(url);
                            }, 0);
                            return cached;
                        }
                        var image = createElementNS('img');

                        function onImageLoad() {
                            removeEventListeners();
                            Cache.add(url, this);
                            if (onLoad)
                                onLoad(this);
                            scope.manager.itemEnd(url);
                        }

                        function onImageError(event) {
                            removeEventListeners();
                            if (onError)
                                onError(event);
                            scope.manager.itemError(url);
                            scope.manager.itemEnd(url);
                        }

                        function removeEventListeners() {
                            image.removeEventListener('load', onImageLoad, false);
                            image.removeEventListener('error', onImageError, false);
                        }
                        image.addEventListener('load', onImageLoad, false);
                        image.addEventListener('error', onImageError, false);
                        if (url.slice(0, 5) !== 'data:') {
                            if (this.crossOrigin !== undefined)
                                image.crossOrigin = this.crossOrigin;
                        }
                        scope.manager.itemStart(url);
                        image.src = url;
                        return image;
                    };
                    return ImageLoader;
                }(Loader));
                var CubeTextureLoader = /** @class */ (function(_super) {
                    __extends(CubeTextureLoader, _super);

                    function CubeTextureLoader(manager) {
                        return _super.call(this, manager) || this;
                    }
                    CubeTextureLoader.prototype.load = function(urls, onLoad, onProgress, onError) {
                        var texture = new CubeTexture();
                        var loader = new ImageLoader(this.manager);
                        loader.setCrossOrigin(this.crossOrigin);
                        loader.setPath(this.path);
                        var loaded = 0;

                        function loadTexture(i) {
                            loader.load(urls[i], function(image) {
                                texture.images[i] = image;
                                loaded++;
                                if (loaded === 6) {
                                    texture.needsUpdate = true;
                                    if (onLoad)
                                        onLoad(texture);
                                }
                            }, undefined, onError);
                        }
                        for (var i = 0; i < urls.length; ++i) {
                            loadTexture(i);
                        }
                        return texture;
                    };
                    return CubeTextureLoader;
                }(Loader));
                /**
                 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
                 *
                 * Sub classes have to implement the parse() method which will be used in load().
                 */
                var DataTextureLoader = /** @class */ (function(_super) {
                    __extends(DataTextureLoader, _super);

                    function DataTextureLoader(manager) {
                        return _super.call(this, manager) || this;
                    }
                    DataTextureLoader.prototype.load = function(url, onLoad, onProgress, onError) {
                        var scope = this;
                        var texture = new DataTexture();
                        var loader = new FileLoader(this.manager);
                        loader.setResponseType('arraybuffer');
                        loader.setRequestHeader(this.requestHeader);
                        loader.setPath(this.path);
                        loader.setWithCredentials(scope.withCredentials);
                        loader.load(url, function(buffer) {
                            var texData = scope.parse(buffer);
                            if (!texData)
                                return;
                            if (texData.image !== undefined) {
                                texture.image = texData.image;
                            } else if (texData.data !== undefined) {
                                texture.image.width = texData.width;
                                texture.image.height = texData.height;
                                texture.image.data = texData.data;
                            }
                            texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
                            texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
                            texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
                            texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
                            texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
                            if (texData.encoding !== undefined) {
                                texture.encoding = texData.encoding;
                            }
                            if (texData.flipY !== undefined) {
                                texture.flipY = texData.flipY;
                            }
                            if (texData.format !== undefined) {
                                texture.format = texData.format;
                            }
                            if (texData.type !== undefined) {
                                texture.type = texData.type;
                            }
                            if (texData.mipmaps !== undefined) {
                                texture.mipmaps = texData.mipmaps;
                                texture.minFilter = LinearMipmapLinearFilter; // presumably...
                            }
                            if (texData.mipmapCount === 1) {
                                texture.minFilter = LinearFilter;
                            }
                            if (texData.generateMipmaps !== undefined) {
                                texture.generateMipmaps = texData.generateMipmaps;
                            }
                            texture.needsUpdate = true;
                            if (onLoad)
                                onLoad(texture, texData);
                        }, onProgress, onError);
                        return texture;
                    };
                    return DataTextureLoader;
                }(Loader));
                var TextureLoader = /** @class */ (function(_super) {
                    __extends(TextureLoader, _super);

                    function TextureLoader(manager) {
                        return _super.call(this, manager) || this;
                    }
                    TextureLoader.prototype.load = function(url, onLoad, onProgress, onError) {
                        var texture = new Texture();
                        var loader = new ImageLoader(this.manager);
                        loader.setCrossOrigin(this.crossOrigin);
                        loader.setPath(this.path);
                        loader.load(url, function(image) {
                            texture.image = image;
                            texture.needsUpdate = true;
                            if (onLoad !== undefined) {
                                onLoad(texture);
                            }
                        }, onProgress, onError);
                        return texture;
                    };
                    return TextureLoader;
                }(Loader));
                var Light = /** @class */ (function(_super) {
                    __extends(Light, _super);

                    function Light(color, intensity) {
                        if (intensity === void 0) {
                            intensity = 1;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'Light';
                        _this_1.color = new Color(color);
                        _this_1.intensity = intensity;
                        return _this_1;
                    }
                    Light.prototype.dispose = function() {
                        // Empty here in base class; some subclasses override.
                    };
                    Light.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.color.copy(source.color);
                        this.intensity = source.intensity;
                        return this;
                    };
                    Light.prototype.toJSON = function(meta) {
                        var data = _super.prototype.toJSON.call(this, meta);
                        data.object.color = this.color.getHex();
                        data.object.intensity = this.intensity;
                        if (this.groundColor !== undefined)
                            data.object.groundColor = this.groundColor.getHex();
                        if (this.distance !== undefined)
                            data.object.distance = this.distance;
                        if (this.angle !== undefined)
                            data.object.angle = this.angle;
                        if (this.decay !== undefined)
                            data.object.decay = this.decay;
                        if (this.penumbra !== undefined)
                            data.object.penumbra = this.penumbra;
                        if (this.shadow !== undefined)
                            data.object.shadow = this.shadow.toJSON();
                        return data;
                    };
                    return Light;
                }(Object3D));
                Light.prototype.isLight = true;
                var HemisphereLight = /** @class */ (function(_super) {
                    __extends(HemisphereLight, _super);

                    function HemisphereLight(skyColor, groundColor, intensity) {
                        var _this_1 = _super.call(this, skyColor, intensity) || this;
                        _this_1.type = 'HemisphereLight';
                        _this_1.position.copy(Object3D.DefaultUp);
                        _this_1.updateMatrix();
                        _this_1.groundColor = new Color(groundColor);
                        return _this_1;
                    }
                    HemisphereLight.prototype.copy = function(source) {
                        Light.prototype.copy.call(this, source);
                        this.groundColor.copy(source.groundColor);
                        return this;
                    };
                    return HemisphereLight;
                }(Light));
                HemisphereLight.prototype.isHemisphereLight = true;
                var _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
                var _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
                var _lookTarget$1 = /*@__PURE__*/ new Vector3();
                var LightShadow = /** @class */ (function() {
                    function LightShadow(camera) {
                        this.camera = camera;
                        this.bias = 0;
                        this.normalBias = 0;
                        this.radius = 1;
                        this.blurSamples = 8;
                        this.mapSize = new Vector2(512, 512);
                        this.map = null;
                        this.mapPass = null;
                        this.matrix = new Matrix4();
                        this.autoUpdate = true;
                        this.needsUpdate = false;
                        this._frustum = new Frustum();
                        this._frameExtents = new Vector2(1, 1);
                        this._viewportCount = 1;
                        this._viewports = [
                            new Vector4(0, 0, 1, 1)
                        ];
                    }
                    LightShadow.prototype.getViewportCount = function() {
                        return this._viewportCount;
                    };
                    LightShadow.prototype.getFrustum = function() {
                        return this._frustum;
                    };
                    LightShadow.prototype.updateMatrices = function(light) {
                        var shadowCamera = this.camera;
                        var shadowMatrix = this.matrix;
                        _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
                        shadowCamera.position.copy(_lightPositionWorld$1);
                        _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
                        shadowCamera.lookAt(_lookTarget$1);
                        shadowCamera.updateMatrixWorld();
                        _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
                        this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
                        shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
                        shadowMatrix.multiply(shadowCamera.projectionMatrix);
                        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
                    };
                    LightShadow.prototype.getViewport = function(viewportIndex) {
                        return this._viewports[viewportIndex];
                    };
                    LightShadow.prototype.getFrameExtents = function() {
                        return this._frameExtents;
                    };
                    LightShadow.prototype.dispose = function() {
                        if (this.map) {
                            this.map.dispose();
                        }
                        if (this.mapPass) {
                            this.mapPass.dispose();
                        }
                    };
                    LightShadow.prototype.copy = function(source) {
                        this.camera = source.camera.clone();
                        this.bias = source.bias;
                        this.radius = source.radius;
                        this.mapSize.copy(source.mapSize);
                        return this;
                    };
                    LightShadow.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    LightShadow.prototype.toJSON = function() {
                        var object = {};
                        if (this.bias !== 0)
                            object.bias = this.bias;
                        if (this.normalBias !== 0)
                            object.normalBias = this.normalBias;
                        if (this.radius !== 1)
                            object.radius = this.radius;
                        if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
                            object.mapSize = this.mapSize.toArray();
                        object.camera = this.camera.toJSON(false).object;
                        delete object.camera.matrix;
                        return object;
                    };
                    return LightShadow;
                }());
                var SpotLightShadow = /** @class */ (function(_super) {
                    __extends(SpotLightShadow, _super);

                    function SpotLightShadow() {
                        var _this_1 = _super.call(this, new PerspectiveCamera(50, 1, 0.5, 500)) || this;
                        _this_1.focus = 1;
                        return _this_1;
                    }
                    SpotLightShadow.prototype.updateMatrices = function(light) {
                        var camera = this.camera;
                        var fov = RAD2DEG * 2 * light.angle * this.focus;
                        var aspect = this.mapSize.width / this.mapSize.height;
                        var far = light.distance || camera.far;
                        if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
                            camera.fov = fov;
                            camera.aspect = aspect;
                            camera.far = far;
                            camera.updateProjectionMatrix();
                        }
                        _super.prototype.updateMatrices.call(this, light);
                    };
                    SpotLightShadow.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.focus = source.focus;
                        return this;
                    };
                    return SpotLightShadow;
                }(LightShadow));
                SpotLightShadow.prototype.isSpotLightShadow = true;
                var SpotLight = /** @class */ (function(_super) {
                    __extends(SpotLight, _super);

                    function SpotLight(color, intensity, distance, angle, penumbra, decay) {
                        if (distance === void 0) {
                            distance = 0;
                        }
                        if (angle === void 0) {
                            angle = Math.PI / 3;
                        }
                        if (penumbra === void 0) {
                            penumbra = 0;
                        }
                        if (decay === void 0) {
                            decay = 1;
                        }
                        var _this_1 = _super.call(this, color, intensity) || this;
                        _this_1.type = 'SpotLight';
                        _this_1.position.copy(Object3D.DefaultUp);
                        _this_1.updateMatrix();
                        _this_1.target = new Object3D();
                        _this_1.distance = distance;
                        _this_1.angle = angle;
                        _this_1.penumbra = penumbra;
                        _this_1.decay = decay; // for physically correct lights, should be 2.
                        _this_1.shadow = new SpotLightShadow();
                        return _this_1;
                    }
                    Object.defineProperty(SpotLight.prototype, "power", {
                        get: function() {
                            // compute the light's luminous power (in lumens) from its intensity (in candela)
                            // by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)
                            return this.intensity * Math.PI;
                        },
                        set: function(power) {
                            // set the light's intensity (in candela) from the desired luminous power (in lumens)
                            this.intensity = power / Math.PI;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    SpotLight.prototype.dispose = function() {
                        this.shadow.dispose();
                    };
                    SpotLight.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.distance = source.distance;
                        this.angle = source.angle;
                        this.penumbra = source.penumbra;
                        this.decay = source.decay;
                        this.target = source.target.clone();
                        this.shadow = source.shadow.clone();
                        return this;
                    };
                    return SpotLight;
                }(Light));
                SpotLight.prototype.isSpotLight = true;
                var _projScreenMatrix = /*@__PURE__*/ new Matrix4();
                var _lightPositionWorld = /*@__PURE__*/ new Vector3();
                var _lookTarget = /*@__PURE__*/ new Vector3();
                var PointLightShadow = /** @class */ (function(_super) {
                    __extends(PointLightShadow, _super);

                    function PointLightShadow() {
                        var _this_1 = _super.call(this, new PerspectiveCamera(90, 1, 0.5, 500)) || this;
                        _this_1._frameExtents = new Vector2(4, 2);
                        _this_1._viewportCount = 6;
                        _this_1._viewports = [
                            // These viewports map a cube-map onto a 2D texture with the
                            // following orientation:
                            //
                            //  xzXZ
                            //   y Y
                            //
                            // X - Positive x direction
                            // x - Negative x direction
                            // Y - Positive y direction
                            // y - Negative y direction
                            // Z - Positive z direction
                            // z - Negative z direction
                            // positive X
                            new Vector4(2, 1, 1, 1),
                            // negative X
                            new Vector4(0, 1, 1, 1),
                            // positive Z
                            new Vector4(3, 1, 1, 1),
                            // negative Z
                            new Vector4(1, 1, 1, 1),
                            // positive Y
                            new Vector4(3, 0, 1, 1),
                            // negative Y
                            new Vector4(1, 0, 1, 1)
                        ];
                        _this_1._cubeDirections = [
                            new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1),
                            new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)
                        ];
                        _this_1._cubeUps = [
                            new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0),
                            new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)
                        ];
                        return _this_1;
                    }
                    PointLightShadow.prototype.updateMatrices = function(light, viewportIndex) {
                        if (viewportIndex === void 0) {
                            viewportIndex = 0;
                        }
                        var camera = this.camera;
                        var shadowMatrix = this.matrix;
                        var far = light.distance || camera.far;
                        if (far !== camera.far) {
                            camera.far = far;
                            camera.updateProjectionMatrix();
                        }
                        _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
                        camera.position.copy(_lightPositionWorld);
                        _lookTarget.copy(camera.position);
                        _lookTarget.add(this._cubeDirections[viewportIndex]);
                        camera.up.copy(this._cubeUps[viewportIndex]);
                        camera.lookAt(_lookTarget);
                        camera.updateMatrixWorld();
                        shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
                        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                        this._frustum.setFromProjectionMatrix(_projScreenMatrix);
                    };
                    return PointLightShadow;
                }(LightShadow));
                PointLightShadow.prototype.isPointLightShadow = true;
                var PointLight = /** @class */ (function(_super) {
                    __extends(PointLight, _super);

                    function PointLight(color, intensity, distance, decay) {
                        if (distance === void 0) {
                            distance = 0;
                        }
                        if (decay === void 0) {
                            decay = 1;
                        }
                        var _this_1 = _super.call(this, color, intensity) || this;
                        _this_1.type = 'PointLight';
                        _this_1.distance = distance;
                        _this_1.decay = decay; // for physically correct lights, should be 2.
                        _this_1.shadow = new PointLightShadow();
                        return _this_1;
                    }
                    Object.defineProperty(PointLight.prototype, "power", {
                        get: function() {
                            // compute the light's luminous power (in lumens) from its intensity (in candela)
                            // for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
                            return this.intensity * 4 * Math.PI;
                        },
                        set: function(power) {
                            // set the light's intensity (in candela) from the desired luminous power (in lumens)
                            this.intensity = power / (4 * Math.PI);
                        },
                        enumerable: false,
                        configurable: true
                    });
                    PointLight.prototype.dispose = function() {
                        this.shadow.dispose();
                    };
                    PointLight.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.distance = source.distance;
                        this.decay = source.decay;
                        this.shadow = source.shadow.clone();
                        return this;
                    };
                    return PointLight;
                }(Light));
                PointLight.prototype.isPointLight = true;
                var DirectionalLightShadow = /** @class */ (function(_super) {
                    __extends(DirectionalLightShadow, _super);

                    function DirectionalLightShadow() {
                        return _super.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500)) || this;
                    }
                    return DirectionalLightShadow;
                }(LightShadow));
                DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
                var DirectionalLight = /** @class */ (function(_super) {
                    __extends(DirectionalLight, _super);

                    function DirectionalLight(color, intensity) {
                        var _this_1 = _super.call(this, color, intensity) || this;
                        _this_1.type = 'DirectionalLight';
                        _this_1.position.copy(Object3D.DefaultUp);
                        _this_1.updateMatrix();
                        _this_1.target = new Object3D();
                        _this_1.shadow = new DirectionalLightShadow();
                        return _this_1;
                    }
                    DirectionalLight.prototype.dispose = function() {
                        this.shadow.dispose();
                    };
                    DirectionalLight.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.target = source.target.clone();
                        this.shadow = source.shadow.clone();
                        return this;
                    };
                    return DirectionalLight;
                }(Light));
                DirectionalLight.prototype.isDirectionalLight = true;
                var AmbientLight = /** @class */ (function(_super) {
                    __extends(AmbientLight, _super);

                    function AmbientLight(color, intensity) {
                        var _this_1 = _super.call(this, color, intensity) || this;
                        _this_1.type = 'AmbientLight';
                        return _this_1;
                    }
                    return AmbientLight;
                }(Light));
                AmbientLight.prototype.isAmbientLight = true;
                var RectAreaLight = /** @class */ (function(_super) {
                    __extends(RectAreaLight, _super);

                    function RectAreaLight(color, intensity, width, height) {
                        if (width === void 0) {
                            width = 10;
                        }
                        if (height === void 0) {
                            height = 10;
                        }
                        var _this_1 = _super.call(this, color, intensity) || this;
                        _this_1.type = 'RectAreaLight';
                        _this_1.width = width;
                        _this_1.height = height;
                        return _this_1;
                    }
                    Object.defineProperty(RectAreaLight.prototype, "power", {
                        get: function() {
                            // compute the light's luminous power (in lumens) from its intensity (in nits)
                            return this.intensity * this.width * this.height * Math.PI;
                        },
                        set: function(power) {
                            // set the light's intensity (in nits) from the desired luminous power (in lumens)
                            this.intensity = power / (this.width * this.height * Math.PI);
                        },
                        enumerable: false,
                        configurable: true
                    });
                    RectAreaLight.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.width = source.width;
                        this.height = source.height;
                        return this;
                    };
                    RectAreaLight.prototype.toJSON = function(meta) {
                        var data = _super.prototype.toJSON.call(this, meta);
                        data.object.width = this.width;
                        data.object.height = this.height;
                        return data;
                    };
                    return RectAreaLight;
                }(Light));
                RectAreaLight.prototype.isRectAreaLight = true;
                /**
                 * Primary reference:
                 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
                 *
                 * Secondary reference:
                 *   https://www.ppsloan.org/publications/StupidSH36.pdf
                 */
                // 3-band SH defined by 9 coefficients
                var SphericalHarmonics3 = /** @class */ (function() {
                    function SphericalHarmonics3() {
                        this.coefficients = [];
                        for (var i = 0; i < 9; i++) {
                            this.coefficients.push(new Vector3());
                        }
                    }
                    SphericalHarmonics3.prototype.set = function(coefficients) {
                        for (var i = 0; i < 9; i++) {
                            this.coefficients[i].copy(coefficients[i]);
                        }
                        return this;
                    };
                    SphericalHarmonics3.prototype.zero = function() {
                        for (var i = 0; i < 9; i++) {
                            this.coefficients[i].set(0, 0, 0);
                        }
                        return this;
                    };
                    // get the radiance in the direction of the normal
                    // target is a Vector3
                    SphericalHarmonics3.prototype.getAt = function(normal, target) {
                        // normal is assumed to be unit length
                        var x = normal.x,
                            y = normal.y,
                            z = normal.z;
                        var coeff = this.coefficients;
                        // band 0
                        target.copy(coeff[0]).multiplyScalar(0.282095);
                        // band 1
                        target.addScaledVector(coeff[1], 0.488603 * y);
                        target.addScaledVector(coeff[2], 0.488603 * z);
                        target.addScaledVector(coeff[3], 0.488603 * x);
                        // band 2
                        target.addScaledVector(coeff[4], 1.092548 * (x * y));
                        target.addScaledVector(coeff[5], 1.092548 * (y * z));
                        target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
                        target.addScaledVector(coeff[7], 1.092548 * (x * z));
                        target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
                        return target;
                    };
                    // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
                    // target is a Vector3
                    // https://graphics.stanford.edu/papers/envmap/envmap.pdf
                    SphericalHarmonics3.prototype.getIrradianceAt = function(normal, target) {
                        // normal is assumed to be unit length
                        var x = normal.x,
                            y = normal.y,
                            z = normal.z;
                        var coeff = this.coefficients;
                        // band 0
                        target.copy(coeff[0]).multiplyScalar(0.886227); //  * 0.282095
                        // band 1
                        target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 *  / 3 ) * 0.488603
                        target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
                        target.addScaledVector(coeff[3], 2.0 * 0.511664 * x);
                        // band 2
                        target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // (  / 4 ) * 1.092548
                        target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
                        target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // (  / 4 ) * 0.315392 * 3
                        target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
                        target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // (  / 4 ) * 0.546274
                        return target;
                    };
                    SphericalHarmonics3.prototype.add = function(sh) {
                        for (var i = 0; i < 9; i++) {
                            this.coefficients[i].add(sh.coefficients[i]);
                        }
                        return this;
                    };
                    SphericalHarmonics3.prototype.addScaledSH = function(sh, s) {
                        for (var i = 0; i < 9; i++) {
                            this.coefficients[i].addScaledVector(sh.coefficients[i], s);
                        }
                        return this;
                    };
                    SphericalHarmonics3.prototype.scale = function(s) {
                        for (var i = 0; i < 9; i++) {
                            this.coefficients[i].multiplyScalar(s);
                        }
                        return this;
                    };
                    SphericalHarmonics3.prototype.lerp = function(sh, alpha) {
                        for (var i = 0; i < 9; i++) {
                            this.coefficients[i].lerp(sh.coefficients[i], alpha);
                        }
                        return this;
                    };
                    SphericalHarmonics3.prototype.equals = function(sh) {
                        for (var i = 0; i < 9; i++) {
                            if (!this.coefficients[i].equals(sh.coefficients[i])) {
                                return false;
                            }
                        }
                        return true;
                    };
                    SphericalHarmonics3.prototype.copy = function(sh) {
                        return this.set(sh.coefficients);
                    };
                    SphericalHarmonics3.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    SphericalHarmonics3.prototype.fromArray = function(array, offset) {
                        if (offset === void 0) {
                            offset = 0;
                        }
                        var coefficients = this.coefficients;
                        for (var i = 0; i < 9; i++) {
                            coefficients[i].fromArray(array, offset + (i * 3));
                        }
                        return this;
                    };
                    SphericalHarmonics3.prototype.toArray = function(array, offset) {
                        if (array === void 0) {
                            array = [];
                        }
                        if (offset === void 0) {
                            offset = 0;
                        }
                        var coefficients = this.coefficients;
                        for (var i = 0; i < 9; i++) {
                            coefficients[i].toArray(array, offset + (i * 3));
                        }
                        return array;
                    };
                    // evaluate the basis functions
                    // shBasis is an Array[ 9 ]
                    SphericalHarmonics3.getBasisAt = function(normal, shBasis) {
                        // normal is assumed to be unit length
                        var x = normal.x,
                            y = normal.y,
                            z = normal.z;
                        // band 0
                        shBasis[0] = 0.282095;
                        // band 1
                        shBasis[1] = 0.488603 * y;
                        shBasis[2] = 0.488603 * z;
                        shBasis[3] = 0.488603 * x;
                        // band 2
                        shBasis[4] = 1.092548 * x * y;
                        shBasis[5] = 1.092548 * y * z;
                        shBasis[6] = 0.315392 * (3 * z * z - 1);
                        shBasis[7] = 1.092548 * x * z;
                        shBasis[8] = 0.546274 * (x * x - y * y);
                    };
                    return SphericalHarmonics3;
                }());
                SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
                var LightProbe = /** @class */ (function(_super) {
                    __extends(LightProbe, _super);

                    function LightProbe(sh, intensity) {
                        if (sh === void 0) {
                            sh = new SphericalHarmonics3();
                        }
                        if (intensity === void 0) {
                            intensity = 1;
                        }
                        var _this_1 = _super.call(this, undefined, intensity) || this;
                        _this_1.sh = sh;
                        return _this_1;
                    }
                    LightProbe.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.sh.copy(source.sh);
                        return this;
                    };
                    LightProbe.prototype.fromJSON = function(json) {
                        this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
                        this.sh.fromArray(json.sh);
                        return this;
                    };
                    LightProbe.prototype.toJSON = function(meta) {
                        var data = _super.prototype.toJSON.call(this, meta);
                        data.object.sh = this.sh.toArray();
                        return data;
                    };
                    return LightProbe;
                }(Light));
                LightProbe.prototype.isLightProbe = true;
                var MaterialLoader = /** @class */ (function(_super) {
                    __extends(MaterialLoader, _super);

                    function MaterialLoader(manager) {
                        var _this_1 = _super.call(this, manager) || this;
                        _this_1.textures = {};
                        return _this_1;
                    }
                    MaterialLoader.prototype.load = function(url, onLoad, onProgress, onError) {
                        var scope = this;
                        var loader = new FileLoader(scope.manager);
                        loader.setPath(scope.path);
                        loader.setRequestHeader(scope.requestHeader);
                        loader.setWithCredentials(scope.withCredentials);
                        loader.load(url, function(text) {
                            try {
                                onLoad(scope.parse(JSON.parse(text)));
                            } catch (e) {
                                if (onError) {
                                    onError(e);
                                } else {
                                    console.error(e);
                                }
                                scope.manager.itemError(url);
                            }
                        }, onProgress, onError);
                    };
                    MaterialLoader.prototype.parse = function(json) {
                        var textures = this.textures;

                        function getTexture(name) {
                            if (textures[name] === undefined) {
                                console.warn('THREE.MaterialLoader: Undefined texture', name);
                            }
                            return textures[name];
                        }
                        var material = Material.fromType(json.type);
                        if (json.uuid !== undefined)
                            material.uuid = json.uuid;
                        if (json.name !== undefined)
                            material.name = json.name;
                        if (json.color !== undefined && material.color !== undefined)
                            material.color.setHex(json.color);
                        if (json.roughness !== undefined)
                            material.roughness = json.roughness;
                        if (json.metalness !== undefined)
                            material.metalness = json.metalness;
                        if (json.sheen !== undefined)
                            material.sheen = json.sheen;
                        if (json.sheenColor !== undefined)
                            material.sheenColor = new Color().setHex(json.sheenColor);
                        if (json.sheenRoughness !== undefined)
                            material.sheenRoughness = json.sheenRoughness;
                        if (json.emissive !== undefined && material.emissive !== undefined)
                            material.emissive.setHex(json.emissive);
                        if (json.specular !== undefined && material.specular !== undefined)
                            material.specular.setHex(json.specular);
                        if (json.specularIntensity !== undefined)
                            material.specularIntensity = json.specularIntensity;
                        if (json.specularColor !== undefined && material.specularColor !== undefined)
                            material.specularColor.setHex(json.specularColor);
                        if (json.shininess !== undefined)
                            material.shininess = json.shininess;
                        if (json.clearcoat !== undefined)
                            material.clearcoat = json.clearcoat;
                        if (json.clearcoatRoughness !== undefined)
                            material.clearcoatRoughness = json.clearcoatRoughness;
                        if (json.transmission !== undefined)
                            material.transmission = json.transmission;
                        if (json.thickness !== undefined)
                            material.thickness = json.thickness;
                        if (json.attenuationDistance !== undefined)
                            material.attenuationDistance = json.attenuationDistance;
                        if (json.attenuationColor !== undefined && material.attenuationColor !== undefined)
                            material.attenuationColor.setHex(json.attenuationColor);
                        if (json.fog !== undefined)
                            material.fog = json.fog;
                        if (json.flatShading !== undefined)
                            material.flatShading = json.flatShading;
                        if (json.blending !== undefined)
                            material.blending = json.blending;
                        if (json.combine !== undefined)
                            material.combine = json.combine;
                        if (json.side !== undefined)
                            material.side = json.side;
                        if (json.shadowSide !== undefined)
                            material.shadowSide = json.shadowSide;
                        if (json.opacity !== undefined)
                            material.opacity = json.opacity;
                        if (json.transparent !== undefined)
                            material.transparent = json.transparent;
                        if (json.alphaTest !== undefined)
                            material.alphaTest = json.alphaTest;
                        if (json.depthTest !== undefined)
                            material.depthTest = json.depthTest;
                        if (json.depthWrite !== undefined)
                            material.depthWrite = json.depthWrite;
                        if (json.colorWrite !== undefined)
                            material.colorWrite = json.colorWrite;
                        if (json.stencilWrite !== undefined)
                            material.stencilWrite = json.stencilWrite;
                        if (json.stencilWriteMask !== undefined)
                            material.stencilWriteMask = json.stencilWriteMask;
                        if (json.stencilFunc !== undefined)
                            material.stencilFunc = json.stencilFunc;
                        if (json.stencilRef !== undefined)
                            material.stencilRef = json.stencilRef;
                        if (json.stencilFuncMask !== undefined)
                            material.stencilFuncMask = json.stencilFuncMask;
                        if (json.stencilFail !== undefined)
                            material.stencilFail = json.stencilFail;
                        if (json.stencilZFail !== undefined)
                            material.stencilZFail = json.stencilZFail;
                        if (json.stencilZPass !== undefined)
                            material.stencilZPass = json.stencilZPass;
                        if (json.wireframe !== undefined)
                            material.wireframe = json.wireframe;
                        if (json.wireframeLinewidth !== undefined)
                            material.wireframeLinewidth = json.wireframeLinewidth;
                        if (json.wireframeLinecap !== undefined)
                            material.wireframeLinecap = json.wireframeLinecap;
                        if (json.wireframeLinejoin !== undefined)
                            material.wireframeLinejoin = json.wireframeLinejoin;
                        if (json.rotation !== undefined)
                            material.rotation = json.rotation;
                        if (json.linewidth !== 1)
                            material.linewidth = json.linewidth;
                        if (json.dashSize !== undefined)
                            material.dashSize = json.dashSize;
                        if (json.gapSize !== undefined)
                            material.gapSize = json.gapSize;
                        if (json.scale !== undefined)
                            material.scale = json.scale;
                        if (json.polygonOffset !== undefined)
                            material.polygonOffset = json.polygonOffset;
                        if (json.polygonOffsetFactor !== undefined)
                            material.polygonOffsetFactor = json.polygonOffsetFactor;
                        if (json.polygonOffsetUnits !== undefined)
                            material.polygonOffsetUnits = json.polygonOffsetUnits;
                        if (json.dithering !== undefined)
                            material.dithering = json.dithering;
                        if (json.alphaToCoverage !== undefined)
                            material.alphaToCoverage = json.alphaToCoverage;
                        if (json.premultipliedAlpha !== undefined)
                            material.premultipliedAlpha = json.premultipliedAlpha;
                        if (json.visible !== undefined)
                            material.visible = json.visible;
                        if (json.toneMapped !== undefined)
                            material.toneMapped = json.toneMapped;
                        if (json.userData !== undefined)
                            material.userData = json.userData;
                        if (json.vertexColors !== undefined) {
                            if (typeof json.vertexColors === 'number') {
                                material.vertexColors = (json.vertexColors > 0) ? true : false;
                            } else {
                                material.vertexColors = json.vertexColors;
                            }
                        }
                        // Shader Material
                        if (json.uniforms !== undefined) {
                            for (var name in json.uniforms) {
                                var uniform = json.uniforms[name];
                                material.uniforms[name] = {};
                                switch (uniform.type) {
                                    case 't':
                                        material.uniforms[name].value = getTexture(uniform.value);
                                        break;
                                    case 'c':
                                        material.uniforms[name].value = new Color().setHex(uniform.value);
                                        break;
                                    case 'v2':
                                        material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                                        break;
                                    case 'v3':
                                        material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                                        break;
                                    case 'v4':
                                        material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                                        break;
                                    case 'm3':
                                        material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
                                        break;
                                    case 'm4':
                                        material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                                        break;
                                    default:
                                        material.uniforms[name].value = uniform.value;
                                }
                            }
                        }
                        if (json.defines !== undefined)
                            material.defines = json.defines;
                        if (json.vertexShader !== undefined)
                            material.vertexShader = json.vertexShader;
                        if (json.fragmentShader !== undefined)
                            material.fragmentShader = json.fragmentShader;
                        if (json.extensions !== undefined) {
                            for (var key in json.extensions) {
                                material.extensions[key] = json.extensions[key];
                            }
                        }
                        // Deprecated
                        if (json.shading !== undefined)
                            material.flatShading = json.shading === 1; // THREE.FlatShading
                        // for PointsMaterial
                        if (json.size !== undefined)
                            material.size = json.size;
                        if (json.sizeAttenuation !== undefined)
                            material.sizeAttenuation = json.sizeAttenuation;
                        // maps
                        if (json.map !== undefined)
                            material.map = getTexture(json.map);
                        if (json.matcap !== undefined)
                            material.matcap = getTexture(json.matcap);
                        if (json.alphaMap !== undefined)
                            material.alphaMap = getTexture(json.alphaMap);
                        if (json.bumpMap !== undefined)
                            material.bumpMap = getTexture(json.bumpMap);
                        if (json.bumpScale !== undefined)
                            material.bumpScale = json.bumpScale;
                        if (json.normalMap !== undefined)
                            material.normalMap = getTexture(json.normalMap);
                        if (json.normalMapType !== undefined)
                            material.normalMapType = json.normalMapType;
                        if (json.normalScale !== undefined) {
                            var normalScale = json.normalScale;
                            if (Array.isArray(normalScale) === false) {
                                // Blender exporter used to export a scalar. See #7459
                                normalScale = [normalScale, normalScale];
                            }
                            material.normalScale = new Vector2().fromArray(normalScale);
                        }
                        if (json.displacementMap !== undefined)
                            material.displacementMap = getTexture(json.displacementMap);
                        if (json.displacementScale !== undefined)
                            material.displacementScale = json.displacementScale;
                        if (json.displacementBias !== undefined)
                            material.displacementBias = json.displacementBias;
                        if (json.roughnessMap !== undefined)
                            material.roughnessMap = getTexture(json.roughnessMap);
                        if (json.metalnessMap !== undefined)
                            material.metalnessMap = getTexture(json.metalnessMap);
                        if (json.emissiveMap !== undefined)
                            material.emissiveMap = getTexture(json.emissiveMap);
                        if (json.emissiveIntensity !== undefined)
                            material.emissiveIntensity = json.emissiveIntensity;
                        if (json.specularMap !== undefined)
                            material.specularMap = getTexture(json.specularMap);
                        if (json.specularIntensityMap !== undefined)
                            material.specularIntensityMap = getTexture(json.specularIntensityMap);
                        if (json.specularColorMap !== undefined)
                            material.specularColorMap = getTexture(json.specularColorMap);
                        if (json.envMap !== undefined)
                            material.envMap = getTexture(json.envMap);
                        if (json.envMapIntensity !== undefined)
                            material.envMapIntensity = json.envMapIntensity;
                        if (json.reflectivity !== undefined)
                            material.reflectivity = json.reflectivity;
                        if (json.refractionRatio !== undefined)
                            material.refractionRatio = json.refractionRatio;
                        if (json.lightMap !== undefined)
                            material.lightMap = getTexture(json.lightMap);
                        if (json.lightMapIntensity !== undefined)
                            material.lightMapIntensity = json.lightMapIntensity;
                        if (json.aoMap !== undefined)
                            material.aoMap = getTexture(json.aoMap);
                        if (json.aoMapIntensity !== undefined)
                            material.aoMapIntensity = json.aoMapIntensity;
                        if (json.gradientMap !== undefined)
                            material.gradientMap = getTexture(json.gradientMap);
                        if (json.clearcoatMap !== undefined)
                            material.clearcoatMap = getTexture(json.clearcoatMap);
                        if (json.clearcoatRoughnessMap !== undefined)
                            material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
                        if (json.clearcoatNormalMap !== undefined)
                            material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
                        if (json.clearcoatNormalScale !== undefined)
                            material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
                        if (json.transmissionMap !== undefined)
                            material.transmissionMap = getTexture(json.transmissionMap);
                        if (json.thicknessMap !== undefined)
                            material.thicknessMap = getTexture(json.thicknessMap);
                        if (json.sheenColorMap !== undefined)
                            material.sheenColorMap = getTexture(json.sheenColorMap);
                        if (json.sheenRoughnessMap !== undefined)
                            material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
                        return material;
                    };
                    MaterialLoader.prototype.setTextures = function(value) {
                        this.textures = value;
                        return this;
                    };
                    return MaterialLoader;
                }(Loader));
                var LoaderUtils = /** @class */ (function() {
                    function LoaderUtils() {}
                    LoaderUtils.decodeText = function(array) {
                        if (typeof TextDecoder !== 'undefined') {
                            return new TextDecoder().decode(array);
                        }
                        // Avoid the String.fromCharCode.apply(null, array) shortcut, which
                        // throws a "maximum call stack size exceeded" error for large arrays.
                        var s = '';
                        for (var i = 0, il = array.length; i < il; i++) {
                            // Implicitly assumes little-endian.
                            s += String.fromCharCode(array[i]);
                        }
                        try {
                            // merges multi-byte utf-8 characters.
                            return decodeURIComponent(escape(s));
                        } catch (e) { // see #16358
                            return s;
                        }
                    };
                    LoaderUtils.extractUrlBase = function(url) {
                        var index = url.lastIndexOf('/');
                        if (index === -1)
                            return './';
                        return url.slice(0, index + 1);
                    };
                    LoaderUtils.resolveURL = function(url, path) {
                        // Invalid URL
                        if (typeof url !== 'string' || url === '')
                            return '';
                        // Host Relative URL
                        if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
                            path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
                        }
                        // Absolute URL http://,https://,//
                        if (/^(https?:)?\/\//i.test(url))
                            return url;
                        // Data URI
                        if (/^data:.*,.*$/i.test(url))
                            return url;
                        // Blob URL
                        if (/^blob:.*$/i.test(url))
                            return url;
                        // Relative URL
                        return path + url;
                    };
                    return LoaderUtils;
                }());
                var InstancedBufferGeometry = /** @class */ (function(_super) {
                    __extends(InstancedBufferGeometry, _super);

                    function InstancedBufferGeometry() {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'InstancedBufferGeometry';
                        _this_1.instanceCount = Infinity;
                        return _this_1;
                    }
                    InstancedBufferGeometry.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.instanceCount = source.instanceCount;
                        return this;
                    };
                    InstancedBufferGeometry.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    InstancedBufferGeometry.prototype.toJSON = function() {
                        var data = _super.prototype.toJSON.call(this, this);
                        data.instanceCount = this.instanceCount;
                        data.isInstancedBufferGeometry = true;
                        return data;
                    };
                    return InstancedBufferGeometry;
                }(BufferGeometry));
                InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
                var BufferGeometryLoader = /** @class */ (function(_super) {
                    __extends(BufferGeometryLoader, _super);

                    function BufferGeometryLoader(manager) {
                        return _super.call(this, manager) || this;
                    }
                    BufferGeometryLoader.prototype.load = function(url, onLoad, onProgress, onError) {
                        var scope = this;
                        var loader = new FileLoader(scope.manager);
                        loader.setPath(scope.path);
                        loader.setRequestHeader(scope.requestHeader);
                        loader.setWithCredentials(scope.withCredentials);
                        loader.load(url, function(text) {
                            try {
                                onLoad(scope.parse(JSON.parse(text)));
                            } catch (e) {
                                if (onError) {
                                    onError(e);
                                } else {
                                    console.error(e);
                                }
                                scope.manager.itemError(url);
                            }
                        }, onProgress, onError);
                    };
                    BufferGeometryLoader.prototype.parse = function(json) {
                        var interleavedBufferMap = {};
                        var arrayBufferMap = {};

                        function getInterleavedBuffer(json, uuid) {
                            if (interleavedBufferMap[uuid] !== undefined)
                                return interleavedBufferMap[uuid];
                            var interleavedBuffers = json.interleavedBuffers;
                            var interleavedBuffer = interleavedBuffers[uuid];
                            var buffer = getArrayBuffer(json, interleavedBuffer.buffer);
                            var array = getTypedArray(interleavedBuffer.type, buffer);
                            var ib = new InterleavedBuffer(array, interleavedBuffer.stride);
                            ib.uuid = interleavedBuffer.uuid;
                            interleavedBufferMap[uuid] = ib;
                            return ib;
                        }

                        function getArrayBuffer(json, uuid) {
                            if (arrayBufferMap[uuid] !== undefined)
                                return arrayBufferMap[uuid];
                            var arrayBuffers = json.arrayBuffers;
                            var arrayBuffer = arrayBuffers[uuid];
                            var ab = new Uint32Array(arrayBuffer).buffer;
                            arrayBufferMap[uuid] = ab;
                            return ab;
                        }
                        var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
                        var index = json.data.index;
                        if (index !== undefined) {
                            var typedArray = getTypedArray(index.type, index.array);
                            geometry.setIndex(new BufferAttribute(typedArray, 1));
                        }
                        var attributes = json.data.attributes;
                        for (var key in attributes) {
                            var attribute = attributes[key];
                            var bufferAttribute = void 0;
                            if (attribute.isInterleavedBufferAttribute) {
                                var interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                                bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                            } else {
                                var typedArray = getTypedArray(attribute.type, attribute.array);
                                var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
                                bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
                            }
                            if (attribute.name !== undefined)
                                bufferAttribute.name = attribute.name;
                            if (attribute.usage !== undefined)
                                bufferAttribute.setUsage(attribute.usage);
                            if (attribute.updateRange !== undefined) {
                                bufferAttribute.updateRange.offset = attribute.updateRange.offset;
                                bufferAttribute.updateRange.count = attribute.updateRange.count;
                            }
                            geometry.setAttribute(key, bufferAttribute);
                        }
                        var morphAttributes = json.data.morphAttributes;
                        if (morphAttributes) {
                            for (var key in morphAttributes) {
                                var attributeArray = morphAttributes[key];
                                var array = [];
                                for (var i = 0, il = attributeArray.length; i < il; i++) {
                                    var attribute = attributeArray[i];
                                    var bufferAttribute = void 0;
                                    if (attribute.isInterleavedBufferAttribute) {
                                        var interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                                        bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
                                    } else {
                                        var typedArray = getTypedArray(attribute.type, attribute.array);
                                        bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
                                    }
                                    if (attribute.name !== undefined)
                                        bufferAttribute.name = attribute.name;
                                    array.push(bufferAttribute);
                                }
                                geometry.morphAttributes[key] = array;
                            }
                        }
                        var morphTargetsRelative = json.data.morphTargetsRelative;
                        if (morphTargetsRelative) {
                            geometry.morphTargetsRelative = true;
                        }
                        var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
                        if (groups !== undefined) {
                            for (var i = 0, n = groups.length; i !== n; ++i) {
                                var group = groups[i];
                                geometry.addGroup(group.start, group.count, group.materialIndex);
                            }
                        }
                        var boundingSphere = json.data.boundingSphere;
                        if (boundingSphere !== undefined) {
                            var center = new Vector3();
                            if (boundingSphere.center !== undefined) {
                                center.fromArray(boundingSphere.center);
                            }
                            geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
                        }
                        if (json.name)
                            geometry.name = json.name;
                        if (json.userData)
                            geometry.userData = json.userData;
                        return geometry;
                    };
                    return BufferGeometryLoader;
                }(Loader));
                var ObjectLoader = /** @class */ (function(_super) {
                    __extends(ObjectLoader, _super);

                    function ObjectLoader(manager) {
                        return _super.call(this, manager) || this;
                    }
                    ObjectLoader.prototype.load = function(url, onLoad, onProgress, onError) {
                        var scope = this;
                        var path = (this.path === '') ? LoaderUtils.extractUrlBase(url) : this.path;
                        this.resourcePath = this.resourcePath || path;
                        var loader = new FileLoader(this.manager);
                        loader.setPath(this.path);
                        loader.setRequestHeader(this.requestHeader);
                        loader.setWithCredentials(this.withCredentials);
                        loader.load(url, function(text) {
                            var json = null;
                            try {
                                json = JSON.parse(text);
                            } catch (error) {
                                if (onError !== undefined)
                                    onError(error);
                                console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
                                return;
                            }
                            var metadata = json.metadata;
                            if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                                console.error('THREE.ObjectLoader: Can\'t load ' + url);
                                return;
                            }
                            scope.parse(json, onLoad);
                        }, onProgress, onError);
                    };
                    ObjectLoader.prototype.loadAsync = function(url, onProgress) {
                        return __awaiter(this, void 0, void 0, function() {
                            var scope, path, loader, text, json, metadata;
                            return __generator(this, function(_a) {
                                switch (_a.label) {
                                    case 0:
                                        scope = this;
                                        path = (this.path === '') ? LoaderUtils.extractUrlBase(url) : this.path;
                                        this.resourcePath = this.resourcePath || path;
                                        loader = new FileLoader(this.manager);
                                        loader.setPath(this.path);
                                        loader.setRequestHeader(this.requestHeader);
                                        loader.setWithCredentials(this.withCredentials);
                                        return [4 /*yield*/ , loader.loadAsync(url, onProgress)];
                                    case 1:
                                        text = _a.sent();
                                        json = JSON.parse(text);
                                        metadata = json.metadata;
                                        if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                                            throw new Error('THREE.ObjectLoader: Can\'t load ' + url);
                                        }
                                        return [4 /*yield*/ , scope.parseAsync(json)];
                                    case 2:
                                        return [2 /*return*/ , _a.sent()];
                                }
                            });
                        });
                    };
                    ObjectLoader.prototype.parse = function(json, onLoad) {
                        var animations = this.parseAnimations(json.animations);
                        var shapes = this.parseShapes(json.shapes);
                        var geometries = this.parseGeometries(json.geometries, shapes);
                        var images = this.parseImages(json.images, function() {
                            if (onLoad !== undefined)
                                onLoad(object);
                        });
                        var textures = this.parseTextures(json.textures, images);
                        var materials = this.parseMaterials(json.materials, textures);
                        var object = this.parseObject(json.object, geometries, materials, textures, animations);
                        var skeletons = this.parseSkeletons(json.skeletons, object);
                        this.bindSkeletons(object, skeletons);
                        //
                        if (onLoad !== undefined) {
                            var hasImages = false;
                            for (var uuid in images) {
                                if (images[uuid] instanceof HTMLImageElement) {
                                    hasImages = true;
                                    break;
                                }
                            }
                            if (hasImages === false)
                                onLoad(object);
                        }
                        return object;
                    };
                    ObjectLoader.prototype.parseAsync = function(json) {
                        return __awaiter(this, void 0, void 0, function() {
                            var animations, shapes, geometries, images, textures, materials, object, skeletons;
                            return __generator(this, function(_a) {
                                switch (_a.label) {
                                    case 0:
                                        animations = this.parseAnimations(json.animations);
                                        shapes = this.parseShapes(json.shapes);
                                        geometries = this.parseGeometries(json.geometries, shapes);
                                        return [4 /*yield*/ , this.parseImagesAsync(json.images)];
                                    case 1:
                                        images = _a.sent();
                                        textures = this.parseTextures(json.textures, images);
                                        materials = this.parseMaterials(json.materials, textures);
                                        object = this.parseObject(json.object, geometries, materials, textures, animations);
                                        skeletons = this.parseSkeletons(json.skeletons, object);
                                        this.bindSkeletons(object, skeletons);
                                        return [2 /*return*/ , object];
                                }
                            });
                        });
                    };
                    ObjectLoader.prototype.parseShapes = function(json) {
                        var shapes = {};
                        if (json !== undefined) {
                            for (var i = 0, l = json.length; i < l; i++) {
                                var shape = new Shape().fromJSON(json[i]);
                                shapes[shape.uuid] = shape;
                            }
                        }
                        return shapes;
                    };
                    ObjectLoader.prototype.parseSkeletons = function(json, object) {
                        var skeletons = {};
                        var bones = {};
                        // generate bone lookup table
                        object.traverse(function(child) {
                            if (child.isBone)
                                bones[child.uuid] = child;
                        });
                        // create skeletons
                        if (json !== undefined) {
                            for (var i = 0, l = json.length; i < l; i++) {
                                var skeleton = new Skeleton().fromJSON(json[i], bones);
                                skeletons[skeleton.uuid] = skeleton;
                            }
                        }
                        return skeletons;
                    };
                    ObjectLoader.prototype.parseGeometries = function(json, shapes) {
                        var geometries = {};
                        if (json !== undefined) {
                            var bufferGeometryLoader = new BufferGeometryLoader();
                            for (var i = 0, l = json.length; i < l; i++) {
                                var geometry = void 0;
                                var data = json[i];
                                switch (data.type) {
                                    case 'BufferGeometry':
                                    case 'InstancedBufferGeometry':
                                        geometry = bufferGeometryLoader.parse(data);
                                        break;
                                    case 'Geometry':
                                        console.error('THREE.ObjectLoader: The legacy Geometry type is no longer supported.');
                                        break;
                                    default:
                                        if (data.type in Geometries) {
                                            geometry = Geometries[data.type].fromJSON(data, shapes);
                                        } else {
                                            console.warn("THREE.ObjectLoader: Unsupported geometry type \"".concat(data.type, "\""));
                                        }
                                }
                                geometry.uuid = data.uuid;
                                if (data.name !== undefined)
                                    geometry.name = data.name;
                                if (geometry.isBufferGeometry === true && data.userData !== undefined)
                                    geometry.userData = data.userData;
                                geometries[data.uuid] = geometry;
                            }
                        }
                        return geometries;
                    };
                    ObjectLoader.prototype.parseMaterials = function(json, textures) {
                        var cache = {}; // MultiMaterial
                        var materials = {};
                        if (json !== undefined) {
                            var loader = new MaterialLoader();
                            loader.setTextures(textures);
                            for (var i = 0, l = json.length; i < l; i++) {
                                var data = json[i];
                                if (data.type === 'MultiMaterial') {
                                    // Deprecated
                                    var array = [];
                                    for (var j = 0; j < data.materials.length; j++) {
                                        var material = data.materials[j];
                                        if (cache[material.uuid] === undefined) {
                                            cache[material.uuid] = loader.parse(material);
                                        }
                                        array.push(cache[material.uuid]);
                                    }
                                    materials[data.uuid] = array;
                                } else {
                                    if (cache[data.uuid] === undefined) {
                                        cache[data.uuid] = loader.parse(data);
                                    }
                                    materials[data.uuid] = cache[data.uuid];
                                }
                            }
                        }
                        return materials;
                    };
                    ObjectLoader.prototype.parseAnimations = function(json) {
                        var animations = {};
                        if (json !== undefined) {
                            for (var i = 0; i < json.length; i++) {
                                var data = json[i];
                                var clip = AnimationClip.parse(data);
                                animations[clip.uuid] = clip;
                            }
                        }
                        return animations;
                    };
                    ObjectLoader.prototype.parseImages = function(json, onLoad) {
                        var scope = this;
                        var images = {};
                        var loader;

                        function loadImage(url) {
                            scope.manager.itemStart(url);
                            return loader.load(url, function() {
                                scope.manager.itemEnd(url);
                            }, undefined, function() {
                                scope.manager.itemError(url);
                                scope.manager.itemEnd(url);
                            });
                        }

                        function deserializeImage(image) {
                            if (typeof image === 'string') {
                                var url = image;
                                var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
                                return loadImage(path);
                            } else {
                                if (image.data) {
                                    return {
                                        data: getTypedArray(image.type, image.data),
                                        width: image.width,
                                        height: image.height
                                    };
                                } else {
                                    return null;
                                }
                            }
                        }
                        if (json !== undefined && json.length > 0) {
                            var manager = new LoadingManager(onLoad);
                            loader = new ImageLoader(manager);
                            loader.setCrossOrigin(this.crossOrigin);
                            for (var i = 0, il = json.length; i < il; i++) {
                                var image = json[i];
                                var url = image.url;
                                if (Array.isArray(url)) {
                                    // load array of images e.g CubeTexture
                                    var imageArray = [];
                                    for (var j = 0, jl = url.length; j < jl; j++) {
                                        var currentUrl = url[j];
                                        var deserializedImage = deserializeImage(currentUrl);
                                        if (deserializedImage !== null) {
                                            if (deserializedImage instanceof HTMLImageElement) {
                                                imageArray.push(deserializedImage);
                                            } else {
                                                // special case: handle array of data textures for cube textures
                                                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                                            }
                                        }
                                    }
                                    images[image.uuid] = new Source(imageArray);
                                } else {
                                    // load single image
                                    var deserializedImage = deserializeImage(image.url);
                                    images[image.uuid] = new Source(deserializedImage);
                                }
                            }
                        }
                        return images;
                    };
                    ObjectLoader.prototype.parseImagesAsync = function(json) {
                        return __awaiter(this, void 0, void 0, function() {
                            function deserializeImage(image) {
                                return __awaiter(this, void 0, void 0, function() {
                                    var url, path;
                                    return __generator(this, function(_a) {
                                        switch (_a.label) {
                                            case 0:
                                                if (!(typeof image === 'string')) return [3 /*break*/ , 2];
                                                url = image;
                                                path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
                                                return [4 /*yield*/ , loader.loadAsync(path)];
                                            case 1:
                                                return [2 /*return*/ , _a.sent()];
                                            case 2:
                                                if (image.data) {
                                                    return [2 /*return*/ , {
                                                        data: getTypedArray(image.type, image.data),
                                                        width: image.width,
                                                        height: image.height
                                                    }];
                                                } else {
                                                    return [2 /*return*/ , null];
                                                }
                                                _a.label = 3;
                                            case 3:
                                                return [2 /*return*/ ];
                                        }
                                    });
                                });
                            }
                            var scope, images, loader, i, il, image, url, imageArray, j, jl, currentUrl, deserializedImage, deserializedImage;
                            return __generator(this, function(_a) {
                                switch (_a.label) {
                                    case 0:
                                        scope = this;
                                        images = {};
                                        if (!(json !== undefined && json.length > 0)) return [3 /*break*/ , 9];
                                        loader = new ImageLoader(this.manager);
                                        loader.setCrossOrigin(this.crossOrigin);
                                        i = 0, il = json.length;
                                        _a.label = 1;
                                    case 1:
                                        if (!(i < il)) return [3 /*break*/ , 9];
                                        image = json[i];
                                        url = image.url;
                                        if (!Array.isArray(url)) return [3 /*break*/ , 6];
                                        imageArray = [];
                                        j = 0, jl = url.length;
                                        _a.label = 2;
                                    case 2:
                                        if (!(j < jl)) return [3 /*break*/ , 5];
                                        currentUrl = url[j];
                                        return [4 /*yield*/ , deserializeImage(currentUrl)];
                                    case 3:
                                        deserializedImage = _a.sent();
                                        if (deserializedImage !== null) {
                                            if (deserializedImage instanceof HTMLImageElement) {
                                                imageArray.push(deserializedImage);
                                            } else {
                                                // special case: handle array of data textures for cube textures
                                                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                                            }
                                        }
                                        _a.label = 4;
                                    case 4:
                                        j++;
                                        return [3 /*break*/ , 2];
                                    case 5:
                                        images[image.uuid] = new Source(imageArray);
                                        return [3 /*break*/ , 8];
                                    case 6:
                                        return [4 /*yield*/ , deserializeImage(image.url)];
                                    case 7:
                                        deserializedImage = _a.sent();
                                        images[image.uuid] = new Source(deserializedImage);
                                        _a.label = 8;
                                    case 8:
                                        i++;
                                        return [3 /*break*/ , 1];
                                    case 9:
                                        return [2 /*return*/ , images];
                                }
                            });
                        });
                    };
                    ObjectLoader.prototype.parseTextures = function(json, images) {
                        function parseConstant(value, type) {
                            if (typeof value === 'number')
                                return value;
                            console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
                            return type[value];
                        }
                        var textures = {};
                        if (json !== undefined) {
                            for (var i = 0, l = json.length; i < l; i++) {
                                var data = json[i];
                                if (data.image === undefined) {
                                    console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
                                }
                                if (images[data.image] === undefined) {
                                    console.warn('THREE.ObjectLoader: Undefined image', data.image);
                                }
                                var source = images[data.image];
                                var image = source.data;
                                var texture = void 0;
                                if (Array.isArray(image)) {
                                    texture = new CubeTexture();
                                    if (image.length === 6)
                                        texture.needsUpdate = true;
                                } else {
                                    if (image && image.data) {
                                        texture = new DataTexture();
                                    } else {
                                        texture = new Texture();
                                    }
                                    if (image)
                                        texture.needsUpdate = true; // textures can have undefined image data
                                }
                                texture.source = source;
                                texture.uuid = data.uuid;
                                if (data.name !== undefined)
                                    texture.name = data.name;
                                if (data.mapping !== undefined)
                                    texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
                                if (data.offset !== undefined)
                                    texture.offset.fromArray(data.offset);
                                if (data.repeat !== undefined)
                                    texture.repeat.fromArray(data.repeat);
                                if (data.center !== undefined)
                                    texture.center.fromArray(data.center);
                                if (data.rotation !== undefined)
                                    texture.rotation = data.rotation;
                                if (data.wrap !== undefined) {
                                    texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                                    texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
                                }
                                if (data.format !== undefined)
                                    texture.format = data.format;
                                if (data.type !== undefined)
                                    texture.type = data.type;
                                if (data.encoding !== undefined)
                                    texture.encoding = data.encoding;
                                if (data.minFilter !== undefined)
                                    texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
                                if (data.magFilter !== undefined)
                                    texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
                                if (data.anisotropy !== undefined)
                                    texture.anisotropy = data.anisotropy;
                                if (data.flipY !== undefined)
                                    texture.flipY = data.flipY;
                                if (data.premultiplyAlpha !== undefined)
                                    texture.premultiplyAlpha = data.premultiplyAlpha;
                                if (data.unpackAlignment !== undefined)
                                    texture.unpackAlignment = data.unpackAlignment;
                                if (data.userData !== undefined)
                                    texture.userData = data.userData;
                                textures[data.uuid] = texture;
                            }
                        }
                        return textures;
                    };
                    ObjectLoader.prototype.parseObject = function(data, geometries, materials, textures, animations) {
                        var object;

                        function getGeometry(name) {
                            if (geometries[name] === undefined) {
                                console.warn('THREE.ObjectLoader: Undefined geometry', name);
                            }
                            return geometries[name];
                        }

                        function getMaterial(name) {
                            if (name === undefined)
                                return undefined;
                            if (Array.isArray(name)) {
                                var array = [];
                                for (var i = 0, l = name.length; i < l; i++) {
                                    var uuid = name[i];
                                    if (materials[uuid] === undefined) {
                                        console.warn('THREE.ObjectLoader: Undefined material', uuid);
                                    }
                                    array.push(materials[uuid]);
                                }
                                return array;
                            }
                            if (materials[name] === undefined) {
                                console.warn('THREE.ObjectLoader: Undefined material', name);
                            }
                            return materials[name];
                        }

                        function getTexture(uuid) {
                            if (textures[uuid] === undefined) {
                                console.warn('THREE.ObjectLoader: Undefined texture', uuid);
                            }
                            return textures[uuid];
                        }
                        var geometry, material;
                        switch (data.type) {
                            case 'Scene':
                                object = new Scene();
                                if (data.background !== undefined) {
                                    if (Number.isInteger(data.background)) {
                                        object.background = new Color(data.background);
                                    } else {
                                        object.background = getTexture(data.background);
                                    }
                                }
                                if (data.environment !== undefined) {
                                    object.environment = getTexture(data.environment);
                                }
                                if (data.fog !== undefined) {
                                    if (data.fog.type === 'Fog') {
                                        object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
                                    } else if (data.fog.type === 'FogExp2') {
                                        object.fog = new FogExp2(data.fog.color, data.fog.density);
                                    }
                                }
                                break;
                            case 'PerspectiveCamera':
                                object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                                if (data.focus !== undefined)
                                    object.focus = data.focus;
                                if (data.zoom !== undefined)
                                    object.zoom = data.zoom;
                                if (data.filmGauge !== undefined)
                                    object.filmGauge = data.filmGauge;
                                if (data.filmOffset !== undefined)
                                    object.filmOffset = data.filmOffset;
                                if (data.view !== undefined)
                                    object.view = Object.assign({}, data.view);
                                break;
                            case 'OrthographicCamera':
                                object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                                if (data.zoom !== undefined)
                                    object.zoom = data.zoom;
                                if (data.view !== undefined)
                                    object.view = Object.assign({}, data.view);
                                break;
                            case 'AmbientLight':
                                object = new AmbientLight(data.color, data.intensity);
                                break;
                            case 'DirectionalLight':
                                object = new DirectionalLight(data.color, data.intensity);
                                break;
                            case 'PointLight':
                                object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                                break;
                            case 'RectAreaLight':
                                object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                                break;
                            case 'SpotLight':
                                object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                                break;
                            case 'HemisphereLight':
                                object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                                break;
                            case 'LightProbe':
                                object = new LightProbe().fromJSON(data);
                                break;
                            case 'SkinnedMesh':
                                geometry = getGeometry(data.geometry);
                                material = getMaterial(data.material);
                                object = new SkinnedMesh(geometry, material);
                                if (data.bindMode !== undefined)
                                    object.bindMode = data.bindMode;
                                if (data.bindMatrix !== undefined)
                                    object.bindMatrix.fromArray(data.bindMatrix);
                                if (data.skeleton !== undefined)
                                    object.skeleton = data.skeleton;
                                break;
                            case 'Mesh':
                                geometry = getGeometry(data.geometry);
                                material = getMaterial(data.material);
                                object = new Mesh(geometry, material);
                                break;
                            case 'InstancedMesh':
                                geometry = getGeometry(data.geometry);
                                material = getMaterial(data.material);
                                var count = data.count;
                                var instanceMatrix = data.instanceMatrix;
                                var instanceColor = data.instanceColor;
                                object = new InstancedMesh(geometry, material, count);
                                object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
                                if (instanceColor !== undefined)
                                    object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
                                break;
                            case 'LOD':
                                object = new LOD();
                                break;
                            case 'Line':
                                object = new Line(getGeometry(data.geometry), getMaterial(data.material));
                                break;
                            case 'LineLoop':
                                object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                                break;
                            case 'LineSegments':
                                object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                                break;
                            case 'PointCloud':
                            case 'Points':
                                object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                                break;
                            case 'Sprite':
                                object = new Sprite(getMaterial(data.material));
                                break;
                            case 'Group':
                                object = new Group();
                                break;
                            case 'Bone':
                                object = new Bone();
                                break;
                            default:
                                object = new Object3D();
                        }
                        object.uuid = data.uuid;
                        if (data.name !== undefined)
                            object.name = data.name;
                        if (data.matrix !== undefined) {
                            object.matrix.fromArray(data.matrix);
                            if (data.matrixAutoUpdate !== undefined)
                                object.matrixAutoUpdate = data.matrixAutoUpdate;
                            if (object.matrixAutoUpdate)
                                object.matrix.decompose(object.position, object.quaternion, object.scale);
                        } else {
                            if (data.position !== undefined)
                                object.position.fromArray(data.position);
                            if (data.rotation !== undefined)
                                object.rotation.fromArray(data.rotation);
                            if (data.quaternion !== undefined)
                                object.quaternion.fromArray(data.quaternion);
                            if (data.scale !== undefined)
                                object.scale.fromArray(data.scale);
                        }
                        if (data.castShadow !== undefined)
                            object.castShadow = data.castShadow;
                        if (data.receiveShadow !== undefined)
                            object.receiveShadow = data.receiveShadow;
                        if (data.shadow) {
                            if (data.shadow.bias !== undefined)
                                object.shadow.bias = data.shadow.bias;
                            if (data.shadow.normalBias !== undefined)
                                object.shadow.normalBias = data.shadow.normalBias;
                            if (data.shadow.radius !== undefined)
                                object.shadow.radius = data.shadow.radius;
                            if (data.shadow.mapSize !== undefined)
                                object.shadow.mapSize.fromArray(data.shadow.mapSize);
                            if (data.shadow.camera !== undefined)
                                object.shadow.camera = this.parseObject(data.shadow.camera);
                        }
                        if (data.visible !== undefined)
                            object.visible = data.visible;
                        if (data.frustumCulled !== undefined)
                            object.frustumCulled = data.frustumCulled;
                        if (data.renderOrder !== undefined)
                            object.renderOrder = data.renderOrder;
                        if (data.userData !== undefined)
                            object.userData = data.userData;
                        if (data.layers !== undefined)
                            object.layers.mask = data.layers;
                        if (data.children !== undefined) {
                            var children = data.children;
                            for (var i = 0; i < children.length; i++) {
                                object.add(this.parseObject(children[i], geometries, materials, textures, animations));
                            }
                        }
                        if (data.animations !== undefined) {
                            var objectAnimations = data.animations;
                            for (var i = 0; i < objectAnimations.length; i++) {
                                var uuid = objectAnimations[i];
                                object.animations.push(animations[uuid]);
                            }
                        }
                        if (data.type === 'LOD') {
                            if (data.autoUpdate !== undefined)
                                object.autoUpdate = data.autoUpdate;
                            var levels = data.levels;
                            for (var l = 0; l < levels.length; l++) {
                                var level = levels[l];
                                var child = object.getObjectByProperty('uuid', level.object);
                                if (child !== undefined) {
                                    object.addLevel(child, level.distance);
                                }
                            }
                        }
                        return object;
                    };
                    ObjectLoader.prototype.bindSkeletons = function(object, skeletons) {
                        if (Object.keys(skeletons).length === 0)
                            return;
                        object.traverse(function(child) {
                            if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
                                var skeleton = skeletons[child.skeleton];
                                if (skeleton === undefined) {
                                    console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
                                } else {
                                    child.bind(skeleton, child.bindMatrix);
                                }
                            }
                        });
                    };
                    /* DEPRECATED */
                    ObjectLoader.prototype.setTexturePath = function(value) {
                        console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
                        return this.setResourcePath(value);
                    };
                    return ObjectLoader;
                }(Loader));
                var TEXTURE_MAPPING = {
                    UVMapping: UVMapping,
                    CubeReflectionMapping: CubeReflectionMapping,
                    CubeRefractionMapping: CubeRefractionMapping,
                    EquirectangularReflectionMapping: EquirectangularReflectionMapping,
                    EquirectangularRefractionMapping: EquirectangularRefractionMapping,
                    CubeUVReflectionMapping: CubeUVReflectionMapping
                };
                var TEXTURE_WRAPPING = {
                    RepeatWrapping: RepeatWrapping,
                    ClampToEdgeWrapping: ClampToEdgeWrapping,
                    MirroredRepeatWrapping: MirroredRepeatWrapping
                };
                var TEXTURE_FILTER = {
                    NearestFilter: NearestFilter,
                    NearestMipmapNearestFilter: NearestMipmapNearestFilter,
                    NearestMipmapLinearFilter: NearestMipmapLinearFilter,
                    LinearFilter: LinearFilter,
                    LinearMipmapNearestFilter: LinearMipmapNearestFilter,
                    LinearMipmapLinearFilter: LinearMipmapLinearFilter
                };
                var ImageBitmapLoader = /** @class */ (function(_super) {
                    __extends(ImageBitmapLoader, _super);

                    function ImageBitmapLoader(manager) {
                        var _this_1 = _super.call(this, manager) || this;
                        if (typeof createImageBitmap === 'undefined') {
                            console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
                        }
                        if (typeof fetch === 'undefined') {
                            console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
                        }
                        _this_1.options = {
                            premultiplyAlpha: 'none'
                        };
                        return _this_1;
                    }
                    ImageBitmapLoader.prototype.setOptions = function(options) {
                        this.options = options;
                        return this;
                    };
                    ImageBitmapLoader.prototype.load = function(url, onLoad, onProgress, onError) {
                        if (url === undefined)
                            url = '';
                        if (this.path !== undefined)
                            url = this.path + url;
                        url = this.manager.resolveURL(url);
                        var scope = this;
                        var cached = Cache.get(url);
                        if (cached !== undefined) {
                            scope.manager.itemStart(url);
                            setTimeout(function() {
                                if (onLoad)
                                    onLoad(cached);
                                scope.manager.itemEnd(url);
                            }, 0);
                            return cached;
                        }
                        var fetchOptions = {};
                        fetchOptions.credentials = (this.crossOrigin === 'anonymous') ? 'same-origin' : 'include';
                        fetchOptions.headers = this.requestHeader;
                        fetch(url, fetchOptions).then(function(res) {
                            return res.blob();
                        }).then(function(blob) {
                            return createImageBitmap(blob, Object.assign(scope.options, {
                                colorSpaceConversion: 'none'
                            }));
                        }).then(function(imageBitmap) {
                            Cache.add(url, imageBitmap);
                            if (onLoad)
                                onLoad(imageBitmap);
                            scope.manager.itemEnd(url);
                        }).catch(function(e) {
                            if (onError)
                                onError(e);
                            scope.manager.itemError(url);
                            scope.manager.itemEnd(url);
                        });
                        scope.manager.itemStart(url);
                    };
                    return ImageBitmapLoader;
                }(Loader));
                ImageBitmapLoader.prototype.isImageBitmapLoader = true;
                var _context;
                var AudioContext = {
                    getContext: function() {
                        if (_context === undefined) {
                            _context = new(window.AudioContext || window.webkitAudioContext)();
                        }
                        return _context;
                    },
                    setContext: function(value) {
                        _context = value;
                    }
                };
                var AudioLoader = /** @class */ (function(_super) {
                    __extends(AudioLoader, _super);

                    function AudioLoader(manager) {
                        return _super.call(this, manager) || this;
                    }
                    AudioLoader.prototype.load = function(url, onLoad, onProgress, onError) {
                        var scope = this;
                        var loader = new FileLoader(this.manager);
                        loader.setResponseType('arraybuffer');
                        loader.setPath(this.path);
                        loader.setRequestHeader(this.requestHeader);
                        loader.setWithCredentials(this.withCredentials);
                        loader.load(url, function(buffer) {
                            try {
                                // Create a copy of the buffer. The `decodeAudioData` method
                                // detaches the buffer when complete, preventing reuse.
                                var bufferCopy = buffer.slice(0);
                                var context = AudioContext.getContext();
                                context.decodeAudioData(bufferCopy, function(audioBuffer) {
                                    onLoad(audioBuffer);
                                });
                            } catch (e) {
                                if (onError) {
                                    onError(e);
                                } else {
                                    console.error(e);
                                }
                                scope.manager.itemError(url);
                            }
                        }, onProgress, onError);
                    };
                    return AudioLoader;
                }(Loader));
                var HemisphereLightProbe = /** @class */ (function(_super) {
                    __extends(HemisphereLightProbe, _super);

                    function HemisphereLightProbe(skyColor, groundColor, intensity) {
                        if (intensity === void 0) {
                            intensity = 1;
                        }
                        var _this_1 = _super.call(this, undefined, intensity) || this;
                        var color1 = new Color().set(skyColor);
                        var color2 = new Color().set(groundColor);
                        var sky = new Vector3(color1.r, color1.g, color1.b);
                        var ground = new Vector3(color2.r, color2.g, color2.b);
                        // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
                        var c0 = Math.sqrt(Math.PI);
                        var c1 = c0 * Math.sqrt(0.75);
                        _this_1.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
                        _this_1.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
                        return _this_1;
                    }
                    return HemisphereLightProbe;
                }(LightProbe));
                HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
                var AmbientLightProbe = /** @class */ (function(_super) {
                    __extends(AmbientLightProbe, _super);

                    function AmbientLightProbe(color, intensity) {
                        if (intensity === void 0) {
                            intensity = 1;
                        }
                        var _this_1 = _super.call(this, undefined, intensity) || this;
                        var color1 = new Color().set(color);
                        // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
                        _this_1.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
                        return _this_1;
                    }
                    return AmbientLightProbe;
                }(LightProbe));
                AmbientLightProbe.prototype.isAmbientLightProbe = true;
                var _eyeRight = /*@__PURE__*/ new Matrix4();
                var _eyeLeft = /*@__PURE__*/ new Matrix4();
                var _projectionMatrix = /*@__PURE__*/ new Matrix4();
                var StereoCamera = /** @class */ (function() {
                    function StereoCamera() {
                        this.type = 'StereoCamera';
                        this.aspect = 1;
                        this.eyeSep = 0.064;
                        this.cameraL = new PerspectiveCamera();
                        this.cameraL.layers.enable(1);
                        this.cameraL.matrixAutoUpdate = false;
                        this.cameraR = new PerspectiveCamera();
                        this.cameraR.layers.enable(2);
                        this.cameraR.matrixAutoUpdate = false;
                        this._cache = {
                            focus: null,
                            fov: null,
                            aspect: null,
                            near: null,
                            far: null,
                            zoom: null,
                            eyeSep: null
                        };
                    }
                    StereoCamera.prototype.update = function(camera) {
                        var cache = this._cache;
                        var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
                            cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
                            cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
                        if (needsUpdate) {
                            cache.focus = camera.focus;
                            cache.fov = camera.fov;
                            cache.aspect = camera.aspect * this.aspect;
                            cache.near = camera.near;
                            cache.far = camera.far;
                            cache.zoom = camera.zoom;
                            cache.eyeSep = this.eyeSep;
                            // Off-axis stereoscopic effect based on
                            // http://paulbourke.net/stereographics/stereorender/
                            _projectionMatrix.copy(camera.projectionMatrix);
                            var eyeSepHalf = cache.eyeSep / 2;
                            var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
                            var ymax = (cache.near * Math.tan(DEG2RAD * cache.fov * 0.5)) / cache.zoom;
                            var xmin = void 0,
                                xmax = void 0;
                            // translate xOffset
                            _eyeLeft.elements[12] = -eyeSepHalf;
                            _eyeRight.elements[12] = eyeSepHalf;
                            // for left eye
                            xmin = -ymax * cache.aspect + eyeSepOnProjection;
                            xmax = ymax * cache.aspect + eyeSepOnProjection;
                            _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
                            _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                            this.cameraL.projectionMatrix.copy(_projectionMatrix);
                            // for right eye
                            xmin = -ymax * cache.aspect - eyeSepOnProjection;
                            xmax = ymax * cache.aspect - eyeSepOnProjection;
                            _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
                            _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                            this.cameraR.projectionMatrix.copy(_projectionMatrix);
                        }
                        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
                        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
                    };
                    return StereoCamera;
                }());
                var Clock = /** @class */ (function() {
                    function Clock(autoStart) {
                        if (autoStart === void 0) {
                            autoStart = true;
                        }
                        this.autoStart = autoStart;
                        this.startTime = 0;
                        this.oldTime = 0;
                        this.elapsedTime = 0;
                        this.running = false;
                    }
                    Clock.prototype.start = function() {
                        this.startTime = now();
                        this.oldTime = this.startTime;
                        this.elapsedTime = 0;
                        this.running = true;
                    };
                    Clock.prototype.stop = function() {
                        this.getElapsedTime();
                        this.running = false;
                        this.autoStart = false;
                    };
                    Clock.prototype.getElapsedTime = function() {
                        this.getDelta();
                        return this.elapsedTime;
                    };
                    Clock.prototype.getDelta = function() {
                        var diff = 0;
                        if (this.autoStart && !this.running) {
                            this.start();
                            return 0;
                        }
                        if (this.running) {
                            var newTime = now();
                            diff = (newTime - this.oldTime) / 1000;
                            this.oldTime = newTime;
                            this.elapsedTime += diff;
                        }
                        return diff;
                    };
                    return Clock;
                }());

                function now() {
                    return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
                }
                var _position$1 = /*@__PURE__*/ new Vector3();
                var _quaternion$1 = /*@__PURE__*/ new Quaternion();
                var _scale$1 = /*@__PURE__*/ new Vector3();
                var _orientation$1 = /*@__PURE__*/ new Vector3();
                var AudioListener = /** @class */ (function(_super) {
                    __extends(AudioListener, _super);

                    function AudioListener() {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'AudioListener';
                        _this_1.context = AudioContext.getContext();
                        _this_1.gain = _this_1.context.createGain();
                        _this_1.gain.connect(_this_1.context.destination);
                        _this_1.filter = null;
                        _this_1.timeDelta = 0;
                        // private
                        _this_1._clock = new Clock();
                        return _this_1;
                    }
                    AudioListener.prototype.getInput = function() {
                        return this.gain;
                    };
                    AudioListener.prototype.removeFilter = function() {
                        if (this.filter !== null) {
                            this.gain.disconnect(this.filter);
                            this.filter.disconnect(this.context.destination);
                            this.gain.connect(this.context.destination);
                            this.filter = null;
                        }
                        return this;
                    };
                    AudioListener.prototype.getFilter = function() {
                        return this.filter;
                    };
                    AudioListener.prototype.setFilter = function(value) {
                        if (this.filter !== null) {
                            this.gain.disconnect(this.filter);
                            this.filter.disconnect(this.context.destination);
                        } else {
                            this.gain.disconnect(this.context.destination);
                        }
                        this.filter = value;
                        this.gain.connect(this.filter);
                        this.filter.connect(this.context.destination);
                        return this;
                    };
                    AudioListener.prototype.getMasterVolume = function() {
                        return this.gain.gain.value;
                    };
                    AudioListener.prototype.setMasterVolume = function(value) {
                        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
                        return this;
                    };
                    AudioListener.prototype.updateMatrixWorld = function(force) {
                        _super.prototype.updateMatrixWorld.call(this, force);
                        var listener = this.context.listener;
                        var up = this.up;
                        this.timeDelta = this._clock.getDelta();
                        this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
                        _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
                        if (listener.positionX) {
                            // code path for Chrome (see #14393)
                            var endTime = this.context.currentTime + this.timeDelta;
                            listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
                            listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
                            listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
                            listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
                            listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
                            listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
                            listener.upX.linearRampToValueAtTime(up.x, endTime);
                            listener.upY.linearRampToValueAtTime(up.y, endTime);
                            listener.upZ.linearRampToValueAtTime(up.z, endTime);
                        } else {
                            listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
                            listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
                        }
                    };
                    return AudioListener;
                }(Object3D));
                var Audio = /** @class */ (function(_super) {
                    __extends(Audio, _super);

                    function Audio(listener) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'Audio';
                        _this_1.listener = listener;
                        _this_1.context = listener.context;
                        _this_1.gain = _this_1.context.createGain();
                        _this_1.gain.connect(listener.getInput());
                        _this_1.autoplay = false;
                        _this_1.buffer = null;
                        _this_1.detune = 0;
                        _this_1.loop = false;
                        _this_1.loopStart = 0;
                        _this_1.loopEnd = 0;
                        _this_1.offset = 0;
                        _this_1.duration = undefined;
                        _this_1.playbackRate = 1;
                        _this_1.isPlaying = false;
                        _this_1.hasPlaybackControl = true;
                        _this_1.source = null;
                        _this_1.sourceType = 'empty';
                        _this_1._startedAt = 0;
                        _this_1._progress = 0;
                        _this_1._connected = false;
                        _this_1.filters = [];
                        return _this_1;
                    }
                    Audio.prototype.getOutput = function() {
                        return this.gain;
                    };
                    Audio.prototype.setNodeSource = function(audioNode) {
                        this.hasPlaybackControl = false;
                        this.sourceType = 'audioNode';
                        this.source = audioNode;
                        this.connect();
                        return this;
                    };
                    Audio.prototype.setMediaElementSource = function(mediaElement) {
                        this.hasPlaybackControl = false;
                        this.sourceType = 'mediaNode';
                        this.source = this.context.createMediaElementSource(mediaElement);
                        this.connect();
                        return this;
                    };
                    Audio.prototype.setMediaStreamSource = function(mediaStream) {
                        this.hasPlaybackControl = false;
                        this.sourceType = 'mediaStreamNode';
                        this.source = this.context.createMediaStreamSource(mediaStream);
                        this.connect();
                        return this;
                    };
                    Audio.prototype.setBuffer = function(audioBuffer) {
                        this.buffer = audioBuffer;
                        this.sourceType = 'buffer';
                        if (this.autoplay)
                            this.play();
                        return this;
                    };
                    Audio.prototype.play = function(delay) {
                        if (delay === void 0) {
                            delay = 0;
                        }
                        if (this.isPlaying === true) {
                            console.warn('THREE.Audio: Audio is already playing.');
                            return;
                        }
                        if (this.hasPlaybackControl === false) {
                            console.warn('THREE.Audio: this Audio has no playback control.');
                            return;
                        }
                        this._startedAt = this.context.currentTime + delay;
                        var source = this.context.createBufferSource();
                        source.buffer = this.buffer;
                        source.loop = this.loop;
                        source.loopStart = this.loopStart;
                        source.loopEnd = this.loopEnd;
                        source.onended = this.onEnded.bind(this);
                        source.start(this._startedAt, this._progress + this.offset, this.duration);
                        this.isPlaying = true;
                        this.source = source;
                        this.setDetune(this.detune);
                        this.setPlaybackRate(this.playbackRate);
                        return this.connect();
                    };
                    Audio.prototype.pause = function() {
                        if (this.hasPlaybackControl === false) {
                            console.warn('THREE.Audio: this Audio has no playback control.');
                            return;
                        }
                        if (this.isPlaying === true) {
                            // update current progress
                            this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
                            if (this.loop === true) {
                                // ensure _progress does not exceed duration with looped audios
                                this._progress = this._progress % (this.duration || this.buffer.duration);
                            }
                            this.source.stop();
                            this.source.onended = null;
                            this.isPlaying = false;
                        }
                        return this;
                    };
                    Audio.prototype.stop = function() {
                        if (this.hasPlaybackControl === false) {
                            console.warn('THREE.Audio: this Audio has no playback control.');
                            return;
                        }
                        this._progress = 0;
                        this.source.stop();
                        this.source.onended = null;
                        this.isPlaying = false;
                        return this;
                    };
                    Audio.prototype.connect = function() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (var i = 1, l = this.filters.length; i < l; i++) {
                                this.filters[i - 1].connect(this.filters[i]);
                            }
                            this.filters[this.filters.length - 1].connect(this.getOutput());
                        } else {
                            this.source.connect(this.getOutput());
                        }
                        this._connected = true;
                        return this;
                    };
                    Audio.prototype.disconnect = function() {
                        if (this.filters.length > 0) {
                            this.source.disconnect(this.filters[0]);
                            for (var i = 1, l = this.filters.length; i < l; i++) {
                                this.filters[i - 1].disconnect(this.filters[i]);
                            }
                            this.filters[this.filters.length - 1].disconnect(this.getOutput());
                        } else {
                            this.source.disconnect(this.getOutput());
                        }
                        this._connected = false;
                        return this;
                    };
                    Audio.prototype.getFilters = function() {
                        return this.filters;
                    };
                    Audio.prototype.setFilters = function(value) {
                        if (!value)
                            value = [];
                        if (this._connected === true) {
                            this.disconnect();
                            this.filters = value.slice();
                            this.connect();
                        } else {
                            this.filters = value.slice();
                        }
                        return this;
                    };
                    Audio.prototype.setDetune = function(value) {
                        this.detune = value;
                        if (this.source.detune === undefined)
                            return; // only set detune when available
                        if (this.isPlaying === true) {
                            this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
                        }
                        return this;
                    };
                    Audio.prototype.getDetune = function() {
                        return this.detune;
                    };
                    Audio.prototype.getFilter = function() {
                        return this.getFilters()[0];
                    };
                    Audio.prototype.setFilter = function(filter) {
                        return this.setFilters(filter ? [filter] : []);
                    };
                    Audio.prototype.setPlaybackRate = function(value) {
                        if (this.hasPlaybackControl === false) {
                            console.warn('THREE.Audio: this Audio has no playback control.');
                            return;
                        }
                        this.playbackRate = value;
                        if (this.isPlaying === true) {
                            this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
                        }
                        return this;
                    };
                    Audio.prototype.getPlaybackRate = function() {
                        return this.playbackRate;
                    };
                    Audio.prototype.onEnded = function() {
                        this.isPlaying = false;
                    };
                    Audio.prototype.getLoop = function() {
                        if (this.hasPlaybackControl === false) {
                            console.warn('THREE.Audio: this Audio has no playback control.');
                            return false;
                        }
                        return this.loop;
                    };
                    Audio.prototype.setLoop = function(value) {
                        if (this.hasPlaybackControl === false) {
                            console.warn('THREE.Audio: this Audio has no playback control.');
                            return;
                        }
                        this.loop = value;
                        if (this.isPlaying === true) {
                            this.source.loop = this.loop;
                        }
                        return this;
                    };
                    Audio.prototype.setLoopStart = function(value) {
                        this.loopStart = value;
                        return this;
                    };
                    Audio.prototype.setLoopEnd = function(value) {
                        this.loopEnd = value;
                        return this;
                    };
                    Audio.prototype.getVolume = function() {
                        return this.gain.gain.value;
                    };
                    Audio.prototype.setVolume = function(value) {
                        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
                        return this;
                    };
                    return Audio;
                }(Object3D));
                var _position = /*@__PURE__*/ new Vector3();
                var _quaternion = /*@__PURE__*/ new Quaternion();
                var _scale = /*@__PURE__*/ new Vector3();
                var _orientation = /*@__PURE__*/ new Vector3();
                var PositionalAudio = /** @class */ (function(_super) {
                    __extends(PositionalAudio, _super);

                    function PositionalAudio(listener) {
                        var _this_1 = _super.call(this, listener) || this;
                        _this_1.panner = _this_1.context.createPanner();
                        _this_1.panner.panningModel = 'HRTF';
                        _this_1.panner.connect(_this_1.gain);
                        return _this_1;
                    }
                    PositionalAudio.prototype.disconnect = function() {
                        _super.prototype.disconnect.call(this);
                        this.panner.disconnect(this.gain);
                    };
                    PositionalAudio.prototype.getOutput = function() {
                        return this.panner;
                    };
                    PositionalAudio.prototype.getRefDistance = function() {
                        return this.panner.refDistance;
                    };
                    PositionalAudio.prototype.setRefDistance = function(value) {
                        this.panner.refDistance = value;
                        return this;
                    };
                    PositionalAudio.prototype.getRolloffFactor = function() {
                        return this.panner.rolloffFactor;
                    };
                    PositionalAudio.prototype.setRolloffFactor = function(value) {
                        this.panner.rolloffFactor = value;
                        return this;
                    };
                    PositionalAudio.prototype.getDistanceModel = function() {
                        return this.panner.distanceModel;
                    };
                    PositionalAudio.prototype.setDistanceModel = function(value) {
                        this.panner.distanceModel = value;
                        return this;
                    };
                    PositionalAudio.prototype.getMaxDistance = function() {
                        return this.panner.maxDistance;
                    };
                    PositionalAudio.prototype.setMaxDistance = function(value) {
                        this.panner.maxDistance = value;
                        return this;
                    };
                    PositionalAudio.prototype.setDirectionalCone = function(coneInnerAngle, coneOuterAngle, coneOuterGain) {
                        this.panner.coneInnerAngle = coneInnerAngle;
                        this.panner.coneOuterAngle = coneOuterAngle;
                        this.panner.coneOuterGain = coneOuterGain;
                        return this;
                    };
                    PositionalAudio.prototype.updateMatrixWorld = function(force) {
                        _super.prototype.updateMatrixWorld.call(this, force);
                        if (this.hasPlaybackControl === true && this.isPlaying === false)
                            return;
                        this.matrixWorld.decompose(_position, _quaternion, _scale);
                        _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
                        var panner = this.panner;
                        if (panner.positionX) {
                            // code path for Chrome and Firefox (see #14393)
                            var endTime = this.context.currentTime + this.listener.timeDelta;
                            panner.positionX.linearRampToValueAtTime(_position.x, endTime);
                            panner.positionY.linearRampToValueAtTime(_position.y, endTime);
                            panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
                            panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
                            panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
                            panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
                        } else {
                            panner.setPosition(_position.x, _position.y, _position.z);
                            panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
                        }
                    };
                    return PositionalAudio;
                }(Audio));
                var AudioAnalyser = /** @class */ (function() {
                    function AudioAnalyser(audio, fftSize) {
                        if (fftSize === void 0) {
                            fftSize = 2048;
                        }
                        this.analyser = audio.context.createAnalyser();
                        this.analyser.fftSize = fftSize;
                        this.data = new Uint8Array(this.analyser.frequencyBinCount);
                        audio.getOutput().connect(this.analyser);
                    }
                    AudioAnalyser.prototype.getFrequencyData = function() {
                        this.analyser.getByteFrequencyData(this.data);
                        return this.data;
                    };
                    AudioAnalyser.prototype.getAverageFrequency = function() {
                        var value = 0;
                        var data = this.getFrequencyData();
                        for (var i = 0; i < data.length; i++) {
                            value += data[i];
                        }
                        return value / data.length;
                    };
                    return AudioAnalyser;
                }());
                var PropertyMixer = /** @class */ (function() {
                    function PropertyMixer(binding, typeName, valueSize) {
                        this.binding = binding;
                        this.valueSize = valueSize;
                        var mixFunction, mixFunctionAdditive, setIdentity;
                        // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
                        //
                        // interpolators can use .buffer as their .result
                        // the data then goes to 'incoming'
                        //
                        // 'accu0' and 'accu1' are used frame-interleaved for
                        // the cumulative result and are compared to detect
                        // changes
                        //
                        // 'orig' stores the original state of the property
                        //
                        // 'add' is used for additive cumulative results
                        //
                        // 'work' is optional and is only present for quaternion types. It is used
                        // to store intermediate quaternion multiplication results
                        switch (typeName) {
                            case 'quaternion':
                                mixFunction = this._slerp;
                                mixFunctionAdditive = this._slerpAdditive;
                                setIdentity = this._setAdditiveIdentityQuaternion;
                                this.buffer = new Float64Array(valueSize * 6);
                                this._workIndex = 5;
                                break;
                            case 'string':
                            case 'bool':
                                mixFunction = this._select;
                                // Use the regular mix function and for additive on these types,
                                // additive is not relevant for non-numeric types
                                mixFunctionAdditive = this._select;
                                setIdentity = this._setAdditiveIdentityOther;
                                this.buffer = new Array(valueSize * 5);
                                break;
                            default:
                                mixFunction = this._lerp;
                                mixFunctionAdditive = this._lerpAdditive;
                                setIdentity = this._setAdditiveIdentityNumeric;
                                this.buffer = new Float64Array(valueSize * 5);
                        }
                        this._mixBufferRegion = mixFunction;
                        this._mixBufferRegionAdditive = mixFunctionAdditive;
                        this._setIdentity = setIdentity;
                        this._origIndex = 3;
                        this._addIndex = 4;
                        this.cumulativeWeight = 0;
                        this.cumulativeWeightAdditive = 0;
                        this.useCount = 0;
                        this.referenceCount = 0;
                    }
                    // accumulate data in the 'incoming' region into 'accu<i>'
                    PropertyMixer.prototype.accumulate = function(accuIndex, weight) {
                        // note: happily accumulating nothing when weight = 0, the caller knows
                        // the weight and shouldn't have made the call in the first place
                        var buffer = this.buffer,
                            stride = this.valueSize,
                            offset = accuIndex * stride + stride;
                        var currentWeight = this.cumulativeWeight;
                        if (currentWeight === 0) {
                            // accuN := incoming * weight
                            for (var i = 0; i !== stride; ++i) {
                                buffer[offset + i] = buffer[i];
                            }
                            currentWeight = weight;
                        } else {
                            // accuN := accuN + incoming * weight
                            currentWeight += weight;
                            var mix = weight / currentWeight;
                            this._mixBufferRegion(buffer, offset, 0, mix, stride);
                        }
                        this.cumulativeWeight = currentWeight;
                    };
                    // accumulate data in the 'incoming' region into 'add'
                    PropertyMixer.prototype.accumulateAdditive = function(weight) {
                        var buffer = this.buffer,
                            stride = this.valueSize,
                            offset = stride * this._addIndex;
                        if (this.cumulativeWeightAdditive === 0) {
                            // add = identity
                            this._setIdentity();
                        }
                        // add := add + incoming * weight
                        this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
                        this.cumulativeWeightAdditive += weight;
                    };
                    // apply the state of 'accu<i>' to the binding when accus differ
                    PropertyMixer.prototype.apply = function(accuIndex) {
                        var stride = this.valueSize,
                            buffer = this.buffer,
                            offset = accuIndex * stride + stride,
                            weight = this.cumulativeWeight,
                            weightAdditive = this.cumulativeWeightAdditive,
                            binding = this.binding;
                        this.cumulativeWeight = 0;
                        this.cumulativeWeightAdditive = 0;
                        if (weight < 1) {
                            // accuN := accuN + original * ( 1 - cumulativeWeight )
                            var originalValueOffset = stride * this._origIndex;
                            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
                        }
                        if (weightAdditive > 0) {
                            // accuN := accuN + additive accuN
                            this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
                        }
                        for (var i = stride, e = stride + stride; i !== e; ++i) {
                            if (buffer[i] !== buffer[i + stride]) {
                                // value has changed -> update scene graph
                                binding.setValue(buffer, offset);
                                break;
                            }
                        }
                    };
                    // remember the state of the bound property and copy it to both accus
                    PropertyMixer.prototype.saveOriginalState = function() {
                        var binding = this.binding;
                        var buffer = this.buffer,
                            stride = this.valueSize,
                            originalValueOffset = stride * this._origIndex;
                        binding.getValue(buffer, originalValueOffset);
                        // accu[0..1] := orig -- initially detect changes against the original
                        for (var i = stride, e = originalValueOffset; i !== e; ++i) {
                            buffer[i] = buffer[originalValueOffset + (i % stride)];
                        }
                        // Add to identity for additive
                        this._setIdentity();
                        this.cumulativeWeight = 0;
                        this.cumulativeWeightAdditive = 0;
                    };
                    // apply the state previously taken via 'saveOriginalState' to the binding
                    PropertyMixer.prototype.restoreOriginalState = function() {
                        var originalValueOffset = this.valueSize * 3;
                        this.binding.setValue(this.buffer, originalValueOffset);
                    };
                    PropertyMixer.prototype._setAdditiveIdentityNumeric = function() {
                        var startIndex = this._addIndex * this.valueSize;
                        var endIndex = startIndex + this.valueSize;
                        for (var i = startIndex; i < endIndex; i++) {
                            this.buffer[i] = 0;
                        }
                    };
                    PropertyMixer.prototype._setAdditiveIdentityQuaternion = function() {
                        this._setAdditiveIdentityNumeric();
                        this.buffer[this._addIndex * this.valueSize + 3] = 1;
                    };
                    PropertyMixer.prototype._setAdditiveIdentityOther = function() {
                        var startIndex = this._origIndex * this.valueSize;
                        var targetIndex = this._addIndex * this.valueSize;
                        for (var i = 0; i < this.valueSize; i++) {
                            this.buffer[targetIndex + i] = this.buffer[startIndex + i];
                        }
                    };
                    // mix functions
                    PropertyMixer.prototype._select = function(buffer, dstOffset, srcOffset, t, stride) {
                        if (t >= 0.5) {
                            for (var i = 0; i !== stride; ++i) {
                                buffer[dstOffset + i] = buffer[srcOffset + i];
                            }
                        }
                    };
                    PropertyMixer.prototype._slerp = function(buffer, dstOffset, srcOffset, t) {
                        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
                    };
                    PropertyMixer.prototype._slerpAdditive = function(buffer, dstOffset, srcOffset, t, stride) {
                        var workOffset = this._workIndex * stride;
                        // Store result in intermediate buffer offset
                        Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
                        // Slerp to the intermediate result
                        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
                    };
                    PropertyMixer.prototype._lerp = function(buffer, dstOffset, srcOffset, t, stride) {
                        var s = 1 - t;
                        for (var i = 0; i !== stride; ++i) {
                            var j = dstOffset + i;
                            buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
                        }
                    };
                    PropertyMixer.prototype._lerpAdditive = function(buffer, dstOffset, srcOffset, t, stride) {
                        for (var i = 0; i !== stride; ++i) {
                            var j = dstOffset + i;
                            buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
                        }
                    };
                    return PropertyMixer;
                }());
                // Characters [].:/ are reserved for track binding syntax.
                var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
                var _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');
                // Attempts to allow node names from any language. ES5's `\w` regexp matches
                // only latin characters, and the unicode \p{L} is not yet supported. So
                // instead, we exclude reserved characters and match everything else.
                var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
                var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';
                // Parent directories, delimited by '/' or ':'. Currently unused, but must
                // be matched to parse the rest of the track name.
                var _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar);
                // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
                var _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);
                // Object on target node, and accessor. May not contain reserved
                // characters. Accessor may contain any character except closing bracket.
                var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);
                // Property and accessor. May not contain reserved characters. Accessor may
                // contain any non-bracket characters.
                var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);
                var _trackRe = new RegExp('' +
                    '^' +
                    _directoryRe +
                    _nodeRe +
                    _objectRe +
                    _propertyRe +
                    '$');
                var _supportedObjectNames = ['material', 'materials', 'bones'];
                var Composite = /** @class */ (function() {
                    function Composite(targetGroup, path, optionalParsedPath) {
                        var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
                        this._targetGroup = targetGroup;
                        this._bindings = targetGroup.subscribe_(path, parsedPath);
                    }
                    Composite.prototype.getValue = function(array, offset) {
                        this.bind(); // bind all binding
                        var firstValidIndex = this._targetGroup.nCachedObjects_,
                            binding = this._bindings[firstValidIndex];
                        // and only call .getValue on the first
                        if (binding !== undefined)
                            binding.getValue(array, offset);
                    };
                    Composite.prototype.setValue = function(array, offset) {
                        var bindings = this._bindings;
                        for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                            bindings[i].setValue(array, offset);
                        }
                    };
                    Composite.prototype.bind = function() {
                        var bindings = this._bindings;
                        for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                            bindings[i].bind();
                        }
                    };
                    Composite.prototype.unbind = function() {
                        var bindings = this._bindings;
                        for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                            bindings[i].unbind();
                        }
                    };
                    return Composite;
                }());
                // Note: This class uses a State pattern on a per-method basis:
                // 'bind' sets 'this.getValue' / 'setValue' and shadows the
                // prototype version of these methods with one that represents
                // the bound state. When the property is not found, the methods
                // become no-ops.
                var PropertyBinding = /** @class */ (function() {
                    function PropertyBinding(rootNode, path, parsedPath) {
                        this.path = path;
                        this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
                        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
                        this.rootNode = rootNode;
                        // initial state of these methods that calls 'bind'
                        this.getValue = this._getValue_unbound;
                        this.setValue = this._setValue_unbound;
                    }
                    PropertyBinding.create = function(root, path, parsedPath) {
                        if (!(root && root.isAnimationObjectGroup)) {
                            return new PropertyBinding(root, path, parsedPath);
                        } else {
                            return new PropertyBinding.Composite(root, path, parsedPath);
                        }
                    };
                    /**
                     * Replaces spaces with underscores and removes unsupported characters from
                     * node names, to ensure compatibility with parseTrackName().
                     *
                     * @param {string} name Node name to be sanitized.
                     * @return {string}
                     */
                    PropertyBinding.sanitizeNodeName = function(name) {
                        return name.replace(/\s/g, '_').replace(_reservedRe, '');
                    };
                    PropertyBinding.parseTrackName = function(trackName) {
                        var matches = _trackRe.exec(trackName);
                        if (matches === null) {
                            throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
                        }
                        var results = {
                            // directoryName: matches[ 1 ], // (tschw) currently unused
                            nodeName: matches[2],
                            objectName: matches[3],
                            objectIndex: matches[4],
                            propertyName: matches[5],
                            propertyIndex: matches[6]
                        };
                        var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
                        if (lastDot !== undefined && lastDot !== -1) {
                            var objectName = results.nodeName.substring(lastDot + 1);
                            // Object names must be checked against an allowlist. Otherwise, there
                            // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
                            // 'bar' could be the objectName, or part of a nodeName (which can
                            // include '.' characters).
                            if (_supportedObjectNames.indexOf(objectName) !== -1) {
                                results.nodeName = results.nodeName.substring(0, lastDot);
                                results.objectName = objectName;
                            }
                        }
                        if (results.propertyName === null || results.propertyName.length === 0) {
                            throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
                        }
                        return results;
                    };
                    PropertyBinding.findNode = function(root, nodeName) {
                        if (nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
                            return root;
                        }
                        // search into skeleton bones.
                        if (root.skeleton) {
                            var bone = root.skeleton.getBoneByName(nodeName);
                            if (bone !== undefined) {
                                return bone;
                            }
                        }
                        // search into node subtree.
                        if (root.children) {
                            var searchNodeSubtree_1 = function(children) {
                                for (var i = 0; i < children.length; i++) {
                                    var childNode = children[i];
                                    if (childNode.name === nodeName || childNode.uuid === nodeName) {
                                        return childNode;
                                    }
                                    var result = searchNodeSubtree_1(childNode.children);
                                    if (result)
                                        return result;
                                }
                                return null;
                            };
                            var subTreeNode = searchNodeSubtree_1(root.children);
                            if (subTreeNode) {
                                return subTreeNode;
                            }
                        }
                        return null;
                    };
                    // these are used to "bind" a nonexistent property
                    PropertyBinding.prototype._getValue_unavailable = function() {};
                    PropertyBinding.prototype._setValue_unavailable = function() {};
                    // Getters
                    PropertyBinding.prototype._getValue_direct = function(buffer, offset) {
                        buffer[offset] = this.targetObject[this.propertyName];
                    };
                    PropertyBinding.prototype._getValue_array = function(buffer, offset) {
                        var source = this.resolvedProperty;
                        for (var i = 0, n = source.length; i !== n; ++i) {
                            buffer[offset++] = source[i];
                        }
                    };
                    PropertyBinding.prototype._getValue_arrayElement = function(buffer, offset) {
                        buffer[offset] = this.resolvedProperty[this.propertyIndex];
                    };
                    PropertyBinding.prototype._getValue_toArray = function(buffer, offset) {
                        this.resolvedProperty.toArray(buffer, offset);
                    };
                    // Direct
                    PropertyBinding.prototype._setValue_direct = function(buffer, offset) {
                        this.targetObject[this.propertyName] = buffer[offset];
                    };
                    PropertyBinding.prototype._setValue_direct_setNeedsUpdate = function(buffer, offset) {
                        this.targetObject[this.propertyName] = buffer[offset];
                        this.targetObject.needsUpdate = true;
                    };
                    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate = function(buffer, offset) {
                        this.targetObject[this.propertyName] = buffer[offset];
                        this.targetObject.matrixWorldNeedsUpdate = true;
                    };
                    // EntireArray
                    PropertyBinding.prototype._setValue_array = function(buffer, offset) {
                        var dest = this.resolvedProperty;
                        for (var i = 0, n = dest.length; i !== n; ++i) {
                            dest[i] = buffer[offset++];
                        }
                    };
                    PropertyBinding.prototype._setValue_array_setNeedsUpdate = function(buffer, offset) {
                        var dest = this.resolvedProperty;
                        for (var i = 0, n = dest.length; i !== n; ++i) {
                            dest[i] = buffer[offset++];
                        }
                        this.targetObject.needsUpdate = true;
                    };
                    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate = function(buffer, offset) {
                        var dest = this.resolvedProperty;
                        for (var i = 0, n = dest.length; i !== n; ++i) {
                            dest[i] = buffer[offset++];
                        }
                        this.targetObject.matrixWorldNeedsUpdate = true;
                    };
                    // ArrayElement
                    PropertyBinding.prototype._setValue_arrayElement = function(buffer, offset) {
                        this.resolvedProperty[this.propertyIndex] = buffer[offset];
                    };
                    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate = function(buffer, offset) {
                        this.resolvedProperty[this.propertyIndex] = buffer[offset];
                        this.targetObject.needsUpdate = true;
                    };
                    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate = function(buffer, offset) {
                        this.resolvedProperty[this.propertyIndex] = buffer[offset];
                        this.targetObject.matrixWorldNeedsUpdate = true;
                    };
                    // HasToFromArray
                    PropertyBinding.prototype._setValue_fromArray = function(buffer, offset) {
                        this.resolvedProperty.fromArray(buffer, offset);
                    };
                    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate = function(buffer, offset) {
                        this.resolvedProperty.fromArray(buffer, offset);
                        this.targetObject.needsUpdate = true;
                    };
                    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate = function(buffer, offset) {
                        this.resolvedProperty.fromArray(buffer, offset);
                        this.targetObject.matrixWorldNeedsUpdate = true;
                    };
                    PropertyBinding.prototype._getValue_unbound = function(targetArray, offset) {
                        this.bind();
                        this.getValue(targetArray, offset);
                    };
                    PropertyBinding.prototype._setValue_unbound = function(sourceArray, offset) {
                        this.bind();
                        this.setValue(sourceArray, offset);
                    };
                    // create getter / setter pair for a property in the scene graph
                    PropertyBinding.prototype.bind = function() {
                        var targetObject = this.node;
                        var parsedPath = this.parsedPath;
                        var objectName = parsedPath.objectName;
                        var propertyName = parsedPath.propertyName;
                        var propertyIndex = parsedPath.propertyIndex;
                        if (!targetObject) {
                            targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
                            this.node = targetObject;
                        }
                        // set fail state so we can just 'return' on error
                        this.getValue = this._getValue_unavailable;
                        this.setValue = this._setValue_unavailable;
                        // ensure there is a value node
                        if (!targetObject) {
                            console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
                            return;
                        }
                        if (objectName) {
                            var objectIndex = parsedPath.objectIndex;
                            // special cases were we need to reach deeper into the hierarchy to get the face materials....
                            switch (objectName) {
                                case 'materials':
                                    if (!targetObject.material) {
                                        console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                                        return;
                                    }
                                    if (!targetObject.material.materials) {
                                        console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                                        return;
                                    }
                                    targetObject = targetObject.material.materials;
                                    break;
                                case 'bones':
                                    if (!targetObject.skeleton) {
                                        console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                                        return;
                                    }
                                    // potential future optimization: skip this if propertyIndex is already an integer
                                    // and convert the integer string to a true integer.
                                    targetObject = targetObject.skeleton.bones;
                                    // support resolving morphTarget names into indices.
                                    for (var i = 0; i < targetObject.length; i++) {
                                        if (targetObject[i].name === objectIndex) {
                                            objectIndex = i;
                                            break;
                                        }
                                    }
                                    break;
                                default:
                                    if (targetObject[objectName] === undefined) {
                                        console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                                        return;
                                    }
                                    targetObject = targetObject[objectName];
                            }
                            if (objectIndex !== undefined) {
                                if (targetObject[objectIndex] === undefined) {
                                    console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                                    return;
                                }
                                targetObject = targetObject[objectIndex];
                            }
                        }
                        // resolve property
                        var nodeProperty = targetObject[propertyName];
                        if (nodeProperty === undefined) {
                            var nodeName = parsedPath.nodeName;
                            console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
                                '.' + propertyName + ' but it wasn\'t found.', targetObject);
                            return;
                        }
                        // determine versioning scheme
                        var versioning = this.Versioning.None;
                        this.targetObject = targetObject;
                        if (targetObject.needsUpdate !== undefined) { // material
                            versioning = this.Versioning.NeedsUpdate;
                        } else if (targetObject.matrixWorldNeedsUpdate !== undefined) { // node transform
                            versioning = this.Versioning.MatrixWorldNeedsUpdate;
                        }
                        // determine how the property gets bound
                        var bindingType = this.BindingType.Direct;
                        if (propertyIndex !== undefined) {
                            // access a sub element of the property array (only primitives are supported right now)
                            if (propertyName === 'morphTargetInfluences') {
                                // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
                                // support resolving morphTarget names into indices.
                                if (!targetObject.geometry) {
                                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                                    return;
                                }
                                if (targetObject.geometry.isBufferGeometry) {
                                    if (!targetObject.geometry.morphAttributes) {
                                        console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                                        return;
                                    }
                                    if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
                                        propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
                                    }
                                } else {
                                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
                                    return;
                                }
                            }
                            bindingType = this.BindingType.ArrayElement;
                            this.resolvedProperty = nodeProperty;
                            this.propertyIndex = propertyIndex;
                        } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
                            // must use copy for Object3D.Euler/Quaternion
                            bindingType = this.BindingType.HasFromToArray;
                            this.resolvedProperty = nodeProperty;
                        } else if (Array.isArray(nodeProperty)) {
                            bindingType = this.BindingType.EntireArray;
                            this.resolvedProperty = nodeProperty;
                        } else {
                            this.propertyName = propertyName;
                        }
                        // select getter / setter
                        this.getValue = this.GetterByBindingType[bindingType];
                        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
                    };
                    PropertyBinding.prototype.unbind = function() {
                        this.node = null;
                        // back to the prototype version of getValue / setValue
                        // note: avoiding to mutate the shape of 'this' via 'delete'
                        this.getValue = this._getValue_unbound;
                        this.setValue = this._setValue_unbound;
                    };
                    return PropertyBinding;
                }());
                PropertyBinding.Composite = Composite;
                PropertyBinding.prototype.BindingType = {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                };
                PropertyBinding.prototype.Versioning = {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                };
                PropertyBinding.prototype.GetterByBindingType = [
                    PropertyBinding.prototype._getValue_direct,
                    PropertyBinding.prototype._getValue_array,
                    PropertyBinding.prototype._getValue_arrayElement,
                    PropertyBinding.prototype._getValue_toArray,
                ];
                PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
                    [
                        // Direct
                        PropertyBinding.prototype._setValue_direct,
                        PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
                        PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
                    ],
                    [
                        // EntireArray
                        PropertyBinding.prototype._setValue_array,
                        PropertyBinding.prototype._setValue_array_setNeedsUpdate,
                        PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,
                    ],
                    [
                        // ArrayElement
                        PropertyBinding.prototype._setValue_arrayElement,
                        PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
                        PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
                    ],
                    [
                        // HasToFromArray
                        PropertyBinding.prototype._setValue_fromArray,
                        PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
                        PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
                    ]
                ];
                /**
                 *
                 * A group of objects that receives a shared animation state.
                 *
                 * Usage:
                 *
                 *  - Add objects you would otherwise pass as 'root' to the
                 *    constructor or the .clipAction method of AnimationMixer.
                 *
                 *  - Instead pass this object as 'root'.
                 *
                 *  - You can also add and remove objects later when the mixer
                 *    is running.
                 *
                 * Note:
                 *
                 *    Objects of this class appear as one object to the mixer,
                 *    so cache control of the individual objects must be done
                 *    on the group.
                 *
                 * Limitation:
                 *
                 *  - The animated properties must be compatible among the
                 *    all objects in the group.
                 *
                 *  - A single property can either be controlled through a
                 *    target group or directly, but not both.
                 */
                var AnimationObjectGroup = /** @class */ (function() {
                    function AnimationObjectGroup() {
                        this.uuid = generateUUID();
                        // cached objects followed by the active ones
                        this._objects = Array.prototype.slice.call(arguments);
                        this.nCachedObjects_ = 0; // threshold
                        // note: read by PropertyBinding.Composite
                        var indices = {};
                        this._indicesByUUID = indices; // for bookkeeping
                        for (var i = 0, n = arguments.length; i !== n; ++i) {
                            indices[arguments[i].uuid] = i;
                        }
                        this._paths = []; // inside: string
                        this._parsedPaths = []; // inside: { we don't care, here }
                        this._bindings = []; // inside: Array< PropertyBinding >
                        this._bindingsIndicesByPath = {}; // inside: indices in these arrays
                        var scope = this;
                        this.stats = {
                            objects: {
                                get total() {
                                    return scope._objects.length;
                                },
                                get inUse() {
                                    return this.total - scope.nCachedObjects_;
                                }
                            },
                            get bindingsPerObject() {
                                return scope._bindings.length;
                            }
                        };
                    }
                    AnimationObjectGroup.prototype.add = function() {
                        var objects = this._objects,
                            indicesByUUID = this._indicesByUUID,
                            paths = this._paths,
                            parsedPaths = this._parsedPaths,
                            bindings = this._bindings,
                            nBindings = bindings.length;
                        var knownObject = undefined,
                            nObjects = objects.length,
                            nCachedObjects = this.nCachedObjects_;
                        for (var i = 0, n = arguments.length; i !== n; ++i) {
                            var object = arguments[i],
                                uuid = object.uuid;
                            var index = indicesByUUID[uuid];
                            if (index === undefined) {
                                // unknown object -> add it to the ACTIVE region
                                index = nObjects++;
                                indicesByUUID[uuid] = index;
                                objects.push(object);
                                // accounting is done, now do the same for all bindings
                                for (var j = 0, m = nBindings; j !== m; ++j) {
                                    bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
                                }
                            } else if (index < nCachedObjects) {
                                knownObject = objects[index];
                                // move existing object to the ACTIVE region
                                var firstActiveIndex = --nCachedObjects,
                                    lastCachedObject = objects[firstActiveIndex];
                                indicesByUUID[lastCachedObject.uuid] = index;
                                objects[index] = lastCachedObject;
                                indicesByUUID[uuid] = firstActiveIndex;
                                objects[firstActiveIndex] = object;
                                // accounting is done, now do the same for all bindings
                                for (var j = 0, m = nBindings; j !== m; ++j) {
                                    var bindingsForPath = bindings[j],
                                        lastCached = bindingsForPath[firstActiveIndex];
                                    var binding = bindingsForPath[index];
                                    bindingsForPath[index] = lastCached;
                                    if (binding === undefined) {
                                        // since we do not bother to create new bindings
                                        // for objects that are cached, the binding may
                                        // or may not exist
                                        binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
                                    }
                                    bindingsForPath[firstActiveIndex] = binding;
                                }
                            } else if (objects[index] !== knownObject) {
                                console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' +
                                    'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
                            } // else the object is already where we want it to be
                        } // for arguments
                        this.nCachedObjects_ = nCachedObjects;
                    };
                    AnimationObjectGroup.prototype.remove = function() {
                        var objects = this._objects,
                            indicesByUUID = this._indicesByUUID,
                            bindings = this._bindings,
                            nBindings = bindings.length;
                        var nCachedObjects = this.nCachedObjects_;
                        for (var i = 0, n = arguments.length; i !== n; ++i) {
                            var object = arguments[i],
                                uuid = object.uuid,
                                index = indicesByUUID[uuid];
                            if (index !== undefined && index >= nCachedObjects) {
                                // move existing object into the CACHED region
                                var lastCachedIndex = nCachedObjects++,
                                    firstActiveObject = objects[lastCachedIndex];
                                indicesByUUID[firstActiveObject.uuid] = index;
                                objects[index] = firstActiveObject;
                                indicesByUUID[uuid] = lastCachedIndex;
                                objects[lastCachedIndex] = object;
                                // accounting is done, now do the same for all bindings
                                for (var j = 0, m = nBindings; j !== m; ++j) {
                                    var bindingsForPath = bindings[j],
                                        firstActive = bindingsForPath[lastCachedIndex],
                                        binding = bindingsForPath[index];
                                    bindingsForPath[index] = firstActive;
                                    bindingsForPath[lastCachedIndex] = binding;
                                }
                            }
                        } // for arguments
                        this.nCachedObjects_ = nCachedObjects;
                    };
                    // remove & forget
                    AnimationObjectGroup.prototype.uncache = function() {
                        var objects = this._objects,
                            indicesByUUID = this._indicesByUUID,
                            bindings = this._bindings,
                            nBindings = bindings.length;
                        var nCachedObjects = this.nCachedObjects_,
                            nObjects = objects.length;
                        for (var i = 0, n = arguments.length; i !== n; ++i) {
                            var object = arguments[i],
                                uuid = object.uuid,
                                index = indicesByUUID[uuid];
                            if (index !== undefined) {
                                delete indicesByUUID[uuid];
                                if (index < nCachedObjects) {
                                    // object is cached, shrink the CACHED region
                                    var firstActiveIndex = --nCachedObjects,
                                        lastCachedObject = objects[firstActiveIndex],
                                        lastIndex = --nObjects,
                                        lastObject = objects[lastIndex];
                                    // last cached object takes this object's place
                                    indicesByUUID[lastCachedObject.uuid] = index;
                                    objects[index] = lastCachedObject;
                                    // last object goes to the activated slot and pop
                                    indicesByUUID[lastObject.uuid] = firstActiveIndex;
                                    objects[firstActiveIndex] = lastObject;
                                    objects.pop();
                                    // accounting is done, now do the same for all bindings
                                    for (var j = 0, m = nBindings; j !== m; ++j) {
                                        var bindingsForPath = bindings[j],
                                            lastCached = bindingsForPath[firstActiveIndex],
                                            last = bindingsForPath[lastIndex];
                                        bindingsForPath[index] = lastCached;
                                        bindingsForPath[firstActiveIndex] = last;
                                        bindingsForPath.pop();
                                    }
                                } else {
                                    // object is active, just swap with the last and pop
                                    var lastIndex = --nObjects,
                                        lastObject = objects[lastIndex];
                                    if (lastIndex > 0) {
                                        indicesByUUID[lastObject.uuid] = index;
                                    }
                                    objects[index] = lastObject;
                                    objects.pop();
                                    // accounting is done, now do the same for all bindings
                                    for (var j = 0, m = nBindings; j !== m; ++j) {
                                        var bindingsForPath = bindings[j];
                                        bindingsForPath[index] = bindingsForPath[lastIndex];
                                        bindingsForPath.pop();
                                    }
                                } // cached or active
                            } // if object is known
                        } // for arguments
                        this.nCachedObjects_ = nCachedObjects;
                    };
                    // Internal interface used by befriended PropertyBinding.Composite:
                    AnimationObjectGroup.prototype.subscribe_ = function(path, parsedPath) {
                        // returns an array of bindings for the given path that is changed
                        // according to the contained objects in the group
                        var indicesByPath = this._bindingsIndicesByPath;
                        var index = indicesByPath[path];
                        var bindings = this._bindings;
                        if (index !== undefined)
                            return bindings[index];
                        var paths = this._paths,
                            parsedPaths = this._parsedPaths,
                            objects = this._objects,
                            nObjects = objects.length,
                            nCachedObjects = this.nCachedObjects_,
                            bindingsForPath = new Array(nObjects);
                        index = bindings.length;
                        indicesByPath[path] = index;
                        paths.push(path);
                        parsedPaths.push(parsedPath);
                        bindings.push(bindingsForPath);
                        for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
                            var object = objects[i];
                            bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
                        }
                        return bindingsForPath;
                    };
                    AnimationObjectGroup.prototype.unsubscribe_ = function(path) {
                        // tells the group to forget about a property path and no longer
                        // update the array previously obtained with 'subscribe_'
                        var indicesByPath = this._bindingsIndicesByPath,
                            index = indicesByPath[path];
                        if (index !== undefined) {
                            var paths = this._paths,
                                parsedPaths = this._parsedPaths,
                                bindings = this._bindings,
                                lastBindingsIndex = bindings.length - 1,
                                lastBindings = bindings[lastBindingsIndex],
                                lastBindingsPath = path[lastBindingsIndex];
                            indicesByPath[lastBindingsPath] = index;
                            bindings[index] = lastBindings;
                            bindings.pop();
                            parsedPaths[index] = parsedPaths[lastBindingsIndex];
                            parsedPaths.pop();
                            paths[index] = paths[lastBindingsIndex];
                            paths.pop();
                        }
                    };
                    return AnimationObjectGroup;
                }());
                AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
                var AnimationAction = /** @class */ (function() {
                    function AnimationAction(mixer, clip, localRoot, blendMode) {
                        if (localRoot === void 0) {
                            localRoot = null;
                        }
                        if (blendMode === void 0) {
                            blendMode = clip.blendMode;
                        }
                        this._mixer = mixer;
                        this._clip = clip;
                        this._localRoot = localRoot;
                        this.blendMode = blendMode;
                        var tracks = clip.tracks,
                            nTracks = tracks.length,
                            interpolants = new Array(nTracks);
                        var interpolantSettings = {
                            endingStart: ZeroCurvatureEnding,
                            endingEnd: ZeroCurvatureEnding
                        };
                        for (var i = 0; i !== nTracks; ++i) {
                            var interpolant = tracks[i].createInterpolant(null);
                            interpolants[i] = interpolant;
                            interpolant.settings = interpolantSettings;
                        }
                        this._interpolantSettings = interpolantSettings;
                        this._interpolants = interpolants; // bound by the mixer
                        // inside: PropertyMixer (managed by the mixer)
                        this._propertyBindings = new Array(nTracks);
                        this._cacheIndex = null; // for the memory manager
                        this._byClipCacheIndex = null; // for the memory manager
                        this._timeScaleInterpolant = null;
                        this._weightInterpolant = null;
                        this.loop = LoopRepeat;
                        this._loopCount = -1;
                        // global mixer time when the action is to be started
                        // it's set back to 'null' upon start of the action
                        this._startTime = null;
                        // scaled local time of the action
                        // gets clamped or wrapped to 0..clip.duration according to loop
                        this.time = 0;
                        this.timeScale = 1;
                        this._effectiveTimeScale = 1;
                        this.weight = 1;
                        this._effectiveWeight = 1;
                        this.repetitions = Infinity; // no. of repetitions when looping
                        this.paused = false; // true -> zero effective time scale
                        this.enabled = true; // false -> zero effective weight
                        this.clampWhenFinished = false; // keep feeding the last frame?
                        this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
                        this.zeroSlopeAtEnd = true; // clips for start, loop and end
                    }
                    // State & Scheduling
                    AnimationAction.prototype.play = function() {
                        this._mixer._activateAction(this);
                        return this;
                    };
                    AnimationAction.prototype.stop = function() {
                        this._mixer._deactivateAction(this);
                        return this.reset();
                    };
                    AnimationAction.prototype.reset = function() {
                        this.paused = false;
                        this.enabled = true;
                        this.time = 0; // restart clip
                        this._loopCount = -1; // forget previous loops
                        this._startTime = null; // forget scheduling
                        return this.stopFading().stopWarping();
                    };
                    AnimationAction.prototype.isRunning = function() {
                        return this.enabled && !this.paused && this.timeScale !== 0 &&
                            this._startTime === null && this._mixer._isActiveAction(this);
                    };
                    // return true when play has been called
                    AnimationAction.prototype.isScheduled = function() {
                        return this._mixer._isActiveAction(this);
                    };
                    AnimationAction.prototype.startAt = function(time) {
                        this._startTime = time;
                        return this;
                    };
                    AnimationAction.prototype.setLoop = function(mode, repetitions) {
                        this.loop = mode;
                        this.repetitions = repetitions;
                        return this;
                    };
                    // Weight
                    // set the weight stopping any scheduled fading
                    // although .enabled = false yields an effective weight of zero, this
                    // method does *not* change .enabled, because it would be confusing
                    AnimationAction.prototype.setEffectiveWeight = function(weight) {
                        this.weight = weight;
                        // note: same logic as when updated at runtime
                        this._effectiveWeight = this.enabled ? weight : 0;
                        return this.stopFading();
                    };
                    // return the weight considering fading and .enabled
                    AnimationAction.prototype.getEffectiveWeight = function() {
                        return this._effectiveWeight;
                    };
                    AnimationAction.prototype.fadeIn = function(duration) {
                        return this._scheduleFading(duration, 0, 1);
                    };
                    AnimationAction.prototype.fadeOut = function(duration) {
                        return this._scheduleFading(duration, 1, 0);
                    };
                    AnimationAction.prototype.crossFadeFrom = function(fadeOutAction, duration, warp) {
                        fadeOutAction.fadeOut(duration);
                        this.fadeIn(duration);
                        if (warp) {
                            var fadeInDuration = this._clip.duration,
                                fadeOutDuration = fadeOutAction._clip.duration,
                                startEndRatio = fadeOutDuration / fadeInDuration,
                                endStartRatio = fadeInDuration / fadeOutDuration;
                            fadeOutAction.warp(1.0, startEndRatio, duration);
                            this.warp(endStartRatio, 1.0, duration);
                        }
                        return this;
                    };
                    AnimationAction.prototype.crossFadeTo = function(fadeInAction, duration, warp) {
                        return fadeInAction.crossFadeFrom(this, duration, warp);
                    };
                    AnimationAction.prototype.stopFading = function() {
                        var weightInterpolant = this._weightInterpolant;
                        if (weightInterpolant !== null) {
                            this._weightInterpolant = null;
                            this._mixer._takeBackControlInterpolant(weightInterpolant);
                        }
                        return this;
                    };
                    // Time Scale Control
                    // set the time scale stopping any scheduled warping
                    // although .paused = true yields an effective time scale of zero, this
                    // method does *not* change .paused, because it would be confusing
                    AnimationAction.prototype.setEffectiveTimeScale = function(timeScale) {
                        this.timeScale = timeScale;
                        this._effectiveTimeScale = this.paused ? 0 : timeScale;
                        return this.stopWarping();
                    };
                    // return the time scale considering warping and .paused
                    AnimationAction.prototype.getEffectiveTimeScale = function() {
                        return this._effectiveTimeScale;
                    };
                    AnimationAction.prototype.setDuration = function(duration) {
                        this.timeScale = this._clip.duration / duration;
                        return this.stopWarping();
                    };
                    AnimationAction.prototype.syncWith = function(action) {
                        this.time = action.time;
                        this.timeScale = action.timeScale;
                        return this.stopWarping();
                    };
                    AnimationAction.prototype.halt = function(duration) {
                        return this.warp(this._effectiveTimeScale, 0, duration);
                    };
                    AnimationAction.prototype.warp = function(startTimeScale, endTimeScale, duration) {
                        var mixer = this._mixer,
                            now = mixer.time,
                            timeScale = this.timeScale;
                        var interpolant = this._timeScaleInterpolant;
                        if (interpolant === null) {
                            interpolant = mixer._lendControlInterpolant();
                            this._timeScaleInterpolant = interpolant;
                        }
                        var times = interpolant.parameterPositions,
                            values = interpolant.sampleValues;
                        times[0] = now;
                        times[1] = now + duration;
                        values[0] = startTimeScale / timeScale;
                        values[1] = endTimeScale / timeScale;
                        return this;
                    };
                    AnimationAction.prototype.stopWarping = function() {
                        var timeScaleInterpolant = this._timeScaleInterpolant;
                        if (timeScaleInterpolant !== null) {
                            this._timeScaleInterpolant = null;
                            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
                        }
                        return this;
                    };
                    // Object Accessors
                    AnimationAction.prototype.getMixer = function() {
                        return this._mixer;
                    };
                    AnimationAction.prototype.getClip = function() {
                        return this._clip;
                    };
                    AnimationAction.prototype.getRoot = function() {
                        return this._localRoot || this._mixer._root;
                    };
                    // Interna
                    AnimationAction.prototype._update = function(time, deltaTime, timeDirection, accuIndex) {
                        // called by the mixer
                        if (!this.enabled) {
                            // call ._updateWeight() to update ._effectiveWeight
                            this._updateWeight(time);
                            return;
                        }
                        var startTime = this._startTime;
                        if (startTime !== null) {
                            // check for scheduled start of action
                            var timeRunning = (time - startTime) * timeDirection;
                            if (timeRunning < 0 || timeDirection === 0) {
                                return; // yet to come / don't decide when delta = 0
                            }
                            // start
                            this._startTime = null; // unschedule
                            deltaTime = timeDirection * timeRunning;
                        }
                        // apply time scale and advance time
                        deltaTime *= this._updateTimeScale(time);
                        var clipTime = this._updateTime(deltaTime);
                        // note: _updateTime may disable the action resulting in
                        // an effective weight of 0
                        var weight = this._updateWeight(time);
                        if (weight > 0) {
                            var interpolants = this._interpolants;
                            var propertyMixers = this._propertyBindings;
                            switch (this.blendMode) {
                                case AdditiveAnimationBlendMode:
                                    for (var j = 0, m = interpolants.length; j !== m; ++j) {
                                        interpolants[j].evaluate(clipTime);
                                        propertyMixers[j].accumulateAdditive(weight);
                                    }
                                    break;
                                case NormalAnimationBlendMode:
                                default:
                                    for (var j = 0, m = interpolants.length; j !== m; ++j) {
                                        interpolants[j].evaluate(clipTime);
                                        propertyMixers[j].accumulate(accuIndex, weight);
                                    }
                            }
                        }
                    };
                    AnimationAction.prototype._updateWeight = function(time) {
                        var weight = 0;
                        if (this.enabled) {
                            weight = this.weight;
                            var interpolant = this._weightInterpolant;
                            if (interpolant !== null) {
                                var interpolantValue = interpolant.evaluate(time)[0];
                                weight *= interpolantValue;
                                if (time > interpolant.parameterPositions[1]) {
                                    this.stopFading();
                                    if (interpolantValue === 0) {
                                        // faded out, disable
                                        this.enabled = false;
                                    }
                                }
                            }
                        }
                        this._effectiveWeight = weight;
                        return weight;
                    };
                    AnimationAction.prototype._updateTimeScale = function(time) {
                        var timeScale = 0;
                        if (!this.paused) {
                            timeScale = this.timeScale;
                            var interpolant = this._timeScaleInterpolant;
                            if (interpolant !== null) {
                                var interpolantValue = interpolant.evaluate(time)[0];
                                timeScale *= interpolantValue;
                                if (time > interpolant.parameterPositions[1]) {
                                    this.stopWarping();
                                    if (timeScale === 0) {
                                        // motion has halted, pause
                                        this.paused = true;
                                    } else {
                                        // warp done - apply final time scale
                                        this.timeScale = timeScale;
                                    }
                                }
                            }
                        }
                        this._effectiveTimeScale = timeScale;
                        return timeScale;
                    };
                    AnimationAction.prototype._updateTime = function(deltaTime) {
                        var duration = this._clip.duration;
                        var loop = this.loop;
                        var time = this.time + deltaTime;
                        var loopCount = this._loopCount;
                        var pingPong = (loop === LoopPingPong);
                        if (deltaTime === 0) {
                            if (loopCount === -1)
                                return time;
                            return (pingPong && (loopCount & 1) === 1) ? duration - time : time;
                        }
                        if (loop === LoopOnce) {
                            if (loopCount === -1) {
                                // just started
                                this._loopCount = 0;
                                this._setEndings(true, true, false);
                            }
                            handle_stop: {
                                if (time >= duration) {
                                    time = duration;
                                } else if (time < 0) {
                                    time = 0;
                                } else {
                                    this.time = time;
                                    break handle_stop;
                                }
                                if (this.clampWhenFinished)
                                    this.paused = true;
                                else
                                    this.enabled = false;
                                this.time = time;
                                this._mixer.dispatchEvent({
                                    type: 'finished',
                                    action: this,
                                    direction: deltaTime < 0 ? -1 : 1
                                });
                            }
                        } else { // repetitive Repeat or PingPong
                            if (loopCount === -1) {
                                // just started
                                if (deltaTime >= 0) {
                                    loopCount = 0;
                                    this._setEndings(true, this.repetitions === 0, pingPong);
                                } else {
                                    // when looping in reverse direction, the initial
                                    // transition through zero counts as a repetition,
                                    // so leave loopCount at -1
                                    this._setEndings(this.repetitions === 0, true, pingPong);
                                }
                            }
                            if (time >= duration || time < 0) {
                                // wrap around
                                var loopDelta = Math.floor(time / duration); // signed
                                time -= duration * loopDelta;
                                loopCount += Math.abs(loopDelta);
                                var pending = this.repetitions - loopCount;
                                if (pending <= 0) {
                                    // have to stop (switch state, clamp time, fire event)
                                    if (this.clampWhenFinished)
                                        this.paused = true;
                                    else
                                        this.enabled = false;
                                    time = deltaTime > 0 ? duration : 0;
                                    this.time = time;
                                    this._mixer.dispatchEvent({
                                        type: 'finished',
                                        action: this,
                                        direction: deltaTime > 0 ? 1 : -1
                                    });
                                } else {
                                    // keep running
                                    if (pending === 1) {
                                        // entering the last round
                                        var atStart = deltaTime < 0;
                                        this._setEndings(atStart, !atStart, pingPong);
                                    } else {
                                        this._setEndings(false, false, pingPong);
                                    }
                                    this._loopCount = loopCount;
                                    this.time = time;
                                    this._mixer.dispatchEvent({
                                        type: 'loop',
                                        action: this,
                                        loopDelta: loopDelta
                                    });
                                }
                            } else {
                                this.time = time;
                            }
                            if (pingPong && (loopCount & 1) === 1) {
                                // invert time for the "pong round"
                                return duration - time;
                            }
                        }
                        return time;
                    };
                    AnimationAction.prototype._setEndings = function(atStart, atEnd, pingPong) {
                        var settings = this._interpolantSettings;
                        if (pingPong) {
                            settings.endingStart = ZeroSlopeEnding;
                            settings.endingEnd = ZeroSlopeEnding;
                        } else {
                            // assuming for LoopOnce atStart == atEnd == true
                            if (atStart) {
                                settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
                            } else {
                                settings.endingStart = WrapAroundEnding;
                            }
                            if (atEnd) {
                                settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
                            } else {
                                settings.endingEnd = WrapAroundEnding;
                            }
                        }
                    };
                    AnimationAction.prototype._scheduleFading = function(duration, weightNow, weightThen) {
                        var mixer = this._mixer,
                            now = mixer.time;
                        var interpolant = this._weightInterpolant;
                        if (interpolant === null) {
                            interpolant = mixer._lendControlInterpolant();
                            this._weightInterpolant = interpolant;
                        }
                        var times = interpolant.parameterPositions,
                            values = interpolant.sampleValues;
                        times[0] = now;
                        values[0] = weightNow;
                        times[1] = now + duration;
                        values[1] = weightThen;
                        return this;
                    };
                    return AnimationAction;
                }());
                var AnimationMixer = /** @class */ (function(_super) {
                    __extends(AnimationMixer, _super);

                    function AnimationMixer(root) {
                        var _this_1 = _super.call(this) || this;
                        _this_1._root = root;
                        _this_1._initMemoryManager();
                        _this_1._accuIndex = 0;
                        _this_1.time = 0;
                        _this_1.timeScale = 1.0;
                        return _this_1;
                    }
                    AnimationMixer.prototype._bindAction = function(action, prototypeAction) {
                        var root = action._localRoot || this._root,
                            tracks = action._clip.tracks,
                            nTracks = tracks.length,
                            bindings = action._propertyBindings,
                            interpolants = action._interpolants,
                            rootUuid = root.uuid,
                            bindingsByRoot = this._bindingsByRootAndName;
                        var bindingsByName = bindingsByRoot[rootUuid];
                        if (bindingsByName === undefined) {
                            bindingsByName = {};
                            bindingsByRoot[rootUuid] = bindingsByName;
                        }
                        for (var i = 0; i !== nTracks; ++i) {
                            var track = tracks[i],
                                trackName = track.name;
                            var binding = bindingsByName[trackName];
                            if (binding !== undefined) {
                                ++binding.referenceCount;
                                bindings[i] = binding;
                            } else {
                                binding = bindings[i];
                                if (binding !== undefined) {
                                    // existing binding, make sure the cache knows
                                    if (binding._cacheIndex === null) {
                                        ++binding.referenceCount;
                                        this._addInactiveBinding(binding, rootUuid, trackName);
                                    }
                                    continue;
                                }
                                var path = prototypeAction && prototypeAction.
                                _propertyBindings[i].binding.parsedPath;
                                binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                                ++binding.referenceCount;
                                this._addInactiveBinding(binding, rootUuid, trackName);
                                bindings[i] = binding;
                            }
                            interpolants[i].resultBuffer = binding.buffer;
                        }
                    };
                    AnimationMixer.prototype._activateAction = function(action) {
                        if (!this._isActiveAction(action)) {
                            if (action._cacheIndex === null) {
                                // this action has been forgotten by the cache, but the user
                                // appears to be still using it -> rebind
                                var rootUuid = (action._localRoot || this._root).uuid,
                                    clipUuid = action._clip.uuid,
                                    actionsForClip = this._actionsByClip[clipUuid];
                                this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                                this._addInactiveAction(action, clipUuid, rootUuid);
                            }
                            var bindings = action._propertyBindings;
                            // increment reference counts / sort out state
                            for (var i = 0, n = bindings.length; i !== n; ++i) {
                                var binding = bindings[i];
                                if (binding.useCount++ === 0) {
                                    this._lendBinding(binding);
                                    binding.saveOriginalState();
                                }
                            }
                            this._lendAction(action);
                        }
                    };
                    AnimationMixer.prototype._deactivateAction = function(action) {
                        if (this._isActiveAction(action)) {
                            var bindings = action._propertyBindings;
                            // decrement reference counts / sort out state
                            for (var i = 0, n = bindings.length; i !== n; ++i) {
                                var binding = bindings[i];
                                if (--binding.useCount === 0) {
                                    binding.restoreOriginalState();
                                    this._takeBackBinding(binding);
                                }
                            }
                            this._takeBackAction(action);
                        }
                    };
                    // Memory manager
                    AnimationMixer.prototype._initMemoryManager = function() {
                        this._actions = []; // 'nActiveActions' followed by inactive ones
                        this._nActiveActions = 0;
                        this._actionsByClip = {};
                        // inside:
                        // {
                        // 	knownActions: Array< AnimationAction > - used as prototypes
                        // 	actionByRoot: AnimationAction - lookup
                        // }
                        this._bindings = []; // 'nActiveBindings' followed by inactive ones
                        this._nActiveBindings = 0;
                        this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
                        this._controlInterpolants = []; // same game as above
                        this._nActiveControlInterpolants = 0;
                        var scope = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return scope._actions.length;
                                },
                                get inUse() {
                                    return scope._nActiveActions;
                                }
                            },
                            bindings: {
                                get total() {
                                    return scope._bindings.length;
                                },
                                get inUse() {
                                    return scope._nActiveBindings;
                                }
                            },
                            controlInterpolants: {
                                get total() {
                                    return scope._controlInterpolants.length;
                                },
                                get inUse() {
                                    return scope._nActiveControlInterpolants;
                                }
                            }
                        };
                    };
                    // Memory management for AnimationAction objects
                    AnimationMixer.prototype._isActiveAction = function(action) {
                        var index = action._cacheIndex;
                        return index !== null && index < this._nActiveActions;
                    };
                    AnimationMixer.prototype._addInactiveAction = function(action, clipUuid, rootUuid) {
                        var actions = this._actions,
                            actionsByClip = this._actionsByClip;
                        var actionsForClip = actionsByClip[clipUuid];
                        if (actionsForClip === undefined) {
                            actionsForClip = {
                                knownActions: [action],
                                actionByRoot: {}
                            };
                            action._byClipCacheIndex = 0;
                            actionsByClip[clipUuid] = actionsForClip;
                        } else {
                            var knownActions = actionsForClip.knownActions;
                            action._byClipCacheIndex = knownActions.length;
                            knownActions.push(action);
                        }
                        action._cacheIndex = actions.length;
                        actions.push(action);
                        actionsForClip.actionByRoot[rootUuid] = action;
                    };
                    AnimationMixer.prototype._removeInactiveAction = function(action) {
                        var actions = this._actions,
                            lastInactiveAction = actions[actions.length - 1],
                            cacheIndex = action._cacheIndex;
                        lastInactiveAction._cacheIndex = cacheIndex;
                        actions[cacheIndex] = lastInactiveAction;
                        actions.pop();
                        action._cacheIndex = null;
                        var clipUuid = action._clip.uuid,
                            actionsByClip = this._actionsByClip,
                            actionsForClip = actionsByClip[clipUuid],
                            knownActionsForClip = actionsForClip.knownActions,
                            lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
                            byClipCacheIndex = action._byClipCacheIndex;
                        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
                        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
                        knownActionsForClip.pop();
                        action._byClipCacheIndex = null;
                        var actionByRoot = actionsForClip.actionByRoot,
                            rootUuid = (action._localRoot || this._root).uuid;
                        delete actionByRoot[rootUuid];
                        if (knownActionsForClip.length === 0) {
                            delete actionsByClip[clipUuid];
                        }
                        this._removeInactiveBindingsForAction(action);
                    };
                    AnimationMixer.prototype._removeInactiveBindingsForAction = function(action) {
                        var bindings = action._propertyBindings;
                        for (var i = 0, n = bindings.length; i !== n; ++i) {
                            var binding = bindings[i];
                            if (--binding.referenceCount === 0) {
                                this._removeInactiveBinding(binding);
                            }
                        }
                    };
                    AnimationMixer.prototype._lendAction = function(action) {
                        // [ active actions |  inactive actions  ]
                        // [  active actions >| inactive actions ]
                        //                 s        a
                        //                  <-swap->
                        //                 a        s
                        var actions = this._actions,
                            prevIndex = action._cacheIndex,
                            lastActiveIndex = this._nActiveActions++,
                            firstInactiveAction = actions[lastActiveIndex];
                        action._cacheIndex = lastActiveIndex;
                        actions[lastActiveIndex] = action;
                        firstInactiveAction._cacheIndex = prevIndex;
                        actions[prevIndex] = firstInactiveAction;
                    };
                    AnimationMixer.prototype._takeBackAction = function(action) {
                        // [  active actions  | inactive actions ]
                        // [ active actions |< inactive actions  ]
                        //        a        s
                        //         <-swap->
                        //        s        a
                        var actions = this._actions,
                            prevIndex = action._cacheIndex,
                            firstInactiveIndex = --this._nActiveActions,
                            lastActiveAction = actions[firstInactiveIndex];
                        action._cacheIndex = firstInactiveIndex;
                        actions[firstInactiveIndex] = action;
                        lastActiveAction._cacheIndex = prevIndex;
                        actions[prevIndex] = lastActiveAction;
                    };
                    // Memory management for PropertyMixer objects
                    AnimationMixer.prototype._addInactiveBinding = function(binding, rootUuid, trackName) {
                        var bindingsByRoot = this._bindingsByRootAndName,
                            bindings = this._bindings;
                        var bindingByName = bindingsByRoot[rootUuid];
                        if (bindingByName === undefined) {
                            bindingByName = {};
                            bindingsByRoot[rootUuid] = bindingByName;
                        }
                        bindingByName[trackName] = binding;
                        binding._cacheIndex = bindings.length;
                        bindings.push(binding);
                    };
                    AnimationMixer.prototype._removeInactiveBinding = function(binding) {
                        var bindings = this._bindings,
                            propBinding = binding.binding,
                            rootUuid = propBinding.rootNode.uuid,
                            trackName = propBinding.path,
                            bindingsByRoot = this._bindingsByRootAndName,
                            bindingByName = bindingsByRoot[rootUuid],
                            lastInactiveBinding = bindings[bindings.length - 1],
                            cacheIndex = binding._cacheIndex;
                        lastInactiveBinding._cacheIndex = cacheIndex;
                        bindings[cacheIndex] = lastInactiveBinding;
                        bindings.pop();
                        delete bindingByName[trackName];
                        if (Object.keys(bindingByName).length === 0) {
                            delete bindingsByRoot[rootUuid];
                        }
                    };
                    AnimationMixer.prototype._lendBinding = function(binding) {
                        var bindings = this._bindings,
                            prevIndex = binding._cacheIndex,
                            lastActiveIndex = this._nActiveBindings++,
                            firstInactiveBinding = bindings[lastActiveIndex];
                        binding._cacheIndex = lastActiveIndex;
                        bindings[lastActiveIndex] = binding;
                        firstInactiveBinding._cacheIndex = prevIndex;
                        bindings[prevIndex] = firstInactiveBinding;
                    };
                    AnimationMixer.prototype._takeBackBinding = function(binding) {
                        var bindings = this._bindings,
                            prevIndex = binding._cacheIndex,
                            firstInactiveIndex = --this._nActiveBindings,
                            lastActiveBinding = bindings[firstInactiveIndex];
                        binding._cacheIndex = firstInactiveIndex;
                        bindings[firstInactiveIndex] = binding;
                        lastActiveBinding._cacheIndex = prevIndex;
                        bindings[prevIndex] = lastActiveBinding;
                    };
                    // Memory management of Interpolants for weight and time scale
                    AnimationMixer.prototype._lendControlInterpolant = function() {
                        var interpolants = this._controlInterpolants,
                            lastActiveIndex = this._nActiveControlInterpolants++;
                        var interpolant = interpolants[lastActiveIndex];
                        if (interpolant === undefined) {
                            interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
                            interpolant.__cacheIndex = lastActiveIndex;
                            interpolants[lastActiveIndex] = interpolant;
                        }
                        return interpolant;
                    };
                    AnimationMixer.prototype._takeBackControlInterpolant = function(interpolant) {
                        var interpolants = this._controlInterpolants,
                            prevIndex = interpolant.__cacheIndex,
                            firstInactiveIndex = --this._nActiveControlInterpolants,
                            lastActiveInterpolant = interpolants[firstInactiveIndex];
                        interpolant.__cacheIndex = firstInactiveIndex;
                        interpolants[firstInactiveIndex] = interpolant;
                        lastActiveInterpolant.__cacheIndex = prevIndex;
                        interpolants[prevIndex] = lastActiveInterpolant;
                    };
                    // return an action for a clip optionally using a custom root target
                    // object (this method allocates a lot of dynamic memory in case a
                    // previously unknown clip/root combination is specified)
                    AnimationMixer.prototype.clipAction = function(clip, optionalRoot, blendMode) {
                        var root = optionalRoot || this._root,
                            rootUuid = root.uuid;
                        var clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
                        var clipUuid = clipObject !== null ? clipObject.uuid : clip;
                        var actionsForClip = this._actionsByClip[clipUuid];
                        var prototypeAction = null;
                        if (blendMode === undefined) {
                            if (clipObject !== null) {
                                blendMode = clipObject.blendMode;
                            } else {
                                blendMode = NormalAnimationBlendMode;
                            }
                        }
                        if (actionsForClip !== undefined) {
                            var existingAction = actionsForClip.actionByRoot[rootUuid];
                            if (existingAction !== undefined && existingAction.blendMode === blendMode) {
                                return existingAction;
                            }
                            // we know the clip, so we don't have to parse all
                            // the bindings again but can just copy
                            prototypeAction = actionsForClip.knownActions[0];
                            // also, take the clip from the prototype action
                            if (clipObject === null)
                                clipObject = prototypeAction._clip;
                        }
                        // clip must be known when specified via string
                        if (clipObject === null)
                            return null;
                        // allocate all resources required to run it
                        var newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
                        this._bindAction(newAction, prototypeAction);
                        // and make the action known to the memory manager
                        this._addInactiveAction(newAction, clipUuid, rootUuid);
                        return newAction;
                    };
                    // get an existing action
                    AnimationMixer.prototype.existingAction = function(clip, optionalRoot) {
                        var root = optionalRoot || this._root,
                            rootUuid = root.uuid,
                            clipObject = typeof clip === 'string' ?
                            AnimationClip.findByName(root, clip) : clip,
                            clipUuid = clipObject ? clipObject.uuid : clip,
                            actionsForClip = this._actionsByClip[clipUuid];
                        if (actionsForClip !== undefined) {
                            return actionsForClip.actionByRoot[rootUuid] || null;
                        }
                        return null;
                    };
                    // deactivates all previously scheduled actions
                    AnimationMixer.prototype.stopAllAction = function() {
                        var actions = this._actions,
                            nActions = this._nActiveActions;
                        for (var i = nActions - 1; i >= 0; --i) {
                            actions[i].stop();
                        }
                        return this;
                    };
                    // advance the time and update apply the animation
                    AnimationMixer.prototype.update = function(deltaTime) {
                        deltaTime *= this.timeScale;
                        var actions = this._actions,
                            nActions = this._nActiveActions,
                            time = this.time += deltaTime,
                            timeDirection = Math.sign(deltaTime),
                            accuIndex = this._accuIndex ^= 1;
                        // run active actions
                        for (var i = 0; i !== nActions; ++i) {
                            var action = actions[i];
                            action._update(time, deltaTime, timeDirection, accuIndex);
                        }
                        // update scene graph
                        var bindings = this._bindings,
                            nBindings = this._nActiveBindings;
                        for (var i = 0; i !== nBindings; ++i) {
                            bindings[i].apply(accuIndex);
                        }
                        return this;
                    };
                    // Allows you to seek to a specific time in an animation.
                    AnimationMixer.prototype.setTime = function(timeInSeconds) {
                        this.time = 0; // Zero out time attribute for AnimationMixer object;
                        for (var i = 0; i < this._actions.length; i++) {
                            this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
                        }
                        return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
                    };
                    // return this mixer's root target object
                    AnimationMixer.prototype.getRoot = function() {
                        return this._root;
                    };
                    // free all resources specific to a particular clip
                    AnimationMixer.prototype.uncacheClip = function(clip) {
                        var actions = this._actions,
                            clipUuid = clip.uuid,
                            actionsByClip = this._actionsByClip,
                            actionsForClip = actionsByClip[clipUuid];
                        if (actionsForClip !== undefined) {
                            // note: just calling _removeInactiveAction would mess up the
                            // iteration state and also require updating the state we can
                            // just throw away
                            var actionsToRemove = actionsForClip.knownActions;
                            for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
                                var action = actionsToRemove[i];
                                this._deactivateAction(action);
                                var cacheIndex = action._cacheIndex,
                                    lastInactiveAction = actions[actions.length - 1];
                                action._cacheIndex = null;
                                action._byClipCacheIndex = null;
                                lastInactiveAction._cacheIndex = cacheIndex;
                                actions[cacheIndex] = lastInactiveAction;
                                actions.pop();
                                this._removeInactiveBindingsForAction(action);
                            }
                            delete actionsByClip[clipUuid];
                        }
                    };
                    // free all resources specific to a particular root target object
                    AnimationMixer.prototype.uncacheRoot = function(root) {
                        var rootUuid = root.uuid,
                            actionsByClip = this._actionsByClip;
                        for (var clipUuid in actionsByClip) {
                            var actionByRoot = actionsByClip[clipUuid].actionByRoot,
                                action = actionByRoot[rootUuid];
                            if (action !== undefined) {
                                this._deactivateAction(action);
                                this._removeInactiveAction(action);
                            }
                        }
                        var bindingsByRoot = this._bindingsByRootAndName,
                            bindingByName = bindingsByRoot[rootUuid];
                        if (bindingByName !== undefined) {
                            for (var trackName in bindingByName) {
                                var binding = bindingByName[trackName];
                                binding.restoreOriginalState();
                                this._removeInactiveBinding(binding);
                            }
                        }
                    };
                    // remove a targeted clip from the cache
                    AnimationMixer.prototype.uncacheAction = function(clip, optionalRoot) {
                        var action = this.existingAction(clip, optionalRoot);
                        if (action !== null) {
                            this._deactivateAction(action);
                            this._removeInactiveAction(action);
                        }
                    };
                    return AnimationMixer;
                }(EventDispatcher));
                AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
                var Uniform = /** @class */ (function() {
                    function Uniform(value) {
                        if (typeof value === 'string') {
                            console.warn('THREE.Uniform: Type parameter is no longer needed.');
                            value = arguments[1];
                        }
                        this.value = value;
                    }
                    Uniform.prototype.clone = function() {
                        return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
                    };
                    return Uniform;
                }());
                var InstancedInterleavedBuffer = /** @class */ (function(_super) {
                    __extends(InstancedInterleavedBuffer, _super);

                    function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
                        if (meshPerAttribute === void 0) {
                            meshPerAttribute = 1;
                        }
                        var _this_1 = _super.call(this, array, stride) || this;
                        _this_1.meshPerAttribute = meshPerAttribute;
                        return _this_1;
                    }
                    InstancedInterleavedBuffer.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source);
                        this.meshPerAttribute = source.meshPerAttribute;
                        return this;
                    };
                    InstancedInterleavedBuffer.prototype.clone = function(data) {
                        var ib = _super.prototype.clone.call(this, data);
                        ib.meshPerAttribute = this.meshPerAttribute;
                        return ib;
                    };
                    InstancedInterleavedBuffer.prototype.toJSON = function(data) {
                        var json = _super.prototype.toJSON.call(this, data);
                        json.isInstancedInterleavedBuffer = true;
                        json.meshPerAttribute = this.meshPerAttribute;
                        return json;
                    };
                    return InstancedInterleavedBuffer;
                }(InterleavedBuffer));
                InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
                var GLBufferAttribute = /** @class */ (function() {
                    function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
                        this.buffer = buffer;
                        this.type = type;
                        this.itemSize = itemSize;
                        this.elementSize = elementSize;
                        this.count = count;
                        this.version = 0;
                    }
                    Object.defineProperty(GLBufferAttribute.prototype, "needsUpdate", {
                        set: function(value) {
                            if (value === true)
                                this.version++;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    GLBufferAttribute.prototype.setBuffer = function(buffer) {
                        this.buffer = buffer;
                        return this;
                    };
                    GLBufferAttribute.prototype.setType = function(type, elementSize) {
                        this.type = type;
                        this.elementSize = elementSize;
                        return this;
                    };
                    GLBufferAttribute.prototype.setItemSize = function(itemSize) {
                        this.itemSize = itemSize;
                        return this;
                    };
                    GLBufferAttribute.prototype.setCount = function(count) {
                        this.count = count;
                        return this;
                    };
                    return GLBufferAttribute;
                }());
                GLBufferAttribute.prototype.isGLBufferAttribute = true;
                var Raycaster = /** @class */ (function() {
                    function Raycaster(origin, direction, near, far) {
                        if (near === void 0) {
                            near = 0;
                        }
                        if (far === void 0) {
                            far = Infinity;
                        }
                        this.ray = new Ray(origin, direction);
                        // direction is assumed to be normalized (for accurate distance calculations)
                        this.near = near;
                        this.far = far;
                        this.camera = null;
                        this.layers = new Layers();
                        this.params = {
                            Mesh: {},
                            Line: {
                                threshold: 1
                            },
                            LOD: {},
                            Points: {
                                threshold: 1
                            },
                            Sprite: {}
                        };
                    }
                    Raycaster.prototype.set = function(origin, direction) {
                        // direction is assumed to be normalized (for accurate distance calculations)
                        this.ray.set(origin, direction);
                    };
                    Raycaster.prototype.setFromCamera = function(coords, camera) {
                        if (camera.isPerspectiveCamera) {
                            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
                            this.camera = camera;
                        } else if (camera.isOrthographicCamera) {
                            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
                            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
                            this.camera = camera;
                        } else {
                            console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
                        }
                    };
                    Raycaster.prototype.intersectObject = function(object, recursive, intersects) {
                        if (recursive === void 0) {
                            recursive = true;
                        }
                        if (intersects === void 0) {
                            intersects = [];
                        }
                        intersectObject(object, this, intersects, recursive);
                        intersects.sort(ascSort);
                        return intersects;
                    };
                    Raycaster.prototype.intersectObjects = function(objects, recursive, intersects) {
                        if (recursive === void 0) {
                            recursive = true;
                        }
                        if (intersects === void 0) {
                            intersects = [];
                        }
                        for (var i = 0, l = objects.length; i < l; i++) {
                            intersectObject(objects[i], this, intersects, recursive);
                        }
                        intersects.sort(ascSort);
                        return intersects;
                    };
                    return Raycaster;
                }());

                function ascSort(a, b) {
                    return a.distance - b.distance;
                }

                function intersectObject(object, raycaster, intersects, recursive) {
                    if (object.layers.test(raycaster.layers)) {
                        object.raycast(raycaster, intersects);
                    }
                    if (recursive === true) {
                        var children = object.children;
                        for (var i = 0, l = children.length; i < l; i++) {
                            intersectObject(children[i], raycaster, intersects, true);
                        }
                    }
                }
                /**
                 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
                 *
                 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
                 * The azimuthal angle (theta) is measured from the positive z-axis.
                 */
                var Spherical = /** @class */ (function() {
                    function Spherical(radius, phi, theta) {
                        if (radius === void 0) {
                            radius = 1;
                        }
                        if (phi === void 0) {
                            phi = 0;
                        }
                        if (theta === void 0) {
                            theta = 0;
                        }
                        this.radius = radius;
                        this.phi = phi; // polar angle
                        this.theta = theta; // azimuthal angle
                        return this;
                    }
                    Spherical.prototype.set = function(radius, phi, theta) {
                        this.radius = radius;
                        this.phi = phi;
                        this.theta = theta;
                        return this;
                    };
                    Spherical.prototype.copy = function(other) {
                        this.radius = other.radius;
                        this.phi = other.phi;
                        this.theta = other.theta;
                        return this;
                    };
                    // restrict phi to be between EPS and PI-EPS
                    Spherical.prototype.makeSafe = function() {
                        var EPS = 0.000001;
                        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
                        return this;
                    };
                    Spherical.prototype.setFromVector3 = function(v) {
                        return this.setFromCartesianCoords(v.x, v.y, v.z);
                    };
                    Spherical.prototype.setFromCartesianCoords = function(x, y, z) {
                        this.radius = Math.sqrt(x * x + y * y + z * z);
                        if (this.radius === 0) {
                            this.theta = 0;
                            this.phi = 0;
                        } else {
                            this.theta = Math.atan2(x, z);
                            this.phi = Math.acos(clamp(y / this.radius, -1, 1));
                        }
                        return this;
                    };
                    Spherical.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    return Spherical;
                }());
                /**
                 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
                 */
                var Cylindrical = /** @class */ (function() {
                    function Cylindrical(radius, theta, y) {
                        if (radius === void 0) {
                            radius = 1;
                        }
                        if (theta === void 0) {
                            theta = 0;
                        }
                        if (y === void 0) {
                            y = 0;
                        }
                        this.radius = radius; // distance from the origin to a point in the x-z plane
                        this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
                        this.y = y; // height above the x-z plane
                        return this;
                    }
                    Cylindrical.prototype.set = function(radius, theta, y) {
                        this.radius = radius;
                        this.theta = theta;
                        this.y = y;
                        return this;
                    };
                    Cylindrical.prototype.copy = function(other) {
                        this.radius = other.radius;
                        this.theta = other.theta;
                        this.y = other.y;
                        return this;
                    };
                    Cylindrical.prototype.setFromVector3 = function(v) {
                        return this.setFromCartesianCoords(v.x, v.y, v.z);
                    };
                    Cylindrical.prototype.setFromCartesianCoords = function(x, y, z) {
                        this.radius = Math.sqrt(x * x + z * z);
                        this.theta = Math.atan2(x, z);
                        this.y = y;
                        return this;
                    };
                    Cylindrical.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    return Cylindrical;
                }());
                var _vector$4 = /*@__PURE__*/ new Vector2();
                var Box2 = /** @class */ (function() {
                    function Box2(min, max) {
                        if (min === void 0) {
                            min = new Vector2(+Infinity, +Infinity);
                        }
                        if (max === void 0) {
                            max = new Vector2(-Infinity, -Infinity);
                        }
                        this.min = min;
                        this.max = max;
                    }
                    Box2.prototype.set = function(min, max) {
                        this.min.copy(min);
                        this.max.copy(max);
                        return this;
                    };
                    Box2.prototype.setFromPoints = function(points) {
                        this.makeEmpty();
                        for (var i = 0, il = points.length; i < il; i++) {
                            this.expandByPoint(points[i]);
                        }
                        return this;
                    };
                    Box2.prototype.setFromCenterAndSize = function(center, size) {
                        var halfSize = _vector$4.copy(size).multiplyScalar(0.5);
                        this.min.copy(center).sub(halfSize);
                        this.max.copy(center).add(halfSize);
                        return this;
                    };
                    Box2.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    Box2.prototype.copy = function(box) {
                        this.min.copy(box.min);
                        this.max.copy(box.max);
                        return this;
                    };
                    Box2.prototype.makeEmpty = function() {
                        this.min.x = this.min.y = +Infinity;
                        this.max.x = this.max.y = -Infinity;
                        return this;
                    };
                    Box2.prototype.isEmpty = function() {
                        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
                        return (this.max.x < this.min.x) || (this.max.y < this.min.y);
                    };
                    Box2.prototype.getCenter = function(target) {
                        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
                    };
                    Box2.prototype.getSize = function(target) {
                        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
                    };
                    Box2.prototype.expandByPoint = function(point) {
                        this.min.min(point);
                        this.max.max(point);
                        return this;
                    };
                    Box2.prototype.expandByVector = function(vector) {
                        this.min.sub(vector);
                        this.max.add(vector);
                        return this;
                    };
                    Box2.prototype.expandByScalar = function(scalar) {
                        this.min.addScalar(-scalar);
                        this.max.addScalar(scalar);
                        return this;
                    };
                    Box2.prototype.containsPoint = function(point) {
                        return point.x < this.min.x || point.x > this.max.x ||
                            point.y < this.min.y || point.y > this.max.y ? false : true;
                    };
                    Box2.prototype.containsBox = function(box) {
                        return this.min.x <= box.min.x && box.max.x <= this.max.x &&
                            this.min.y <= box.min.y && box.max.y <= this.max.y;
                    };
                    Box2.prototype.getParameter = function(point, target) {
                        // This can potentially have a divide by zero if the box
                        // has a size dimension of 0.
                        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
                    };
                    Box2.prototype.intersectsBox = function(box) {
                        // using 4 splitting planes to rule out intersections
                        return box.max.x < this.min.x || box.min.x > this.max.x ||
                            box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
                    };
                    Box2.prototype.clampPoint = function(point, target) {
                        return target.copy(point).clamp(this.min, this.max);
                    };
                    Box2.prototype.distanceToPoint = function(point) {
                        var clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
                        return clampedPoint.sub(point).length();
                    };
                    Box2.prototype.intersect = function(box) {
                        this.min.max(box.min);
                        this.max.min(box.max);
                        return this;
                    };
                    Box2.prototype.union = function(box) {
                        this.min.min(box.min);
                        this.max.max(box.max);
                        return this;
                    };
                    Box2.prototype.translate = function(offset) {
                        this.min.add(offset);
                        this.max.add(offset);
                        return this;
                    };
                    Box2.prototype.equals = function(box) {
                        return box.min.equals(this.min) && box.max.equals(this.max);
                    };
                    return Box2;
                }());
                Box2.prototype.isBox2 = true;
                var _startP = /*@__PURE__*/ new Vector3();
                var _startEnd = /*@__PURE__*/ new Vector3();
                var Line3 = /** @class */ (function() {
                    function Line3(start, end) {
                        if (start === void 0) {
                            start = new Vector3();
                        }
                        if (end === void 0) {
                            end = new Vector3();
                        }
                        this.start = start;
                        this.end = end;
                    }
                    Line3.prototype.set = function(start, end) {
                        this.start.copy(start);
                        this.end.copy(end);
                        return this;
                    };
                    Line3.prototype.copy = function(line) {
                        this.start.copy(line.start);
                        this.end.copy(line.end);
                        return this;
                    };
                    Line3.prototype.getCenter = function(target) {
                        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
                    };
                    Line3.prototype.delta = function(target) {
                        return target.subVectors(this.end, this.start);
                    };
                    Line3.prototype.distanceSq = function() {
                        return this.start.distanceToSquared(this.end);
                    };
                    Line3.prototype.distance = function() {
                        return this.start.distanceTo(this.end);
                    };
                    Line3.prototype.at = function(t, target) {
                        return this.delta(target).multiplyScalar(t).add(this.start);
                    };
                    Line3.prototype.closestPointToPointParameter = function(point, clampToLine) {
                        _startP.subVectors(point, this.start);
                        _startEnd.subVectors(this.end, this.start);
                        var startEnd2 = _startEnd.dot(_startEnd);
                        var startEnd_startP = _startEnd.dot(_startP);
                        var t = startEnd_startP / startEnd2;
                        if (clampToLine) {
                            t = clamp(t, 0, 1);
                        }
                        return t;
                    };
                    Line3.prototype.closestPointToPoint = function(point, clampToLine, target) {
                        var t = this.closestPointToPointParameter(point, clampToLine);
                        return this.delta(target).multiplyScalar(t).add(this.start);
                    };
                    Line3.prototype.applyMatrix4 = function(matrix) {
                        this.start.applyMatrix4(matrix);
                        this.end.applyMatrix4(matrix);
                        return this;
                    };
                    Line3.prototype.equals = function(line) {
                        return line.start.equals(this.start) && line.end.equals(this.end);
                    };
                    Line3.prototype.clone = function() {
                        return new this.constructor().copy(this);
                    };
                    return Line3;
                }());
                var _vector$3 = /*@__PURE__*/ new Vector3();
                var SpotLightHelper = /** @class */ (function(_super) {
                    __extends(SpotLightHelper, _super);

                    function SpotLightHelper(light, color) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.light = light;
                        _this_1.light.updateMatrixWorld();
                        _this_1.matrix = light.matrixWorld;
                        _this_1.matrixAutoUpdate = false;
                        _this_1.color = color;
                        var geometry = new BufferGeometry();
                        var positions = [
                            0, 0, 0, 0, 0, 1,
                            0, 0, 0, 1, 0, 1,
                            0, 0, 0, -1, 0, 1,
                            0, 0, 0, 0, 1, 1,
                            0, 0, 0, 0, -1, 1
                        ];
                        for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
                            var p1 = (i / l) * Math.PI * 2;
                            var p2 = (j / l) * Math.PI * 2;
                            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
                        }
                        geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
                        var material = new LineBasicMaterial({
                            fog: false,
                            toneMapped: false
                        });
                        _this_1.cone = new LineSegments(geometry, material);
                        _this_1.add(_this_1.cone);
                        _this_1.update();
                        return _this_1;
                    }
                    SpotLightHelper.prototype.dispose = function() {
                        this.cone.geometry.dispose();
                        this.cone.material.dispose();
                    };
                    SpotLightHelper.prototype.update = function() {
                        this.light.updateMatrixWorld();
                        var coneLength = this.light.distance ? this.light.distance : 1000;
                        var coneWidth = coneLength * Math.tan(this.light.angle);
                        this.cone.scale.set(coneWidth, coneWidth, coneLength);
                        _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
                        this.cone.lookAt(_vector$3);
                        if (this.color !== undefined) {
                            this.cone.material.color.set(this.color);
                        } else {
                            this.cone.material.color.copy(this.light.color);
                        }
                    };
                    return SpotLightHelper;
                }(Object3D));
                var _vector$2 = /*@__PURE__*/ new Vector3();
                var _boneMatrix = /*@__PURE__*/ new Matrix4();
                var _matrixWorldInv = /*@__PURE__*/ new Matrix4();
                var SkeletonHelper = /** @class */ (function(_super) {
                    __extends(SkeletonHelper, _super);

                    function SkeletonHelper(object) {
                        var _this_1 = this;
                        var bones = getBoneList(object);
                        var geometry = new BufferGeometry();
                        var vertices = [];
                        var colors = [];
                        var color1 = new Color(0, 0, 1);
                        var color2 = new Color(0, 1, 0);
                        for (var i = 0; i < bones.length; i++) {
                            var bone = bones[i];
                            if (bone.parent && bone.parent.isBone) {
                                vertices.push(0, 0, 0);
                                vertices.push(0, 0, 0);
                                colors.push(color1.r, color1.g, color1.b);
                                colors.push(color2.r, color2.g, color2.b);
                            }
                        }
                        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
                        var material = new LineBasicMaterial({
                            vertexColors: true,
                            depthTest: false,
                            depthWrite: false,
                            toneMapped: false,
                            transparent: true
                        });
                        _this_1 = _super.call(this, geometry, material) || this;
                        _this_1.type = 'SkeletonHelper';
                        _this_1.isSkeletonHelper = true;
                        _this_1.root = object;
                        _this_1.bones = bones;
                        _this_1.matrix = object.matrixWorld;
                        _this_1.matrixAutoUpdate = false;
                        return _this_1;
                    }
                    SkeletonHelper.prototype.updateMatrixWorld = function(force) {
                        var bones = this.bones;
                        var geometry = this.geometry;
                        var position = geometry.getAttribute('position');
                        _matrixWorldInv.copy(this.root.matrixWorld).invert();
                        for (var i = 0, j = 0; i < bones.length; i++) {
                            var bone = bones[i];
                            if (bone.parent && bone.parent.isBone) {
                                _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
                                _vector$2.setFromMatrixPosition(_boneMatrix);
                                position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
                                _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
                                _vector$2.setFromMatrixPosition(_boneMatrix);
                                position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
                                j += 2;
                            }
                        }
                        geometry.getAttribute('position').needsUpdate = true;
                        _super.prototype.updateMatrixWorld.call(this, force);
                    };
                    return SkeletonHelper;
                }(LineSegments));

                function getBoneList(object) {
                    var boneList = [];
                    if (object.isBone === true) {
                        boneList.push(object);
                    }
                    for (var i = 0; i < object.children.length; i++) {
                        boneList.push.apply(boneList, getBoneList(object.children[i]));
                    }
                    return boneList;
                }
                var PointLightHelper = /** @class */ (function(_super) {
                    __extends(PointLightHelper, _super);

                    function PointLightHelper(light, sphereSize, color) {
                        var _this_1 = this;
                        var geometry = new SphereGeometry(sphereSize, 4, 2);
                        var material = new MeshBasicMaterial({
                            wireframe: true,
                            fog: false,
                            toneMapped: false
                        });
                        _this_1 = _super.call(this, geometry, material) || this;
                        _this_1.light = light;
                        _this_1.light.updateMatrixWorld();
                        _this_1.color = color;
                        _this_1.type = 'PointLightHelper';
                        _this_1.matrix = _this_1.light.matrixWorld;
                        _this_1.matrixAutoUpdate = false;
                        _this_1.update();
                        return _this_1;
                        /*
    // TODO: delete this comment?
    const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
    const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

    this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
    this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

    const d = light.distance;

    if ( d === 0.0 ) {

        this.lightDistance.visible = false;

    } else {

        this.lightDistance.scale.set( d, d, d );

    }

    this.add( this.lightDistance );
    */
                    }
                    PointLightHelper.prototype.dispose = function() {
                        this.geometry.dispose();
                        this.material.dispose();
                    };
                    PointLightHelper.prototype.update = function() {
                        if (this.color !== undefined) {
                            this.material.color.set(this.color);
                        } else {
                            this.material.color.copy(this.light.color);
                        }
                        /*
                        const d = this.light.distance;

                        if ( d === 0.0 ) {

                            this.lightDistance.visible = false;

                        } else {

                            this.lightDistance.visible = true;
                            this.lightDistance.scale.set( d, d, d );

                        }
                        */
                    };
                    return PointLightHelper;
                }(Mesh));
                var _vector$1 = /*@__PURE__*/ new Vector3();
                var _color1 = /*@__PURE__*/ new Color();
                var _color2 = /*@__PURE__*/ new Color();
                var HemisphereLightHelper = /** @class */ (function(_super) {
                    __extends(HemisphereLightHelper, _super);

                    function HemisphereLightHelper(light, size, color) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.light = light;
                        _this_1.light.updateMatrixWorld();
                        _this_1.matrix = light.matrixWorld;
                        _this_1.matrixAutoUpdate = false;
                        _this_1.color = color;
                        var geometry = new OctahedronGeometry(size);
                        geometry.rotateY(Math.PI * 0.5);
                        _this_1.material = new MeshBasicMaterial({
                            wireframe: true,
                            fog: false,
                            toneMapped: false
                        });
                        if (_this_1.color === undefined)
                            _this_1.material.vertexColors = true;
                        var position = geometry.getAttribute('position');
                        var colors = new Float32Array(position.count * 3);
                        geometry.setAttribute('color', new BufferAttribute(colors, 3));
                        _this_1.add(new Mesh(geometry, _this_1.material));
                        _this_1.update();
                        return _this_1;
                    }
                    HemisphereLightHelper.prototype.dispose = function() {
                        this.children[0].geometry.dispose();
                        this.children[0].material.dispose();
                    };
                    HemisphereLightHelper.prototype.update = function() {
                        var mesh = this.children[0];
                        if (this.color !== undefined) {
                            this.material.color.set(this.color);
                        } else {
                            var colors = mesh.geometry.getAttribute('color');
                            _color1.copy(this.light.color);
                            _color2.copy(this.light.groundColor);
                            for (var i = 0, l = colors.count; i < l; i++) {
                                var color = (i < (l / 2)) ? _color1 : _color2;
                                colors.setXYZ(i, color.r, color.g, color.b);
                            }
                            colors.needsUpdate = true;
                        }
                        mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
                    };
                    return HemisphereLightHelper;
                }(Object3D));
                var GridHelper = /** @class */ (function(_super) {
                    __extends(GridHelper, _super);

                    function GridHelper(size, divisions, color1, color2) {
                        if (size === void 0) {
                            size = 10;
                        }
                        if (divisions === void 0) {
                            divisions = 10;
                        }
                        if (color1 === void 0) {
                            color1 = 0x444444;
                        }
                        if (color2 === void 0) {
                            color2 = 0x888888;
                        }
                        var _this_1 = this;
                        color1 = new Color(color1);
                        color2 = new Color(color2);
                        var center = divisions / 2;
                        var step = size / divisions;
                        var halfSize = size / 2;
                        var vertices = [],
                            colors = [];
                        for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
                            vertices.push(-halfSize, 0, k, halfSize, 0, k);
                            vertices.push(k, 0, -halfSize, k, 0, halfSize);
                            var color = i === center ? color1 : color2;
                            color.toArray(colors, j);
                            j += 3;
                            color.toArray(colors, j);
                            j += 3;
                            color.toArray(colors, j);
                            j += 3;
                            color.toArray(colors, j);
                            j += 3;
                        }
                        var geometry = new BufferGeometry();
                        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
                        var material = new LineBasicMaterial({
                            vertexColors: true,
                            toneMapped: false
                        });
                        _this_1 = _super.call(this, geometry, material) || this;
                        _this_1.type = 'GridHelper';
                        return _this_1;
                    }
                    return GridHelper;
                }(LineSegments));
                var PolarGridHelper = /** @class */ (function(_super) {
                    __extends(PolarGridHelper, _super);

                    function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
                        if (radius === void 0) {
                            radius = 10;
                        }
                        if (radials === void 0) {
                            radials = 16;
                        }
                        if (circles === void 0) {
                            circles = 8;
                        }
                        if (divisions === void 0) {
                            divisions = 64;
                        }
                        if (color1 === void 0) {
                            color1 = 0x444444;
                        }
                        if (color2 === void 0) {
                            color2 = 0x888888;
                        }
                        var _this_1 = this;
                        color1 = new Color(color1);
                        color2 = new Color(color2);
                        var vertices = [];
                        var colors = [];
                        // create the radials
                        for (var i = 0; i <= radials; i++) {
                            var v = (i / radials) * (Math.PI * 2);
                            var x = Math.sin(v) * radius;
                            var z = Math.cos(v) * radius;
                            vertices.push(0, 0, 0);
                            vertices.push(x, 0, z);
                            var color = (i & 1) ? color1 : color2;
                            colors.push(color.r, color.g, color.b);
                            colors.push(color.r, color.g, color.b);
                        }
                        // create the circles
                        for (var i = 0; i <= circles; i++) {
                            var color = (i & 1) ? color1 : color2;
                            var r = radius - (radius / circles * i);
                            for (var j = 0; j < divisions; j++) {
                                // first vertex
                                var v = (j / divisions) * (Math.PI * 2);
                                var x = Math.sin(v) * r;
                                var z = Math.cos(v) * r;
                                vertices.push(x, 0, z);
                                colors.push(color.r, color.g, color.b);
                                // second vertex
                                v = ((j + 1) / divisions) * (Math.PI * 2);
                                x = Math.sin(v) * r;
                                z = Math.cos(v) * r;
                                vertices.push(x, 0, z);
                                colors.push(color.r, color.g, color.b);
                            }
                        }
                        var geometry = new BufferGeometry();
                        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
                        var material = new LineBasicMaterial({
                            vertexColors: true,
                            toneMapped: false
                        });
                        _this_1 = _super.call(this, geometry, material) || this;
                        _this_1.type = 'PolarGridHelper';
                        return _this_1;
                    }
                    return PolarGridHelper;
                }(LineSegments));
                var _v1 = /*@__PURE__*/ new Vector3();
                var _v2 = /*@__PURE__*/ new Vector3();
                var _v3 = /*@__PURE__*/ new Vector3();
                var DirectionalLightHelper = /** @class */ (function(_super) {
                    __extends(DirectionalLightHelper, _super);

                    function DirectionalLightHelper(light, size, color) {
                        var _this_1 = _super.call(this) || this;
                        _this_1.light = light;
                        _this_1.light.updateMatrixWorld();
                        _this_1.matrix = light.matrixWorld;
                        _this_1.matrixAutoUpdate = false;
                        _this_1.color = color;
                        if (size === undefined)
                            size = 1;
                        var geometry = new BufferGeometry();
                        geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0,
                            size, size, 0,
                            size, -size, 0, -size, -size, 0, -size, size, 0
                        ], 3));
                        var material = new LineBasicMaterial({
                            fog: false,
                            toneMapped: false
                        });
                        _this_1.lightPlane = new Line(geometry, material);
                        _this_1.add(_this_1.lightPlane);
                        geometry = new BufferGeometry();
                        geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
                        _this_1.targetLine = new Line(geometry, material);
                        _this_1.add(_this_1.targetLine);
                        _this_1.update();
                        return _this_1;
                    }
                    DirectionalLightHelper.prototype.dispose = function() {
                        this.lightPlane.geometry.dispose();
                        this.lightPlane.material.dispose();
                        this.targetLine.geometry.dispose();
                        this.targetLine.material.dispose();
                    };
                    DirectionalLightHelper.prototype.update = function() {
                        _v1.setFromMatrixPosition(this.light.matrixWorld);
                        _v2.setFromMatrixPosition(this.light.target.matrixWorld);
                        _v3.subVectors(_v2, _v1);
                        this.lightPlane.lookAt(_v2);
                        if (this.color !== undefined) {
                            this.lightPlane.material.color.set(this.color);
                            this.targetLine.material.color.set(this.color);
                        } else {
                            this.lightPlane.material.color.copy(this.light.color);
                            this.targetLine.material.color.copy(this.light.color);
                        }
                        this.targetLine.lookAt(_v2);
                        this.targetLine.scale.z = _v3.length();
                    };
                    return DirectionalLightHelper;
                }(Object3D));
                var _vector = /*@__PURE__*/ new Vector3();
                var _camera = /*@__PURE__*/ new Camera();
                /**
                 *	- shows frustum, line of sight and up of the camera
                 *	- suitable for fast updates
                 * 	- based on frustum visualization in lightgl.js shadowmap example
                 *		https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html
                 */
                var CameraHelper = /** @class */ (function(_super) {
                    __extends(CameraHelper, _super);

                    function CameraHelper(camera) {
                        var _this_1 = this;
                        var geometry = new BufferGeometry();
                        var material = new LineBasicMaterial({
                            color: 0xffffff,
                            vertexColors: true,
                            toneMapped: false
                        });
                        var vertices = [];
                        var colors = [];
                        var pointMap = {};
                        // colors
                        var colorFrustum = new Color(0xffaa00);
                        var colorCone = new Color(0xff0000);
                        var colorUp = new Color(0x00aaff);
                        var colorTarget = new Color(0xffffff);
                        var colorCross = new Color(0x333333);
                        // near
                        addLine('n1', 'n2', colorFrustum);
                        addLine('n2', 'n4', colorFrustum);
                        addLine('n4', 'n3', colorFrustum);
                        addLine('n3', 'n1', colorFrustum);
                        // far
                        addLine('f1', 'f2', colorFrustum);
                        addLine('f2', 'f4', colorFrustum);
                        addLine('f4', 'f3', colorFrustum);
                        addLine('f3', 'f1', colorFrustum);
                        // sides
                        addLine('n1', 'f1', colorFrustum);
                        addLine('n2', 'f2', colorFrustum);
                        addLine('n3', 'f3', colorFrustum);
                        addLine('n4', 'f4', colorFrustum);
                        // cone
                        addLine('p', 'n1', colorCone);
                        addLine('p', 'n2', colorCone);
                        addLine('p', 'n3', colorCone);
                        addLine('p', 'n4', colorCone);
                        // up
                        addLine('u1', 'u2', colorUp);
                        addLine('u2', 'u3', colorUp);
                        addLine('u3', 'u1', colorUp);
                        // target
                        addLine('c', 't', colorTarget);
                        addLine('p', 'c', colorCross);
                        // cross
                        addLine('cn1', 'cn2', colorCross);
                        addLine('cn3', 'cn4', colorCross);
                        addLine('cf1', 'cf2', colorCross);
                        addLine('cf3', 'cf4', colorCross);

                        function addLine(a, b, color) {
                            addPoint(a, color);
                            addPoint(b, color);
                        }

                        function addPoint(id, color) {
                            vertices.push(0, 0, 0);
                            colors.push(color.r, color.g, color.b);
                            if (pointMap[id] === undefined) {
                                pointMap[id] = [];
                            }
                            pointMap[id].push((vertices.length / 3) - 1);
                        }
                        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
                        _this_1 = _super.call(this, geometry, material) || this;
                        _this_1.type = 'CameraHelper';
                        _this_1.camera = camera;
                        if (_this_1.camera.updateProjectionMatrix)
                            _this_1.camera.updateProjectionMatrix();
                        _this_1.matrix = camera.matrixWorld;
                        _this_1.matrixAutoUpdate = false;
                        _this_1.pointMap = pointMap;
                        _this_1.update();
                        return _this_1;
                    }
                    CameraHelper.prototype.update = function() {
                        var geometry = this.geometry;
                        var pointMap = this.pointMap;
                        var w = 1,
                            h = 1;
                        // we need just camera projection matrix inverse
                        // world matrix must be identity
                        _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
                        // center / target
                        setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
                        setPoint('t', pointMap, geometry, _camera, 0, 0, 1);
                        // near
                        setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
                        setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
                        setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
                        setPoint('n4', pointMap, geometry, _camera, w, h, -1);
                        // far
                        setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
                        setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
                        setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
                        setPoint('f4', pointMap, geometry, _camera, w, h, 1);
                        // up
                        setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
                        setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
                        setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1);
                        // cross
                        setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
                        setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
                        setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
                        setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
                        setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
                        setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
                        setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
                        setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
                        geometry.getAttribute('position').needsUpdate = true;
                    };
                    CameraHelper.prototype.dispose = function() {
                        this.geometry.dispose();
                        this.material.dispose();
                    };
                    return CameraHelper;
                }(LineSegments));

                function setPoint(point, pointMap, geometry, camera, x, y, z) {
                    _vector.set(x, y, z).unproject(camera);
                    var points = pointMap[point];
                    if (points !== undefined) {
                        var position = geometry.getAttribute('position');
                        for (var i = 0, l = points.length; i < l; i++) {
                            position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
                        }
                    }
                }
                var _box = /*@__PURE__*/ new Box3();
                var BoxHelper = /** @class */ (function(_super) {
                    __extends(BoxHelper, _super);

                    function BoxHelper(object, color) {
                        if (color === void 0) {
                            color = 0xffff00;
                        }
                        var _this_1 = this;
                        var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
                        var positions = new Float32Array(8 * 3);
                        var geometry = new BufferGeometry();
                        geometry.setIndex(new BufferAttribute(indices, 1));
                        geometry.setAttribute('position', new BufferAttribute(positions, 3));
                        _this_1 = _super.call(this, geometry, new LineBasicMaterial({
                            color: color,
                            toneMapped: false
                        })) || this;
                        _this_1.object = object;
                        _this_1.type = 'BoxHelper';
                        _this_1.matrixAutoUpdate = false;
                        _this_1.update();
                        return _this_1;
                    }
                    BoxHelper.prototype.update = function(object) {
                        if (object !== undefined) {
                            console.warn('THREE.BoxHelper: .update() has no longer arguments.');
                        }
                        if (this.object !== undefined) {
                            _box.setFromObject(this.object);
                        }
                        if (_box.isEmpty())
                            return;
                        var min = _box.min;
                        var max = _box.max;
                        /*
                            5____4
                        1/___0/|
                        | 6__|_7
                        2/___3/

                        0: max.x, max.y, max.z
                        1: min.x, max.y, max.z
                        2: min.x, min.y, max.z
                        3: max.x, min.y, max.z
                        4: max.x, max.y, min.z
                        5: min.x, max.y, min.z
                        6: min.x, min.y, min.z
                        7: max.x, min.y, min.z
                        */
                        var position = this.geometry.attributes.position;
                        var array = position.array;
                        array[0] = max.x;
                        array[1] = max.y;
                        array[2] = max.z;
                        array[3] = min.x;
                        array[4] = max.y;
                        array[5] = max.z;
                        array[6] = min.x;
                        array[7] = min.y;
                        array[8] = max.z;
                        array[9] = max.x;
                        array[10] = min.y;
                        array[11] = max.z;
                        array[12] = max.x;
                        array[13] = max.y;
                        array[14] = min.z;
                        array[15] = min.x;
                        array[16] = max.y;
                        array[17] = min.z;
                        array[18] = min.x;
                        array[19] = min.y;
                        array[20] = min.z;
                        array[21] = max.x;
                        array[22] = min.y;
                        array[23] = min.z;
                        position.needsUpdate = true;
                        this.geometry.computeBoundingSphere();
                    };
                    BoxHelper.prototype.setFromObject = function(object) {
                        this.object = object;
                        this.update();
                        return this;
                    };
                    BoxHelper.prototype.copy = function(source) {
                        LineSegments.prototype.copy.call(this, source);
                        this.object = source.object;
                        return this;
                    };
                    return BoxHelper;
                }(LineSegments));
                var Box3Helper = /** @class */ (function(_super) {
                    __extends(Box3Helper, _super);

                    function Box3Helper(box, color) {
                        if (color === void 0) {
                            color = 0xffff00;
                        }
                        var _this_1 = this;
                        var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
                        var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
                        var geometry = new BufferGeometry();
                        geometry.setIndex(new BufferAttribute(indices, 1));
                        geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
                        _this_1 = _super.call(this, geometry, new LineBasicMaterial({
                            color: color,
                            toneMapped: false
                        })) || this;
                        _this_1.box = box;
                        _this_1.type = 'Box3Helper';
                        _this_1.geometry.computeBoundingSphere();
                        return _this_1;
                    }
                    Box3Helper.prototype.updateMatrixWorld = function(force) {
                        var box = this.box;
                        if (box.isEmpty())
                            return;
                        box.getCenter(this.position);
                        box.getSize(this.scale);
                        this.scale.multiplyScalar(0.5);
                        _super.prototype.updateMatrixWorld.call(this, force);
                    };
                    return Box3Helper;
                }(LineSegments));
                var PlaneHelper = /** @class */ (function(_super) {
                    __extends(PlaneHelper, _super);

                    function PlaneHelper(plane, size, hex) {
                        if (size === void 0) {
                            size = 1;
                        }
                        if (hex === void 0) {
                            hex = 0xffff00;
                        }
                        var _this_1 = this;
                        var color = hex;
                        var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
                        var geometry = new BufferGeometry();
                        geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
                        geometry.computeBoundingSphere();
                        _this_1 = _super.call(this, geometry, new LineBasicMaterial({
                            color: color,
                            toneMapped: false
                        })) || this;
                        _this_1.type = 'PlaneHelper';
                        _this_1.plane = plane;
                        _this_1.size = size;
                        var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
                        var geometry2 = new BufferGeometry();
                        geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
                        geometry2.computeBoundingSphere();
                        _this_1.add(new Mesh(geometry2, new MeshBasicMaterial({
                            color: color,
                            opacity: 0.2,
                            transparent: true,
                            depthWrite: false,
                            toneMapped: false
                        })));
                        return _this_1;
                    }
                    PlaneHelper.prototype.updateMatrixWorld = function(force) {
                        var scale = -this.plane.constant;
                        if (Math.abs(scale) < 1e-8)
                            scale = 1e-8; // sign does not matter
                        this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
                        this.children[0].material.side = (scale < 0) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here
                        this.lookAt(this.plane.normal);
                        _super.prototype.updateMatrixWorld.call(this, force);
                    };
                    return PlaneHelper;
                }(Line));
                var _axis = /*@__PURE__*/ new Vector3();
                var _lineGeometry, _coneGeometry;
                var ArrowHelper = /** @class */ (function(_super) {
                    __extends(ArrowHelper, _super);
                    // dir is assumed to be normalized
                    function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
                        if (dir === void 0) {
                            dir = new Vector3(0, 0, 1);
                        }
                        if (origin === void 0) {
                            origin = new Vector3(0, 0, 0);
                        }
                        if (length === void 0) {
                            length = 1;
                        }
                        if (color === void 0) {
                            color = 0xffff00;
                        }
                        if (headLength === void 0) {
                            headLength = length * 0.2;
                        }
                        if (headWidth === void 0) {
                            headWidth = headLength * 0.2;
                        }
                        var _this_1 = _super.call(this) || this;
                        _this_1.type = 'ArrowHelper';
                        if (_lineGeometry === undefined) {
                            _lineGeometry = new BufferGeometry();
                            _lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
                            _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
                            _coneGeometry.translate(0, -0.5, 0);
                        }
                        _this_1.position.copy(origin);
                        _this_1.line = new Line(_lineGeometry, new LineBasicMaterial({
                            color: color,
                            toneMapped: false
                        }));
                        _this_1.line.matrixAutoUpdate = false;
                        _this_1.add(_this_1.line);
                        _this_1.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
                            color: color,
                            toneMapped: false
                        }));
                        _this_1.cone.matrixAutoUpdate = false;
                        _this_1.add(_this_1.cone);
                        _this_1.setDirection(dir);
                        _this_1.setLength(length, headLength, headWidth);
                        return _this_1;
                    }
                    ArrowHelper.prototype.setDirection = function(dir) {
                        // dir is assumed to be normalized
                        if (dir.y > 0.99999) {
                            this.quaternion.set(0, 0, 0, 1);
                        } else if (dir.y < -0.99999) {
                            this.quaternion.set(1, 0, 0, 0);
                        } else {
                            _axis.set(dir.z, 0, -dir.x).normalize();
                            var radians = Math.acos(dir.y);
                            this.quaternion.setFromAxisAngle(_axis, radians);
                        }
                    };
                    ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
                        if (headLength === void 0) {
                            headLength = length * 0.2;
                        }
                        if (headWidth === void 0) {
                            headWidth = headLength * 0.2;
                        }
                        this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
                        this.line.updateMatrix();
                        this.cone.scale.set(headWidth, headLength, headWidth);
                        this.cone.position.y = length;
                        this.cone.updateMatrix();
                    };
                    ArrowHelper.prototype.setColor = function(color) {
                        this.line.material.color.set(color);
                        this.cone.material.color.set(color);
                    };
                    ArrowHelper.prototype.copy = function(source) {
                        _super.prototype.copy.call(this, source, false);
                        this.line.copy(source.line);
                        this.cone.copy(source.cone);
                        return this;
                    };
                    return ArrowHelper;
                }(Object3D));
                var AxesHelper = /** @class */ (function(_super) {
                    __extends(AxesHelper, _super);

                    function AxesHelper(size) {
                        if (size === void 0) {
                            size = 1;
                        }
                        var _this_1 = this;
                        var vertices = [
                            0, 0, 0, size, 0, 0,
                            0, 0, 0, 0, size, 0,
                            0, 0, 0, 0, 0, size
                        ];
                        var colors = [
                            1, 0, 0, 1, 0.6, 0,
                            0, 1, 0, 0.6, 1, 0,
                            0, 0, 1, 0, 0.6, 1
                        ];
                        var geometry = new BufferGeometry();
                        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
                        var material = new LineBasicMaterial({
                            vertexColors: true,
                            toneMapped: false
                        });
                        _this_1 = _super.call(this, geometry, material) || this;
                        _this_1.type = 'AxesHelper';
                        return _this_1;
                    }
                    AxesHelper.prototype.setColors = function(xAxisColor, yAxisColor, zAxisColor) {
                        var color = new Color();
                        var array = this.geometry.attributes.color.array;
                        color.set(xAxisColor);
                        color.toArray(array, 0);
                        color.toArray(array, 3);
                        color.set(yAxisColor);
                        color.toArray(array, 6);
                        color.toArray(array, 9);
                        color.set(zAxisColor);
                        color.toArray(array, 12);
                        color.toArray(array, 15);
                        this.geometry.attributes.color.needsUpdate = true;
                        return this;
                    };
                    AxesHelper.prototype.dispose = function() {
                        this.geometry.dispose();
                        this.material.dispose();
                    };
                    return AxesHelper;
                }(LineSegments));
                var ShapePath = /** @class */ (function() {
                    function ShapePath() {
                        this.type = 'ShapePath';
                        this.color = new Color();
                        this.subPaths = [];
                        this.currentPath = null;
                    }
                    ShapePath.prototype.moveTo = function(x, y) {
                        this.currentPath = new Path();
                        this.subPaths.push(this.currentPath);
                        this.currentPath.moveTo(x, y);
                        return this;
                    };
                    ShapePath.prototype.lineTo = function(x, y) {
                        this.currentPath.lineTo(x, y);
                        return this;
                    };
                    ShapePath.prototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
                        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
                        return this;
                    };
                    ShapePath.prototype.bezierCurveTo = function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
                        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
                        return this;
                    };
                    ShapePath.prototype.splineThru = function(pts) {
                        this.currentPath.splineThru(pts);
                        return this;
                    };
                    ShapePath.prototype.toShapes = function(isCCW, noHoles) {
                        function toShapesNoHoles(inSubpaths) {
                            var shapes = [];
                            for (var i = 0, l = inSubpaths.length; i < l; i++) {
                                var tmpPath_1 = inSubpaths[i];
                                var tmpShape_1 = new Shape();
                                tmpShape_1.curves = tmpPath_1.curves;
                                shapes.push(tmpShape_1);
                            }
                            return shapes;
                        }

                        function isPointInsidePolygon(inPt, inPolygon) {
                            var polyLen = inPolygon.length;
                            // inPt on polygon contour => immediate success    or
                            // toggling of inside/outside at every single! intersection point of an edge
                            //  with the horizontal line through inPt, left of inPt
                            //  not counting lowerY endpoints of edges and whole edges on that line
                            var inside = false;
                            for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                                var edgeLowPt = inPolygon[p];
                                var edgeHighPt = inPolygon[q];
                                var edgeDx = edgeHighPt.x - edgeLowPt.x;
                                var edgeDy = edgeHighPt.y - edgeLowPt.y;
                                if (Math.abs(edgeDy) > Number.EPSILON) {
                                    // not parallel
                                    if (edgeDy < 0) {
                                        edgeLowPt = inPolygon[q];
                                        edgeDx = -edgeDx;
                                        edgeHighPt = inPolygon[p];
                                        edgeDy = -edgeDy;
                                    }
                                    if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y))
                                        continue;
                                    if (inPt.y === edgeLowPt.y) {
                                        if (inPt.x === edgeLowPt.x)
                                            return true; // inPt is on contour ?
                                        // continue;				// no intersection or edgeLowPt => doesn't count !!!
                                    } else {
                                        var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                                        if (perpEdge === 0)
                                            return true; // inPt is on contour ?
                                        if (perpEdge < 0)
                                            continue;
                                        inside = !inside; // true intersection left of inPt
                                    }
                                } else {
                                    // parallel or collinear
                                    if (inPt.y !== edgeLowPt.y)
                                        continue; // parallel
                                    // edge lies on the same horizontal line as inPt
                                    if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) ||
                                        ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x)))
                                        return true; // inPt: Point on contour !
                                    // continue;
                                }
                            }
                            return inside;
                        }
                        var isClockWise = ShapeUtils.isClockWise;
                        var subPaths = this.subPaths;
                        if (subPaths.length === 0)
                            return [];
                        if (noHoles === true)
                            return toShapesNoHoles(subPaths);
                        var solid, tmpPath, tmpShape;
                        var shapes = [];
                        if (subPaths.length === 1) {
                            tmpPath = subPaths[0];
                            tmpShape = new Shape();
                            tmpShape.curves = tmpPath.curves;
                            shapes.push(tmpShape);
                            return shapes;
                        }
                        var holesFirst = !isClockWise(subPaths[0].getPoints());
                        holesFirst = isCCW ? !holesFirst : holesFirst;
                        // console.log("Holes first", holesFirst);
                        var betterShapeHoles = [];
                        var newShapes = [];
                        var newShapeHoles = [];
                        var mainIdx = 0;
                        var tmpPoints;
                        newShapes[mainIdx] = undefined;
                        newShapeHoles[mainIdx] = [];
                        for (var i = 0, l = subPaths.length; i < l; i++) {
                            tmpPath = subPaths[i];
                            tmpPoints = tmpPath.getPoints();
                            solid = isClockWise(tmpPoints);
                            solid = isCCW ? !solid : solid;
                            if (solid) {
                                if ((!holesFirst) && (newShapes[mainIdx]))
                                    mainIdx++;
                                newShapes[mainIdx] = {
                                    s: new Shape(),
                                    p: tmpPoints
                                };
                                newShapes[mainIdx].s.curves = tmpPath.curves;
                                if (holesFirst)
                                    mainIdx++;
                                newShapeHoles[mainIdx] = [];
                                //console.log('cw', i);
                            } else {
                                newShapeHoles[mainIdx].push({
                                    h: tmpPath,
                                    p: tmpPoints[0]
                                });
                                //console.log('ccw', i);
                            }
                        }
                        // only Holes? -> probably all Shapes with wrong orientation
                        if (!newShapes[0])
                            return toShapesNoHoles(subPaths);
                        if (newShapes.length > 1) {
                            var ambiguous = false;
                            var toChange = 0;
                            for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                                betterShapeHoles[sIdx] = [];
                            }
                            for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                                var sho = newShapeHoles[sIdx];
                                for (var hIdx = 0; hIdx < sho.length; hIdx++) {
                                    var ho = sho[hIdx];
                                    var hole_unassigned = true;
                                    for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                                        if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                                            if (sIdx !== s2Idx)
                                                toChange++;
                                            if (hole_unassigned) {
                                                hole_unassigned = false;
                                                betterShapeHoles[s2Idx].push(ho);
                                            } else {
                                                ambiguous = true;
                                            }
                                        }
                                    }
                                    if (hole_unassigned) {
                                        betterShapeHoles[sIdx].push(ho);
                                    }
                                }
                            }
                            if (toChange > 0 && ambiguous === false) {
                                newShapeHoles = betterShapeHoles;
                            }
                        }
                        var tmpHoles;
                        for (var i = 0, il = newShapes.length; i < il; i++) {
                            tmpShape = newShapes[i].s;
                            shapes.push(tmpShape);
                            tmpHoles = newShapeHoles[i];
                            for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
                                tmpShape.holes.push(tmpHoles[j].h);
                            }
                        }
                        //console.log("shape", shapes);
                        return shapes;
                    };
                    return ShapePath;
                }());
                // Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
                var DataUtils = /** @class */ (function() {
                    function DataUtils() {}
                    // float32 to float16
                    DataUtils.toHalfFloat = function(val) {
                        if (Math.abs(val) > 65504)
                            console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.');
                        val = clamp(val, -65504, 65504);
                        _floatView[0] = val;
                        var f = _uint32View[0];
                        var e = (f >> 23) & 0x1ff;
                        return _baseTable[e] + ((f & 0x007fffff) >> _shiftTable[e]);
                    };
                    // float16 to float32
                    DataUtils.fromHalfFloat = function(val) {
                        var m = val >> 10;
                        _uint32View[0] = _mantissaTable[_offsetTable[m] + (val & 0x3ff)] + _exponentTable[m];
                        return _floatView[0];
                    };
                    return DataUtils;
                }());
                // float32 to float16 helpers
                var _buffer = new ArrayBuffer(4);
                var _floatView = new Float32Array(_buffer);
                var _uint32View = new Uint32Array(_buffer);
                var _baseTable = new Uint32Array(512);
                var _shiftTable = new Uint32Array(512);
                for (var i = 0; i < 256; ++i) {
                    var e = i - 127;
                    // very small number (0, -0)
                    if (e < -27) {
                        _baseTable[i] = 0x0000;
                        _baseTable[i | 0x100] = 0x8000;
                        _shiftTable[i] = 24;
                        _shiftTable[i | 0x100] = 24;
                        // small number (denorm)
                    } else if (e < -14) {
                        _baseTable[i] = 0x0400 >> (-e - 14);
                        _baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;
                        _shiftTable[i] = -e - 1;
                        _shiftTable[i | 0x100] = -e - 1;
                        // normal number
                    } else if (e <= 15) {
                        _baseTable[i] = (e + 15) << 10;
                        _baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;
                        _shiftTable[i] = 13;
                        _shiftTable[i | 0x100] = 13;
                        // large number (Infinity, -Infinity)
                    } else if (e < 128) {
                        _baseTable[i] = 0x7c00;
                        _baseTable[i | 0x100] = 0xfc00;
                        _shiftTable[i] = 24;
                        _shiftTable[i | 0x100] = 24;
                        // stay (NaN, Infinity, -Infinity)
                    } else {
                        _baseTable[i] = 0x7c00;
                        _baseTable[i | 0x100] = 0xfc00;
                        _shiftTable[i] = 13;
                        _shiftTable[i | 0x100] = 13;
                    }
                }
                // float16 to float32 helpers
                var _mantissaTable = new Uint32Array(2048);
                var _exponentTable = new Uint32Array(64);
                var _offsetTable = new Uint32Array(64);
                for (var i = 1; i < 1024; ++i) {
                    var m = i << 13; // zero pad mantissa bits
                    var e = 0; // zero exponent
                    // normalized
                    while ((m & 0x00800000) === 0) {
                        m <<= 1;
                        e -= 0x00800000; // decrement exponent
                    }
                    m &= ~0x00800000; // clear leading 1 bit
                    e += 0x38800000; // adjust bias
                    _mantissaTable[i] = m | e;
                }
                for (var i = 1024; i < 2048; ++i) {
                    _mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);
                }
                for (var i = 1; i < 31; ++i) {
                    _exponentTable[i] = i << 23;
                }
                _exponentTable[31] = 0x47800000;
                _exponentTable[32] = 0x80000000;
                for (var i = 33; i < 63; ++i) {
                    _exponentTable[i] = 0x80000000 + ((i - 32) << 23);
                }
                _exponentTable[63] = 0xc7800000;
                for (var i = 1; i < 64; ++i) {
                    if (i !== 32) {
                        _offsetTable[i] = 1024;
                    }
                }
                var LineStrip = 0;
                var LinePieces = 1;
                var NoColors = 0;
                var FaceColors = 1;
                var VertexColors = 2;

                function MeshFaceMaterial(materials) {
                    console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
                    return materials;
                }

                function MultiMaterial(materials) {
                    if (materials === void 0) {
                        materials = [];
                    }
                    console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
                    materials.isMultiMaterial = true;
                    materials.materials = materials;
                    materials.clone = function() {
                        return materials.slice();
                    };
                    return materials;
                }
                var PointCloud = /** @class */ (function(_super) {
                    __extends(PointCloud, _super);

                    function PointCloud(geometry, material) {
                        console.warn('THREE.PointCloud has been renamed to THREE.Points.');
                        return _super.call(this, geometry, material) || this;
                    }
                    return PointCloud;
                }(Points));
                var Particle = /** @class */ (function(_super) {
                    __extends(Particle, _super);

                    function Particle(material) {
                        console.warn('THREE.Particle has been renamed to THREE.Sprite.');
                        return _super.call(this, material) || this;
                    }
                    return Particle;
                }(Sprite));
                var ParticleSystem = /** @class */ (function(_super) {
                    __extends(ParticleSystem, _super);

                    function ParticleSystem(geometry, material) {
                        console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
                        return _super.call(this, geometry, material) || this;
                    }
                    return ParticleSystem;
                }(Points));
                var PointCloudMaterial = /** @class */ (function(_super) {
                    __extends(PointCloudMaterial, _super);

                    function PointCloudMaterial(parameters) {
                        console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
                        return _super.call(this, parameters) || this;
                    }
                    return PointCloudMaterial;
                }(PointsMaterial));
                var ParticleBasicMaterial = /** @class */ (function(_super) {
                    __extends(ParticleBasicMaterial, _super);

                    function ParticleBasicMaterial(parameters) {
                        console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
                        return _super.call(this, parameters) || this;
                    }
                    return ParticleBasicMaterial;
                }(PointsMaterial));
                var ParticleSystemMaterial = /** @class */ (function(_super) {
                    __extends(ParticleSystemMaterial, _super);

                    function ParticleSystemMaterial(parameters) {
                        console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
                        return _super.call(this, parameters) || this;
                    }
                    return ParticleSystemMaterial;
                }(PointsMaterial));
                var Vertex = /** @class */ (function(_super) {
                    __extends(Vertex, _super);

                    function Vertex(x, y, z) {
                        console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
                        return _super.call(this, x, y, z) || this;
                    }
                    return Vertex;
                }(Vector3));
                //
                var DynamicBufferAttribute = /** @class */ (function(_super) {
                    __extends(DynamicBufferAttribute, _super);

                    function DynamicBufferAttribute(array, itemSize) {
                        var _this_1 = this;
                        console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
                        _this_1 = _super.call(this, array, itemSize) || this;
                        _this_1.setUsage(DynamicDrawUsage);
                        return _this_1;
                    }
                    return DynamicBufferAttribute;
                }(BufferAttribute));
                var Int8Attribute = /** @class */ (function(_super) {
                    __extends(Int8Attribute, _super);

                    function Int8Attribute(array, itemSize) {
                        console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
                        return _super.call(this, array, itemSize) || this;
                    }
                    return Int8Attribute;
                }(Int8BufferAttribute));
                var Uint8Attribute = /** @class */ (function(_super) {
                    __extends(Uint8Attribute, _super);

                    function Uint8Attribute(array, itemSize) {
                        console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
                        return _super.call(this, array, itemSize) || this;
                    }
                    return Uint8Attribute;
                }(Uint8BufferAttribute));
                var Uint8ClampedAttribute = /** @class */ (function(_super) {
                    __extends(Uint8ClampedAttribute, _super);

                    function Uint8ClampedAttribute(array, itemSize) {
                        console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
                        return _super.call(this, array, itemSize) || this;
                    }
                    return Uint8ClampedAttribute;
                }(Uint8ClampedBufferAttribute));
                var Int16Attribute = /** @class */ (function(_super) {
                    __extends(Int16Attribute, _super);

                    function Int16Attribute(array, itemSize) {
                        console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
                        return _super.call(this, array, itemSize) || this;
                    }
                    return Int16Attribute;
                }(Int16BufferAttribute));
                var Uint16Attribute = /** @class */ (function(_super) {
                    __extends(Uint16Attribute, _super);

                    function Uint16Attribute(array, itemSize) {
                        console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
                        return _super.call(this, array, itemSize) || this;
                    }
                    return Uint16Attribute;
                }(Uint16BufferAttribute));
                var Int32Attribute = /** @class */ (function(_super) {
                    __extends(Int32Attribute, _super);

                    function Int32Attribute(array, itemSize) {
                        console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
                        return _super.call(this, array, itemSize) || this;
                    }
                    return Int32Attribute;
                }(Int32BufferAttribute));
                var Uint32Attribute = /** @class */ (function(_super) {
                    __extends(Uint32Attribute, _super);

                    function Uint32Attribute(array, itemSize) {
                        console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
                        return _super.call(this, array, itemSize) || this;
                    }
                    return Uint32Attribute;
                }(Uint32BufferAttribute));
                var Float32Attribute = /** @class */ (function(_super) {
                    __extends(Float32Attribute, _super);

                    function Float32Attribute(array, itemSize) {
                        console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
                        return _super.call(this, array, itemSize) || this;
                    }
                    return Float32Attribute;
                }(Float32BufferAttribute));
                var Float64Attribute = /** @class */ (function(_super) {
                    __extends(Float64Attribute, _super);

                    function Float64Attribute(array, itemSize) {
                        console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
                        return _super.call(this, array, itemSize) || this;
                    }
                    return Float64Attribute;
                }(Float64BufferAttribute));
                //
                Curve.create = function(construct, getPoint) {
                    console.log('THREE.Curve.create() has been deprecated');
                    construct.prototype = Object.create(Curve.prototype);
                    construct.prototype.constructor = construct;
                    construct.prototype.getPoint = getPoint;
                    return construct;
                };
                //
                Path.prototype.fromPoints = function(points) {
                    console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
                    return this.setFromPoints(points);
                };
                //
                var AxisHelper = /** @class */ (function(_super) {
                    __extends(AxisHelper, _super);

                    function AxisHelper(size) {
                        console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
                        return _super.call(this, size) || this;
                    }
                    return AxisHelper;
                }(AxesHelper));
                var BoundingBoxHelper = /** @class */ (function(_super) {
                    __extends(BoundingBoxHelper, _super);

                    function BoundingBoxHelper(object, color) {
                        console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
                        return _super.call(this, object, color) || this;
                    }
                    return BoundingBoxHelper;
                }(BoxHelper));
                var EdgesHelper = /** @class */ (function(_super) {
                    __extends(EdgesHelper, _super);

                    function EdgesHelper(object, hex) {
                        console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
                        return _super.call(this, new EdgesGeometry(object.geometry), new LineBasicMaterial({
                            color: hex !== undefined ? hex : 0xffffff
                        })) || this;
                    }
                    return EdgesHelper;
                }(LineSegments));
                GridHelper.prototype.setColors = function() {
                    console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
                };
                SkeletonHelper.prototype.update = function() {
                    console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
                };
                var WireframeHelper = /** @class */ (function(_super) {
                    __extends(WireframeHelper, _super);

                    function WireframeHelper(object, hex) {
                        console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
                        return _super.call(this, new WireframeGeometry(object.geometry), new LineBasicMaterial({
                            color: hex !== undefined ? hex : 0xffffff
                        })) || this;
                    }
                    return WireframeHelper;
                }(LineSegments));
                //
                Loader.prototype.extractUrlBase = function(url) {
                    console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
                    return LoaderUtils.extractUrlBase(url);
                };
                Loader.Handlers = {
                    add: function( /* regex, loader */ ) {
                        console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
                    },
                    get: function( /* file */ ) {
                        console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
                    }
                };
                var XHRLoader = /** @class */ (function(_super) {
                    __extends(XHRLoader, _super);

                    function XHRLoader(manager) {
                        console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
                        return _super.call(this, manager) || this;
                    }
                    return XHRLoader;
                }(FileLoader));
                var BinaryTextureLoader = /** @class */ (function(_super) {
                    __extends(BinaryTextureLoader, _super);

                    function BinaryTextureLoader(manager) {
                        console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
                        return _super.call(this, manager) || this;
                    }
                    return BinaryTextureLoader;
                }(DataTextureLoader));
                //
                Box2.prototype.center = function(optionalTarget) {
                    console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
                    return this.getCenter(optionalTarget);
                };
                Box2.prototype.empty = function() {
                    console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
                    return this.isEmpty();
                };
                Box2.prototype.isIntersectionBox = function(box) {
                    console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
                    return this.intersectsBox(box);
                };
                Box2.prototype.size = function(optionalTarget) {
                    console.warn('THREE.Box2: .size() has been renamed to .getSize().');
                    return this.getSize(optionalTarget);
                };
                //
                Box3.prototype.center = function(optionalTarget) {
                    console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
                    return this.getCenter(optionalTarget);
                };
                Box3.prototype.empty = function() {
                    console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
                    return this.isEmpty();
                };
                Box3.prototype.isIntersectionBox = function(box) {
                    console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
                    return this.intersectsBox(box);
                };
                Box3.prototype.isIntersectionSphere = function(sphere) {
                    console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
                    return this.intersectsSphere(sphere);
                };
                Box3.prototype.size = function(optionalTarget) {
                    console.warn('THREE.Box3: .size() has been renamed to .getSize().');
                    return this.getSize(optionalTarget);
                };
                //
                Euler.prototype.toVector3 = function() {
                    console.error('THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead');
                };
                //
                Sphere.prototype.empty = function() {
                    console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
                    return this.isEmpty();
                };
                //
                Frustum.prototype.setFromMatrix = function(m) {
                    console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
                    return this.setFromProjectionMatrix(m);
                };
                //
                Line3.prototype.center = function(optionalTarget) {
                    console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
                    return this.getCenter(optionalTarget);
                };
                //
                Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
                    console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
                    return this.toArray(array, offset);
                };
                Matrix3.prototype.multiplyVector3 = function(vector) {
                    console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
                    return vector.applyMatrix3(this);
                };
                Matrix3.prototype.multiplyVector3Array = function( /* a */ ) {
                    console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
                };
                Matrix3.prototype.applyToBufferAttribute = function(attribute) {
                    console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
                    return attribute.applyMatrix3(this);
                };
                Matrix3.prototype.applyToVector3Array = function( /* array, offset, length */ ) {
                    console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
                };
                Matrix3.prototype.getInverse = function(matrix) {
                    console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
                    return this.copy(matrix).invert();
                };
                //
                Matrix4.prototype.extractPosition = function(m) {
                    console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
                    return this.copyPosition(m);
                };
                Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
                    console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
                    return this.toArray(array, offset);
                };
                Matrix4.prototype.getPosition = function() {
                    console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
                    return new Vector3().setFromMatrixColumn(this, 3);
                };
                Matrix4.prototype.setRotationFromQuaternion = function(q) {
                    console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
                    return this.makeRotationFromQuaternion(q);
                };
                Matrix4.prototype.multiplyToArray = function() {
                    console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
                };
                Matrix4.prototype.multiplyVector3 = function(vector) {
                    console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
                    return vector.applyMatrix4(this);
                };
                Matrix4.prototype.multiplyVector4 = function(vector) {
                    console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
                    return vector.applyMatrix4(this);
                };
                Matrix4.prototype.multiplyVector3Array = function( /* a */ ) {
                    console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
                };
                Matrix4.prototype.rotateAxis = function(v) {
                    console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
                    v.transformDirection(this);
                };
                Matrix4.prototype.crossVector = function(vector) {
                    console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
                    return vector.applyMatrix4(this);
                };
                Matrix4.prototype.translate = function() {
                    console.error('THREE.Matrix4: .translate() has been removed.');
                };
                Matrix4.prototype.rotateX = function() {
                    console.error('THREE.Matrix4: .rotateX() has been removed.');
                };
                Matrix4.prototype.rotateY = function() {
                    console.error('THREE.Matrix4: .rotateY() has been removed.');
                };
                Matrix4.prototype.rotateZ = function() {
                    console.error('THREE.Matrix4: .rotateZ() has been removed.');
                };
                Matrix4.prototype.rotateByAxis = function() {
                    console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
                };
                Matrix4.prototype.applyToBufferAttribute = function(attribute) {
                    console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
                    return attribute.applyMatrix4(this);
                };
                Matrix4.prototype.applyToVector3Array = function( /* array, offset, length */ ) {
                    console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
                };
                Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
                    console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
                    return this.makePerspective(left, right, top, bottom, near, far);
                };
                Matrix4.prototype.getInverse = function(matrix) {
                    console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
                    return this.copy(matrix).invert();
                };
                //
                Plane.prototype.isIntersectionLine = function(line) {
                    console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
                    return this.intersectsLine(line);
                };
                //
                Quaternion.prototype.multiplyVector3 = function(vector) {
                    console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
                    return vector.applyQuaternion(this);
                };
                Quaternion.prototype.inverse = function() {
                    console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');
                    return this.invert();
                };
                //
                Ray.prototype.isIntersectionBox = function(box) {
                    console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
                    return this.intersectsBox(box);
                };
                Ray.prototype.isIntersectionPlane = function(plane) {
                    console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
                    return this.intersectsPlane(plane);
                };
                Ray.prototype.isIntersectionSphere = function(sphere) {
                    console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
                    return this.intersectsSphere(sphere);
                };
                //
                Triangle.prototype.area = function() {
                    console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
                    return this.getArea();
                };
                Triangle.prototype.barycoordFromPoint = function(point, target) {
                    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
                    return this.getBarycoord(point, target);
                };
                Triangle.prototype.midpoint = function(target) {
                    console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
                    return this.getMidpoint(target);
                };
                Triangle.prototypenormal = function(target) {
                    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
                    return this.getNormal(target);
                };
                Triangle.prototype.plane = function(target) {
                    console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
                    return this.getPlane(target);
                };
                Triangle.barycoordFromPoint = function(point, a, b, c, target) {
                    console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
                    return Triangle.getBarycoord(point, a, b, c, target);
                };
                Triangle.normal = function(a, b, c, target) {
                    console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
                    return Triangle.getNormal(a, b, c, target);
                };
                //
                Shape.prototype.extractAllPoints = function(divisions) {
                    console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
                    return this.extractPoints(divisions);
                };
                Shape.prototype.extrude = function(options) {
                    console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
                    return new ExtrudeGeometry(this, options);
                };
                Shape.prototype.makeGeometry = function(options) {
                    console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
                    return new ShapeGeometry(this, options);
                };
                //
                Vector2.prototype.fromAttribute = function(attribute, index, offset) {
                    console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
                    return this.fromBufferAttribute(attribute, index, offset);
                };
                Vector2.prototype.distanceToManhattan = function(v) {
                    console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
                    return this.manhattanDistanceTo(v);
                };
                Vector2.prototype.lengthManhattan = function() {
                    console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
                    return this.manhattanLength();
                };
                //
                Vector3.prototype.setEulerFromRotationMatrix = function() {
                    console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
                };
                Vector3.prototype.setEulerFromQuaternion = function() {
                    console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
                };
                Vector3.prototype.getPositionFromMatrix = function(m) {
                    console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
                    return this.setFromMatrixPosition(m);
                };
                Vector3.prototype.getScaleFromMatrix = function(m) {
                    console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
                    return this.setFromMatrixScale(m);
                };
                Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
                    console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
                    return this.setFromMatrixColumn(matrix, index);
                };
                Vector3.prototype.applyProjection = function(m) {
                    console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
                    return this.applyMatrix4(m);
                };
                Vector3.prototype.fromAttribute = function(attribute, index, offset) {
                    console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
                    return this.fromBufferAttribute(attribute, index, offset);
                };
                Vector3.prototype.distanceToManhattan = function(v) {
                    console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
                    return this.manhattanDistanceTo(v);
                };
                Vector3.prototype.lengthManhattan = function() {
                    console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
                    return this.manhattanLength();
                };
                //
                Vector4.prototype.fromAttribute = function(attribute, index, offset) {
                    console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
                    return this.fromBufferAttribute(attribute, index, offset);
                };
                Vector4.prototype.lengthManhattan = function() {
                    console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
                    return this.manhattanLength();
                };
                //
                Object3D.prototype.getChildByName = function(name) {
                    console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
                    return this.getObjectByName(name);
                };
                Object3D.prototype.renderDepth = function() {
                    console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
                };
                Object3D.prototype.translate = function(distance, axis) {
                    console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
                    return this.translateOnAxis(axis, distance);
                };
                Object3D.prototype.getWorldRotation = function() {
                    console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
                };
                Object3D.prototype.applyMatrix = function(matrix) {
                    console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
                    return this.applyMatrix4(matrix);
                };
                Object.defineProperties(Object3D.prototype, {
                    eulerOrder: {
                        get: function() {
                            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
                            return this.rotation.order;
                        },
                        set: function(value) {
                            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
                            this.rotation.order = value;
                        }
                    },
                    useQuaternion: {
                        get: function() {
                            console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
                        },
                        set: function() {
                            console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
                        }
                    }
                });
                Mesh.prototype.setDrawMode = function() {
                    console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
                };
                Object.defineProperties(Mesh.prototype, {
                    drawMode: {
                        get: function() {
                            console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
                            return TrianglesDrawMode;
                        },
                        set: function() {
                            console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
                        }
                    }
                });
                SkinnedMesh.prototype.initBones = function() {
                    console.error('THREE.SkinnedMesh: initBones() has been removed.');
                };
                //
                PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
                    console.warn('THREE.PerspectiveCamera.setLens is deprecated. ' +
                        'Use .setFocalLength and .filmGauge for a photographic setup.');
                    if (filmGauge !== undefined)
                        this.filmGauge = filmGauge;
                    this.setFocalLength(focalLength);
                };
                //
                Object.defineProperties(Light.prototype, {
                    onlyShadow: {
                        set: function() {
                            console.warn('THREE.Light: .onlyShadow has been removed.');
                        }
                    },
                    shadowCameraFov: {
                        set: function(value) {
                            console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
                            this.shadow.camera.fov = value;
                        }
                    },
                    shadowCameraLeft: {
                        set: function(value) {
                            console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
                            this.shadow.camera.left = value;
                        }
                    },
                    shadowCameraRight: {
                        set: function(value) {
                            console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
                            this.shadow.camera.right = value;
                        }
                    },
                    shadowCameraTop: {
                        set: function(value) {
                            console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
                            this.shadow.camera.top = value;
                        }
                    },
                    shadowCameraBottom: {
                        set: function(value) {
                            console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
                            this.shadow.camera.bottom = value;
                        }
                    },
                    shadowCameraNear: {
                        set: function(value) {
                            console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
                            this.shadow.camera.near = value;
                        }
                    },
                    shadowCameraFar: {
                        set: function(value) {
                            console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
                            this.shadow.camera.far = value;
                        }
                    },
                    shadowCameraVisible: {
                        set: function() {
                            console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
                        }
                    },
                    shadowBias: {
                        set: function(value) {
                            console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
                            this.shadow.bias = value;
                        }
                    },
                    shadowDarkness: {
                        set: function() {
                            console.warn('THREE.Light: .shadowDarkness has been removed.');
                        }
                    },
                    shadowMapWidth: {
                        set: function(value) {
                            console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
                            this.shadow.mapSize.width = value;
                        }
                    },
                    shadowMapHeight: {
                        set: function(value) {
                            console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
                            this.shadow.mapSize.height = value;
                        }
                    }
                });
                //
                Object.defineProperties(BufferAttribute.prototype, {
                    length: {
                        get: function() {
                            console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
                            return this.array.length;
                        }
                    },
                    dynamic: {
                        get: function() {
                            console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
                            return this.usage === DynamicDrawUsage;
                        },
                        set: function( /* value */ ) {
                            console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
                            this.setUsage(DynamicDrawUsage);
                        }
                    }
                });
                BufferAttribute.prototype.setDynamic = function(value) {
                    console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
                    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
                    return this;
                };
                BufferAttribute.prototype.copyIndicesArray = function( /* indices */ ) {
                        console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
                    },
                    BufferAttribute.prototype.setArray = function( /* array */ ) {
                        console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
                    };
                //
                BufferGeometry.prototype.addIndex = function(index) {
                    console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
                    this.setIndex(index);
                };
                BufferGeometry.prototype.addAttribute = function(name, attribute) {
                    console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');
                    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
                        console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
                        return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
                    }
                    if (name === 'index') {
                        console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
                        this.setIndex(attribute);
                        return this;
                    }
                    return this.setAttribute(name, attribute);
                };
                BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
                    if (indexOffset !== undefined) {
                        console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
                    }
                    console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
                    this.addGroup(start, count);
                };
                BufferGeometry.prototype.clearDrawCalls = function() {
                    console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
                    this.clearGroups();
                };
                BufferGeometry.prototype.computeOffsets = function() {
                    console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
                };
                BufferGeometry.prototype.removeAttribute = function(name) {
                    console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
                    return this.deleteAttribute(name);
                };
                BufferGeometry.prototype.applyMatrix = function(matrix) {
                    console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
                    return this.applyMatrix4(matrix);
                };
                Object.defineProperties(BufferGeometry.prototype, {
                    drawcalls: {
                        get: function() {
                            console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
                            return this.groups;
                        }
                    },
                    offsets: {
                        get: function() {
                            console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
                            return this.groups;
                        }
                    }
                });
                InterleavedBuffer.prototype.setDynamic = function(value) {
                    console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
                    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
                    return this;
                };
                InterleavedBuffer.prototype.setArray = function( /* array */ ) {
                    console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
                };
                //
                ExtrudeGeometry.prototype.getArrays = function() {
                    console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');
                };
                ExtrudeGeometry.prototype.addShapeList = function() {
                    console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');
                };
                ExtrudeGeometry.prototype.addShape = function() {
                    console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');
                };
                //
                Scene.prototype.dispose = function() {
                    console.error('THREE.Scene: .dispose() has been removed.');
                };
                //
                Uniform.prototype.onUpdate = function() {
                    console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
                    return this;
                };
                //
                Object.defineProperties(Material.prototype, {
                    wrapAround: {
                        get: function() {
                            console.warn('THREE.Material: .wrapAround has been removed.');
                        },
                        set: function() {
                            console.warn('THREE.Material: .wrapAround has been removed.');
                        }
                    },
                    overdraw: {
                        get: function() {
                            console.warn('THREE.Material: .overdraw has been removed.');
                        },
                        set: function() {
                            console.warn('THREE.Material: .overdraw has been removed.');
                        }
                    },
                    wrapRGB: {
                        get: function() {
                            console.warn('THREE.Material: .wrapRGB has been removed.');
                            return new Color();
                        }
                    },
                    shading: {
                        get: function() {
                            console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                        },
                        set: function(value) {
                            console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
                            this.flatShading = (value === FlatShading);
                        }
                    },
                    stencilMask: {
                        get: function() {
                            console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
                            return this.stencilFuncMask;
                        },
                        set: function(value) {
                            console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
                            this.stencilFuncMask = value;
                        }
                    },
                    vertexTangents: {
                        get: function() {
                            console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');
                        },
                        set: function() {
                            console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');
                        }
                    },
                });
                Object.defineProperties(ShaderMaterial.prototype, {
                    derivatives: {
                        get: function() {
                            console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
                            return this.extensions.derivatives;
                        },
                        set: function(value) {
                            console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
                            this.extensions.derivatives = value;
                        }
                    }
                });
                //
                WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
                    console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
                    this.setRenderTarget(renderTarget);
                    this.clear(color, depth, stencil);
                };
                WebGLRenderer.prototype.animate = function(callback) {
                    console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
                    this.setAnimationLoop(callback);
                };
                WebGLRenderer.prototype.getCurrentRenderTarget = function() {
                    console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
                    return this.getRenderTarget();
                };
                WebGLRenderer.prototype.getMaxAnisotropy = function() {
                    console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
                    return this.capabilities.getMaxAnisotropy();
                };
                WebGLRenderer.prototype.getPrecision = function() {
                    console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
                    return this.capabilities.precision;
                };
                WebGLRenderer.prototype.resetGLState = function() {
                    console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
                    return this.state.reset();
                };
                WebGLRenderer.prototype.supportsFloatTextures = function() {
                    console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
                    return this.extensions.get('OES_texture_float');
                };
                WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
                    console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
                    return this.extensions.get('OES_texture_half_float');
                };
                WebGLRenderer.prototype.supportsStandardDerivatives = function() {
                    console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
                    return this.extensions.get('OES_standard_derivatives');
                };
                WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
                    console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
                    return this.extensions.get('WEBGL_compressed_texture_s3tc');
                };
                WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
                    console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
                    return this.extensions.get('WEBGL_compressed_texture_pvrtc');
                };
                WebGLRenderer.prototype.supportsBlendMinMax = function() {
                    console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
                    return this.extensions.get('EXT_blend_minmax');
                };
                WebGLRenderer.prototype.supportsVertexTextures = function() {
                    console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
                    return this.capabilities.vertexTextures;
                };
                WebGLRenderer.prototype.supportsInstancedArrays = function() {
                    console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
                    return this.extensions.get('ANGLE_instanced_arrays');
                };
                WebGLRenderer.prototype.enableScissorTest = function(boolean) {
                    console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
                    this.setScissorTest(boolean);
                };
                WebGLRenderer.prototype.initMaterial = function() {
                    console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
                };
                WebGLRenderer.prototype.addPrePlugin = function() {
                    console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
                };
                WebGLRenderer.prototype.addPostPlugin = function() {
                    console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
                };
                WebGLRenderer.prototype.updateShadowMap = function() {
                    console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
                };
                WebGLRenderer.prototype.setFaceCulling = function() {
                    console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
                };
                WebGLRenderer.prototype.allocTextureUnit = function() {
                    console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
                };
                WebGLRenderer.prototype.setTexture = function() {
                    console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
                };
                WebGLRenderer.prototype.setTexture2D = function() {
                    console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
                };
                WebGLRenderer.prototype.setTextureCube = function() {
                    console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
                };
                WebGLRenderer.prototype.getActiveMipMapLevel = function() {
                    console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
                    return this.getActiveMipmapLevel();
                };
                Object.defineProperties(WebGLRenderer.prototype, {
                    shadowMapEnabled: {
                        get: function() {
                            return this.shadowMap.enabled;
                        },
                        set: function(value) {
                            console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
                            this.shadowMap.enabled = value;
                        }
                    },
                    shadowMapType: {
                        get: function() {
                            return this.shadowMap.type;
                        },
                        set: function(value) {
                            console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
                            this.shadowMap.type = value;
                        }
                    },
                    shadowMapCullFace: {
                        get: function() {
                            console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
                            return undefined;
                        },
                        set: function( /* value */ ) {
                            console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
                        }
                    },
                    context: {
                        get: function() {
                            console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
                            return this.getContext();
                        }
                    },
                    vr: {
                        get: function() {
                            console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
                            return this.xr;
                        }
                    },
                    gammaInput: {
                        get: function() {
                            console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
                            return false;
                        },
                        set: function() {
                            console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
                        }
                    },
                    gammaOutput: {
                        get: function() {
                            console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
                            return false;
                        },
                        set: function(value) {
                            console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
                            this.outputEncoding = (value === true) ? sRGBEncoding : LinearEncoding;
                        }
                    },
                    toneMappingWhitePoint: {
                        get: function() {
                            console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
                            return 1.0;
                        },
                        set: function() {
                            console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
                        }
                    },
                    gammaFactor: {
                        get: function() {
                            console.warn('THREE.WebGLRenderer: .gammaFactor has been removed.');
                            return 2;
                        },
                        set: function() {
                            console.warn('THREE.WebGLRenderer: .gammaFactor has been removed.');
                        }
                    }
                });
                Object.defineProperties(WebGLShadowMap.prototype, {
                    cullFace: {
                        get: function() {
                            console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
                            return undefined;
                        },
                        set: function( /* cullFace */ ) {
                            console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
                        }
                    },
                    renderReverseSided: {
                        get: function() {
                            console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
                            return undefined;
                        },
                        set: function() {
                            console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
                        }
                    },
                    renderSingleSided: {
                        get: function() {
                            console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
                            return undefined;
                        },
                        set: function() {
                            console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
                        }
                    }
                });
                var WebGLRenderTargetCube = /** @class */ (function(_super) {
                    __extends(WebGLRenderTargetCube, _super);

                    function WebGLRenderTargetCube(width, height, options) {
                        console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
                        return _super.call(this, width, options) || this;
                    }
                    return WebGLRenderTargetCube;
                }(WebGLCubeRenderTarget));
                //
                Object.defineProperties(WebGLRenderTarget.prototype, {
                    wrapS: {
                        get: function() {
                            console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
                            return this.texture.wrapS;
                        },
                        set: function(value) {
                            console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
                            this.texture.wrapS = value;
                        }
                    },
                    wrapT: {
                        get: function() {
                            console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
                            return this.texture.wrapT;
                        },
                        set: function(value) {
                            console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
                            this.texture.wrapT = value;
                        }
                    },
                    magFilter: {
                        get: function() {
                            console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
                            return this.texture.magFilter;
                        },
                        set: function(value) {
                            console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
                            this.texture.magFilter = value;
                        }
                    },
                    minFilter: {
                        get: function() {
                            console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
                            return this.texture.minFilter;
                        },
                        set: function(value) {
                            console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
                            this.texture.minFilter = value;
                        }
                    },
                    anisotropy: {
                        get: function() {
                            console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
                            return this.texture.anisotropy;
                        },
                        set: function(value) {
                            console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
                            this.texture.anisotropy = value;
                        }
                    },
                    offset: {
                        get: function() {
                            console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
                            return this.texture.offset;
                        },
                        set: function(value) {
                            console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
                            this.texture.offset = value;
                        }
                    },
                    repeat: {
                        get: function() {
                            console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
                            return this.texture.repeat;
                        },
                        set: function(value) {
                            console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
                            this.texture.repeat = value;
                        }
                    },
                    format: {
                        get: function() {
                            console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
                            return this.texture.format;
                        },
                        set: function(value) {
                            console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
                            this.texture.format = value;
                        }
                    },
                    type: {
                        get: function() {
                            console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
                            return this.texture.type;
                        },
                        set: function(value) {
                            console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
                            this.texture.type = value;
                        }
                    },
                    generateMipmaps: {
                        get: function() {
                            console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
                            return this.texture.generateMipmaps;
                        },
                        set: function(value) {
                            console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
                            this.texture.generateMipmaps = value;
                        }
                    }
                });
                //
                Audio.prototype.load = function(file) {
                    console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
                    var scope = this;
                    var audioLoader = new AudioLoader();
                    audioLoader.load(file, function(buffer) {
                        scope.setBuffer(buffer);
                    });
                    return this;
                };
                AudioAnalyser.prototype.getData = function() {
                    console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
                    return this.getFrequencyData();
                };
                //
                CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
                    console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
                    return this.update(renderer, scene);
                };
                CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
                    console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');
                    return this.renderTarget.clear(renderer, color, depth, stencil);
                };
                ImageUtils.crossOrigin = undefined;
                ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
                    console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
                    var loader = new TextureLoader();
                    loader.setCrossOrigin(this.crossOrigin);
                    var texture = loader.load(url, onLoad, undefined, onError);
                    if (mapping)
                        texture.mapping = mapping;
                    return texture;
                };
                ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
                    console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
                    var loader = new CubeTextureLoader();
                    loader.setCrossOrigin(this.crossOrigin);
                    var texture = loader.load(urls, onLoad, undefined, onError);
                    if (mapping)
                        texture.mapping = mapping;
                    return texture;
                };
                ImageUtils.loadCompressedTexture = function() {
                    console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
                };
                ImageUtils.loadCompressedTextureCube = function() {
                    console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
                };
                //
                function CanvasRenderer() {
                    console.error('THREE.CanvasRenderer has been removed');
                }
                //
                function JSONLoader() {
                    console.error('THREE.JSONLoader has been removed.');
                }
                //
                var SceneUtils = {
                    createMultiMaterialObject: function( /* geometry, materials */ ) {
                        console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
                    },
                    detach: function( /* child, parent, scene */ ) {
                        console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
                    },
                    attach: function( /* child, scene, parent */ ) {
                        console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
                    }
                };
                //
                function LensFlare() {
                    console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
                }
                //
                var ParametricGeometry = /** @class */ (function(_super) {
                    __extends(ParametricGeometry, _super);

                    function ParametricGeometry() {
                        console.error('THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js');
                        return _super.call(this) || this;
                    }
                    return ParametricGeometry;
                }(BufferGeometry));
                var TextGeometry = /** @class */ (function(_super) {
                    __extends(TextGeometry, _super);

                    function TextGeometry() {
                        console.error('THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js');
                        return _super.call(this) || this;
                    }
                    return TextGeometry;
                }(BufferGeometry));

                function FontLoader() {
                    console.error('THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js');
                }

                function Font() {
                    console.error('THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js');
                }

                function ImmediateRenderObject() {
                    console.error('THREE.ImmediateRenderObject has been removed.');
                }
                var WebGLMultisampleRenderTarget = /** @class */ (function(_super) {
                    __extends(WebGLMultisampleRenderTarget, _super);

                    function WebGLMultisampleRenderTarget(width, height, options) {
                        var _this_1 = this;
                        console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.');
                        _this_1 = _super.call(this, width, height, options) || this;
                        _this_1.samples = 4;
                        return _this_1;
                    }
                    return WebGLMultisampleRenderTarget;
                }(WebGLRenderTarget));
                var DataTexture2DArray = /** @class */ (function(_super) {
                    __extends(DataTexture2DArray, _super);

                    function DataTexture2DArray(data, width, height, depth) {
                        console.warn('THREE.DataTexture2DArray has been renamed to DataArrayTexture.');
                        return _super.call(this, data, width, height, depth) || this;
                    }
                    return DataTexture2DArray;
                }(DataArrayTexture));
                var DataTexture3D = /** @class */ (function(_super) {
                    __extends(DataTexture3D, _super);

                    function DataTexture3D(data, width, height, depth) {
                        console.warn('THREE.DataTexture3D has been renamed to Data3DTexture.');
                        return _super.call(this, data, width, height, depth) || this;
                    }
                    return DataTexture3D;
                }(Data3DTexture));
                if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
                    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
                        detail: {
                            revision: REVISION,
                        }
                    }));
                }
                if (typeof window !== 'undefined') {
                    if (window.__THREE__) {
                        console.warn('WARNING: Multiple instances of Three.js being imported.');
                    } else {
                        window.__THREE__ = REVISION;
                    }
                }



                /***/
            }),

        /***/
        "./node_modules/three/examples/jsm/geometries/TextGeometry.js":
            /*!********************************************************************!*\
              !*** ./node_modules/three/examples/jsm/geometries/TextGeometry.js ***!
              \********************************************************************/
            /***/
            (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "TextGeometry": function() {
                        return /* binding */ TextGeometry;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");
                /**
                 * Text = 3D Text
                 *
                 * parameters = {
                 *  font: <THREE.Font>, // font
                 *
                 *  size: <float>, // size of the text
                 *  height: <float>, // thickness to extrude text
                 *  curveSegments: <int>, // number of points on the curves
                 *
                 *  bevelEnabled: <bool>, // turn on bevel
                 *  bevelThickness: <float>, // how deep into text bevel goes
                 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
                 *  bevelOffset: <float> // how far from text outline does bevel start
                 * }
                 */
                var __extends = (undefined && undefined.__extends) || (function() {
                    var extendStatics = function(d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({
                                    __proto__: []
                                }
                                instanceof Array && function(d, b) {
                                    d.__proto__ = b;
                                }) ||
                            function(d, b) {
                                for (var p in b)
                                    if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
                            };
                        return extendStatics(d, b);
                    };
                    return function(d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);

                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();

                var TextGeometry = /** @class */ (function(_super) {
                    __extends(TextGeometry, _super);

                    function TextGeometry(text, parameters) {
                        if (parameters === void 0) {
                            parameters = {};
                        }
                        var _this = this;
                        var font = parameters.font;
                        if (font === undefined) {
                            _this = _super.call(this) || this; // generate default extrude geometry
                        } else {
                            var shapes = font.generateShapes(text, parameters.size);
                            // translate parameters to ExtrudeGeometry API
                            parameters.depth = parameters.height !== undefined ? parameters.height : 50;
                            // defaults
                            if (parameters.bevelThickness === undefined)
                                parameters.bevelThickness = 10;
                            if (parameters.bevelSize === undefined)
                                parameters.bevelSize = 8;
                            if (parameters.bevelEnabled === undefined)
                                parameters.bevelEnabled = false;
                            _this = _super.call(this, shapes, parameters) || this;
                        }
                        _this.type = 'TextGeometry';
                        return _this;
                    }
                    return TextGeometry;
                }(three__WEBPACK_IMPORTED_MODULE_0__.ExtrudeGeometry));



                /***/
            }),

        /***/
        "./node_modules/three/examples/jsm/loaders/FontLoader.js":
            /*!***************************************************************!*\
              !*** ./node_modules/three/examples/jsm/loaders/FontLoader.js ***!
              \***************************************************************/
            /***/
            (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "Font": function() {
                        return /* binding */ Font;
                    },
                    /* harmony export */
                    "FontLoader": function() {
                        return /* binding */ FontLoader;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");
                var __extends = (undefined && undefined.__extends) || (function() {
                    var extendStatics = function(d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({
                                    __proto__: []
                                }
                                instanceof Array && function(d, b) {
                                    d.__proto__ = b;
                                }) ||
                            function(d, b) {
                                for (var p in b)
                                    if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
                            };
                        return extendStatics(d, b);
                    };
                    return function(d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);

                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();

                var FontLoader = /** @class */ (function(_super) {
                    __extends(FontLoader, _super);

                    function FontLoader(manager) {
                        return _super.call(this, manager) || this;
                    }
                    FontLoader.prototype.load = function(url, onLoad, onProgress, onError) {
                        var scope = this;
                        var loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);
                        loader.setPath(this.path);
                        loader.setRequestHeader(this.requestHeader);
                        loader.setWithCredentials(scope.withCredentials);
                        loader.load(url, function(text) {
                            var json;
                            try {
                                json = JSON.parse(text);
                            } catch (e) {
                                console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
                                json = JSON.parse(text.substring(65, text.length - 2));
                            }
                            var font = scope.parse(json);
                            if (onLoad)
                                onLoad(font);
                        }, onProgress, onError);
                    };
                    FontLoader.prototype.parse = function(json) {
                        return new Font(json);
                    };
                    return FontLoader;
                }(three__WEBPACK_IMPORTED_MODULE_0__.Loader));
                //
                var Font = /** @class */ (function() {
                    function Font(data) {
                        this.type = 'Font';
                        this.data = data;
                    }
                    Font.prototype.generateShapes = function(text, size) {
                        if (size === void 0) {
                            size = 100;
                        }
                        var shapes = [];
                        var paths = createPaths(text, size, this.data);
                        for (var p = 0, pl = paths.length; p < pl; p++) {
                            Array.prototype.push.apply(shapes, paths[p].toShapes());
                        }
                        return shapes;
                    };
                    return Font;
                }());

                function createPaths(text, size, data) {
                    var chars = Array.from(text);
                    var scale = size / data.resolution;
                    var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
                    var paths = [];
                    var offsetX = 0,
                        offsetY = 0;
                    for (var i = 0; i < chars.length; i++) {
                        var char = chars[i];
                        if (char === '\n') {
                            offsetX = 0;
                            offsetY -= line_height;
                        } else {
                            var ret = createPath(char, scale, offsetX, offsetY, data);
                            offsetX += ret.offsetX;
                            paths.push(ret.path);
                        }
                    }
                    return paths;
                }

                function createPath(char, scale, offsetX, offsetY, data) {
                    var glyph = data.glyphs[char] || data.glyphs['?'];
                    if (!glyph) {
                        console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
                        return;
                    }
                    var path = new three__WEBPACK_IMPORTED_MODULE_0__.ShapePath();
                    var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
                    if (glyph.o) {
                        var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));
                        for (var i = 0, l = outline.length; i < l;) {
                            var action = outline[i++];
                            switch (action) {
                                case 'm': // moveTo
                                    x = outline[i++] * scale + offsetX;
                                    y = outline[i++] * scale + offsetY;
                                    path.moveTo(x, y);
                                    break;
                                case 'l': // lineTo
                                    x = outline[i++] * scale + offsetX;
                                    y = outline[i++] * scale + offsetY;
                                    path.lineTo(x, y);
                                    break;
                                case 'q': // quadraticCurveTo
                                    cpx = outline[i++] * scale + offsetX;
                                    cpy = outline[i++] * scale + offsetY;
                                    cpx1 = outline[i++] * scale + offsetX;
                                    cpy1 = outline[i++] * scale + offsetY;
                                    path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
                                    break;
                                case 'b': // bezierCurveTo
                                    cpx = outline[i++] * scale + offsetX;
                                    cpy = outline[i++] * scale + offsetY;
                                    cpx1 = outline[i++] * scale + offsetX;
                                    cpy1 = outline[i++] * scale + offsetY;
                                    cpx2 = outline[i++] * scale + offsetX;
                                    cpy2 = outline[i++] * scale + offsetY;
                                    path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
                                    break;
                            }
                        }
                    }
                    return {
                        offsetX: glyph.ha * scale,
                        path: path
                    };
                }
                Font.prototype.isFont = true;



                /***/
            }),

        /***/
        "./node_modules/three/examples/jsm/modifiers/TessellateModifier.js":
            /*!*************************************************************************!*\
              !*** ./node_modules/three/examples/jsm/modifiers/TessellateModifier.js ***!
              \*************************************************************************/
            /***/
            (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "TessellateModifier": function() {
                        return /* binding */ TessellateModifier;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");

                /**
                 * Break faces with edges longer than maxEdgeLength
                 */
                var TessellateModifier = /** @class */ (function() {
                    function TessellateModifier(maxEdgeLength, maxIterations) {
                        if (maxEdgeLength === void 0) {
                            maxEdgeLength = 0.1;
                        }
                        if (maxIterations === void 0) {
                            maxIterations = 6;
                        }
                        this.maxEdgeLength = maxEdgeLength;
                        this.maxIterations = maxIterations;
                    }
                    TessellateModifier.prototype.modify = function(geometry) {
                        if (geometry.isGeometry === true) {
                            console.error('THREE.TessellateModifier no longer supports Geometry. Use BufferGeometry instead.');
                            return geometry;
                        }
                        if (geometry.index !== null) {
                            geometry = geometry.toNonIndexed();
                        }
                        //
                        var maxIterations = this.maxIterations;
                        var maxEdgeLengthSquared = this.maxEdgeLength * this.maxEdgeLength;
                        var va = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                        var vb = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                        var vc = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                        var vm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                        var vs = [va, vb, vc, vm];
                        var na = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                        var nb = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                        var nc = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                        var nm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                        var ns = [na, nb, nc, nm];
                        var ca = new three__WEBPACK_IMPORTED_MODULE_0__.Color();
                        var cb = new three__WEBPACK_IMPORTED_MODULE_0__.Color();
                        var cc = new three__WEBPACK_IMPORTED_MODULE_0__.Color();
                        var cm = new three__WEBPACK_IMPORTED_MODULE_0__.Color();
                        var cs = [ca, cb, cc, cm];
                        var ua = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
                        var ub = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
                        var uc = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
                        var um = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
                        var us = [ua, ub, uc, um];
                        var u2a = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
                        var u2b = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
                        var u2c = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
                        var u2m = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();
                        var u2s = [u2a, u2b, u2c, u2m];
                        var attributes = geometry.attributes;
                        var hasNormals = attributes.normal !== undefined;
                        var hasColors = attributes.color !== undefined;
                        var hasUVs = attributes.uv !== undefined;
                        var hasUV2s = attributes.uv2 !== undefined;
                        var positions = attributes.position.array;
                        var normals = hasNormals ? attributes.normal.array : null;
                        var colors = hasColors ? attributes.color.array : null;
                        var uvs = hasUVs ? attributes.uv.array : null;
                        var uv2s = hasUV2s ? attributes.uv2.array : null;
                        var positions2 = positions;
                        var normals2 = normals;
                        var colors2 = colors;
                        var uvs2 = uvs;
                        var uv2s2 = uv2s;
                        var iteration = 0;
                        var tessellating = true;

                        function addTriangle(a, b, c) {
                            var v1 = vs[a];
                            var v2 = vs[b];
                            var v3 = vs[c];
                            positions2.push(v1.x, v1.y, v1.z);
                            positions2.push(v2.x, v2.y, v2.z);
                            positions2.push(v3.x, v3.y, v3.z);
                            if (hasNormals) {
                                var n1 = ns[a];
                                var n2 = ns[b];
                                var n3 = ns[c];
                                normals2.push(n1.x, n1.y, n1.z);
                                normals2.push(n2.x, n2.y, n2.z);
                                normals2.push(n3.x, n3.y, n3.z);
                            }
                            if (hasColors) {
                                var c1 = cs[a];
                                var c2 = cs[b];
                                var c3 = cs[c];
                                colors2.push(c1.x, c1.y, c1.z);
                                colors2.push(c2.x, c2.y, c2.z);
                                colors2.push(c3.x, c3.y, c3.z);
                            }
                            if (hasUVs) {
                                var u1 = us[a];
                                var u2 = us[b];
                                var u3 = us[c];
                                uvs2.push(u1.x, u1.y);
                                uvs2.push(u2.x, u2.y);
                                uvs2.push(u3.x, u3.y);
                            }
                            if (hasUV2s) {
                                var u21 = u2s[a];
                                var u22 = u2s[b];
                                var u23 = u2s[c];
                                uv2s2.push(u21.x, u21.y);
                                uv2s2.push(u22.x, u22.y);
                                uv2s2.push(u23.x, u23.y);
                            }
                        }
                        while (tessellating && iteration < maxIterations) {
                            iteration++;
                            tessellating = false;
                            positions = positions2;
                            positions2 = [];
                            if (hasNormals) {
                                normals = normals2;
                                normals2 = [];
                            }
                            if (hasColors) {
                                colors = colors2;
                                colors2 = [];
                            }
                            if (hasUVs) {
                                uvs = uvs2;
                                uvs2 = [];
                            }
                            if (hasUV2s) {
                                uv2s = uv2s2;
                                uv2s2 = [];
                            }
                            for (var i = 0, i2 = 0, il = positions.length; i < il; i += 9, i2 += 6) {
                                va.fromArray(positions, i + 0);
                                vb.fromArray(positions, i + 3);
                                vc.fromArray(positions, i + 6);
                                if (hasNormals) {
                                    na.fromArray(normals, i + 0);
                                    nb.fromArray(normals, i + 3);
                                    nc.fromArray(normals, i + 6);
                                }
                                if (hasColors) {
                                    ca.fromArray(colors, i + 0);
                                    cb.fromArray(colors, i + 3);
                                    cc.fromArray(colors, i + 6);
                                }
                                if (hasUVs) {
                                    ua.fromArray(uvs, i2 + 0);
                                    ub.fromArray(uvs, i2 + 2);
                                    uc.fromArray(uvs, i2 + 4);
                                }
                                if (hasUV2s) {
                                    u2a.fromArray(uv2s, i2 + 0);
                                    u2b.fromArray(uv2s, i2 + 2);
                                    u2c.fromArray(uv2s, i2 + 4);
                                }
                                var dab = va.distanceToSquared(vb);
                                var dbc = vb.distanceToSquared(vc);
                                var dac = va.distanceToSquared(vc);
                                if (dab > maxEdgeLengthSquared || dbc > maxEdgeLengthSquared || dac > maxEdgeLengthSquared) {
                                    tessellating = true;
                                    if (dab >= dbc && dab >= dac) {
                                        vm.lerpVectors(va, vb, 0.5);
                                        if (hasNormals)
                                            nm.lerpVectors(na, nb, 0.5);
                                        if (hasColors)
                                            cm.lerpColors(ca, cb, 0.5);
                                        if (hasUVs)
                                            um.lerpVectors(ua, ub, 0.5);
                                        if (hasUV2s)
                                            u2m.lerpVectors(u2a, u2b, 0.5);
                                        addTriangle(0, 3, 2);
                                        addTriangle(3, 1, 2);
                                    } else if (dbc >= dab && dbc >= dac) {
                                        vm.lerpVectors(vb, vc, 0.5);
                                        if (hasNormals)
                                            nm.lerpVectors(nb, nc, 0.5);
                                        if (hasColors)
                                            cm.lerpColors(cb, cc, 0.5);
                                        if (hasUVs)
                                            um.lerpVectors(ub, uc, 0.5);
                                        if (hasUV2s)
                                            u2m.lerpVectors(u2b, u2c, 0.5);
                                        addTriangle(0, 1, 3);
                                        addTriangle(3, 2, 0);
                                    } else {
                                        vm.lerpVectors(va, vc, 0.5);
                                        if (hasNormals)
                                            nm.lerpVectors(na, nc, 0.5);
                                        if (hasColors)
                                            cm.lerpColors(ca, cc, 0.5);
                                        if (hasUVs)
                                            um.lerpVectors(ua, uc, 0.5);
                                        if (hasUV2s)
                                            u2m.lerpVectors(u2a, u2c, 0.5);
                                        addTriangle(0, 1, 3);
                                        addTriangle(3, 1, 2);
                                    }
                                } else {
                                    addTriangle(0, 1, 2);
                                }
                            }
                        }
                        var geometry2 = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
                        geometry2.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(positions2, 3));
                        if (hasNormals) {
                            geometry2.setAttribute('normal', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(normals2, 3));
                        }
                        if (hasColors) {
                            geometry2.setAttribute('color', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(colors2, 3));
                        }
                        if (hasUVs) {
                            geometry2.setAttribute('uv', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(uvs2, 2));
                        }
                        if (hasUV2s) {
                            geometry2.setAttribute('uv2', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(uv2s2, 2));
                        }
                        return geometry2;
                    };
                    return TessellateModifier;
                }());



                /***/
            }),

        /***/
        "./node_modules/three/examples/jsm/postprocessing/EffectComposer.js":
            /*!**************************************************************************!*\
              !*** ./node_modules/three/examples/jsm/postprocessing/EffectComposer.js ***!
              \**************************************************************************/
            /***/
            (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "EffectComposer": function() {
                        return /* binding */ EffectComposer;
                    },
                    /* harmony export */
                    "FullScreenQuad": function() {
                        return /* binding */ FullScreenQuad;
                    },
                    /* harmony export */
                    "Pass": function() {
                        return /* binding */ Pass;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");
                /* harmony import */
                var _shaders_CopyShader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../shaders/CopyShader.js */ "./node_modules/three/examples/jsm/shaders/CopyShader.js");
                /* harmony import */
                var _ShaderPass_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./ShaderPass.js */ "./node_modules/three/examples/jsm/postprocessing/ShaderPass.js");
                /* harmony import */
                var _MaskPass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./MaskPass.js */ "./node_modules/three/examples/jsm/postprocessing/MaskPass.js");





                var EffectComposer = /** @class */ (function() {
                    function EffectComposer(renderer, renderTarget) {
                        this.renderer = renderer;
                        if (renderTarget === undefined) {
                            var size = renderer.getSize(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2());
                            this._pixelRatio = renderer.getPixelRatio();
                            this._width = size.width;
                            this._height = size.height;
                            renderTarget = new three__WEBPACK_IMPORTED_MODULE_3__.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio);
                            renderTarget.texture.name = 'EffectComposer.rt1';
                        } else {
                            this._pixelRatio = 1;
                            this._width = renderTarget.width;
                            this._height = renderTarget.height;
                        }
                        this.renderTarget1 = renderTarget;
                        this.renderTarget2 = renderTarget.clone();
                        this.renderTarget2.texture.name = 'EffectComposer.rt2';
                        this.writeBuffer = this.renderTarget1;
                        this.readBuffer = this.renderTarget2;
                        this.renderToScreen = true;
                        this.passes = [];
                        // dependencies
                        if (_shaders_CopyShader_js__WEBPACK_IMPORTED_MODULE_0__.CopyShader === undefined) {
                            console.error('THREE.EffectComposer relies on CopyShader');
                        }
                        if (_ShaderPass_js__WEBPACK_IMPORTED_MODULE_1__.ShaderPass === undefined) {
                            console.error('THREE.EffectComposer relies on ShaderPass');
                        }
                        this.copyPass = new _ShaderPass_js__WEBPACK_IMPORTED_MODULE_1__.ShaderPass(_shaders_CopyShader_js__WEBPACK_IMPORTED_MODULE_0__.CopyShader);
                        this.clock = new three__WEBPACK_IMPORTED_MODULE_3__.Clock();
                    }
                    EffectComposer.prototype.swapBuffers = function() {
                        var tmp = this.readBuffer;
                        this.readBuffer = this.writeBuffer;
                        this.writeBuffer = tmp;
                    };
                    EffectComposer.prototype.addPass = function(pass) {
                        this.passes.push(pass);
                        pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
                    };
                    EffectComposer.prototype.insertPass = function(pass, index) {
                        this.passes.splice(index, 0, pass);
                        pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
                    };
                    EffectComposer.prototype.removePass = function(pass) {
                        var index = this.passes.indexOf(pass);
                        if (index !== -1) {
                            this.passes.splice(index, 1);
                        }
                    };
                    EffectComposer.prototype.isLastEnabledPass = function(passIndex) {
                        for (var i = passIndex + 1; i < this.passes.length; i++) {
                            if (this.passes[i].enabled) {
                                return false;
                            }
                        }
                        return true;
                    };
                    EffectComposer.prototype.render = function(deltaTime) {
                        // deltaTime value is in seconds
                        if (deltaTime === undefined) {
                            deltaTime = this.clock.getDelta();
                        }
                        var currentRenderTarget = this.renderer.getRenderTarget();
                        var maskActive = false;
                        for (var i = 0, il = this.passes.length; i < il; i++) {
                            var pass = this.passes[i];
                            if (pass.enabled === false)
                                continue;
                            pass.renderToScreen = (this.renderToScreen && this.isLastEnabledPass(i));
                            pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);
                            if (pass.needsSwap) {
                                if (maskActive) {
                                    var context = this.renderer.getContext();
                                    var stencil = this.renderer.state.buffers.stencil;
                                    //context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
                                    stencil.setFunc(context.NOTEQUAL, 1, 0xffffffff);
                                    this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);
                                    //context.stencilFunc( context.EQUAL, 1, 0xffffffff );
                                    stencil.setFunc(context.EQUAL, 1, 0xffffffff);
                                }
                                this.swapBuffers();
                            }
                            if (_MaskPass_js__WEBPACK_IMPORTED_MODULE_2__.MaskPass !== undefined) {
                                if (pass instanceof _MaskPass_js__WEBPACK_IMPORTED_MODULE_2__.MaskPass) {
                                    maskActive = true;
                                } else if (pass instanceof _MaskPass_js__WEBPACK_IMPORTED_MODULE_2__.ClearMaskPass) {
                                    maskActive = false;
                                }
                            }
                        }
                        this.renderer.setRenderTarget(currentRenderTarget);
                    };
                    EffectComposer.prototype.reset = function(renderTarget) {
                        if (renderTarget === undefined) {
                            var size = this.renderer.getSize(new three__WEBPACK_IMPORTED_MODULE_3__.Vector2());
                            this._pixelRatio = this.renderer.getPixelRatio();
                            this._width = size.width;
                            this._height = size.height;
                            renderTarget = this.renderTarget1.clone();
                            renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
                        }
                        this.renderTarget1.dispose();
                        this.renderTarget2.dispose();
                        this.renderTarget1 = renderTarget;
                        this.renderTarget2 = renderTarget.clone();
                        this.writeBuffer = this.renderTarget1;
                        this.readBuffer = this.renderTarget2;
                    };
                    EffectComposer.prototype.setSize = function(width, height) {
                        this._width = width;
                        this._height = height;
                        var effectiveWidth = this._width * this._pixelRatio;
                        var effectiveHeight = this._height * this._pixelRatio;
                        this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
                        this.renderTarget2.setSize(effectiveWidth, effectiveHeight);
                        for (var i = 0; i < this.passes.length; i++) {
                            this.passes[i].setSize(effectiveWidth, effectiveHeight);
                        }
                    };
                    EffectComposer.prototype.setPixelRatio = function(pixelRatio) {
                        this._pixelRatio = pixelRatio;
                        this.setSize(this._width, this._height);
                    };
                    return EffectComposer;
                }());
                var Pass = /** @class */ (function() {
                    function Pass() {
                        // if set to true, the pass is processed by the composer
                        this.enabled = true;
                        // if set to true, the pass indicates to swap read and write buffer after rendering
                        this.needsSwap = true;
                        // if set to true, the pass clears its buffer before rendering
                        this.clear = false;
                        // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
                        this.renderToScreen = false;
                    }
                    Pass.prototype.setSize = function( /* width, height */ ) {};
                    Pass.prototype.render = function( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {
                        console.error('THREE.Pass: .render() must be implemented in derived pass.');
                    };
                    return Pass;
                }());
                // Helper for passes that need to fill the viewport with a single quad.
                var _camera = new three__WEBPACK_IMPORTED_MODULE_3__.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                // https://github.com/mrdoob/three.js/pull/21358
                var _geometry = new three__WEBPACK_IMPORTED_MODULE_3__.BufferGeometry();
                _geometry.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
                _geometry.setAttribute('uv', new three__WEBPACK_IMPORTED_MODULE_3__.Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
                var FullScreenQuad = /** @class */ (function() {
                    function FullScreenQuad(material) {
                        this._mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(_geometry, material);
                    }
                    FullScreenQuad.prototype.dispose = function() {
                        this._mesh.geometry.dispose();
                    };
                    FullScreenQuad.prototype.render = function(renderer) {
                        renderer.render(this._mesh, _camera);
                    };
                    Object.defineProperty(FullScreenQuad.prototype, "material", {
                        get: function() {
                            return this._mesh.material;
                        },
                        set: function(value) {
                            this._mesh.material = value;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    return FullScreenQuad;
                }());



                /***/
            }),

        /***/
        "./node_modules/three/examples/jsm/postprocessing/MaskPass.js":
            /*!********************************************************************!*\
              !*** ./node_modules/three/examples/jsm/postprocessing/MaskPass.js ***!
              \********************************************************************/
            /***/
            (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "ClearMaskPass": function() {
                        return /* binding */ ClearMaskPass;
                    },
                    /* harmony export */
                    "MaskPass": function() {
                        return /* binding */ MaskPass;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var _Pass_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./Pass.js */ "./node_modules/three/examples/jsm/postprocessing/Pass.js");
                var __extends = (undefined && undefined.__extends) || (function() {
                    var extendStatics = function(d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({
                                    __proto__: []
                                }
                                instanceof Array && function(d, b) {
                                    d.__proto__ = b;
                                }) ||
                            function(d, b) {
                                for (var p in b)
                                    if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
                            };
                        return extendStatics(d, b);
                    };
                    return function(d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);

                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();

                var MaskPass = /** @class */ (function(_super) {
                    __extends(MaskPass, _super);

                    function MaskPass(scene, camera) {
                        var _this = _super.call(this) || this;
                        _this.scene = scene;
                        _this.camera = camera;
                        _this.clear = true;
                        _this.needsSwap = false;
                        _this.inverse = false;
                        return _this;
                    }
                    MaskPass.prototype.render = function(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {
                        var context = renderer.getContext();
                        var state = renderer.state;
                        // don't update color or depth
                        state.buffers.color.setMask(false);
                        state.buffers.depth.setMask(false);
                        // lock buffers
                        state.buffers.color.setLocked(true);
                        state.buffers.depth.setLocked(true);
                        // set up stencil
                        var writeValue, clearValue;
                        if (this.inverse) {
                            writeValue = 0;
                            clearValue = 1;
                        } else {
                            writeValue = 1;
                            clearValue = 0;
                        }
                        state.buffers.stencil.setTest(true);
                        state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
                        state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
                        state.buffers.stencil.setClear(clearValue);
                        state.buffers.stencil.setLocked(true);
                        // draw into the stencil buffer
                        renderer.setRenderTarget(readBuffer);
                        if (this.clear)
                            renderer.clear();
                        renderer.render(this.scene, this.camera);
                        renderer.setRenderTarget(writeBuffer);
                        if (this.clear)
                            renderer.clear();
                        renderer.render(this.scene, this.camera);
                        // unlock color and depth buffer for subsequent rendering
                        state.buffers.color.setLocked(false);
                        state.buffers.depth.setLocked(false);
                        // only render where stencil is set to 1
                        state.buffers.stencil.setLocked(false);
                        state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1
                        state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
                        state.buffers.stencil.setLocked(true);
                    };
                    return MaskPass;
                }(_Pass_js__WEBPACK_IMPORTED_MODULE_0__.Pass));
                var ClearMaskPass = /** @class */ (function(_super) {
                    __extends(ClearMaskPass, _super);

                    function ClearMaskPass() {
                        var _this = _super.call(this) || this;
                        _this.needsSwap = false;
                        return _this;
                    }
                    ClearMaskPass.prototype.render = function(renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {
                        renderer.state.buffers.stencil.setLocked(false);
                        renderer.state.buffers.stencil.setTest(false);
                    };
                    return ClearMaskPass;
                }(_Pass_js__WEBPACK_IMPORTED_MODULE_0__.Pass));



                /***/
            }),

        /***/
        "./node_modules/three/examples/jsm/postprocessing/Pass.js":
            /*!****************************************************************!*\
              !*** ./node_modules/three/examples/jsm/postprocessing/Pass.js ***!
              \****************************************************************/
            /***/
            (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "FullScreenQuad": function() {
                        return /* binding */ FullScreenQuad;
                    },
                    /* harmony export */
                    "Pass": function() {
                        return /* binding */ Pass;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");

                var Pass = /** @class */ (function() {
                    function Pass() {
                        // if set to true, the pass is processed by the composer
                        this.enabled = true;
                        // if set to true, the pass indicates to swap read and write buffer after rendering
                        this.needsSwap = true;
                        // if set to true, the pass clears its buffer before rendering
                        this.clear = false;
                        // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
                        this.renderToScreen = false;
                    }
                    Pass.prototype.setSize = function( /* width, height */ ) {};
                    Pass.prototype.render = function( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {
                        console.error('THREE.Pass: .render() must be implemented in derived pass.');
                    };
                    return Pass;
                }());
                // Helper for passes that need to fill the viewport with a single quad.
                var _camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                // https://github.com/mrdoob/three.js/pull/21358
                var _geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
                _geometry.setAttribute('position', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
                _geometry.setAttribute('uv', new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
                var FullScreenQuad = /** @class */ (function() {
                    function FullScreenQuad(material) {
                        this._mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(_geometry, material);
                    }
                    FullScreenQuad.prototype.dispose = function() {
                        this._mesh.geometry.dispose();
                    };
                    FullScreenQuad.prototype.render = function(renderer) {
                        renderer.render(this._mesh, _camera);
                    };
                    Object.defineProperty(FullScreenQuad.prototype, "material", {
                        get: function() {
                            return this._mesh.material;
                        },
                        set: function(value) {
                            this._mesh.material = value;
                        },
                        enumerable: false,
                        configurable: true
                    });
                    return FullScreenQuad;
                }());



                /***/
            }),

        /***/
        "./node_modules/three/examples/jsm/postprocessing/RenderPass.js":
            /*!**********************************************************************!*\
              !*** ./node_modules/three/examples/jsm/postprocessing/RenderPass.js ***!
              \**********************************************************************/
            /***/
            (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "RenderPass": function() {
                        return /* binding */ RenderPass;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");
                /* harmony import */
                var _Pass_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./Pass.js */ "./node_modules/three/examples/jsm/postprocessing/Pass.js");
                var __extends = (undefined && undefined.__extends) || (function() {
                    var extendStatics = function(d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({
                                    __proto__: []
                                }
                                instanceof Array && function(d, b) {
                                    d.__proto__ = b;
                                }) ||
                            function(d, b) {
                                for (var p in b)
                                    if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
                            };
                        return extendStatics(d, b);
                    };
                    return function(d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);

                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();


                var RenderPass = /** @class */ (function(_super) {
                    __extends(RenderPass, _super);

                    function RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha) {
                        var _this = _super.call(this) || this;
                        _this.scene = scene;
                        _this.camera = camera;
                        _this.overrideMaterial = overrideMaterial;
                        _this.clearColor = clearColor;
                        _this.clearAlpha = (clearAlpha !== undefined) ? clearAlpha : 0;
                        _this.clear = true;
                        _this.clearDepth = false;
                        _this.needsSwap = false;
                        _this._oldClearColor = new three__WEBPACK_IMPORTED_MODULE_1__.Color();
                        return _this;
                    }
                    RenderPass.prototype.render = function(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {
                        var oldAutoClear = renderer.autoClear;
                        renderer.autoClear = false;
                        var oldClearAlpha, oldOverrideMaterial;
                        if (this.overrideMaterial !== undefined) {
                            oldOverrideMaterial = this.scene.overrideMaterial;
                            this.scene.overrideMaterial = this.overrideMaterial;
                        }
                        if (this.clearColor) {
                            renderer.getClearColor(this._oldClearColor);
                            oldClearAlpha = renderer.getClearAlpha();
                            renderer.setClearColor(this.clearColor, this.clearAlpha);
                        }
                        if (this.clearDepth) {
                            renderer.clearDepth();
                        }
                        renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
                        // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
                        if (this.clear)
                            renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
                        renderer.render(this.scene, this.camera);
                        if (this.clearColor) {
                            renderer.setClearColor(this._oldClearColor, oldClearAlpha);
                        }
                        if (this.overrideMaterial !== undefined) {
                            this.scene.overrideMaterial = oldOverrideMaterial;
                        }
                        renderer.autoClear = oldAutoClear;
                    };
                    return RenderPass;
                }(_Pass_js__WEBPACK_IMPORTED_MODULE_0__.Pass));



                /***/
            }),

        /***/
        "./node_modules/three/examples/jsm/postprocessing/ShaderPass.js":
            /*!**********************************************************************!*\
              !*** ./node_modules/three/examples/jsm/postprocessing/ShaderPass.js ***!
              \**********************************************************************/
            /***/
            (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "ShaderPass": function() {
                        return /* binding */ ShaderPass;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");
                /* harmony import */
                var _Pass_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./Pass.js */ "./node_modules/three/examples/jsm/postprocessing/Pass.js");
                var __extends = (undefined && undefined.__extends) || (function() {
                    var extendStatics = function(d, b) {
                        extendStatics = Object.setPrototypeOf ||
                            ({
                                    __proto__: []
                                }
                                instanceof Array && function(d, b) {
                                    d.__proto__ = b;
                                }) ||
                            function(d, b) {
                                for (var p in b)
                                    if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
                            };
                        return extendStatics(d, b);
                    };
                    return function(d, b) {
                        if (typeof b !== "function" && b !== null)
                            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                        extendStatics(d, b);

                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                })();


                var ShaderPass = /** @class */ (function(_super) {
                    __extends(ShaderPass, _super);

                    function ShaderPass(shader, textureID) {
                        var _this = _super.call(this) || this;
                        _this.textureID = (textureID !== undefined) ? textureID : 'tDiffuse';
                        if (shader instanceof three__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial) {
                            _this.uniforms = shader.uniforms;
                            _this.material = shader;
                        } else if (shader) {
                            _this.uniforms = three__WEBPACK_IMPORTED_MODULE_1__.UniformsUtils.clone(shader.uniforms);
                            _this.material = new three__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial({
                                defines: Object.assign({}, shader.defines),
                                uniforms: _this.uniforms,
                                vertexShader: shader.vertexShader,
                                fragmentShader: shader.fragmentShader
                            });
                        }
                        _this.fsQuad = new _Pass_js__WEBPACK_IMPORTED_MODULE_0__.FullScreenQuad(_this.material);
                        return _this;
                    }
                    ShaderPass.prototype.render = function(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {
                        if (this.uniforms[this.textureID]) {
                            this.uniforms[this.textureID].value = readBuffer.texture;
                        }
                        this.fsQuad.material = this.material;
                        if (this.renderToScreen) {
                            renderer.setRenderTarget(null);
                            this.fsQuad.render(renderer);
                        } else {
                            renderer.setRenderTarget(writeBuffer);
                            // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
                            if (this.clear)
                                renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
                            this.fsQuad.render(renderer);
                        }
                    };
                    return ShaderPass;
                }(_Pass_js__WEBPACK_IMPORTED_MODULE_0__.Pass));



                /***/
            }),

        /***/
        "./node_modules/three/examples/jsm/shaders/CopyShader.js":
            /*!***************************************************************!*\
              !*** ./node_modules/three/examples/jsm/shaders/CopyShader.js ***!
              \***************************************************************/
            /***/
            (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "CopyShader": function() {
                        return /* binding */ CopyShader;
                    }
                    /* harmony export */
                });
                /**
                 * Full-screen textured quad shader
                 */
                var CopyShader = {
                    uniforms: {
                        'tDiffuse': {
                            value: null
                        },
                        'opacity': {
                            value: 1.0
                        }
                    },
                    vertexShader: /* glsl */ "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
                    fragmentShader: /* glsl */ "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor.a *= opacity;\n\n\n\t\t}"
                };



                /***/
            }),

        /***/
        "./node_modules/three/examples/jsm/shaders/FXAAShader.js":
            /*!***************************************************************!*\
              !*** ./node_modules/three/examples/jsm/shaders/FXAAShader.js ***!
              \***************************************************************/
            /***/
            (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "FXAAShader": function() {
                        return /* binding */ FXAAShader;
                    }
                    /* harmony export */
                });
                /* harmony import */
                var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");

                /**
                 * NVIDIA FXAA by Timothy Lottes
                 * https://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf
                 * - WebGL port by @supereggbert
                 * http://www.glge.org/demos/fxaa/
                 * Further improved by Daniel Sturk
                 */
                var FXAAShader = {
                    uniforms: {
                        'tDiffuse': {
                            value: null
                        },
                        'resolution': {
                            value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1 / 1024, 1 / 512)
                        }
                    },
                    vertexShader: /* glsl */ "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
                    fragmentShader: "\n\tprecision highp float;\n\n\tuniform sampler2D tDiffuse;\n\n\tuniform vec2 resolution;\n\n\tvarying vec2 vUv;\n\n\t// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n\t//----------------------------------------------------------------------------------\n\t// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n\t// SDK Version: v3.00\n\t// Email:       gameworks@nvidia.com\n\t// Site:        http://developer.nvidia.com/\n\t//\n\t// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n\t//\n\t// Redistribution and use in source and binary forms, with or without\n\t// modification, are permitted provided that the following conditions\n\t// are met:\n\t//  * Redistributions of source code must retain the above copyright\n\t//    notice, this list of conditions and the following disclaimer.\n\t//  * Redistributions in binary form must reproduce the above copyright\n\t//    notice, this list of conditions and the following disclaimer in the\n\t//    documentation and/or other materials provided with the distribution.\n\t//  * Neither the name of NVIDIA CORPORATION nor the names of its\n\t//    contributors may be used to endorse or promote products derived\n\t//    from this software without specific prior written permission.\n\t//\n\t// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY\n\t// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\t// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n\t// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n\t// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n\t// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\t// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n\t// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n\t// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t//\n\t//----------------------------------------------------------------------------------\n\n\t#ifndef FXAA_DISCARD\n\t\t\t//\n\t\t\t// Only valid for PC OpenGL currently.\n\t\t\t// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n\t\t\t//\n\t\t\t// 1 = Use discard on pixels which don't need AA.\n\t\t\t//     For APIs which enable concurrent TEX+ROP from same surface.\n\t\t\t// 0 = Return unchanged color on pixels which don't need AA.\n\t\t\t//\n\t\t\t#define FXAA_DISCARD 0\n\t#endif\n\n\t/*--------------------------------------------------------------------------*/\n\t#define FxaaTexTop(t, p) texture2D(t, p, -100.0)\n\t#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)\n\t/*--------------------------------------------------------------------------*/\n\n\t#define NUM_SAMPLES 5\n\n\t// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha\n\tfloat contrast( vec4 a, vec4 b ) {\n\t\t\tvec4 diff = abs( a - b );\n\t\t\treturn max( max( max( diff.r, diff.g ), diff.b ), diff.a );\n\t}\n\n\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\tFXAA3 QUALITY - PC\n\n\t============================================================================*/\n\n\t/*--------------------------------------------------------------------------*/\n\tvec4 FxaaPixelShader(\n\t\t\tvec2 posM,\n\t\t\tsampler2D tex,\n\t\t\tvec2 fxaaQualityRcpFrame,\n\t\t\tfloat fxaaQualityEdgeThreshold,\n\t\t\tfloat fxaaQualityinvEdgeThreshold\n\t) {\n\t\t\tvec4 rgbaM = FxaaTexTop(tex, posM);\n\t\t\tvec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\t// . S .\n\t\t\t// W M E\n\t\t\t// . N .\n\n\t\t\tbool earlyExit = max( max( max(\n\t\t\t\t\tcontrast( rgbaM, rgbaN ),\n\t\t\t\t\tcontrast( rgbaM, rgbaS ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaE ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaW ) )\n\t\t\t\t\t< fxaaQualityEdgeThreshold;\n\t\t\t// . 0 .\n\t\t\t// 0 0 0\n\t\t\t// . 0 .\n\n\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\tif(earlyExit) FxaaDiscard;\n\t\t\t#else\n\t\t\t\t\tif(earlyExit) return rgbaM;\n\t\t\t#endif\n\n\t\t\tfloat contrastN = contrast( rgbaM, rgbaN );\n\t\t\tfloat contrastS = contrast( rgbaM, rgbaS );\n\t\t\tfloat contrastE = contrast( rgbaM, rgbaE );\n\t\t\tfloat contrastW = contrast( rgbaM, rgbaW );\n\n\t\t\tfloat relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );\n\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\tbool horzSpan = relativeVContrast > 0.;\n\t\t\t// . 1 .\n\t\t\t// 0 0 0\n\t\t\t// . 1 .\n\n\t\t\t// 45 deg edge detection and corners of objects, aka V/H contrast is too similar\n\t\t\tif( abs( relativeVContrast ) < .3 ) {\n\t\t\t\t\t// locate the edge\n\t\t\t\t\tvec2 dirToEdge;\n\t\t\t\t\tdirToEdge.x = contrastE > contrastW ? 1. : -1.;\n\t\t\t\t\tdirToEdge.y = contrastS > contrastN ? 1. : -1.;\n\t\t\t\t\t// . 2 .      . 1 .\n\t\t\t\t\t// 1 0 2  ~=  0 0 1\n\t\t\t\t\t// . 1 .      . 0 .\n\n\t\t\t\t\t// tap 2 pixels and see which ones are \"outside\" the edge, to\n\t\t\t\t\t// determine if the edge is vertical or horizontal\n\n\t\t\t\t\tvec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongH = contrast( rgbaM, rgbaAlongH );\n\t\t\t\t\t// . 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 H\n\n\t\t\t\t\tvec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongV = contrast( rgbaM, rgbaAlongV );\n\t\t\t\t\t// V 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 .\n\n\t\t\t\t\trelativeVContrast = matchAlongV - matchAlongH;\n\t\t\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\t\t\tif( abs( relativeVContrast ) < .3 ) { // 45 deg edge\n\t\t\t\t\t\t\t// 1 1 .\n\t\t\t\t\t\t\t// 0 0 1\n\t\t\t\t\t\t\t// . 0 1\n\n\t\t\t\t\t\t\t// do a simple blur\n\t\t\t\t\t\t\treturn mix(\n\t\t\t\t\t\t\t\t\trgbaM,\n\t\t\t\t\t\t\t\t\t(rgbaN + rgbaS + rgbaE + rgbaW) * .25,\n\t\t\t\t\t\t\t\t\t.4\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\thorzSpan = relativeVContrast > 0.;\n\t\t\t}\n\n\t\t\tif(!horzSpan) rgbaN = rgbaW;\n\t\t\tif(!horzSpan) rgbaS = rgbaE;\n\t\t\t// . 0 .      1\n\t\t\t// 1 0 1  ->  0\n\t\t\t// . 0 .      1\n\n\t\t\tbool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );\n\t\t\tif(!pairN) rgbaN = rgbaS;\n\n\t\t\tvec2 offNP;\n\t\t\toffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n\t\t\toffNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\n\t\t\tbool doneN = false;\n\t\t\tbool doneP = false;\n\n\t\t\tfloat nDist = 0.;\n\t\t\tfloat pDist = 0.;\n\n\t\t\tvec2 posN = posM;\n\t\t\tvec2 posP = posM;\n\n\t\t\tint iterationsUsed = 0;\n\t\t\tint iterationsUsedN = 0;\n\t\t\tint iterationsUsedP = 0;\n\t\t\tfor( int i = 0; i < NUM_SAMPLES; i++ ) {\n\t\t\t\t\titerationsUsed = i;\n\n\t\t\t\t\tfloat increment = float(i + 1);\n\n\t\t\t\t\tif(!doneN) {\n\t\t\t\t\t\t\tnDist += increment;\n\t\t\t\t\t\t\tposN = posM + offNP * nDist;\n\t\t\t\t\t\t\tvec4 rgbaEndN = FxaaTexTop(tex, posN.xy);\n\t\t\t\t\t\t\tdoneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );\n\t\t\t\t\t\t\titerationsUsedN = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!doneP) {\n\t\t\t\t\t\t\tpDist += increment;\n\t\t\t\t\t\t\tposP = posM - offNP * pDist;\n\t\t\t\t\t\t\tvec4 rgbaEndP = FxaaTexTop(tex, posP.xy);\n\t\t\t\t\t\t\tdoneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );\n\t\t\t\t\t\t\titerationsUsedP = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(doneN || doneP) break;\n\t\t\t}\n\n\n\t\t\tif ( !doneP && !doneN ) return rgbaM; // failed to find end of edge\n\n\t\t\tfloat dist = min(\n\t\t\t\t\tdoneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,\n\t\t\t\t\tdoneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.\n\t\t\t);\n\n\t\t\t// hacky way of reduces blurriness of mostly diagonal edges\n\t\t\t// but reduces AA quality\n\t\t\tdist = pow(dist, .5);\n\n\t\t\tdist = 1. - dist;\n\n\t\t\treturn mix(\n\t\t\t\t\trgbaM,\n\t\t\t\t\trgbaN,\n\t\t\t\t\tdist * .5\n\t\t\t);\n\t}\n\n\tvoid main() {\n\t\t\tconst float edgeDetectionQuality = .2;\n\t\t\tconst float invEdgeDetectionQuality = 1. / edgeDetectionQuality;\n\n\t\t\tgl_FragColor = FxaaPixelShader(\n\t\t\t\t\tvUv,\n\t\t\t\t\ttDiffuse,\n\t\t\t\t\tresolution,\n\t\t\t\t\tedgeDetectionQuality, // [0,1] contrast needed, otherwise early discard\n\t\t\t\t\tinvEdgeDetectionQuality\n\t\t\t);\n\n\t}\n\t"
                };



                /***/
            }),

        /***/
        "./node_modules/three/examples/jsm/shaders/HorizontalBlurShader.js":
            /*!*************************************************************************!*\
              !*** ./node_modules/three/examples/jsm/shaders/HorizontalBlurShader.js ***!
              \*************************************************************************/
            /***/
            (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "HorizontalBlurShader": function() {
                        return /* binding */ HorizontalBlurShader;
                    }
                    /* harmony export */
                });
                /**
                 * Two pass Gaussian blur filter (horizontal and vertical blur shaders)
                 * - see http://www.cake23.de/traveling-wavefronts-lit-up.html
                 *
                 * - 9 samples per pass
                 * - standard deviation 2.7
                 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
                 */
                var HorizontalBlurShader = {
                    uniforms: {
                        'tDiffuse': {
                            value: null
                        },
                        'h': {
                            value: 1.0 / 512.0
                        }
                    },
                    vertexShader: /* glsl */ "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
                    fragmentShader: /* glsl */ "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float h;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 sum = vec4( 0.0 );\n\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}"
                };



                /***/
            }),

        /***/
        "./node_modules/three/examples/jsm/shaders/VerticalBlurShader.js":
            /*!***********************************************************************!*\
              !*** ./node_modules/three/examples/jsm/shaders/VerticalBlurShader.js ***!
              \***********************************************************************/
            /***/
            (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "VerticalBlurShader": function() {
                        return /* binding */ VerticalBlurShader;
                    }
                    /* harmony export */
                });
                /**
                 * Two pass Gaussian blur filter (horizontal and vertical blur shaders)
                 * - see http://www.cake23.de/traveling-wavefronts-lit-up.html
                 *
                 * - 9 samples per pass
                 * - standard deviation 2.7
                 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
                 */
                var VerticalBlurShader = {
                    uniforms: {
                        'tDiffuse': {
                            value: null
                        },
                        'v': {
                            value: 1.0 / 512.0
                        }
                    },
                    vertexShader: /* glsl */ "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
                    fragmentShader: /* glsl */ "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform float v;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 sum = vec4( 0.0 );\n\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n\t\t\tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}"
                };



                /***/
            }),

        /***/
        "./node_modules/throttle-debounce/esm/index.js":
            /*!*****************************************************!*\
              !*** ./node_modules/throttle-debounce/esm/index.js ***!
              \*****************************************************/
            /***/
            (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

                __webpack_require__.r(__webpack_exports__);
                /* harmony export */
                __webpack_require__.d(__webpack_exports__, {
                    /* harmony export */
                    "debounce": function() {
                        return /* binding */ debounce;
                    },
                    /* harmony export */
                    "throttle": function() {
                        return /* binding */ throttle;
                    }
                    /* harmony export */
                });
                /* eslint-disable no-undefined,no-param-reassign,no-shadow */
                /**
                 * Throttle execution of a function. Especially useful for rate limiting
                 * execution of handlers on events like resize and scroll.
                 *
                 * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
                 * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
                 *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
                 *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
                 *                                    the internal counter is reset).
                 * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
                 *                                    to `callback` when the throttled-function is executed.
                 * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
                 *                                    schedule `callback` to execute after `delay` ms.
                 *
                 * @returns {Function}  A new, throttled, function.
                 */
                function throttle(delay, noTrailing, callback, debounceMode) {
                    /*
                     * After wrapper has stopped being called, this timeout ensures that
                     * `callback` is executed at the proper times in `throttle` and `end`
                     * debounce modes.
                     */
                    var timeoutID;
                    var cancelled = false; // Keep track of the last time `callback` was executed.
                    var lastExec = 0; // Function to clear existing timeout
                    function clearExistingTimeout() {
                        if (timeoutID) {
                            clearTimeout(timeoutID);
                        }
                    } // Function to cancel next exec
                    function cancel() {
                        clearExistingTimeout();
                        cancelled = true;
                    } // `noTrailing` defaults to falsy.
                    if (typeof noTrailing !== 'boolean') {
                        debounceMode = callback;
                        callback = noTrailing;
                        noTrailing = undefined;
                    }
                    /*
                     * The `wrapper` function encapsulates all of the throttling / debouncing
                     * functionality and when executed will limit the rate at which `callback`
                     * is executed.
                     */
                    function wrapper() {
                        for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
                            arguments_[_key] = arguments[_key];
                        }
                        var self = this;
                        var elapsed = Date.now() - lastExec;
                        if (cancelled) {
                            return;
                        } // Execute `callback` and update the `lastExec` timestamp.
                        function exec() {
                            lastExec = Date.now();
                            callback.apply(self, arguments_);
                        }
                        /*
                         * If `debounceMode` is true (at begin) this is used to clear the flag
                         * to allow future `callback` executions.
                         */
                        function clear() {
                            timeoutID = undefined;
                        }
                        if (debounceMode && !timeoutID) {
                            /*
                             * Since `wrapper` is being called for the first time and
                             * `debounceMode` is true (at begin), execute `callback`.
                             */
                            exec();
                        }
                        clearExistingTimeout();
                        if (debounceMode === undefined && elapsed > delay) {
                            /*
                             * In throttle mode, if `delay` time has been exceeded, execute
                             * `callback`.
                             */
                            exec();
                        } else if (noTrailing !== true) {
                            /*
                             * In trailing throttle mode, since `delay` time has not been
                             * exceeded, schedule `callback` to execute `delay` ms after most
                             * recent execution.
                             *
                             * If `debounceMode` is true (at begin), schedule `clear` to execute
                             * after `delay` ms.
                             *
                             * If `debounceMode` is false (at end), schedule `callback` to
                             * execute after `delay` ms.
                             */
                            timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
                        }
                    }
                    wrapper.cancel = cancel; // Return the wrapper function.
                    return wrapper;
                }
                /* eslint-disable no-undefined */
                /**
                 * Debounce execution of a function. Debouncing, unlike throttling,
                 * guarantees that a function is only executed a single time, either at the
                 * very beginning of a series of calls, or at the very end.
                 *
                 * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
                 * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
                 *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
                 *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
                 * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
                 *                                  to `callback` when the debounced-function is executed.
                 *
                 * @returns {Function} A new, debounced function.
                 */
                function debounce(delay, atBegin, callback) {
                    return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
                }




                /***/
            }),

        /***/
        "./src/scripts/3d/font/TypefaceHelvetikerBold.json":
            /*!*********************************************************!*\
              !*** ./src/scripts/3d/font/TypefaceHelvetikerBold.json ***!
              \*********************************************************/
            /***/
            (function(module) {

                module.exports = JSON.parse('{"glyphs":{"X":{"x_min":0,"x_max":894.453125,"ha":999,"o":"m 894 0 l 654 0 l 445 351 l 238 0 l 0 0 l 316 516 l 0 1013 l 238 1013 l 445 659 l 652 1013 l 894 1013 l 577 519 l 894 0 "}},"cssFontWeight":"bold","ascender":1216,"underlinePosition":-100,"cssFontStyle":"normal","boundingBox":{"yMin":-333,"xMin":-162,"yMax":1216,"xMax":1681},"resolution":1000,"original_font_information":{"postscript_name":"Helvetiker-Bold","version_string":"Version 1.00 2004 initial release","vendor_url":"http://www.magenta.gr","full_font_name":"Helvetiker Bold","font_family_name":"Helvetiker","copyright":"Copyright (c) Magenta ltd, 2004.","description":"","trademark":"","designer":"","designer_url":"","unique_font_identifier":"Magenta ltd:Helvetiker Bold:22-10-104","license_url":"http://www.ellak.gr/fonts/MgOpen/license.html","license_description":"Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\\r\\n\\r\\nPermission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license (\\"Fonts\\") and associated documentation files (the \\"Font Software\\"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \\r\\n\\r\\nThe above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\\r\\n\\r\\nThe Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word \\"MgOpen\\", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\\r\\n\\r\\nThis License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the \\"MgOpen\\" name.\\r\\n\\r\\nThe Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \\r\\n\\r\\nTHE FONT SOFTWARE IS PROVIDED \\"AS IS\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.","manufacturer_name":"Magenta ltd","font_sub_family_name":"Bold"},"descender":-334,"familyName":"Helvetiker","lineHeight":1549,"underlineThickness":50}');

                /***/
            })

        /******/
    });
    /************************************************************************/
    /******/ // The module cache
    /******/
    var __webpack_module_cache__ = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/ // Check if module is in cache
        /******/
        var cachedModule = __webpack_module_cache__[moduleId];
        /******/
        if (cachedModule !== undefined) {
            /******/
            return cachedModule.exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = __webpack_module_cache__[moduleId] = {
            /******/ // no module.id needed
            /******/ // no module.loaded needed
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /************************************************************************/
    /******/
    /* webpack/runtime/amd options */
    /******/
    ! function() {
        /******/
        __webpack_require__.amdO = {};
        /******/
    }();
    /******/
    /******/
    /* webpack/runtime/compat get default export */
    /******/
    ! function() {
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/
        __webpack_require__.n = function(module) {
            /******/
            var getter = module && module.__esModule ?
                /******/
                function() {
                    return module['default'];
                } :
                /******/
                function() {
                    return module;
                };
            /******/
            __webpack_require__.d(getter, {
                a: getter
            });
            /******/
            return getter;
            /******/
        };
        /******/
    }();
    /******/
    /******/
    /* webpack/runtime/define property getters */
    /******/
    ! function() {
        /******/ // define getter functions for harmony exports
        /******/
        __webpack_require__.d = function(exports, definition) {
            /******/
            for (var key in definition) {
                /******/
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                    /******/
                    Object.defineProperty(exports, key, {
                        enumerable: true,
                        get: definition[key]
                    });
                    /******/
                }
                /******/
            }
            /******/
        };
        /******/
    }();
    /******/
    /******/
    /* webpack/runtime/global */
    /******/
    ! function() {
        /******/
        __webpack_require__.g = (function() {
            /******/
            if (typeof globalThis === 'object') return globalThis;
            /******/
            try {
                /******/
                return this || new Function('return this')();
                /******/
            } catch (e) {
                /******/
                if (typeof window === 'object') return window;
                /******/
            }
            /******/
        })();
        /******/
    }();
    /******/
    /******/
    /* webpack/runtime/hasOwnProperty shorthand */
    /******/
    ! function() {
        /******/
        __webpack_require__.o = function(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        /******/
    }();
    /******/
    /******/
    /* webpack/runtime/make namespace object */
    /******/
    ! function() {
        /******/ // define __esModule on exports
        /******/
        __webpack_require__.r = function(exports) {
            /******/
            if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                /******/
                Object.defineProperty(exports, Symbol.toStringTag, {
                    value: 'Module'
                });
                /******/
            }
            /******/
            Object.defineProperty(exports, '__esModule', {
                value: true
            });
            /******/
        };
        /******/
    }();
    /******/
    /************************************************************************/
    var __webpack_exports__ = {};
    // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
    ! function() {
        /*!******************************!*\
          !*** ./src/scripts/entry.ts ***!
          \******************************/
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */
        var proxy_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! proxy-polyfill */ "./node_modules/proxy-polyfill/src/index.js");
        /* harmony import */
        var proxy_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __webpack_require__.n(proxy_polyfill__WEBPACK_IMPORTED_MODULE_0__);
        /* harmony import */
        var core_js_es_symbol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! core-js/es/symbol */ "./node_modules/core-js/es/symbol/index.js");
        /* harmony import */
        var core_js_es_symbol__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __webpack_require__.n(core_js_es_symbol__WEBPACK_IMPORTED_MODULE_1__);
        /* harmony import */
        var wicg_inert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! wicg-inert */ "./node_modules/wicg-inert/dist/inert.esm.js");
        /* harmony import */
        var wicg_inert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __webpack_require__.n(wicg_inert__WEBPACK_IMPORTED_MODULE_2__);
        /* harmony import */
        var what_input__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! what-input */ "./node_modules/what-input/dist/what-input.js");
        /* harmony import */
        var what_input__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __webpack_require__.n(what_input__WEBPACK_IMPORTED_MODULE_3__);
        /* harmony import */
        var furnace__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! furnace */ "./node_modules/furnace/dist/index.js");
        /* harmony import */
        var _scripts_app__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! @/scripts/app */ "./src/scripts/app.ts");
        /* harmony import */
        var gsap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
        /* harmony import */
        var gsap_ScrollToPlugin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! gsap/ScrollToPlugin */ "./node_modules/gsap/ScrollToPlugin.js");








        gsap__WEBPACK_IMPORTED_MODULE_6__.gsap.registerPlugin(gsap_ScrollToPlugin__WEBPACK_IMPORTED_MODULE_7__.ScrollToPlugin);
        var userAgent = window.navigator.userAgent.toUpperCase();
        var isIE = !(userAgent.indexOf('MSIE') === -1 && userAgent.indexOf('TRIDENT') === -1);
        var redirectIe = function() {
            if (location.pathname === window.__ieDirectory) {
                return;
            }
            location.href = window.__ieDirectory;
        };
        document.addEventListener('DOMContentLoaded', function() {
            if (isIE) {
                redirectIe();
                return;
            }
            furnace__WEBPACK_IMPORTED_MODULE_4__["default"].create(document.documentElement, _scripts_app__WEBPACK_IMPORTED_MODULE_5__.Application);
        });

    }();
    /******/
})();
//# sourceMappingURL=bundle.js.map